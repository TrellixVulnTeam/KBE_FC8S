# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_ChFiDS')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_ChFiDS')
    _ChFiDS = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ChFiDS', [dirname(__file__)])
        except ImportError:
            import _ChFiDS
            return _ChFiDS
        try:
            _mod = imp.load_module('_ChFiDS', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _ChFiDS = swig_import_helper()
    del swig_import_helper
else:
    import _ChFiDS
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ChFiDS.delete_SwigPyIterator

    def value(self):
        return _ChFiDS.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _ChFiDS.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _ChFiDS.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _ChFiDS.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _ChFiDS.SwigPyIterator_equal(self, x)

    def copy(self):
        return _ChFiDS.SwigPyIterator_copy(self)

    def next(self):
        return _ChFiDS.SwigPyIterator_next(self)

    def __next__(self):
        return _ChFiDS.SwigPyIterator___next__(self)

    def previous(self):
        return _ChFiDS.SwigPyIterator_previous(self)

    def advance(self, n):
        return _ChFiDS.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _ChFiDS.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _ChFiDS.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _ChFiDS.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _ChFiDS.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _ChFiDS.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _ChFiDS.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _ChFiDS.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _ChFiDS.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_ChFiDS.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _ChFiDS.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _ChFiDS.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ChFiDS.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _ChFiDS.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _ChFiDS.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _ChFiDS.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _ChFiDS.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_ChFiDS.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _ChFiDS.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _ChFiDS.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ChFiDS.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _ChFiDS.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _ChFiDS.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _ChFiDS.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _ChFiDS.ptr_to_number(item)
ptr_to_number = _ChFiDS.ptr_to_number

def HashCode(*args):
    return _ChFiDS.HashCode(*args)
HashCode = _ChFiDS.HashCode

def ptr_equal(a, b):
    return _ChFiDS.ptr_equal(a, b)
ptr_equal = _ChFiDS.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Law
else:
    import Law
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepAdaptor
else:
    import BRepAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dAdaptor
else:
    import Geom2dAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
ChFiDS_Sym = _ChFiDS.ChFiDS_Sym
ChFiDS_TwoDist = _ChFiDS.ChFiDS_TwoDist
ChFiDS_DistAngle = _ChFiDS.ChFiDS_DistAngle
ChFiDS_OnSame = _ChFiDS.ChFiDS_OnSame
ChFiDS_OnDiff = _ChFiDS.ChFiDS_OnDiff
ChFiDS_AllSame = _ChFiDS.ChFiDS_AllSame
ChFiDS_BreakPoint = _ChFiDS.ChFiDS_BreakPoint
ChFiDS_FreeBoundary = _ChFiDS.ChFiDS_FreeBoundary
ChFiDS_Closed = _ChFiDS.ChFiDS_Closed
ChFiDS_Tangent = _ChFiDS.ChFiDS_Tangent
ChFiDS_Ok = _ChFiDS.ChFiDS_Ok
ChFiDS_Error = _ChFiDS.ChFiDS_Error
ChFiDS_WalkingFailure = _ChFiDS.ChFiDS_WalkingFailure
ChFiDS_StartsolFailure = _ChFiDS.ChFiDS_StartsolFailure
ChFiDS_TwistedSurface = _ChFiDS.ChFiDS_TwistedSurface
class ChFiDS_Spine(Standard.Standard_Transient):
    """
    Contains information necessary for construction of
    a 3D fillet or chamfer:

    - guideline composed of edges of the solid, tangents
    between them, and borders by faces tangents
    between them.

    Tools for construction of the Sp
    by propagation from an edge of solid
    are provided in the Builder of Fil3d.

    The Spine contains among others the
    information about the nature of extremities
    of the fillet ( on free border , on section or closed ).

    IMPORTANT NOTE  :    the guideline
    represented in this way is not C2, although the path
    claims it. Several palliative workarounds
    (see the methods at the end) are planned,
    but they are not enough. It is necessary to change
    the approach and double the Spine of line C2 with
    the known consequences for management of
    interactions between KPart Blend in Fil3d.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ChFiDS_Spine
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ChFiDS_Spine(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ChFiDS_Spine self) -> ChFiDS_Spine
        __init__(ChFiDS_Spine self, Standard_Real const Tol) -> ChFiDS_Spine

        :type Tol: float

        """
        this = _ChFiDS.new_ChFiDS_Spine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetEdges(self, *args):
        """
        SetEdges(ChFiDS_Spine self, TopoDS_Edge E)

        store edges composing the guideline

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _ChFiDS.ChFiDS_Spine_SetEdges(self, *args)


    def PutInFirst(self, *args):
        """
        PutInFirst(ChFiDS_Spine self, TopoDS_Edge E)

        store the edge at the first position before all others

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _ChFiDS.ChFiDS_Spine_PutInFirst(self, *args)


    def NbEdges(self, *args):
        """
        NbEdges(ChFiDS_Spine self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.ChFiDS_Spine_NbEdges(self, *args)


    def Edges(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _ChFiDS.ChFiDS_Spine_Edges(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstStatus(self, *args):
        """
        SetFirstStatus(ChFiDS_Spine self, ChFiDS_State const S)

        stores if the start of a set of edges starts on a
        section of free border or forms  a closed contour

        :type S: OCC.wrapper.ChFiDS.ChFiDS_State

        """
        return _ChFiDS.ChFiDS_Spine_SetFirstStatus(self, *args)


    def SetLastStatus(self, *args):
        """
        SetLastStatus(ChFiDS_Spine self, ChFiDS_State const S)

        stores if the end of a set of edges starts on a
        section of free border or forms  a closed contour

        :type S: OCC.wrapper.ChFiDS.ChFiDS_State

        """
        return _ChFiDS.ChFiDS_Spine_SetLastStatus(self, *args)


    def AppendElSpine(self, *args):
        """
        AppendElSpine(ChFiDS_Spine self, Handle_ChFiDS_HElSpine Els)

        :type Els: OCC.wrapper.ChFiDS.Handle_ChFiDS_HElSpine

        """
        return _ChFiDS.ChFiDS_Spine_AppendElSpine(self, *args)


    def ElSpine(self, *args):
        """
        ElSpine(ChFiDS_Spine self, Standard_Integer const IE) -> Handle_ChFiDS_HElSpine
        ElSpine(ChFiDS_Spine self, TopoDS_Edge E) -> Handle_ChFiDS_HElSpine
        ElSpine(ChFiDS_Spine self, Standard_Real const W) -> Handle_ChFiDS_HElSpine

        :type W: float
        :rtype: OCC.wrapper.ChFiDS.Handle_ChFiDS_HElSpine

        """
        return _ChFiDS.ChFiDS_Spine_ElSpine(self, *args)


    def ChangeElSpines(self, *args):
        """
        ChangeElSpines(ChFiDS_Spine self) -> NCollection_List_Handle_ChFiDS_HElSpine

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_ListOfHElSpine

        """
        return _ChFiDS.ChFiDS_Spine_ChangeElSpines(self, *args)


    def Reset(self, *args):
        """
        Reset(ChFiDS_Spine self, Standard_Boolean const AllData)

        :type AllData: bool

        """
        return _ChFiDS.ChFiDS_Spine_Reset(self, *args)


    def SplitDone(self, *args):
        """
        SplitDone(ChFiDS_Spine self) -> Standard_Boolean
        SplitDone(ChFiDS_Spine self, Standard_Boolean const B)

        :type B: bool

        """
        return _ChFiDS.ChFiDS_Spine_SplitDone(self, *args)


    def Load(self, *args):
        """
        Load(ChFiDS_Spine self)

        prepare the guideline depending on the edges that
        are elementary arks (take parameters from
        a single curvilinear abscissa); to be able to call
        methods on the geometry (first,last,value,d1,d2)
        it is necessary to start with preparation otherwise an
        exception will be raised


        """
        return _ChFiDS.ChFiDS_Spine_Load(self, *args)


    def Resolution(self, *args):
        """
        Resolution(ChFiDS_Spine self, Standard_Real const R3d) -> Standard_Real

        :type R3d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.ChFiDS_Spine_Resolution(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(ChFiDS_Spine self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.ChFiDS_Spine_IsClosed(self, *args)


    def SetFirstParameter(self, *args):
        """
        SetFirstParameter(ChFiDS_Spine self, Standard_Real const Par)

        :type Par: float

        """
        return _ChFiDS.ChFiDS_Spine_SetFirstParameter(self, *args)


    def SetLastParameter(self, *args):
        """
        SetLastParameter(ChFiDS_Spine self, Standard_Real const Par)

        :type Par: float

        """
        return _ChFiDS.ChFiDS_Spine_SetLastParameter(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(ChFiDS_Spine self) -> Standard_Real
        FirstParameter(ChFiDS_Spine self, Standard_Integer const IndexSpine) -> Standard_Real

        gives the total length of all arcs before the
        number IndexSp

        :type IndexSpine: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.ChFiDS_Spine_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(ChFiDS_Spine self) -> Standard_Real
        LastParameter(ChFiDS_Spine self, Standard_Integer const IndexSpine) -> Standard_Real

        gives the total length till the ark with number
        IndexSpine (inclus)

        :type IndexSpine: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.ChFiDS_Spine_LastParameter(self, *args)


    def Length(self, *args):
        """
        Length(ChFiDS_Spine self, Standard_Integer const IndexSpine) -> Standard_Real

        gives the length of ark with number IndexSp

        :type IndexSpine: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.ChFiDS_Spine_Length(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(ChFiDS_Spine self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.ChFiDS_Spine_IsPeriodic(self, *args)


    def Period(self, *args):
        """
        Period(ChFiDS_Spine self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.ChFiDS_Spine_Period(self, *args)


    def Parameter(self, *args):
        """
        Parameter(ChFiDS_Spine self, Standard_Real const AbsC, Standard_Boolean const Oriented)
        Parameter(ChFiDS_Spine self, Standard_Integer const Index, Standard_Real const AbsC, Standard_Boolean const Oriented)

        :type Index: int
        :type AbsC: float
        :type U: float
        :type Oriented: bool

        """
        return _ChFiDS.ChFiDS_Spine_Parameter(self, *args)


    def Value(self, *args):
        """
        Value(ChFiDS_Spine self, Standard_Real const AbsC) -> gp_Pnt

        :type AbsC: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _ChFiDS.ChFiDS_Spine_Value(self, *args)


    def D0(self, *args):
        """
        D0(ChFiDS_Spine self, Standard_Real const AbsC, gp_Pnt P)

        :type AbsC: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _ChFiDS.ChFiDS_Spine_D0(self, *args)


    def D1(self, *args):
        """
        D1(ChFiDS_Spine self, Standard_Real const AbsC, gp_Pnt P, gp_Vec V1)

        :type AbsC: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec

        """
        return _ChFiDS.ChFiDS_Spine_D1(self, *args)


    def D2(self, *args):
        """
        D2(ChFiDS_Spine self, Standard_Real const AbsC, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        :type AbsC: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _ChFiDS.ChFiDS_Spine_D2(self, *args)


    def SetCurrent(self, *args):
        """
        SetCurrent(ChFiDS_Spine self, Standard_Integer const Index)

        :type Index: int

        """
        return _ChFiDS.ChFiDS_Spine_SetCurrent(self, *args)


    def CurrentElementarySpine(self, *args):
        """
        sets the current curve and returns it

        :type Index: int
        :rtype: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve

        """
        res = _ChFiDS.ChFiDS_Spine_CurrentElementarySpine(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CurrentIndexOfElementarySpine(self, *args):
        """
        CurrentIndexOfElementarySpine(ChFiDS_Spine self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.ChFiDS_Spine_CurrentIndexOfElementarySpine(self, *args)


    def GetType(self, *args):
        """
        GetType(ChFiDS_Spine self) -> GeomAbs_CurveType

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

        """
        return _ChFiDS.ChFiDS_Spine_GetType(self, *args)


    def Line(self, *args):
        """
        Line(ChFiDS_Spine self) -> gp_Lin

        :rtype: OCC.wrapper.gp.gp_Lin

        """
        return _ChFiDS.ChFiDS_Spine_Line(self, *args)


    def Circle(self, *args):
        """
        Circle(ChFiDS_Spine self) -> gp_Circ

        :rtype: OCC.wrapper.gp.gp_Circ

        """
        return _ChFiDS.ChFiDS_Spine_Circle(self, *args)


    def FirstStatus(self, *args):
        """
        FirstStatus(ChFiDS_Spine self) -> ChFiDS_State

        returns if the set of edges starts on a free boundary
        or if the first vertex is a breakpoint or if the set is
        closed

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_State

        """
        return _ChFiDS.ChFiDS_Spine_FirstStatus(self, *args)


    def LastStatus(self, *args):
        """
        LastStatus(ChFiDS_Spine self) -> ChFiDS_State

        returns the state at the end of the set

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_State

        """
        return _ChFiDS.ChFiDS_Spine_LastStatus(self, *args)


    def Status(self, *args):
        """
        Status(ChFiDS_Spine self, Standard_Boolean const IsFirst) -> ChFiDS_State

        :type IsFirst: bool
        :rtype: OCC.wrapper.ChFiDS.ChFiDS_State

        """
        return _ChFiDS.ChFiDS_Spine_Status(self, *args)


    def SetStatus(self, *args):
        """
        SetStatus(ChFiDS_Spine self, ChFiDS_State const S, Standard_Boolean const IsFirst)

        :type S: OCC.wrapper.ChFiDS.ChFiDS_State
        :type IsFirst: bool

        """
        return _ChFiDS.ChFiDS_Spine_SetStatus(self, *args)


    def IsTangencyExtremity(self, *args):
        """
        IsTangencyExtremity(ChFiDS_Spine self, Standard_Boolean const IsFirst) -> Standard_Boolean

        returns   if the  set  of  edges starts (or   end) on
        Tangency point.

        :type IsFirst: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.ChFiDS_Spine_IsTangencyExtremity(self, *args)


    def SetTangencyExtremity(self, *args):
        """
        SetTangencyExtremity(ChFiDS_Spine self, Standard_Boolean const IsTangency, Standard_Boolean const IsFirst)

        :type IsTangency: bool
        :type IsFirst: bool

        """
        return _ChFiDS.ChFiDS_Spine_SetTangencyExtremity(self, *args)


    def Absc(self, *args):
        """
        Absc(ChFiDS_Spine self, Standard_Real const U) -> Standard_Real
        Absc(ChFiDS_Spine self, Standard_Real const U, Standard_Integer const I) -> Standard_Real
        Absc(ChFiDS_Spine self, TopoDS_Vertex V) -> Standard_Real

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.ChFiDS_Spine_Absc(self, *args)


    def FirstVertex(self, *args):
        """
        FirstVertex(ChFiDS_Spine self) -> TopoDS_Vertex

        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _ChFiDS.ChFiDS_Spine_FirstVertex(self, *args)


    def LastVertex(self, *args):
        """
        LastVertex(ChFiDS_Spine self) -> TopoDS_Vertex

        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _ChFiDS.ChFiDS_Spine_LastVertex(self, *args)


    def SetFirstTgt(self, *args):
        """
        SetFirstTgt(ChFiDS_Spine self, Standard_Real const W)

        :type W: float

        """
        return _ChFiDS.ChFiDS_Spine_SetFirstTgt(self, *args)


    def SetLastTgt(self, *args):
        """
        SetLastTgt(ChFiDS_Spine self, Standard_Real const W)

        :type W: float

        """
        return _ChFiDS.ChFiDS_Spine_SetLastTgt(self, *args)


    def HasFirstTgt(self, *args):
        """
        HasFirstTgt(ChFiDS_Spine self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.ChFiDS_Spine_HasFirstTgt(self, *args)


    def HasLastTgt(self, *args):
        """
        HasLastTgt(ChFiDS_Spine self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.ChFiDS_Spine_HasLastTgt(self, *args)


    def SetReference(self, *args):
        """
        SetReference(ChFiDS_Spine self, Standard_Real const W)
        SetReference(ChFiDS_Spine self, Standard_Integer const I)

        set  a  parameter  reference  for  the approx,  at the
        middle  of edge I.

        :type I: int

        """
        return _ChFiDS.ChFiDS_Spine_SetReference(self, *args)


    def Index(self, *args):
        """
        Index(ChFiDS_Spine self, Standard_Real const W, Standard_Boolean const Forward) -> Standard_Integer
        Index(ChFiDS_Spine self, TopoDS_Edge E) -> Standard_Integer

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.ChFiDS_Spine_Index(self, *args)


    def UnsetReference(self, *args):
        """UnsetReference(ChFiDS_Spine self)"""
        return _ChFiDS.ChFiDS_Spine_UnsetReference(self, *args)


    def SetErrorStatus(self, *args):
        """
        SetErrorStatus(ChFiDS_Spine self, ChFiDS_ErrorStatus const state)

        :type state: OCC.wrapper.ChFiDS.ChFiDS_ErrorStatus

        """
        return _ChFiDS.ChFiDS_Spine_SetErrorStatus(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(ChFiDS_Spine self) -> ChFiDS_ErrorStatus

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_ErrorStatus

        """
        return _ChFiDS.ChFiDS_Spine_ErrorStatus(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ChFiDS.ChFiDS_Spine_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ChFiDS.ChFiDS_Spine_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ChFiDS.ChFiDS_Spine_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ChFiDS.delete_ChFiDS_Spine
ChFiDS_Spine_swigregister = _ChFiDS.ChFiDS_Spine_swigregister
ChFiDS_Spine_swigregister(ChFiDS_Spine)

def ChFiDS_Spine_get_type_name(*args):
    """
    ChFiDS_Spine_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ChFiDS.ChFiDS_Spine_get_type_name(*args)

def ChFiDS_Spine_get_type_descriptor(*args):
    """
    ChFiDS_Spine_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ChFiDS.ChFiDS_Spine_get_type_descriptor(*args)

class ChFiDS_Stripe(Standard.Standard_Transient):
    """Data characterising a band of fillet."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ChFiDS_Stripe
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ChFiDS_Stripe(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ChFiDS_Stripe self) -> ChFiDS_Stripe

        Data characterising a band of fillet.
        """
        this = _ChFiDS.new_ChFiDS_Stripe(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Reset(self, *args):
        """
        Reset(ChFiDS_Stripe self)

        Reset everything except Spine.


        """
        return _ChFiDS.ChFiDS_Stripe_Reset(self, *args)


    def SetOfSurfData(self, *args):
        """
        :rtype: OCC.wrapper.ChFiDS.Handle_ChFiDS_HData

        """
        res = _ChFiDS.ChFiDS_Stripe_SetOfSurfData(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Spine(self, *args):
        """
        :rtype: OCC.wrapper.ChFiDS.Handle_ChFiDS_Spine

        """
        res = _ChFiDS.ChFiDS_Stripe_Spine(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSetOfSurfData(self, *args):
        """
        ChangeSetOfSurfData(ChFiDS_Stripe self) -> Handle_ChFiDS_HData

        :rtype: OCC.wrapper.ChFiDS.Handle_ChFiDS_HData

        """
        return _ChFiDS.ChFiDS_Stripe_ChangeSetOfSurfData(self, *args)


    def ChangeSpine(self, *args):
        """
        ChangeSpine(ChFiDS_Stripe self) -> Handle_ChFiDS_Spine

        :rtype: OCC.wrapper.ChFiDS.Handle_ChFiDS_Spine

        """
        return _ChFiDS.ChFiDS_Stripe_ChangeSpine(self, *args)


    def OrientationOnFace1(self, *args):
        """
        OrientationOnFace1(ChFiDS_Stripe self) -> TopAbs_Orientation
        OrientationOnFace1(ChFiDS_Stripe self, TopAbs_Orientation const Or1)

        :type Or1: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _ChFiDS.ChFiDS_Stripe_OrientationOnFace1(self, *args)


    def OrientationOnFace2(self, *args):
        """
        OrientationOnFace2(ChFiDS_Stripe self) -> TopAbs_Orientation
        OrientationOnFace2(ChFiDS_Stripe self, TopAbs_Orientation const Or2)

        :type Or2: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _ChFiDS.ChFiDS_Stripe_OrientationOnFace2(self, *args)


    def Choix(self, *args):
        """
        Choix(ChFiDS_Stripe self) -> Standard_Integer
        Choix(ChFiDS_Stripe self, Standard_Integer const C)

        :type C: int

        """
        return _ChFiDS.ChFiDS_Stripe_Choix(self, *args)


    def FirstParameters(self, *args):
        """
        FirstParameters(ChFiDS_Stripe self)

        :type Pdeb: float
        :type Pfin: float

        """
        return _ChFiDS.ChFiDS_Stripe_FirstParameters(self, *args)


    def LastParameters(self, *args):
        """
        LastParameters(ChFiDS_Stripe self)

        :type Pdeb: float
        :type Pfin: float

        """
        return _ChFiDS.ChFiDS_Stripe_LastParameters(self, *args)


    def ChangeFirstParameters(self, *args):
        """
        ChangeFirstParameters(ChFiDS_Stripe self, Standard_Real const Pdeb, Standard_Real const Pfin)

        :type Pdeb: float
        :type Pfin: float

        """
        return _ChFiDS.ChFiDS_Stripe_ChangeFirstParameters(self, *args)


    def ChangeLastParameters(self, *args):
        """
        ChangeLastParameters(ChFiDS_Stripe self, Standard_Real const Pdeb, Standard_Real const Pfin)

        :type Pdeb: float
        :type Pfin: float

        """
        return _ChFiDS.ChFiDS_Stripe_ChangeLastParameters(self, *args)


    def FirstCurve(self, *args):
        """
        FirstCurve(ChFiDS_Stripe self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.ChFiDS_Stripe_FirstCurve(self, *args)


    def LastCurve(self, *args):
        """
        LastCurve(ChFiDS_Stripe self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.ChFiDS_Stripe_LastCurve(self, *args)


    def ChangeFirstCurve(self, *args):
        """
        ChangeFirstCurve(ChFiDS_Stripe self, Standard_Integer const Index)

        :type Index: int

        """
        return _ChFiDS.ChFiDS_Stripe_ChangeFirstCurve(self, *args)


    def ChangeLastCurve(self, *args):
        """
        ChangeLastCurve(ChFiDS_Stripe self, Standard_Integer const Index)

        :type Index: int

        """
        return _ChFiDS.ChFiDS_Stripe_ChangeLastCurve(self, *args)


    def FirstPCurve(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _ChFiDS.ChFiDS_Stripe_FirstPCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LastPCurve(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _ChFiDS.ChFiDS_Stripe_LastPCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirstPCurve(self, *args):
        """
        ChangeFirstPCurve(ChFiDS_Stripe self) -> Handle_Geom2d_Curve

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _ChFiDS.ChFiDS_Stripe_ChangeFirstPCurve(self, *args)


    def ChangeLastPCurve(self, *args):
        """
        ChangeLastPCurve(ChFiDS_Stripe self) -> Handle_Geom2d_Curve

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _ChFiDS.ChFiDS_Stripe_ChangeLastPCurve(self, *args)


    def FirstPCurveOrientation(self, *args):
        """
        FirstPCurveOrientation(ChFiDS_Stripe self) -> TopAbs_Orientation
        FirstPCurveOrientation(ChFiDS_Stripe self, TopAbs_Orientation const O)

        :type O: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _ChFiDS.ChFiDS_Stripe_FirstPCurveOrientation(self, *args)


    def LastPCurveOrientation(self, *args):
        """
        LastPCurveOrientation(ChFiDS_Stripe self) -> TopAbs_Orientation
        LastPCurveOrientation(ChFiDS_Stripe self, TopAbs_Orientation const O)

        :type O: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _ChFiDS.ChFiDS_Stripe_LastPCurveOrientation(self, *args)


    def IndexFirstPointOnS1(self, *args):
        """
        IndexFirstPointOnS1(ChFiDS_Stripe self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.ChFiDS_Stripe_IndexFirstPointOnS1(self, *args)


    def IndexFirstPointOnS2(self, *args):
        """
        IndexFirstPointOnS2(ChFiDS_Stripe self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.ChFiDS_Stripe_IndexFirstPointOnS2(self, *args)


    def IndexLastPointOnS1(self, *args):
        """
        IndexLastPointOnS1(ChFiDS_Stripe self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.ChFiDS_Stripe_IndexLastPointOnS1(self, *args)


    def IndexLastPointOnS2(self, *args):
        """
        IndexLastPointOnS2(ChFiDS_Stripe self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.ChFiDS_Stripe_IndexLastPointOnS2(self, *args)


    def ChangeIndexFirstPointOnS1(self, *args):
        """
        ChangeIndexFirstPointOnS1(ChFiDS_Stripe self, Standard_Integer const Index)

        :type Index: int

        """
        return _ChFiDS.ChFiDS_Stripe_ChangeIndexFirstPointOnS1(self, *args)


    def ChangeIndexFirstPointOnS2(self, *args):
        """
        ChangeIndexFirstPointOnS2(ChFiDS_Stripe self, Standard_Integer const Index)

        :type Index: int

        """
        return _ChFiDS.ChFiDS_Stripe_ChangeIndexFirstPointOnS2(self, *args)


    def ChangeIndexLastPointOnS1(self, *args):
        """
        ChangeIndexLastPointOnS1(ChFiDS_Stripe self, Standard_Integer const Index)

        :type Index: int

        """
        return _ChFiDS.ChFiDS_Stripe_ChangeIndexLastPointOnS1(self, *args)


    def ChangeIndexLastPointOnS2(self, *args):
        """
        ChangeIndexLastPointOnS2(ChFiDS_Stripe self, Standard_Integer const Index)

        :type Index: int

        """
        return _ChFiDS.ChFiDS_Stripe_ChangeIndexLastPointOnS2(self, *args)


    def Parameters(self, *args):
        """
        Parameters(ChFiDS_Stripe self, Standard_Boolean const First)

        :type First: bool
        :type Pdeb: float
        :type Pfin: float

        """
        return _ChFiDS.ChFiDS_Stripe_Parameters(self, *args)


    def SetParameters(self, *args):
        """
        SetParameters(ChFiDS_Stripe self, Standard_Boolean const First, Standard_Real const Pdeb, Standard_Real const Pfin)

        :type First: bool
        :type Pdeb: float
        :type Pfin: float

        """
        return _ChFiDS.ChFiDS_Stripe_SetParameters(self, *args)


    def Curve(self, *args):
        """
        Curve(ChFiDS_Stripe self, Standard_Boolean const First) -> Standard_Integer

        :type First: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.ChFiDS_Stripe_Curve(self, *args)


    def SetCurve(self, *args):
        """
        SetCurve(ChFiDS_Stripe self, Standard_Integer const Index, Standard_Boolean const First)

        :type Index: int
        :type First: bool

        """
        return _ChFiDS.ChFiDS_Stripe_SetCurve(self, *args)


    def PCurve(self, *args):
        """
        :type First: bool
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _ChFiDS.ChFiDS_Stripe_PCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangePCurve(self, *args):
        """
        ChangePCurve(ChFiDS_Stripe self, Standard_Boolean const First) -> Handle_Geom2d_Curve

        :type First: bool
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _ChFiDS.ChFiDS_Stripe_ChangePCurve(self, *args)


    def Orientation(self, *args):
        """
        Orientation(ChFiDS_Stripe self, Standard_Integer const OnS) -> TopAbs_Orientation
        Orientation(ChFiDS_Stripe self, Standard_Boolean const First) -> TopAbs_Orientation

        :type First: bool
        :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _ChFiDS.ChFiDS_Stripe_Orientation(self, *args)


    def SetOrientation(self, *args):
        """
        SetOrientation(ChFiDS_Stripe self, TopAbs_Orientation const Or, Standard_Integer const OnS)
        SetOrientation(ChFiDS_Stripe self, TopAbs_Orientation const Or, Standard_Boolean const First)

        :type Or: OCC.wrapper.TopAbs.TopAbs_Orientation
        :type First: bool

        """
        return _ChFiDS.ChFiDS_Stripe_SetOrientation(self, *args)


    def IndexPoint(self, *args):
        """
        IndexPoint(ChFiDS_Stripe self, Standard_Boolean const First, Standard_Integer const OnS) -> Standard_Integer

        :type First: bool
        :type OnS: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.ChFiDS_Stripe_IndexPoint(self, *args)


    def SetIndexPoint(self, *args):
        """
        SetIndexPoint(ChFiDS_Stripe self, Standard_Integer const Index, Standard_Boolean const First, Standard_Integer const OnS)

        :type Index: int
        :type First: bool
        :type OnS: int

        """
        return _ChFiDS.ChFiDS_Stripe_SetIndexPoint(self, *args)


    def SolidIndex(self, *args):
        """
        SolidIndex(ChFiDS_Stripe self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.ChFiDS_Stripe_SolidIndex(self, *args)


    def SetSolidIndex(self, *args):
        """
        SetSolidIndex(ChFiDS_Stripe self, Standard_Integer const Index)

        :type Index: int

        """
        return _ChFiDS.ChFiDS_Stripe_SetSolidIndex(self, *args)


    def InDS(self, *args):
        """
        InDS(ChFiDS_Stripe self, Standard_Boolean const First, Standard_Integer const Nb=1)

        Set nb of SurfData's at end put in DS

        :type First: bool
        :type Nb: int

        """
        return _ChFiDS.ChFiDS_Stripe_InDS(self, *args)


    def IsInDS(self, *args):
        """
        IsInDS(ChFiDS_Stripe self, Standard_Boolean const First) -> Standard_Integer

        Returns nb of SurfData's at end being in DS

        :type First: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.ChFiDS_Stripe_IsInDS(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ChFiDS.ChFiDS_Stripe_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ChFiDS.ChFiDS_Stripe_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ChFiDS.ChFiDS_Stripe_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ChFiDS.delete_ChFiDS_Stripe
ChFiDS_Stripe_swigregister = _ChFiDS.ChFiDS_Stripe_swigregister
ChFiDS_Stripe_swigregister(ChFiDS_Stripe)

def ChFiDS_Stripe_get_type_name(*args):
    """
    ChFiDS_Stripe_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ChFiDS.ChFiDS_Stripe_get_type_name(*args)

def ChFiDS_Stripe_get_type_descriptor(*args):
    """
    ChFiDS_Stripe_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ChFiDS.ChFiDS_Stripe_get_type_descriptor(*args)

class ChFiDS_ChamfSpine(ChFiDS_Spine):
    """
    Provides  data specific to chamfers
    distances on  each  of faces.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ChFiDS_ChamfSpine
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ChFiDS_ChamfSpine(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ChFiDS_ChamfSpine self) -> ChFiDS_ChamfSpine
        __init__(ChFiDS_ChamfSpine self, Standard_Real const Tol) -> ChFiDS_ChamfSpine

        :type Tol: float

        """
        this = _ChFiDS.new_ChFiDS_ChamfSpine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetDist(self, *args):
        """
        SetDist(ChFiDS_ChamfSpine self, Standard_Real const Dis)

        :type Dis: float

        """
        return _ChFiDS.ChFiDS_ChamfSpine_SetDist(self, *args)


    def GetDist(self, *args):
        """
        GetDist(ChFiDS_ChamfSpine self)

        :type Dis: float

        """
        return _ChFiDS.ChFiDS_ChamfSpine_GetDist(self, *args)


    def SetDists(self, *args):
        """
        SetDists(ChFiDS_ChamfSpine self, Standard_Real const Dis1, Standard_Real const Dis2)

        :type Dis1: float
        :type Dis2: float

        """
        return _ChFiDS.ChFiDS_ChamfSpine_SetDists(self, *args)


    def Dists(self, *args):
        """
        Dists(ChFiDS_ChamfSpine self)

        :type Dis1: float
        :type Dis2: float

        """
        return _ChFiDS.ChFiDS_ChamfSpine_Dists(self, *args)


    def GetDistAngle(self, *args):
        """
        GetDistAngle(ChFiDS_ChamfSpine self)

        :type Dis: float
        :type Angle: float
        :type DisOnF1: bool

        """
        return _ChFiDS.ChFiDS_ChamfSpine_GetDistAngle(self, *args)


    def SetDistAngle(self, *args):
        """
        SetDistAngle(ChFiDS_ChamfSpine self, Standard_Real const Dis, Standard_Real const Angle, Standard_Boolean const DisOnF1)

        :type Dis: float
        :type Angle: float
        :type DisOnF1: bool

        """
        return _ChFiDS.ChFiDS_ChamfSpine_SetDistAngle(self, *args)


    def IsChamfer(self, *args):
        """
        IsChamfer(ChFiDS_ChamfSpine self) -> ChFiDS_ChamfMethod

        Return the method of chamfers used

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_ChamfMethod

        """
        return _ChFiDS.ChFiDS_ChamfSpine_IsChamfer(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ChFiDS.ChFiDS_ChamfSpine_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ChFiDS.ChFiDS_ChamfSpine_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ChFiDS.ChFiDS_ChamfSpine_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ChFiDS.delete_ChFiDS_ChamfSpine
ChFiDS_ChamfSpine_swigregister = _ChFiDS.ChFiDS_ChamfSpine_swigregister
ChFiDS_ChamfSpine_swigregister(ChFiDS_ChamfSpine)

def ChFiDS_ChamfSpine_get_type_name(*args):
    """
    ChFiDS_ChamfSpine_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ChFiDS.ChFiDS_ChamfSpine_get_type_name(*args)

def ChFiDS_ChamfSpine_get_type_descriptor(*args):
    """
    ChFiDS_ChamfSpine_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ChFiDS.ChFiDS_ChamfSpine_get_type_descriptor(*args)

class ChFiDS_HData(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ChFiDS_HData
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ChFiDS_HData(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ChFiDS_HData self) -> ChFiDS_HData
        __init__(ChFiDS_HData self, NCollection_Sequence_Handle_ChFiDS_SurfData theOther) -> ChFiDS_HData

        :type theOther: OCC.wrapper.ChFiDS.ChFiDS_SequenceOfSurfData

        """
        this = _ChFiDS.new_ChFiDS_HData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.ChFiDS.ChFiDS_SequenceOfSurfData

        """
        res = _ChFiDS.ChFiDS_HData_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(ChFiDS_HData self, Handle_ChFiDS_SurfData theItem)
        Append(ChFiDS_HData self, NCollection_Sequence_Handle_ChFiDS_SurfData theSequence)

        :type theSequence: OCC.wrapper.ChFiDS.ChFiDS_SequenceOfSurfData

        """
        return _ChFiDS.ChFiDS_HData_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(ChFiDS_HData self) -> NCollection_Sequence_Handle_ChFiDS_SurfData

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_SequenceOfSurfData

        """
        return _ChFiDS.ChFiDS_HData_ChangeSequence(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ChFiDS.ChFiDS_HData_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ChFiDS.ChFiDS_HData_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ChFiDS.ChFiDS_HData_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ChFiDS.delete_ChFiDS_HData
ChFiDS_HData_swigregister = _ChFiDS.ChFiDS_HData_swigregister
ChFiDS_HData_swigregister(ChFiDS_HData)

def ChFiDS_HData_get_type_name(*args):
    """
    ChFiDS_HData_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ChFiDS.ChFiDS_HData_get_type_name(*args)

def ChFiDS_HData_get_type_descriptor(*args):
    """
    ChFiDS_HData_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ChFiDS.ChFiDS_HData_get_type_descriptor(*args)

class ChFiDS_CircSection(object):
    """A Section of fillet."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ChFiDS_CircSection self) -> ChFiDS_CircSection

        A Section of fillet.
        """
        this = _ChFiDS.new_ChFiDS_CircSection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Set(self, *args):
        """
        Set(ChFiDS_CircSection self, gp_Circ C, Standard_Real const F, Standard_Real const L)
        Set(ChFiDS_CircSection self, gp_Lin C, Standard_Real const F, Standard_Real const L)

        :type C: OCC.wrapper.gp.gp_Lin
        :type F: float
        :type L: float

        """
        return _ChFiDS.ChFiDS_CircSection_Set(self, *args)


    def Get(self, *args):
        """
        Get(ChFiDS_CircSection self, gp_Circ C)
        Get(ChFiDS_CircSection self, gp_Lin C)

        :type C: OCC.wrapper.gp.gp_Lin
        :type F: float
        :type L: float

        """
        return _ChFiDS.ChFiDS_CircSection_Get(self, *args)

    __swig_destroy__ = _ChFiDS.delete_ChFiDS_CircSection
ChFiDS_CircSection_swigregister = _ChFiDS.ChFiDS_CircSection_swigregister
ChFiDS_CircSection_swigregister(ChFiDS_CircSection)

class ChFiDS_FilSpine(ChFiDS_Spine):
    """
    Provides  data specific to  the fillets -
    vector or rule  of evolution (C2).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ChFiDS_FilSpine
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ChFiDS_FilSpine(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ChFiDS_FilSpine self) -> ChFiDS_FilSpine
        __init__(ChFiDS_FilSpine self, Standard_Real const Tol) -> ChFiDS_FilSpine

        :type Tol: float

        """
        this = _ChFiDS.new_ChFiDS_FilSpine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Reset(self, *args):
        """
        Reset(ChFiDS_FilSpine self, Standard_Boolean const AllData)

        :type AllData: bool

        """
        return _ChFiDS.ChFiDS_FilSpine_Reset(self, *args)


    def UnSetRadius(self, *args):
        """
        UnSetRadius(ChFiDS_FilSpine self, TopoDS_Edge E)
        UnSetRadius(ChFiDS_FilSpine self, TopoDS_Vertex V)

        resets the vector on Vertex V.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _ChFiDS.ChFiDS_FilSpine_UnSetRadius(self, *args)


    def SetRadius(self, *args):
        """
        SetRadius(ChFiDS_FilSpine self, Standard_Real const Radius, TopoDS_Edge E)
        SetRadius(ChFiDS_FilSpine self, Standard_Real const Radius, TopoDS_Vertex V)
        SetRadius(ChFiDS_FilSpine self, gp_XY UandR, Standard_Integer const IinC)
        SetRadius(ChFiDS_FilSpine self, Standard_Real const Radius)
        SetRadius(ChFiDS_FilSpine self, Handle_Law_Function C, Standard_Integer const IinC)

        initializes the rule of evolution on all spine.

        :type C: OCC.wrapper.Law.Handle_Law_Function
        :type IinC: int

        """
        return _ChFiDS.ChFiDS_FilSpine_SetRadius(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(ChFiDS_FilSpine self) -> Standard_Boolean
        IsConstant(ChFiDS_FilSpine self, Standard_Integer const IE) -> Standard_Boolean

        returns true if the radius is constant
        all along the edge E.

        :type IE: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.ChFiDS_FilSpine_IsConstant(self, *args)


    def Radius(self, *args):
        """
        Radius(ChFiDS_FilSpine self) -> Standard_Real
        Radius(ChFiDS_FilSpine self, Standard_Integer const IE) -> Standard_Real
        Radius(ChFiDS_FilSpine self, TopoDS_Edge E) -> Standard_Real

        returns the radius if the fillet is constant
        all along the edge E.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.ChFiDS_FilSpine_Radius(self, *args)


    def AppendElSpine(self, *args):
        """
        AppendElSpine(ChFiDS_FilSpine self, Handle_ChFiDS_HElSpine Els)

        :type Els: OCC.wrapper.ChFiDS.Handle_ChFiDS_HElSpine

        """
        return _ChFiDS.ChFiDS_FilSpine_AppendElSpine(self, *args)


    def Law_(self, *args):
        """
        Law_(ChFiDS_FilSpine self, Handle_ChFiDS_HElSpine Els) -> Handle_Law_Composite

        :type Els: OCC.wrapper.ChFiDS.Handle_ChFiDS_HElSpine
        :rtype: OCC.wrapper.Law.Handle_Law_Composite

        """
        return _ChFiDS.ChFiDS_FilSpine_Law_(self, *args)


    def ChangeLaw(self, *args):
        """
        ChangeLaw(ChFiDS_FilSpine self, TopoDS_Edge E) -> Handle_Law_Function

        returns the elementary law

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Law.Handle_Law_Function

        """
        return _ChFiDS.ChFiDS_FilSpine_ChangeLaw(self, *args)


    def MaxRadFromSeqAndLaws(self, *args):
        """
        MaxRadFromSeqAndLaws(ChFiDS_FilSpine self) -> Standard_Real

        returns the maximum radius if the fillet is non-constant

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.ChFiDS_FilSpine_MaxRadFromSeqAndLaws(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ChFiDS.ChFiDS_FilSpine_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ChFiDS.ChFiDS_FilSpine_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ChFiDS.ChFiDS_FilSpine_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ChFiDS.delete_ChFiDS_FilSpine
ChFiDS_FilSpine_swigregister = _ChFiDS.ChFiDS_FilSpine_swigregister
ChFiDS_FilSpine_swigregister(ChFiDS_FilSpine)

def ChFiDS_FilSpine_get_type_name(*args):
    """
    ChFiDS_FilSpine_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ChFiDS.ChFiDS_FilSpine_get_type_name(*args)

def ChFiDS_FilSpine_get_type_descriptor(*args):
    """
    ChFiDS_FilSpine_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ChFiDS.ChFiDS_FilSpine_get_type_descriptor(*args)

class ChFiDS_HElSpine(Adaptor3d.Adaptor3d_HCurve):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ChFiDS_HElSpine
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ChFiDS_HElSpine(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ChFiDS_HElSpine self) -> ChFiDS_HElSpine
        __init__(ChFiDS_HElSpine self, ChFiDS_ElSpine C) -> ChFiDS_HElSpine

        Creates a GenHCurve from a Curve

        :type C: OCC.wrapper.ChFiDS.ChFiDS_ElSpine

        """
        this = _ChFiDS.new_ChFiDS_HElSpine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Set(self, *args):
        """
        Set(ChFiDS_HElSpine self, ChFiDS_ElSpine C)

        Sets the field of the GenHCurve.

        :type C: OCC.wrapper.ChFiDS.ChFiDS_ElSpine

        """
        return _ChFiDS.ChFiDS_HElSpine_Set(self, *args)


    def Curve(self, *args):
        """
        Returns the curve used to create the GenHCurve.
        This is redefined from HCurve, cannot be inline.

        :rtype: OCC.wrapper.Adaptor3d.Adaptor3d_Curve

        """
        res = _ChFiDS.ChFiDS_HElSpine_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetCurve(self, *args):
        """
        GetCurve(ChFiDS_HElSpine self) -> Adaptor3d_Curve

        Returns the curve used to create the GenHCurve.
        This is redefined from HCurve, cannot be inline.

        :rtype: OCC.wrapper.Adaptor3d.Adaptor3d_Curve

        """
        return _ChFiDS.ChFiDS_HElSpine_GetCurve(self, *args)


    def ChangeCurve(self, *args):
        """
        ChangeCurve(ChFiDS_HElSpine self) -> ChFiDS_ElSpine

        Returns the curve used to create the GenHCurve.

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_ElSpine

        """
        return _ChFiDS.ChFiDS_HElSpine_ChangeCurve(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ChFiDS.ChFiDS_HElSpine_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ChFiDS.ChFiDS_HElSpine_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ChFiDS.ChFiDS_HElSpine_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ChFiDS.delete_ChFiDS_HElSpine
ChFiDS_HElSpine_swigregister = _ChFiDS.ChFiDS_HElSpine_swigregister
ChFiDS_HElSpine_swigregister(ChFiDS_HElSpine)

def ChFiDS_HElSpine_get_type_name(*args):
    """
    ChFiDS_HElSpine_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ChFiDS.ChFiDS_HElSpine_get_type_name(*args)

def ChFiDS_HElSpine_get_type_descriptor(*args):
    """
    ChFiDS_HElSpine_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ChFiDS.ChFiDS_HElSpine_get_type_descriptor(*args)

class ChFiDS_SurfData(Standard.Standard_Transient):
    """
    data structure for all information related to  the
    fillet and to 2 faces vis a vis
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ChFiDS_SurfData
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ChFiDS_SurfData(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ChFiDS_SurfData self) -> ChFiDS_SurfData

        data structure for all information related to  the
        fillet and to 2 faces vis a vis
        """
        this = _ChFiDS.new_ChFiDS_SurfData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Copy(self, *args):
        """
        Copy(ChFiDS_SurfData self, Handle_ChFiDS_SurfData Other)

        :type Other: OCC.wrapper.ChFiDS.Handle_ChFiDS_SurfData

        """
        return _ChFiDS.ChFiDS_SurfData_Copy(self, *args)


    def IndexOfS1(self, *args):
        """
        IndexOfS1(ChFiDS_SurfData self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.ChFiDS_SurfData_IndexOfS1(self, *args)


    def IndexOfS2(self, *args):
        """
        IndexOfS2(ChFiDS_SurfData self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.ChFiDS_SurfData_IndexOfS2(self, *args)


    def IsOnCurve1(self, *args):
        """
        IsOnCurve1(ChFiDS_SurfData self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.ChFiDS_SurfData_IsOnCurve1(self, *args)


    def IsOnCurve2(self, *args):
        """
        IsOnCurve2(ChFiDS_SurfData self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.ChFiDS_SurfData_IsOnCurve2(self, *args)


    def IndexOfC1(self, *args):
        """
        IndexOfC1(ChFiDS_SurfData self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.ChFiDS_SurfData_IndexOfC1(self, *args)


    def IndexOfC2(self, *args):
        """
        IndexOfC2(ChFiDS_SurfData self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.ChFiDS_SurfData_IndexOfC2(self, *args)


    def Surf(self, *args):
        """
        Surf(ChFiDS_SurfData self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.ChFiDS_SurfData_Surf(self, *args)


    def Orientation(self, *args):
        """
        Orientation(ChFiDS_SurfData self) -> TopAbs_Orientation

        :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _ChFiDS.ChFiDS_SurfData_Orientation(self, *args)


    def InterferenceOnS1(self, *args):
        """
        :rtype: OCC.wrapper.ChFiDS.ChFiDS_FaceInterference

        """
        res = _ChFiDS.ChFiDS_SurfData_InterferenceOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InterferenceOnS2(self, *args):
        """
        :rtype: OCC.wrapper.ChFiDS.ChFiDS_FaceInterference

        """
        res = _ChFiDS.ChFiDS_SurfData_InterferenceOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def VertexFirstOnS1(self, *args):
        """
        :rtype: OCC.wrapper.ChFiDS.ChFiDS_CommonPoint

        """
        res = _ChFiDS.ChFiDS_SurfData_VertexFirstOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def VertexFirstOnS2(self, *args):
        """
        :rtype: OCC.wrapper.ChFiDS.ChFiDS_CommonPoint

        """
        res = _ChFiDS.ChFiDS_SurfData_VertexFirstOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def VertexLastOnS1(self, *args):
        """
        :rtype: OCC.wrapper.ChFiDS.ChFiDS_CommonPoint

        """
        res = _ChFiDS.ChFiDS_SurfData_VertexLastOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def VertexLastOnS2(self, *args):
        """
        :rtype: OCC.wrapper.ChFiDS.ChFiDS_CommonPoint

        """
        res = _ChFiDS.ChFiDS_SurfData_VertexLastOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeIndexOfS1(self, *args):
        """
        ChangeIndexOfS1(ChFiDS_SurfData self, Standard_Integer const Index)

        :type Index: int

        """
        return _ChFiDS.ChFiDS_SurfData_ChangeIndexOfS1(self, *args)


    def ChangeIndexOfS2(self, *args):
        """
        ChangeIndexOfS2(ChFiDS_SurfData self, Standard_Integer const Index)

        :type Index: int

        """
        return _ChFiDS.ChFiDS_SurfData_ChangeIndexOfS2(self, *args)


    def ChangeSurf(self, *args):
        """
        ChangeSurf(ChFiDS_SurfData self, Standard_Integer const Index)

        :type Index: int

        """
        return _ChFiDS.ChFiDS_SurfData_ChangeSurf(self, *args)


    def SetIndexOfC1(self, *args):
        """
        SetIndexOfC1(ChFiDS_SurfData self, Standard_Integer const Index)

        :type Index: int

        """
        return _ChFiDS.ChFiDS_SurfData_SetIndexOfC1(self, *args)


    def SetIndexOfC2(self, *args):
        """
        SetIndexOfC2(ChFiDS_SurfData self, Standard_Integer const Index)

        :type Index: int

        """
        return _ChFiDS.ChFiDS_SurfData_SetIndexOfC2(self, *args)


    def ChangeOrientation(self, *args):
        """
        ChangeOrientation(ChFiDS_SurfData self) -> TopAbs_Orientation &

        :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _ChFiDS.ChFiDS_SurfData_ChangeOrientation(self, *args)


    def ChangeInterferenceOnS1(self, *args):
        """
        ChangeInterferenceOnS1(ChFiDS_SurfData self) -> ChFiDS_FaceInterference

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_FaceInterference

        """
        return _ChFiDS.ChFiDS_SurfData_ChangeInterferenceOnS1(self, *args)


    def ChangeInterferenceOnS2(self, *args):
        """
        ChangeInterferenceOnS2(ChFiDS_SurfData self) -> ChFiDS_FaceInterference

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_FaceInterference

        """
        return _ChFiDS.ChFiDS_SurfData_ChangeInterferenceOnS2(self, *args)


    def ChangeVertexFirstOnS1(self, *args):
        """
        ChangeVertexFirstOnS1(ChFiDS_SurfData self) -> ChFiDS_CommonPoint

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_CommonPoint

        """
        return _ChFiDS.ChFiDS_SurfData_ChangeVertexFirstOnS1(self, *args)


    def ChangeVertexFirstOnS2(self, *args):
        """
        ChangeVertexFirstOnS2(ChFiDS_SurfData self) -> ChFiDS_CommonPoint

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_CommonPoint

        """
        return _ChFiDS.ChFiDS_SurfData_ChangeVertexFirstOnS2(self, *args)


    def ChangeVertexLastOnS1(self, *args):
        """
        ChangeVertexLastOnS1(ChFiDS_SurfData self) -> ChFiDS_CommonPoint

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_CommonPoint

        """
        return _ChFiDS.ChFiDS_SurfData_ChangeVertexLastOnS1(self, *args)


    def ChangeVertexLastOnS2(self, *args):
        """
        ChangeVertexLastOnS2(ChFiDS_SurfData self) -> ChFiDS_CommonPoint

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_CommonPoint

        """
        return _ChFiDS.ChFiDS_SurfData_ChangeVertexLastOnS2(self, *args)


    def Interference(self, *args):
        """
        :type OnS: int
        :rtype: OCC.wrapper.ChFiDS.ChFiDS_FaceInterference

        """
        res = _ChFiDS.ChFiDS_SurfData_Interference(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeInterference(self, *args):
        """
        ChangeInterference(ChFiDS_SurfData self, Standard_Integer const OnS) -> ChFiDS_FaceInterference

        :type OnS: int
        :rtype: OCC.wrapper.ChFiDS.ChFiDS_FaceInterference

        """
        return _ChFiDS.ChFiDS_SurfData_ChangeInterference(self, *args)


    def Index(self, *args):
        """
        Index(ChFiDS_SurfData self, Standard_Integer const OfS) -> Standard_Integer

        :type OfS: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.ChFiDS_SurfData_Index(self, *args)


    def Vertex(self, *args):
        """
        returns one of the four vertices  wether First is true
        or wrong and OnS equals 1 or 2.

        :type First: bool
        :type OnS: int
        :rtype: OCC.wrapper.ChFiDS.ChFiDS_CommonPoint

        """
        res = _ChFiDS.ChFiDS_SurfData_Vertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeVertex(self, *args):
        """
        ChangeVertex(ChFiDS_SurfData self, Standard_Boolean const First, Standard_Integer const OnS) -> ChFiDS_CommonPoint

        returns one of the four vertices  wether First is true
        or wrong and OnS equals 1 or 2.

        :type First: bool
        :type OnS: int
        :rtype: OCC.wrapper.ChFiDS.ChFiDS_CommonPoint

        """
        return _ChFiDS.ChFiDS_SurfData_ChangeVertex(self, *args)


    def IsOnCurve(self, *args):
        """
        IsOnCurve(ChFiDS_SurfData self, Standard_Integer const OnS) -> Standard_Boolean

        :type OnS: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.ChFiDS_SurfData_IsOnCurve(self, *args)


    def IndexOfC(self, *args):
        """
        IndexOfC(ChFiDS_SurfData self, Standard_Integer const OnS) -> Standard_Integer

        :type OnS: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.ChFiDS_SurfData_IndexOfC(self, *args)


    def FirstSpineParam(self, *args):
        """
        FirstSpineParam(ChFiDS_SurfData self) -> Standard_Real
        FirstSpineParam(ChFiDS_SurfData self, Standard_Real const Par)

        :type Par: float

        """
        return _ChFiDS.ChFiDS_SurfData_FirstSpineParam(self, *args)


    def LastSpineParam(self, *args):
        """
        LastSpineParam(ChFiDS_SurfData self) -> Standard_Real
        LastSpineParam(ChFiDS_SurfData self, Standard_Real const Par)

        :type Par: float

        """
        return _ChFiDS.ChFiDS_SurfData_LastSpineParam(self, *args)


    def FirstExtensionValue(self, *args):
        """
        FirstExtensionValue(ChFiDS_SurfData self) -> Standard_Real
        FirstExtensionValue(ChFiDS_SurfData self, Standard_Real const Extend)

        :type Extend: float

        """
        return _ChFiDS.ChFiDS_SurfData_FirstExtensionValue(self, *args)


    def LastExtensionValue(self, *args):
        """
        LastExtensionValue(ChFiDS_SurfData self) -> Standard_Real
        LastExtensionValue(ChFiDS_SurfData self, Standard_Real const Extend)

        :type Extend: float

        """
        return _ChFiDS.ChFiDS_SurfData_LastExtensionValue(self, *args)


    def Simul(self, *args):
        """
        Simul(ChFiDS_SurfData self) -> Handle_Standard_Transient

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _ChFiDS.ChFiDS_SurfData_Simul(self, *args)


    def SetSimul(self, *args):
        """
        SetSimul(ChFiDS_SurfData self, Handle_Standard_Transient S)

        :type S: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _ChFiDS.ChFiDS_SurfData_SetSimul(self, *args)


    def ResetSimul(self, *args):
        """ResetSimul(ChFiDS_SurfData self)"""
        return _ChFiDS.ChFiDS_SurfData_ResetSimul(self, *args)


    def Get2dPoints(self, *args):
        """
        Get2dPoints(ChFiDS_SurfData self, Standard_Boolean const First, Standard_Integer const OnS) -> gp_Pnt2d
        Get2dPoints(ChFiDS_SurfData self, gp_Pnt2d P2df1, gp_Pnt2d P2dl1, gp_Pnt2d P2df2, gp_Pnt2d P2dl2)

        :type P2df1: OCC.wrapper.gp.gp_Pnt2d
        :type P2dl1: OCC.wrapper.gp.gp_Pnt2d
        :type P2df2: OCC.wrapper.gp.gp_Pnt2d
        :type P2dl2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _ChFiDS.ChFiDS_SurfData_Get2dPoints(self, *args)


    def Set2dPoints(self, *args):
        """
        Set2dPoints(ChFiDS_SurfData self, gp_Pnt2d P2df1, gp_Pnt2d P2dl1, gp_Pnt2d P2df2, gp_Pnt2d P2dl2)

        :type P2df1: OCC.wrapper.gp.gp_Pnt2d
        :type P2dl1: OCC.wrapper.gp.gp_Pnt2d
        :type P2df2: OCC.wrapper.gp.gp_Pnt2d
        :type P2dl2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _ChFiDS.ChFiDS_SurfData_Set2dPoints(self, *args)


    def TwistOnS1(self, *args):
        """
        TwistOnS1(ChFiDS_SurfData self) -> Standard_Boolean
        TwistOnS1(ChFiDS_SurfData self, Standard_Boolean const T)

        :type T: bool

        """
        return _ChFiDS.ChFiDS_SurfData_TwistOnS1(self, *args)


    def TwistOnS2(self, *args):
        """
        TwistOnS2(ChFiDS_SurfData self) -> Standard_Boolean
        TwistOnS2(ChFiDS_SurfData self, Standard_Boolean const T)

        :type T: bool

        """
        return _ChFiDS.ChFiDS_SurfData_TwistOnS2(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ChFiDS.ChFiDS_SurfData_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ChFiDS.ChFiDS_SurfData_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ChFiDS.ChFiDS_SurfData_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ChFiDS.delete_ChFiDS_SurfData
ChFiDS_SurfData_swigregister = _ChFiDS.ChFiDS_SurfData_swigregister
ChFiDS_SurfData_swigregister(ChFiDS_SurfData)

def ChFiDS_SurfData_get_type_name(*args):
    """
    ChFiDS_SurfData_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ChFiDS.ChFiDS_SurfData_get_type_name(*args)

def ChFiDS_SurfData_get_type_descriptor(*args):
    """
    ChFiDS_SurfData_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ChFiDS.ChFiDS_SurfData_get_type_descriptor(*args)

class ChFiDS_CommonPoint(object):
    """
    point    start/end of  fillet common  to  2 adjacent  filets
    and  to an edge on  one of 2 faces participating
    in  the construction of  the  fillet
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ChFiDS_CommonPoint self) -> ChFiDS_CommonPoint

        Empty constructor.


        """
        this = _ChFiDS.new_ChFiDS_CommonPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Reset(self, *args):
        """
        Reset(ChFiDS_CommonPoint self)

        default value for all fields


        """
        return _ChFiDS.ChFiDS_CommonPoint_Reset(self, *args)


    def SetVertex(self, *args):
        """
        SetVertex(ChFiDS_CommonPoint self, TopoDS_Vertex V)

        Sets the values of a point which is a vertex on
        the initial facet of restriction of one
        of the surface.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _ChFiDS.ChFiDS_CommonPoint_SetVertex(self, *args)


    def SetArc(self, *args):
        """
        SetArc(ChFiDS_CommonPoint self, Standard_Real const Tol, TopoDS_Edge A, Standard_Real const Param, TopAbs_Orientation const TArc)

        Sets the values of a point which is on the arc
        A, at parameter Param.

        :type Tol: float
        :type A: OCC.wrapper.TopoDS.TopoDS_Edge
        :type Param: float
        :type TArc: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _ChFiDS.ChFiDS_CommonPoint_SetArc(self, *args)


    def SetParameter(self, *args):
        """
        SetParameter(ChFiDS_CommonPoint self, Standard_Real const Param)

        Sets the value of the parameter on the spine

        :type Param: float

        """
        return _ChFiDS.ChFiDS_CommonPoint_SetParameter(self, *args)


    def SetPoint(self, *args):
        """
        SetPoint(ChFiDS_CommonPoint self, gp_Pnt Point)

        Set the 3d point for a commonpoint that is not
        a vertex or on an arc.

        :type Point: OCC.wrapper.gp.gp_Pnt

        """
        return _ChFiDS.ChFiDS_CommonPoint_SetPoint(self, *args)


    def SetVector(self, *args):
        """
        SetVector(ChFiDS_CommonPoint self, gp_Vec Vector)

        Set the output 3d  vector

        :type Vector: OCC.wrapper.gp.gp_Vec

        """
        return _ChFiDS.ChFiDS_CommonPoint_SetVector(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(ChFiDS_CommonPoint self, Standard_Real const Tol)

        This method set the fuzziness on the point.

        :type Tol: float

        """
        return _ChFiDS.ChFiDS_CommonPoint_SetTolerance(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(ChFiDS_CommonPoint self) -> Standard_Real

        This method returns the fuzziness on the point.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.ChFiDS_CommonPoint_Tolerance(self, *args)


    def IsVertex(self, *args):
        """
        IsVertex(ChFiDS_CommonPoint self) -> Standard_Boolean

        Returns TRUE if the point is a vertex on the initial
        restriction facet of the surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.ChFiDS_CommonPoint_IsVertex(self, *args)


    def Vertex(self, *args):
        """
        Returns the information about the point when it is
        on the domain of the first patch, i-e when the function
        IsVertex returns True.
        Otherwise, an exception is raised.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        res = _ChFiDS.ChFiDS_CommonPoint_Vertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsOnArc(self, *args):
        """
        IsOnArc(ChFiDS_CommonPoint self) -> Standard_Boolean

        Returns TRUE if the point is a on an edge of the initial
        restriction facet of the surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.ChFiDS_CommonPoint_IsOnArc(self, *args)


    def Arc(self, *args):
        """
        Returns the arc of restriction containing the
        vertex.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _ChFiDS.ChFiDS_CommonPoint_Arc(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TransitionOnArc(self, *args):
        """
        TransitionOnArc(ChFiDS_CommonPoint self) -> TopAbs_Orientation

        Returns the transition of the point on the arc
        returned by Arc().

        :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _ChFiDS.ChFiDS_CommonPoint_TransitionOnArc(self, *args)


    def ParameterOnArc(self, *args):
        """
        ParameterOnArc(ChFiDS_CommonPoint self) -> Standard_Real

        Returns the parameter of the point on the
        arc returned by the method Arc().

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.ChFiDS_CommonPoint_ParameterOnArc(self, *args)


    def Parameter(self, *args):
        """
        Parameter(ChFiDS_CommonPoint self) -> Standard_Real

        Returns  the parameter the  paramter on the  spine

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.ChFiDS_CommonPoint_Parameter(self, *args)


    def Point(self, *args):
        """
        Returns the 3d point

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _ChFiDS.ChFiDS_CommonPoint_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasVector(self, *args):
        """
        HasVector(ChFiDS_CommonPoint self) -> Standard_Boolean

        Returns TRUE if the output vector is  stored.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.ChFiDS_CommonPoint_HasVector(self, *args)


    def Vector(self, *args):
        """
        Returns the output  3d vector

        :rtype: OCC.wrapper.gp.gp_Vec

        """
        res = _ChFiDS.ChFiDS_CommonPoint_Vector(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ChFiDS.delete_ChFiDS_CommonPoint
ChFiDS_CommonPoint_swigregister = _ChFiDS.ChFiDS_CommonPoint_swigregister
ChFiDS_CommonPoint_swigregister(ChFiDS_CommonPoint)

class Handle_ChFiDS_HData(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ChFiDS_HData self)

        Nullify the handle


        """
        return _ChFiDS.Handle_ChFiDS_HData_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ChFiDS_HData self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ChFiDS.Handle_ChFiDS_HData_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ChFiDS_HData self, ChFiDS_HData thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ChFiDS.Handle_ChFiDS_HData_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ChFiDS_HData self, Handle_ChFiDS_HData theHandle) -> Handle_ChFiDS_HData
        assign(Handle_ChFiDS_HData self, ChFiDS_HData thePtr) -> Handle_ChFiDS_HData
        assign(Handle_ChFiDS_HData self, Handle_ChFiDS_HData theHandle) -> Handle_ChFiDS_HData

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ChFiDS.Handle_ChFiDS_HData_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ChFiDS_HData self) -> ChFiDS_HData

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ChFiDS.Handle_ChFiDS_HData_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ChFiDS_HData self) -> ChFiDS_HData

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ChFiDS.Handle_ChFiDS_HData___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ChFiDS_HData self) -> ChFiDS_HData

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ChFiDS.Handle_ChFiDS_HData___ref__(self, *args)


    def __hash__(self):
        return _ChFiDS.Handle_ChFiDS_HData___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ChFiDS.Handle_ChFiDS_HData___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ChFiDS.new_Handle_ChFiDS_HData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ChFiDS.Handle_ChFiDS_HData_DownCast)
    __swig_destroy__ = _ChFiDS.delete_Handle_ChFiDS_HData

    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.ChFiDS.ChFiDS_SequenceOfSurfData

        """
        res = _ChFiDS.Handle_ChFiDS_HData_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Handle_ChFiDS_HData self, Handle_ChFiDS_SurfData theItem)
        Append(Handle_ChFiDS_HData self, NCollection_Sequence_Handle_ChFiDS_SurfData theSequence)

        :type theSequence: OCC.wrapper.ChFiDS.ChFiDS_SequenceOfSurfData

        """
        return _ChFiDS.Handle_ChFiDS_HData_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Handle_ChFiDS_HData self) -> NCollection_Sequence_Handle_ChFiDS_SurfData

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_SequenceOfSurfData

        """
        return _ChFiDS.Handle_ChFiDS_HData_ChangeSequence(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ChFiDS_HData self) -> char const *

        :rtype: const char *

        """
        return _ChFiDS.Handle_ChFiDS_HData_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ChFiDS.Handle_ChFiDS_HData_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ChFiDS.Handle_ChFiDS_HData_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_ChFiDS_HData self)

        Memory deallocator for transient classes


        """
        return _ChFiDS.Handle_ChFiDS_HData_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ChFiDS_HData self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ChFiDS_HData self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_HData_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ChFiDS_HData self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ChFiDS_HData self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_HData_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ChFiDS_HData self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ChFiDS.Handle_ChFiDS_HData_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ChFiDS_HData self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_HData_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ChFiDS_HData self)

        Increments the reference counter of this object


        """
        return _ChFiDS.Handle_ChFiDS_HData_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ChFiDS_HData self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_HData_DecrementRefCounter(self, *args)

Handle_ChFiDS_HData_swigregister = _ChFiDS.Handle_ChFiDS_HData_swigregister
Handle_ChFiDS_HData_swigregister(Handle_ChFiDS_HData)

def Handle_ChFiDS_HData_DownCast(thing):
    return _ChFiDS.Handle_ChFiDS_HData_DownCast(thing)
Handle_ChFiDS_HData_DownCast = _ChFiDS.Handle_ChFiDS_HData_DownCast

class NCollection_Sequence_Handle_ChFiDS_SurfData(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_ChFiDS_SurfData self) -> NCollection_Sequence< opencascade::handle< ChFiDS_SurfData > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_SurfData_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_ChFiDS_SurfData self) -> NCollection_Sequence< opencascade::handle< ChFiDS_SurfData > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_SurfData_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_ChFiDS_SurfData self) -> NCollection_Sequence< opencascade::handle< ChFiDS_SurfData > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_SurfData_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_ChFiDS_SurfData self) -> NCollection_Sequence< opencascade::handle< ChFiDS_SurfData > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_SurfData_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _ChFiDS.new_NCollection_Sequence_Handle_ChFiDS_SurfData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_ChFiDS_SurfData self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_SurfData_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_ChFiDS_SurfData self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_SurfData_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_ChFiDS_SurfData self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_SurfData_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_ChFiDS_SurfData self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_SurfData_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_ChFiDS_SurfData self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_SurfData_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_ChFiDS_SurfData self)

        Reverse sequence


        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_SurfData_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_ChFiDS_SurfData self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_SurfData_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_SurfData_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_ChFiDS_SurfData self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_SurfData_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_ChFiDS_SurfData self, NCollection_Sequence_Handle_ChFiDS_SurfData theOther) -> NCollection_Sequence_Handle_ChFiDS_SurfData

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_SurfData_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_ChFiDS_SurfData self, NCollection_Sequence_Handle_ChFiDS_SurfData theOther) -> NCollection_Sequence_Handle_ChFiDS_SurfData

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_SurfData_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_ChFiDS_SurfData self, NCollection_Sequence< opencascade::handle< ChFiDS_SurfData > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_ChFiDS_SurfData self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_ChFiDS_SurfData self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_SurfData_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_ChFiDS_SurfData self, Handle_ChFiDS_SurfData theItem)
        Append(NCollection_Sequence_Handle_ChFiDS_SurfData self, NCollection_Sequence_Handle_ChFiDS_SurfData theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_SurfData_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_ChFiDS_SurfData self, Handle_ChFiDS_SurfData theItem)
        Prepend(NCollection_Sequence_Handle_ChFiDS_SurfData self, NCollection_Sequence_Handle_ChFiDS_SurfData theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_SurfData_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_ChFiDS_SurfData self, Standard_Integer const theIndex, Handle_ChFiDS_SurfData theItem)
        InsertBefore(NCollection_Sequence_Handle_ChFiDS_SurfData self, Standard_Integer const theIndex, NCollection_Sequence_Handle_ChFiDS_SurfData theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_SurfData_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_ChFiDS_SurfData self, NCollection_Sequence< opencascade::handle< ChFiDS_SurfData > >::Iterator & thePosition, Handle_ChFiDS_SurfData theItem)
        InsertAfter(NCollection_Sequence_Handle_ChFiDS_SurfData self, Standard_Integer const theIndex, NCollection_Sequence_Handle_ChFiDS_SurfData theSeq)
        InsertAfter(NCollection_Sequence_Handle_ChFiDS_SurfData self, Standard_Integer const theIndex, Handle_ChFiDS_SurfData theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_SurfData_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_ChFiDS_SurfData self, Standard_Integer const theIndex, NCollection_Sequence_Handle_ChFiDS_SurfData theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_SurfData_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _ChFiDS.NCollection_Sequence_Handle_ChFiDS_SurfData_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_ChFiDS_SurfData self) -> Handle_ChFiDS_SurfData

        First item access

        :rtype: TheItemType &

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_SurfData_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _ChFiDS.NCollection_Sequence_Handle_ChFiDS_SurfData_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_ChFiDS_SurfData self) -> Handle_ChFiDS_SurfData

        Last item access

        :rtype: TheItemType &

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_SurfData_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _ChFiDS.NCollection_Sequence_Handle_ChFiDS_SurfData_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_ChFiDS_SurfData self, Standard_Integer const theIndex) -> Handle_ChFiDS_SurfData

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_SurfData_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _ChFiDS.NCollection_Sequence_Handle_ChFiDS_SurfData___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_ChFiDS_SurfData self, Standard_Integer const theIndex, Handle_ChFiDS_SurfData theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_SurfData_SetValue(self, *args)


    def __iter__(self):
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_SurfData___iter__(self)
    __swig_destroy__ = _ChFiDS.delete_NCollection_Sequence_Handle_ChFiDS_SurfData
NCollection_Sequence_Handle_ChFiDS_SurfData_swigregister = _ChFiDS.NCollection_Sequence_Handle_ChFiDS_SurfData_swigregister
NCollection_Sequence_Handle_ChFiDS_SurfData_swigregister(NCollection_Sequence_Handle_ChFiDS_SurfData)

def NCollection_Sequence_Handle_ChFiDS_SurfData_delNode(*args):
    """
    NCollection_Sequence_Handle_ChFiDS_SurfData_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_SurfData_delNode(*args)

class NCollection_Sequence_Handle_ChFiDS_SurfData_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _ChFiDS.new_NCollection_Sequence_Handle_ChFiDS_SurfData_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ChFiDS.delete_NCollection_Sequence_Handle_ChFiDS_SurfData_IteratorHelper

    def __next__(self):
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_SurfData_IteratorHelper___next__(self)
NCollection_Sequence_Handle_ChFiDS_SurfData_IteratorHelper_swigregister = _ChFiDS.NCollection_Sequence_Handle_ChFiDS_SurfData_IteratorHelper_swigregister
NCollection_Sequence_Handle_ChFiDS_SurfData_IteratorHelper_swigregister(NCollection_Sequence_Handle_ChFiDS_SurfData_IteratorHelper)


try:
	ChFiDS_SequenceOfSurfData = NCollection_Sequence_Handle_ChFiDS_SurfData
except NameError:
	pass # does not exist, probably ignored

class Handle_ChFiDS_ChamfSpine(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ChFiDS_ChamfSpine self)

        Nullify the handle


        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ChFiDS_ChamfSpine self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ChFiDS_ChamfSpine self, ChFiDS_ChamfSpine thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ChFiDS_ChamfSpine self, Handle_ChFiDS_ChamfSpine theHandle) -> Handle_ChFiDS_ChamfSpine
        assign(Handle_ChFiDS_ChamfSpine self, ChFiDS_ChamfSpine thePtr) -> Handle_ChFiDS_ChamfSpine
        assign(Handle_ChFiDS_ChamfSpine self, Handle_ChFiDS_ChamfSpine theHandle) -> Handle_ChFiDS_ChamfSpine

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ChFiDS_ChamfSpine self) -> ChFiDS_ChamfSpine

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ChFiDS_ChamfSpine self) -> ChFiDS_ChamfSpine

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ChFiDS_ChamfSpine self) -> ChFiDS_ChamfSpine

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine___ref__(self, *args)


    def __hash__(self):
        return _ChFiDS.Handle_ChFiDS_ChamfSpine___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ChFiDS.Handle_ChFiDS_ChamfSpine___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ChFiDS.new_Handle_ChFiDS_ChamfSpine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ChFiDS.Handle_ChFiDS_ChamfSpine_DownCast)
    __swig_destroy__ = _ChFiDS.delete_Handle_ChFiDS_ChamfSpine

    def SetDist(self, *args):
        """
        SetDist(Handle_ChFiDS_ChamfSpine self, Standard_Real const Dis)

        :type Dis: float

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_SetDist(self, *args)


    def GetDist(self, *args):
        """
        GetDist(Handle_ChFiDS_ChamfSpine self)

        :type Dis: float

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_GetDist(self, *args)


    def SetDists(self, *args):
        """
        SetDists(Handle_ChFiDS_ChamfSpine self, Standard_Real const Dis1, Standard_Real const Dis2)

        :type Dis1: float
        :type Dis2: float

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_SetDists(self, *args)


    def Dists(self, *args):
        """
        Dists(Handle_ChFiDS_ChamfSpine self)

        :type Dis1: float
        :type Dis2: float

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_Dists(self, *args)


    def GetDistAngle(self, *args):
        """
        GetDistAngle(Handle_ChFiDS_ChamfSpine self)

        :type Dis: float
        :type Angle: float
        :type DisOnF1: bool

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_GetDistAngle(self, *args)


    def SetDistAngle(self, *args):
        """
        SetDistAngle(Handle_ChFiDS_ChamfSpine self, Standard_Real const Dis, Standard_Real const Angle, Standard_Boolean const DisOnF1)

        :type Dis: float
        :type Angle: float
        :type DisOnF1: bool

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_SetDistAngle(self, *args)


    def IsChamfer(self, *args):
        """
        IsChamfer(Handle_ChFiDS_ChamfSpine self) -> ChFiDS_ChamfMethod

        Return the method of chamfers used

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_ChamfMethod

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_IsChamfer(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ChFiDS_ChamfSpine self) -> char const *

        :rtype: const char *

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ChFiDS.Handle_ChFiDS_ChamfSpine_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ChFiDS.Handle_ChFiDS_ChamfSpine_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetEdges(self, *args):
        """
        SetEdges(Handle_ChFiDS_ChamfSpine self, TopoDS_Edge E)

        store edges composing the guideline

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_SetEdges(self, *args)


    def PutInFirst(self, *args):
        """
        PutInFirst(Handle_ChFiDS_ChamfSpine self, TopoDS_Edge E)

        store the edge at the first position before all others

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_PutInFirst(self, *args)


    def NbEdges(self, *args):
        """
        NbEdges(Handle_ChFiDS_ChamfSpine self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_NbEdges(self, *args)


    def Edges(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _ChFiDS.Handle_ChFiDS_ChamfSpine_Edges(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstStatus(self, *args):
        """
        SetFirstStatus(Handle_ChFiDS_ChamfSpine self, ChFiDS_State const S)

        stores if the start of a set of edges starts on a
        section of free border or forms  a closed contour

        :type S: OCC.wrapper.ChFiDS.ChFiDS_State

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_SetFirstStatus(self, *args)


    def SetLastStatus(self, *args):
        """
        SetLastStatus(Handle_ChFiDS_ChamfSpine self, ChFiDS_State const S)

        stores if the end of a set of edges starts on a
        section of free border or forms  a closed contour

        :type S: OCC.wrapper.ChFiDS.ChFiDS_State

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_SetLastStatus(self, *args)


    def AppendElSpine(self, *args):
        """
        AppendElSpine(Handle_ChFiDS_ChamfSpine self, Handle_ChFiDS_HElSpine Els)

        :type Els: OCC.wrapper.ChFiDS.Handle_ChFiDS_HElSpine

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_AppendElSpine(self, *args)


    def ElSpine(self, *args):
        """
        ElSpine(Handle_ChFiDS_ChamfSpine self, Standard_Integer const IE) -> Handle_ChFiDS_HElSpine
        ElSpine(Handle_ChFiDS_ChamfSpine self, TopoDS_Edge E) -> Handle_ChFiDS_HElSpine
        ElSpine(Handle_ChFiDS_ChamfSpine self, Standard_Real const W) -> Handle_ChFiDS_HElSpine

        :type W: float
        :rtype: OCC.wrapper.ChFiDS.Handle_ChFiDS_HElSpine

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_ElSpine(self, *args)


    def ChangeElSpines(self, *args):
        """
        ChangeElSpines(Handle_ChFiDS_ChamfSpine self) -> NCollection_List_Handle_ChFiDS_HElSpine

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_ListOfHElSpine

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_ChangeElSpines(self, *args)


    def Reset(self, *args):
        """
        Reset(Handle_ChFiDS_ChamfSpine self, Standard_Boolean const AllData)

        :type AllData: bool

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_Reset(self, *args)


    def SplitDone(self, *args):
        """
        SplitDone(Handle_ChFiDS_ChamfSpine self) -> Standard_Boolean
        SplitDone(Handle_ChFiDS_ChamfSpine self, Standard_Boolean const B)

        :type B: bool

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_SplitDone(self, *args)


    def Load(self, *args):
        """
        Load(Handle_ChFiDS_ChamfSpine self)

        prepare the guideline depending on the edges that
        are elementary arks (take parameters from
        a single curvilinear abscissa); to be able to call
        methods on the geometry (first,last,value,d1,d2)
        it is necessary to start with preparation otherwise an
        exception will be raised


        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_Load(self, *args)


    def Resolution(self, *args):
        """
        Resolution(Handle_ChFiDS_ChamfSpine self, Standard_Real const R3d) -> Standard_Real

        :type R3d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_Resolution(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_ChFiDS_ChamfSpine self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_IsClosed(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_ChFiDS_ChamfSpine self) -> Standard_Real
        FirstParameter(Handle_ChFiDS_ChamfSpine self, Standard_Integer const IndexSpine) -> Standard_Real

        gives the total length of all arcs before the
        number IndexSp

        :type IndexSpine: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_ChFiDS_ChamfSpine self) -> Standard_Real
        LastParameter(Handle_ChFiDS_ChamfSpine self, Standard_Integer const IndexSpine) -> Standard_Real

        gives the total length till the ark with number
        IndexSpine (inclus)

        :type IndexSpine: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_LastParameter(self, *args)


    def SetFirstParameter(self, *args):
        """
        SetFirstParameter(Handle_ChFiDS_ChamfSpine self, Standard_Real const Par)

        :type Par: float

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_SetFirstParameter(self, *args)


    def SetLastParameter(self, *args):
        """
        SetLastParameter(Handle_ChFiDS_ChamfSpine self, Standard_Real const Par)

        :type Par: float

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_SetLastParameter(self, *args)


    def Length(self, *args):
        """
        Length(Handle_ChFiDS_ChamfSpine self, Standard_Integer const IndexSpine) -> Standard_Real

        gives the length of ark with number IndexSp

        :type IndexSpine: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_Length(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_ChFiDS_ChamfSpine self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_IsPeriodic(self, *args)


    def Period(self, *args):
        """
        Period(Handle_ChFiDS_ChamfSpine self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_Period(self, *args)


    def Absc(self, *args):
        """
        Absc(Handle_ChFiDS_ChamfSpine self, Standard_Real const U) -> Standard_Real
        Absc(Handle_ChFiDS_ChamfSpine self, Standard_Real const U, Standard_Integer const I) -> Standard_Real
        Absc(Handle_ChFiDS_ChamfSpine self, TopoDS_Vertex V) -> Standard_Real

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_Absc(self, *args)


    def Parameter(self, *args):
        """
        Parameter(Handle_ChFiDS_ChamfSpine self, Standard_Real const AbsC, Standard_Boolean const Oriented)
        Parameter(Handle_ChFiDS_ChamfSpine self, Standard_Integer const Index, Standard_Real const AbsC, Standard_Boolean const Oriented)

        :type Index: int
        :type AbsC: float
        :type U: float
        :type Oriented: bool

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_Parameter(self, *args)


    def Value(self, *args):
        """
        Value(Handle_ChFiDS_ChamfSpine self, Standard_Real const AbsC) -> gp_Pnt

        :type AbsC: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_Value(self, *args)


    def D0(self, *args):
        """
        D0(Handle_ChFiDS_ChamfSpine self, Standard_Real const AbsC, gp_Pnt P)

        :type AbsC: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_ChFiDS_ChamfSpine self, Standard_Real const AbsC, gp_Pnt P, gp_Vec V1)

        :type AbsC: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_ChFiDS_ChamfSpine self, Standard_Real const AbsC, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        :type AbsC: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_D2(self, *args)


    def SetCurrent(self, *args):
        """
        SetCurrent(Handle_ChFiDS_ChamfSpine self, Standard_Integer const Index)

        :type Index: int

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_SetCurrent(self, *args)


    def CurrentElementarySpine(self, *args):
        """
        sets the current curve and returns it

        :type Index: int
        :rtype: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve

        """
        res = _ChFiDS.Handle_ChFiDS_ChamfSpine_CurrentElementarySpine(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CurrentIndexOfElementarySpine(self, *args):
        """
        CurrentIndexOfElementarySpine(Handle_ChFiDS_ChamfSpine self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_CurrentIndexOfElementarySpine(self, *args)


    def GetType(self, *args):
        """
        GetType(Handle_ChFiDS_ChamfSpine self) -> GeomAbs_CurveType

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_GetType(self, *args)


    def Line(self, *args):
        """
        Line(Handle_ChFiDS_ChamfSpine self) -> gp_Lin

        :rtype: OCC.wrapper.gp.gp_Lin

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_Line(self, *args)


    def Circle(self, *args):
        """
        Circle(Handle_ChFiDS_ChamfSpine self) -> gp_Circ

        :rtype: OCC.wrapper.gp.gp_Circ

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_Circle(self, *args)


    def FirstStatus(self, *args):
        """
        FirstStatus(Handle_ChFiDS_ChamfSpine self) -> ChFiDS_State

        returns if the set of edges starts on a free boundary
        or if the first vertex is a breakpoint or if the set is
        closed

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_State

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_FirstStatus(self, *args)


    def LastStatus(self, *args):
        """
        LastStatus(Handle_ChFiDS_ChamfSpine self) -> ChFiDS_State

        returns the state at the end of the set

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_State

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_LastStatus(self, *args)


    def Status(self, *args):
        """
        Status(Handle_ChFiDS_ChamfSpine self, Standard_Boolean const IsFirst) -> ChFiDS_State

        :type IsFirst: bool
        :rtype: OCC.wrapper.ChFiDS.ChFiDS_State

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_Status(self, *args)


    def SetStatus(self, *args):
        """
        SetStatus(Handle_ChFiDS_ChamfSpine self, ChFiDS_State const S, Standard_Boolean const IsFirst)

        :type S: OCC.wrapper.ChFiDS.ChFiDS_State
        :type IsFirst: bool

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_SetStatus(self, *args)


    def IsTangencyExtremity(self, *args):
        """
        IsTangencyExtremity(Handle_ChFiDS_ChamfSpine self, Standard_Boolean const IsFirst) -> Standard_Boolean

        returns   if the  set  of  edges starts (or   end) on
        Tangency point.

        :type IsFirst: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_IsTangencyExtremity(self, *args)


    def SetTangencyExtremity(self, *args):
        """
        SetTangencyExtremity(Handle_ChFiDS_ChamfSpine self, Standard_Boolean const IsTangency, Standard_Boolean const IsFirst)

        :type IsTangency: bool
        :type IsFirst: bool

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_SetTangencyExtremity(self, *args)


    def FirstVertex(self, *args):
        """
        FirstVertex(Handle_ChFiDS_ChamfSpine self) -> TopoDS_Vertex

        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_FirstVertex(self, *args)


    def LastVertex(self, *args):
        """
        LastVertex(Handle_ChFiDS_ChamfSpine self) -> TopoDS_Vertex

        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_LastVertex(self, *args)


    def SetFirstTgt(self, *args):
        """
        SetFirstTgt(Handle_ChFiDS_ChamfSpine self, Standard_Real const W)

        :type W: float

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_SetFirstTgt(self, *args)


    def SetLastTgt(self, *args):
        """
        SetLastTgt(Handle_ChFiDS_ChamfSpine self, Standard_Real const W)

        :type W: float

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_SetLastTgt(self, *args)


    def HasFirstTgt(self, *args):
        """
        HasFirstTgt(Handle_ChFiDS_ChamfSpine self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_HasFirstTgt(self, *args)


    def HasLastTgt(self, *args):
        """
        HasLastTgt(Handle_ChFiDS_ChamfSpine self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_HasLastTgt(self, *args)


    def SetReference(self, *args):
        """
        SetReference(Handle_ChFiDS_ChamfSpine self, Standard_Real const W)
        SetReference(Handle_ChFiDS_ChamfSpine self, Standard_Integer const I)

        set  a  parameter  reference  for  the approx,  at the
        middle  of edge I.

        :type I: int

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_SetReference(self, *args)


    def Index(self, *args):
        """
        Index(Handle_ChFiDS_ChamfSpine self, Standard_Real const W, Standard_Boolean const Forward) -> Standard_Integer
        Index(Handle_ChFiDS_ChamfSpine self, TopoDS_Edge E) -> Standard_Integer

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_Index(self, *args)


    def UnsetReference(self, *args):
        """UnsetReference(Handle_ChFiDS_ChamfSpine self)"""
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_UnsetReference(self, *args)


    def SetErrorStatus(self, *args):
        """
        SetErrorStatus(Handle_ChFiDS_ChamfSpine self, ChFiDS_ErrorStatus const state)

        :type state: OCC.wrapper.ChFiDS.ChFiDS_ErrorStatus

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_SetErrorStatus(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(Handle_ChFiDS_ChamfSpine self) -> ChFiDS_ErrorStatus

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_ErrorStatus

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_ErrorStatus(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ChFiDS_ChamfSpine self)

        Memory deallocator for transient classes


        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ChFiDS_ChamfSpine self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ChFiDS_ChamfSpine self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ChFiDS_ChamfSpine self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ChFiDS_ChamfSpine self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ChFiDS_ChamfSpine self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ChFiDS_ChamfSpine self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ChFiDS_ChamfSpine self)

        Increments the reference counter of this object


        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ChFiDS_ChamfSpine self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_ChamfSpine_DecrementRefCounter(self, *args)

Handle_ChFiDS_ChamfSpine_swigregister = _ChFiDS.Handle_ChFiDS_ChamfSpine_swigregister
Handle_ChFiDS_ChamfSpine_swigregister(Handle_ChFiDS_ChamfSpine)

def Handle_ChFiDS_ChamfSpine_DownCast(thing):
    return _ChFiDS.Handle_ChFiDS_ChamfSpine_DownCast(thing)
Handle_ChFiDS_ChamfSpine_DownCast = _ChFiDS.Handle_ChFiDS_ChamfSpine_DownCast

class NCollection_Sequence_Handle_ChFiDS_Spine(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_ChFiDS_Spine self) -> NCollection_Sequence< opencascade::handle< ChFiDS_Spine > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_Spine_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_ChFiDS_Spine self) -> NCollection_Sequence< opencascade::handle< ChFiDS_Spine > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_Spine_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_ChFiDS_Spine self) -> NCollection_Sequence< opencascade::handle< ChFiDS_Spine > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_Spine_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_ChFiDS_Spine self) -> NCollection_Sequence< opencascade::handle< ChFiDS_Spine > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_Spine_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _ChFiDS.new_NCollection_Sequence_Handle_ChFiDS_Spine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_ChFiDS_Spine self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_Spine_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_ChFiDS_Spine self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_Spine_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_ChFiDS_Spine self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_Spine_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_ChFiDS_Spine self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_Spine_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_ChFiDS_Spine self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_Spine_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_ChFiDS_Spine self)

        Reverse sequence


        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_Spine_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_ChFiDS_Spine self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_Spine_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_Spine_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_ChFiDS_Spine self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_Spine_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_ChFiDS_Spine self, NCollection_Sequence_Handle_ChFiDS_Spine theOther) -> NCollection_Sequence_Handle_ChFiDS_Spine

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_Spine_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_ChFiDS_Spine self, NCollection_Sequence_Handle_ChFiDS_Spine theOther) -> NCollection_Sequence_Handle_ChFiDS_Spine

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_Spine_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_ChFiDS_Spine self, NCollection_Sequence< opencascade::handle< ChFiDS_Spine > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_ChFiDS_Spine self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_ChFiDS_Spine self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_Spine_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_ChFiDS_Spine self, Handle_ChFiDS_Spine theItem)
        Append(NCollection_Sequence_Handle_ChFiDS_Spine self, NCollection_Sequence_Handle_ChFiDS_Spine theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_Spine_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_ChFiDS_Spine self, Handle_ChFiDS_Spine theItem)
        Prepend(NCollection_Sequence_Handle_ChFiDS_Spine self, NCollection_Sequence_Handle_ChFiDS_Spine theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_Spine_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_ChFiDS_Spine self, Standard_Integer const theIndex, Handle_ChFiDS_Spine theItem)
        InsertBefore(NCollection_Sequence_Handle_ChFiDS_Spine self, Standard_Integer const theIndex, NCollection_Sequence_Handle_ChFiDS_Spine theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_Spine_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_ChFiDS_Spine self, NCollection_Sequence< opencascade::handle< ChFiDS_Spine > >::Iterator & thePosition, Handle_ChFiDS_Spine theItem)
        InsertAfter(NCollection_Sequence_Handle_ChFiDS_Spine self, Standard_Integer const theIndex, NCollection_Sequence_Handle_ChFiDS_Spine theSeq)
        InsertAfter(NCollection_Sequence_Handle_ChFiDS_Spine self, Standard_Integer const theIndex, Handle_ChFiDS_Spine theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_Spine_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_ChFiDS_Spine self, Standard_Integer const theIndex, NCollection_Sequence_Handle_ChFiDS_Spine theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_Spine_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _ChFiDS.NCollection_Sequence_Handle_ChFiDS_Spine_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_ChFiDS_Spine self) -> Handle_ChFiDS_Spine

        First item access

        :rtype: TheItemType &

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_Spine_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _ChFiDS.NCollection_Sequence_Handle_ChFiDS_Spine_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_ChFiDS_Spine self) -> Handle_ChFiDS_Spine

        Last item access

        :rtype: TheItemType &

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_Spine_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _ChFiDS.NCollection_Sequence_Handle_ChFiDS_Spine_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_ChFiDS_Spine self, Standard_Integer const theIndex) -> Handle_ChFiDS_Spine

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_Spine_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _ChFiDS.NCollection_Sequence_Handle_ChFiDS_Spine___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_ChFiDS_Spine self, Standard_Integer const theIndex, Handle_ChFiDS_Spine theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_Spine_SetValue(self, *args)


    def __iter__(self):
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_Spine___iter__(self)
    __swig_destroy__ = _ChFiDS.delete_NCollection_Sequence_Handle_ChFiDS_Spine
NCollection_Sequence_Handle_ChFiDS_Spine_swigregister = _ChFiDS.NCollection_Sequence_Handle_ChFiDS_Spine_swigregister
NCollection_Sequence_Handle_ChFiDS_Spine_swigregister(NCollection_Sequence_Handle_ChFiDS_Spine)

def NCollection_Sequence_Handle_ChFiDS_Spine_delNode(*args):
    """
    NCollection_Sequence_Handle_ChFiDS_Spine_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_Spine_delNode(*args)

class NCollection_Sequence_Handle_ChFiDS_Spine_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _ChFiDS.new_NCollection_Sequence_Handle_ChFiDS_Spine_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ChFiDS.delete_NCollection_Sequence_Handle_ChFiDS_Spine_IteratorHelper

    def __next__(self):
        return _ChFiDS.NCollection_Sequence_Handle_ChFiDS_Spine_IteratorHelper___next__(self)
NCollection_Sequence_Handle_ChFiDS_Spine_IteratorHelper_swigregister = _ChFiDS.NCollection_Sequence_Handle_ChFiDS_Spine_IteratorHelper_swigregister
NCollection_Sequence_Handle_ChFiDS_Spine_IteratorHelper_swigregister(NCollection_Sequence_Handle_ChFiDS_Spine_IteratorHelper)


try:
	ChFiDS_SequenceOfSpine = NCollection_Sequence_Handle_ChFiDS_Spine
except NameError:
	pass # does not exist, probably ignored

class ChFiDS_StripeMap(object):
    """encapsulation of IndexedDataMapOfVertexListOfStripe"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ChFiDS_StripeMap self) -> ChFiDS_StripeMap

        encapsulation of IndexedDataMapOfVertexListOfStripe
        """
        this = _ChFiDS.new_ChFiDS_StripeMap(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args):
        """
        Add(ChFiDS_StripeMap self, TopoDS_Vertex V, Handle_ChFiDS_Stripe F)

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type F: OCC.wrapper.ChFiDS.Handle_ChFiDS_Stripe

        """
        return _ChFiDS.ChFiDS_StripeMap_Add(self, *args)


    def Extent(self, *args):
        """
        Extent(ChFiDS_StripeMap self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.ChFiDS_StripeMap_Extent(self, *args)


    def FindFromKey(self, *args):
        """
        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :rtype: OCC.wrapper.ChFiDS.ChFiDS_ListOfStripe

        """
        res = _ChFiDS.ChFiDS_StripeMap_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.ChFiDS.ChFiDS_ListOfStripe

        """
        res = _ChFiDS.ChFiDS_StripeMap_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __call__(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.ChFiDS.ChFiDS_ListOfStripe

        """
        res = _ChFiDS.ChFiDS_StripeMap___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindKey(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        res = _ChFiDS.ChFiDS_StripeMap_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """Clear(ChFiDS_StripeMap self)"""
        return _ChFiDS.ChFiDS_StripeMap_Clear(self, *args)

    __swig_destroy__ = _ChFiDS.delete_ChFiDS_StripeMap
ChFiDS_StripeMap_swigregister = _ChFiDS.ChFiDS_StripeMap_swigregister
ChFiDS_StripeMap_swigregister(ChFiDS_StripeMap)

class ChFiDS_Regul(object):
    """Storage of  a curve  and its 2 faces or surfaces of  support."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ChFiDS_Regul self) -> ChFiDS_Regul

        Storage of  a curve  and its 2 faces or surfaces of  support.
        """
        this = _ChFiDS.new_ChFiDS_Regul(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetCurve(self, *args):
        """
        SetCurve(ChFiDS_Regul self, Standard_Integer const IC)

        :type IC: int

        """
        return _ChFiDS.ChFiDS_Regul_SetCurve(self, *args)


    def SetS1(self, *args):
        """
        SetS1(ChFiDS_Regul self, Standard_Integer const IS1, Standard_Boolean const IsFace)

        :type IS1: int
        :type IsFace: bool

        """
        return _ChFiDS.ChFiDS_Regul_SetS1(self, *args)


    def SetS2(self, *args):
        """
        SetS2(ChFiDS_Regul self, Standard_Integer const IS2, Standard_Boolean const IsFace)

        :type IS2: int
        :type IsFace: bool

        """
        return _ChFiDS.ChFiDS_Regul_SetS2(self, *args)


    def IsSurface1(self, *args):
        """
        IsSurface1(ChFiDS_Regul self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.ChFiDS_Regul_IsSurface1(self, *args)


    def IsSurface2(self, *args):
        """
        IsSurface2(ChFiDS_Regul self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.ChFiDS_Regul_IsSurface2(self, *args)


    def Curve(self, *args):
        """
        Curve(ChFiDS_Regul self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.ChFiDS_Regul_Curve(self, *args)


    def S1(self, *args):
        """
        S1(ChFiDS_Regul self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.ChFiDS_Regul_S1(self, *args)


    def S2(self, *args):
        """
        S2(ChFiDS_Regul self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.ChFiDS_Regul_S2(self, *args)

    __swig_destroy__ = _ChFiDS.delete_ChFiDS_Regul
ChFiDS_Regul_swigregister = _ChFiDS.ChFiDS_Regul_swigregister
ChFiDS_Regul_swigregister(ChFiDS_Regul)

class NCollection_List_Handle_ChFiDS_Stripe(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_Handle_ChFiDS_Stripe self) -> NCollection_List< opencascade::handle< ChFiDS_Stripe > >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _ChFiDS.NCollection_List_Handle_ChFiDS_Stripe_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_Handle_ChFiDS_Stripe self) -> NCollection_List< opencascade::handle< ChFiDS_Stripe > >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _ChFiDS.NCollection_List_Handle_ChFiDS_Stripe_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_Handle_ChFiDS_Stripe self) -> NCollection_List< opencascade::handle< ChFiDS_Stripe > >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _ChFiDS.NCollection_List_Handle_ChFiDS_Stripe_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_Handle_ChFiDS_Stripe self) -> NCollection_List< opencascade::handle< ChFiDS_Stripe > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _ChFiDS.NCollection_List_Handle_ChFiDS_Stripe_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _ChFiDS.new_NCollection_List_Handle_ChFiDS_Stripe(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_Handle_ChFiDS_Stripe self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.NCollection_List_Handle_ChFiDS_Stripe_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_Handle_ChFiDS_Stripe self, NCollection_List_Handle_ChFiDS_Stripe theOther) -> NCollection_List_Handle_ChFiDS_Stripe

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _ChFiDS.NCollection_List_Handle_ChFiDS_Stripe_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_Handle_ChFiDS_Stripe self, NCollection_List_Handle_ChFiDS_Stripe theOther) -> NCollection_List_Handle_ChFiDS_Stripe

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _ChFiDS.NCollection_List_Handle_ChFiDS_Stripe_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_Handle_ChFiDS_Stripe self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _ChFiDS.NCollection_List_Handle_ChFiDS_Stripe_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _ChFiDS.NCollection_List_Handle_ChFiDS_Stripe_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _ChFiDS.NCollection_List_Handle_ChFiDS_Stripe_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_Handle_ChFiDS_Stripe self, Handle_ChFiDS_Stripe theItem) -> Handle_ChFiDS_Stripe
        Append(NCollection_List_Handle_ChFiDS_Stripe self, Handle_ChFiDS_Stripe theItem, NCollection_List< opencascade::handle< ChFiDS_Stripe > >::Iterator & theIter)
        Append(NCollection_List_Handle_ChFiDS_Stripe self, NCollection_List_Handle_ChFiDS_Stripe theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _ChFiDS.NCollection_List_Handle_ChFiDS_Stripe_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_Handle_ChFiDS_Stripe self, Handle_ChFiDS_Stripe theItem) -> Handle_ChFiDS_Stripe
        Prepend(NCollection_List_Handle_ChFiDS_Stripe self, NCollection_List_Handle_ChFiDS_Stripe theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _ChFiDS.NCollection_List_Handle_ChFiDS_Stripe_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_Handle_ChFiDS_Stripe self)

        RemoveFirst item


        """
        return _ChFiDS.NCollection_List_Handle_ChFiDS_Stripe_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_Handle_ChFiDS_Stripe self, NCollection_List< opencascade::handle< ChFiDS_Stripe > >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _ChFiDS.NCollection_List_Handle_ChFiDS_Stripe_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_Handle_ChFiDS_Stripe self, Handle_ChFiDS_Stripe theItem, NCollection_List< opencascade::handle< ChFiDS_Stripe > >::Iterator & theIter) -> Handle_ChFiDS_Stripe
        InsertBefore(NCollection_List_Handle_ChFiDS_Stripe self, NCollection_List_Handle_ChFiDS_Stripe theOther, NCollection_List< opencascade::handle< ChFiDS_Stripe > >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _ChFiDS.NCollection_List_Handle_ChFiDS_Stripe_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_Handle_ChFiDS_Stripe self, Handle_ChFiDS_Stripe theItem, NCollection_List< opencascade::handle< ChFiDS_Stripe > >::Iterator & theIter) -> Handle_ChFiDS_Stripe
        InsertAfter(NCollection_List_Handle_ChFiDS_Stripe self, NCollection_List_Handle_ChFiDS_Stripe theOther, NCollection_List< opencascade::handle< ChFiDS_Stripe > >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _ChFiDS.NCollection_List_Handle_ChFiDS_Stripe_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_Handle_ChFiDS_Stripe self)

        Reverse the list


        """
        return _ChFiDS.NCollection_List_Handle_ChFiDS_Stripe_Reverse(self, *args)


    def __iter__(self):
        return _ChFiDS.NCollection_List_Handle_ChFiDS_Stripe___iter__(self)
    __swig_destroy__ = _ChFiDS.delete_NCollection_List_Handle_ChFiDS_Stripe
NCollection_List_Handle_ChFiDS_Stripe_swigregister = _ChFiDS.NCollection_List_Handle_ChFiDS_Stripe_swigregister
NCollection_List_Handle_ChFiDS_Stripe_swigregister(NCollection_List_Handle_ChFiDS_Stripe)

class NCollection_List_Handle_ChFiDS_Stripe_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _ChFiDS.new_NCollection_List_Handle_ChFiDS_Stripe_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ChFiDS.delete_NCollection_List_Handle_ChFiDS_Stripe_IteratorHelper

    def __next__(self):
        return _ChFiDS.NCollection_List_Handle_ChFiDS_Stripe_IteratorHelper___next__(self)
NCollection_List_Handle_ChFiDS_Stripe_IteratorHelper_swigregister = _ChFiDS.NCollection_List_Handle_ChFiDS_Stripe_IteratorHelper_swigregister
NCollection_List_Handle_ChFiDS_Stripe_IteratorHelper_swigregister(NCollection_List_Handle_ChFiDS_Stripe_IteratorHelper)


try:
	ChFiDS_ListOfStripe = NCollection_List_Handle_ChFiDS_Stripe
except NameError:
	pass # does not exist, probably ignored

class NCollection_Array1_Handle_ChFiDS_Stripe(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_ChFiDS_Stripe self) -> NCollection_Array1< opencascade::handle< ChFiDS_Stripe > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _ChFiDS.NCollection_Array1_Handle_ChFiDS_Stripe_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_ChFiDS_Stripe self) -> NCollection_Array1< opencascade::handle< ChFiDS_Stripe > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _ChFiDS.NCollection_Array1_Handle_ChFiDS_Stripe_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_ChFiDS_Stripe self) -> NCollection_Array1< opencascade::handle< ChFiDS_Stripe > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _ChFiDS.NCollection_Array1_Handle_ChFiDS_Stripe_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_ChFiDS_Stripe self) -> NCollection_Array1< opencascade::handle< ChFiDS_Stripe > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _ChFiDS.NCollection_Array1_Handle_ChFiDS_Stripe_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _ChFiDS.new_NCollection_Array1_Handle_ChFiDS_Stripe(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_ChFiDS_Stripe self, Handle_ChFiDS_Stripe theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _ChFiDS.NCollection_Array1_Handle_ChFiDS_Stripe_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_ChFiDS_Stripe self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.NCollection_Array1_Handle_ChFiDS_Stripe_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_ChFiDS_Stripe self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.NCollection_Array1_Handle_ChFiDS_Stripe_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_ChFiDS_Stripe self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.NCollection_Array1_Handle_ChFiDS_Stripe_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_ChFiDS_Stripe self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.NCollection_Array1_Handle_ChFiDS_Stripe_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_ChFiDS_Stripe self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.NCollection_Array1_Handle_ChFiDS_Stripe_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_ChFiDS_Stripe self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.NCollection_Array1_Handle_ChFiDS_Stripe_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_ChFiDS_Stripe self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.NCollection_Array1_Handle_ChFiDS_Stripe_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_ChFiDS_Stripe self, NCollection_Array1_Handle_ChFiDS_Stripe theOther) -> NCollection_Array1_Handle_ChFiDS_Stripe

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _ChFiDS.NCollection_Array1_Handle_ChFiDS_Stripe_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_ChFiDS_Stripe self, NCollection_Array1_Handle_ChFiDS_Stripe theOther) -> NCollection_Array1_Handle_ChFiDS_Stripe

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _ChFiDS.NCollection_Array1_Handle_ChFiDS_Stripe_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_ChFiDS_Stripe self, NCollection_Array1_Handle_ChFiDS_Stripe theOther) -> NCollection_Array1_Handle_ChFiDS_Stripe
        assign(NCollection_Array1_Handle_ChFiDS_Stripe self, NCollection_Array1_Handle_ChFiDS_Stripe theOther) -> NCollection_Array1_Handle_ChFiDS_Stripe

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _ChFiDS.NCollection_Array1_Handle_ChFiDS_Stripe_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _ChFiDS.NCollection_Array1_Handle_ChFiDS_Stripe_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_ChFiDS_Stripe self) -> Handle_ChFiDS_Stripe

        @return first element

        :rtype: TheItemType &

        """
        return _ChFiDS.NCollection_Array1_Handle_ChFiDS_Stripe_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _ChFiDS.NCollection_Array1_Handle_ChFiDS_Stripe_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_ChFiDS_Stripe self) -> Handle_ChFiDS_Stripe

        @return last element

        :rtype: TheItemType &

        """
        return _ChFiDS.NCollection_Array1_Handle_ChFiDS_Stripe_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _ChFiDS.NCollection_Array1_Handle_ChFiDS_Stripe_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_ChFiDS_Stripe self, Standard_Integer const theIndex) -> Handle_ChFiDS_Stripe

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _ChFiDS.NCollection_Array1_Handle_ChFiDS_Stripe_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _ChFiDS.NCollection_Array1_Handle_ChFiDS_Stripe___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _ChFiDS.NCollection_Array1_Handle_ChFiDS_Stripe_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_ChFiDS_Stripe self, Standard_Integer const theIndex, Handle_ChFiDS_Stripe theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _ChFiDS.NCollection_Array1_Handle_ChFiDS_Stripe_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_ChFiDS_Stripe self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _ChFiDS.NCollection_Array1_Handle_ChFiDS_Stripe_Resize(self, *args)

    __swig_destroy__ = _ChFiDS.delete_NCollection_Array1_Handle_ChFiDS_Stripe
NCollection_Array1_Handle_ChFiDS_Stripe_swigregister = _ChFiDS.NCollection_Array1_Handle_ChFiDS_Stripe_swigregister
NCollection_Array1_Handle_ChFiDS_Stripe_swigregister(NCollection_Array1_Handle_ChFiDS_Stripe)


try:
	ChFiDS_StripeArray1 = NCollection_Array1_Handle_ChFiDS_Stripe
except NameError:
	pass # does not exist, probably ignored

class ChFiDS_SecHArray1(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ChFiDS_SecHArray1
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ChFiDS_SecHArray1(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ChFiDS_SecHArray1 self, Standard_Integer const theLower, Standard_Integer const theUpper) -> ChFiDS_SecHArray1
        __init__(ChFiDS_SecHArray1 self, Standard_Integer const theLower, Standard_Integer const theUpper, ChFiDS_CircSection theValue) -> ChFiDS_SecHArray1
        __init__(ChFiDS_SecHArray1 self, NCollection_Array1_ChFiDS_CircSection theOther) -> ChFiDS_SecHArray1

        :type theOther: OCC.wrapper.ChFiDS.ChFiDS_SecArray1

        """
        this = _ChFiDS.new_ChFiDS_SecHArray1(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.ChFiDS.ChFiDS_SecArray1

        """
        res = _ChFiDS.ChFiDS_SecHArray1_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(ChFiDS_SecHArray1 self) -> NCollection_Array1_ChFiDS_CircSection

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_SecArray1

        """
        return _ChFiDS.ChFiDS_SecHArray1_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ChFiDS.ChFiDS_SecHArray1_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ChFiDS.ChFiDS_SecHArray1_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ChFiDS.ChFiDS_SecHArray1_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ChFiDS.delete_ChFiDS_SecHArray1
ChFiDS_SecHArray1_swigregister = _ChFiDS.ChFiDS_SecHArray1_swigregister
ChFiDS_SecHArray1_swigregister(ChFiDS_SecHArray1)

def ChFiDS_SecHArray1_get_type_name(*args):
    """
    ChFiDS_SecHArray1_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ChFiDS.ChFiDS_SecHArray1_get_type_name(*args)

def ChFiDS_SecHArray1_get_type_descriptor(*args):
    """
    ChFiDS_SecHArray1_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ChFiDS.ChFiDS_SecHArray1_get_type_descriptor(*args)

class ChFiDS_FaceInterference(object):
    """interference face/fillet"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ChFiDS_FaceInterference self) -> ChFiDS_FaceInterference

        interference face/fillet
        """
        this = _ChFiDS.new_ChFiDS_FaceInterference(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetInterference(self, *args):
        """
        SetInterference(ChFiDS_FaceInterference self, Standard_Integer const LineIndex, TopAbs_Orientation const Trans, Handle_Geom2d_Curve PCurv1, Handle_Geom2d_Curve PCurv2)

        :type LineIndex: int
        :type Trans: OCC.wrapper.TopAbs.TopAbs_Orientation
        :type PCurv1: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type PCurv2: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _ChFiDS.ChFiDS_FaceInterference_SetInterference(self, *args)


    def SetTransition(self, *args):
        """
        SetTransition(ChFiDS_FaceInterference self, TopAbs_Orientation const Trans)

        :type Trans: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _ChFiDS.ChFiDS_FaceInterference_SetTransition(self, *args)


    def SetFirstParameter(self, *args):
        """
        SetFirstParameter(ChFiDS_FaceInterference self, Standard_Real const U1)

        :type U1: float

        """
        return _ChFiDS.ChFiDS_FaceInterference_SetFirstParameter(self, *args)


    def SetLastParameter(self, *args):
        """
        SetLastParameter(ChFiDS_FaceInterference self, Standard_Real const U1)

        :type U1: float

        """
        return _ChFiDS.ChFiDS_FaceInterference_SetLastParameter(self, *args)


    def SetParameter(self, *args):
        """
        SetParameter(ChFiDS_FaceInterference self, Standard_Real const U1, Standard_Boolean const IsFirst)

        :type U1: float
        :type IsFirst: bool

        """
        return _ChFiDS.ChFiDS_FaceInterference_SetParameter(self, *args)


    def LineIndex(self, *args):
        """
        LineIndex(ChFiDS_FaceInterference self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.ChFiDS_FaceInterference_LineIndex(self, *args)


    def SetLineIndex(self, *args):
        """
        SetLineIndex(ChFiDS_FaceInterference self, Standard_Integer const I)

        :type I: int

        """
        return _ChFiDS.ChFiDS_FaceInterference_SetLineIndex(self, *args)


    def Transition(self, *args):
        """
        Transition(ChFiDS_FaceInterference self) -> TopAbs_Orientation

        :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _ChFiDS.ChFiDS_FaceInterference_Transition(self, *args)


    def PCurveOnFace(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _ChFiDS.ChFiDS_FaceInterference_PCurveOnFace(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PCurveOnSurf(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _ChFiDS.ChFiDS_FaceInterference_PCurveOnSurf(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangePCurveOnFace(self, *args):
        """
        ChangePCurveOnFace(ChFiDS_FaceInterference self) -> Handle_Geom2d_Curve

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _ChFiDS.ChFiDS_FaceInterference_ChangePCurveOnFace(self, *args)


    def ChangePCurveOnSurf(self, *args):
        """
        ChangePCurveOnSurf(ChFiDS_FaceInterference self) -> Handle_Geom2d_Curve

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _ChFiDS.ChFiDS_FaceInterference_ChangePCurveOnSurf(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(ChFiDS_FaceInterference self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.ChFiDS_FaceInterference_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(ChFiDS_FaceInterference self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.ChFiDS_FaceInterference_LastParameter(self, *args)


    def Parameter(self, *args):
        """
        Parameter(ChFiDS_FaceInterference self, Standard_Boolean const IsFirst) -> Standard_Real

        :type IsFirst: bool
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.ChFiDS_FaceInterference_Parameter(self, *args)

    __swig_destroy__ = _ChFiDS.delete_ChFiDS_FaceInterference
ChFiDS_FaceInterference_swigregister = _ChFiDS.ChFiDS_FaceInterference_swigregister
ChFiDS_FaceInterference_swigregister(ChFiDS_FaceInterference)

class NCollection_List_ChFiDS_Regul_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _ChFiDS.new_NCollection_List_ChFiDS_Regul_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ChFiDS.delete_NCollection_List_ChFiDS_Regul_IteratorHelper

    def __next__(self):
        return _ChFiDS.NCollection_List_ChFiDS_Regul_IteratorHelper___next__(self)
NCollection_List_ChFiDS_Regul_IteratorHelper_swigregister = _ChFiDS.NCollection_List_ChFiDS_Regul_IteratorHelper_swigregister
NCollection_List_ChFiDS_Regul_IteratorHelper_swigregister(NCollection_List_ChFiDS_Regul_IteratorHelper)


try:
	ChFiDS_Regularities = NCollection_List_ChFiDS_Regul
except NameError:
	pass # does not exist, probably ignored

class Handle_ChFiDS_Stripe(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ChFiDS_Stripe self)

        Nullify the handle


        """
        return _ChFiDS.Handle_ChFiDS_Stripe_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ChFiDS_Stripe self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ChFiDS_Stripe self, ChFiDS_Stripe thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ChFiDS_Stripe self, Handle_ChFiDS_Stripe theHandle) -> Handle_ChFiDS_Stripe
        assign(Handle_ChFiDS_Stripe self, ChFiDS_Stripe thePtr) -> Handle_ChFiDS_Stripe
        assign(Handle_ChFiDS_Stripe self, Handle_ChFiDS_Stripe theHandle) -> Handle_ChFiDS_Stripe

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ChFiDS_Stripe self) -> ChFiDS_Stripe

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ChFiDS_Stripe self) -> ChFiDS_Stripe

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ChFiDS.Handle_ChFiDS_Stripe___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ChFiDS_Stripe self) -> ChFiDS_Stripe

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ChFiDS.Handle_ChFiDS_Stripe___ref__(self, *args)


    def __hash__(self):
        return _ChFiDS.Handle_ChFiDS_Stripe___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ChFiDS.Handle_ChFiDS_Stripe___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ChFiDS.new_Handle_ChFiDS_Stripe(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ChFiDS.Handle_ChFiDS_Stripe_DownCast)
    __swig_destroy__ = _ChFiDS.delete_Handle_ChFiDS_Stripe

    def Reset(self, *args):
        """
        Reset(Handle_ChFiDS_Stripe self)

        Reset everything except Spine.


        """
        return _ChFiDS.Handle_ChFiDS_Stripe_Reset(self, *args)


    def SetOfSurfData(self, *args):
        """
        :rtype: OCC.wrapper.ChFiDS.Handle_ChFiDS_HData

        """
        res = _ChFiDS.Handle_ChFiDS_Stripe_SetOfSurfData(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Spine(self, *args):
        """
        :rtype: OCC.wrapper.ChFiDS.Handle_ChFiDS_Spine

        """
        res = _ChFiDS.Handle_ChFiDS_Stripe_Spine(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def OrientationOnFace1(self, *args):
        """
        OrientationOnFace1(Handle_ChFiDS_Stripe self) -> TopAbs_Orientation
        OrientationOnFace1(Handle_ChFiDS_Stripe self, TopAbs_Orientation const Or1)

        :type Or1: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_OrientationOnFace1(self, *args)


    def OrientationOnFace2(self, *args):
        """
        OrientationOnFace2(Handle_ChFiDS_Stripe self) -> TopAbs_Orientation
        OrientationOnFace2(Handle_ChFiDS_Stripe self, TopAbs_Orientation const Or2)

        :type Or2: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_OrientationOnFace2(self, *args)


    def Choix(self, *args):
        """
        Choix(Handle_ChFiDS_Stripe self) -> Standard_Integer
        Choix(Handle_ChFiDS_Stripe self, Standard_Integer const C)

        :type C: int

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_Choix(self, *args)


    def ChangeSetOfSurfData(self, *args):
        """
        ChangeSetOfSurfData(Handle_ChFiDS_Stripe self) -> Handle_ChFiDS_HData

        :rtype: OCC.wrapper.ChFiDS.Handle_ChFiDS_HData

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_ChangeSetOfSurfData(self, *args)


    def ChangeSpine(self, *args):
        """
        ChangeSpine(Handle_ChFiDS_Stripe self) -> Handle_ChFiDS_Spine

        :rtype: OCC.wrapper.ChFiDS.Handle_ChFiDS_Spine

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_ChangeSpine(self, *args)


    def FirstParameters(self, *args):
        """
        FirstParameters(Handle_ChFiDS_Stripe self)

        :type Pdeb: float
        :type Pfin: float

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_FirstParameters(self, *args)


    def LastParameters(self, *args):
        """
        LastParameters(Handle_ChFiDS_Stripe self)

        :type Pdeb: float
        :type Pfin: float

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_LastParameters(self, *args)


    def ChangeFirstParameters(self, *args):
        """
        ChangeFirstParameters(Handle_ChFiDS_Stripe self, Standard_Real const Pdeb, Standard_Real const Pfin)

        :type Pdeb: float
        :type Pfin: float

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_ChangeFirstParameters(self, *args)


    def ChangeLastParameters(self, *args):
        """
        ChangeLastParameters(Handle_ChFiDS_Stripe self, Standard_Real const Pdeb, Standard_Real const Pfin)

        :type Pdeb: float
        :type Pfin: float

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_ChangeLastParameters(self, *args)


    def FirstCurve(self, *args):
        """
        FirstCurve(Handle_ChFiDS_Stripe self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_FirstCurve(self, *args)


    def LastCurve(self, *args):
        """
        LastCurve(Handle_ChFiDS_Stripe self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_LastCurve(self, *args)


    def ChangeFirstCurve(self, *args):
        """
        ChangeFirstCurve(Handle_ChFiDS_Stripe self, Standard_Integer const Index)

        :type Index: int

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_ChangeFirstCurve(self, *args)


    def ChangeLastCurve(self, *args):
        """
        ChangeLastCurve(Handle_ChFiDS_Stripe self, Standard_Integer const Index)

        :type Index: int

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_ChangeLastCurve(self, *args)


    def FirstPCurve(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _ChFiDS.Handle_ChFiDS_Stripe_FirstPCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LastPCurve(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _ChFiDS.Handle_ChFiDS_Stripe_LastPCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirstPCurve(self, *args):
        """
        ChangeFirstPCurve(Handle_ChFiDS_Stripe self) -> Handle_Geom2d_Curve

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_ChangeFirstPCurve(self, *args)


    def ChangeLastPCurve(self, *args):
        """
        ChangeLastPCurve(Handle_ChFiDS_Stripe self) -> Handle_Geom2d_Curve

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_ChangeLastPCurve(self, *args)


    def FirstPCurveOrientation(self, *args):
        """
        FirstPCurveOrientation(Handle_ChFiDS_Stripe self) -> TopAbs_Orientation
        FirstPCurveOrientation(Handle_ChFiDS_Stripe self, TopAbs_Orientation const O)

        :type O: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_FirstPCurveOrientation(self, *args)


    def LastPCurveOrientation(self, *args):
        """
        LastPCurveOrientation(Handle_ChFiDS_Stripe self) -> TopAbs_Orientation
        LastPCurveOrientation(Handle_ChFiDS_Stripe self, TopAbs_Orientation const O)

        :type O: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_LastPCurveOrientation(self, *args)


    def IndexFirstPointOnS1(self, *args):
        """
        IndexFirstPointOnS1(Handle_ChFiDS_Stripe self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_IndexFirstPointOnS1(self, *args)


    def IndexFirstPointOnS2(self, *args):
        """
        IndexFirstPointOnS2(Handle_ChFiDS_Stripe self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_IndexFirstPointOnS2(self, *args)


    def IndexLastPointOnS1(self, *args):
        """
        IndexLastPointOnS1(Handle_ChFiDS_Stripe self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_IndexLastPointOnS1(self, *args)


    def IndexLastPointOnS2(self, *args):
        """
        IndexLastPointOnS2(Handle_ChFiDS_Stripe self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_IndexLastPointOnS2(self, *args)


    def ChangeIndexFirstPointOnS1(self, *args):
        """
        ChangeIndexFirstPointOnS1(Handle_ChFiDS_Stripe self, Standard_Integer const Index)

        :type Index: int

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_ChangeIndexFirstPointOnS1(self, *args)


    def ChangeIndexFirstPointOnS2(self, *args):
        """
        ChangeIndexFirstPointOnS2(Handle_ChFiDS_Stripe self, Standard_Integer const Index)

        :type Index: int

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_ChangeIndexFirstPointOnS2(self, *args)


    def ChangeIndexLastPointOnS1(self, *args):
        """
        ChangeIndexLastPointOnS1(Handle_ChFiDS_Stripe self, Standard_Integer const Index)

        :type Index: int

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_ChangeIndexLastPointOnS1(self, *args)


    def ChangeIndexLastPointOnS2(self, *args):
        """
        ChangeIndexLastPointOnS2(Handle_ChFiDS_Stripe self, Standard_Integer const Index)

        :type Index: int

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_ChangeIndexLastPointOnS2(self, *args)


    def Parameters(self, *args):
        """
        Parameters(Handle_ChFiDS_Stripe self, Standard_Boolean const First)

        :type First: bool
        :type Pdeb: float
        :type Pfin: float

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_Parameters(self, *args)


    def SetParameters(self, *args):
        """
        SetParameters(Handle_ChFiDS_Stripe self, Standard_Boolean const First, Standard_Real const Pdeb, Standard_Real const Pfin)

        :type First: bool
        :type Pdeb: float
        :type Pfin: float

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_SetParameters(self, *args)


    def Curve(self, *args):
        """
        Curve(Handle_ChFiDS_Stripe self, Standard_Boolean const First) -> Standard_Integer

        :type First: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_Curve(self, *args)


    def SetCurve(self, *args):
        """
        SetCurve(Handle_ChFiDS_Stripe self, Standard_Integer const Index, Standard_Boolean const First)

        :type Index: int
        :type First: bool

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_SetCurve(self, *args)


    def PCurve(self, *args):
        """
        :type First: bool
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _ChFiDS.Handle_ChFiDS_Stripe_PCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangePCurve(self, *args):
        """
        ChangePCurve(Handle_ChFiDS_Stripe self, Standard_Boolean const First) -> Handle_Geom2d_Curve

        :type First: bool
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_ChangePCurve(self, *args)


    def Orientation(self, *args):
        """
        Orientation(Handle_ChFiDS_Stripe self, Standard_Integer const OnS) -> TopAbs_Orientation
        Orientation(Handle_ChFiDS_Stripe self, Standard_Boolean const First) -> TopAbs_Orientation

        :type First: bool
        :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_Orientation(self, *args)


    def SetOrientation(self, *args):
        """
        SetOrientation(Handle_ChFiDS_Stripe self, TopAbs_Orientation const Or, Standard_Integer const OnS)
        SetOrientation(Handle_ChFiDS_Stripe self, TopAbs_Orientation const Or, Standard_Boolean const First)

        :type Or: OCC.wrapper.TopAbs.TopAbs_Orientation
        :type First: bool

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_SetOrientation(self, *args)


    def IndexPoint(self, *args):
        """
        IndexPoint(Handle_ChFiDS_Stripe self, Standard_Boolean const First, Standard_Integer const OnS) -> Standard_Integer

        :type First: bool
        :type OnS: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_IndexPoint(self, *args)


    def SetIndexPoint(self, *args):
        """
        SetIndexPoint(Handle_ChFiDS_Stripe self, Standard_Integer const Index, Standard_Boolean const First, Standard_Integer const OnS)

        :type Index: int
        :type First: bool
        :type OnS: int

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_SetIndexPoint(self, *args)


    def SolidIndex(self, *args):
        """
        SolidIndex(Handle_ChFiDS_Stripe self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_SolidIndex(self, *args)


    def SetSolidIndex(self, *args):
        """
        SetSolidIndex(Handle_ChFiDS_Stripe self, Standard_Integer const Index)

        :type Index: int

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_SetSolidIndex(self, *args)


    def InDS(self, *args):
        """
        InDS(Handle_ChFiDS_Stripe self, Standard_Boolean const First, Standard_Integer const Nb=1)

        Set nb of SurfData's at end put in DS

        :type First: bool
        :type Nb: int

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_InDS(self, *args)


    def IsInDS(self, *args):
        """
        IsInDS(Handle_ChFiDS_Stripe self, Standard_Boolean const First) -> Standard_Integer

        Returns nb of SurfData's at end being in DS

        :type First: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_IsInDS(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ChFiDS_Stripe self) -> char const *

        :rtype: const char *

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ChFiDS.Handle_ChFiDS_Stripe_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ChFiDS.Handle_ChFiDS_Stripe_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_ChFiDS_Stripe self)

        Memory deallocator for transient classes


        """
        return _ChFiDS.Handle_ChFiDS_Stripe_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ChFiDS_Stripe self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ChFiDS_Stripe self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ChFiDS_Stripe self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ChFiDS_Stripe self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ChFiDS_Stripe self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ChFiDS_Stripe self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ChFiDS_Stripe self)

        Increments the reference counter of this object


        """
        return _ChFiDS.Handle_ChFiDS_Stripe_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ChFiDS_Stripe self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_Stripe_DecrementRefCounter(self, *args)

Handle_ChFiDS_Stripe_swigregister = _ChFiDS.Handle_ChFiDS_Stripe_swigregister
Handle_ChFiDS_Stripe_swigregister(Handle_ChFiDS_Stripe)

def Handle_ChFiDS_Stripe_DownCast(thing):
    return _ChFiDS.Handle_ChFiDS_Stripe_DownCast(thing)
Handle_ChFiDS_Stripe_DownCast = _ChFiDS.Handle_ChFiDS_Stripe_DownCast

class NCollection_Array1_ChFiDS_CircSection(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_ChFiDS_CircSection self) -> NCollection_Array1< ChFiDS_CircSection >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _ChFiDS.NCollection_Array1_ChFiDS_CircSection_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_ChFiDS_CircSection self) -> NCollection_Array1< ChFiDS_CircSection >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _ChFiDS.NCollection_Array1_ChFiDS_CircSection_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_ChFiDS_CircSection self) -> NCollection_Array1< ChFiDS_CircSection >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _ChFiDS.NCollection_Array1_ChFiDS_CircSection_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_ChFiDS_CircSection self) -> NCollection_Array1< ChFiDS_CircSection >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _ChFiDS.NCollection_Array1_ChFiDS_CircSection_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _ChFiDS.new_NCollection_Array1_ChFiDS_CircSection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_ChFiDS_CircSection self, ChFiDS_CircSection theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _ChFiDS.NCollection_Array1_ChFiDS_CircSection_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_ChFiDS_CircSection self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.NCollection_Array1_ChFiDS_CircSection_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_ChFiDS_CircSection self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.NCollection_Array1_ChFiDS_CircSection_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_ChFiDS_CircSection self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.NCollection_Array1_ChFiDS_CircSection_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_ChFiDS_CircSection self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.NCollection_Array1_ChFiDS_CircSection_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_ChFiDS_CircSection self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.NCollection_Array1_ChFiDS_CircSection_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_ChFiDS_CircSection self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.NCollection_Array1_ChFiDS_CircSection_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_ChFiDS_CircSection self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.NCollection_Array1_ChFiDS_CircSection_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_ChFiDS_CircSection self, NCollection_Array1_ChFiDS_CircSection theOther) -> NCollection_Array1_ChFiDS_CircSection

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _ChFiDS.NCollection_Array1_ChFiDS_CircSection_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_ChFiDS_CircSection self, NCollection_Array1_ChFiDS_CircSection theOther) -> NCollection_Array1_ChFiDS_CircSection

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _ChFiDS.NCollection_Array1_ChFiDS_CircSection_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_ChFiDS_CircSection self, NCollection_Array1_ChFiDS_CircSection theOther) -> NCollection_Array1_ChFiDS_CircSection
        assign(NCollection_Array1_ChFiDS_CircSection self, NCollection_Array1_ChFiDS_CircSection theOther) -> NCollection_Array1_ChFiDS_CircSection

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _ChFiDS.NCollection_Array1_ChFiDS_CircSection_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _ChFiDS.NCollection_Array1_ChFiDS_CircSection_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_ChFiDS_CircSection self) -> ChFiDS_CircSection

        @return first element

        :rtype: TheItemType &

        """
        return _ChFiDS.NCollection_Array1_ChFiDS_CircSection_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _ChFiDS.NCollection_Array1_ChFiDS_CircSection_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_ChFiDS_CircSection self) -> ChFiDS_CircSection

        @return last element

        :rtype: TheItemType &

        """
        return _ChFiDS.NCollection_Array1_ChFiDS_CircSection_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _ChFiDS.NCollection_Array1_ChFiDS_CircSection_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_ChFiDS_CircSection self, Standard_Integer const theIndex) -> ChFiDS_CircSection

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _ChFiDS.NCollection_Array1_ChFiDS_CircSection_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _ChFiDS.NCollection_Array1_ChFiDS_CircSection___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _ChFiDS.NCollection_Array1_ChFiDS_CircSection_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_ChFiDS_CircSection self, Standard_Integer const theIndex, ChFiDS_CircSection theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _ChFiDS.NCollection_Array1_ChFiDS_CircSection_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_ChFiDS_CircSection self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _ChFiDS.NCollection_Array1_ChFiDS_CircSection_Resize(self, *args)

    __swig_destroy__ = _ChFiDS.delete_NCollection_Array1_ChFiDS_CircSection
NCollection_Array1_ChFiDS_CircSection_swigregister = _ChFiDS.NCollection_Array1_ChFiDS_CircSection_swigregister
NCollection_Array1_ChFiDS_CircSection_swigregister(NCollection_Array1_ChFiDS_CircSection)


try:
	ChFiDS_SecArray1 = NCollection_Array1_ChFiDS_CircSection
except NameError:
	pass # does not exist, probably ignored

class ChFiDS_Map(object):
    """Encapsulation of IndexedDataMapOfShapeListOfShape."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ChFiDS_Map self) -> ChFiDS_Map

        Create an empty Map


        """
        this = _ChFiDS.new_ChFiDS_Map(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Fill(self, *args):
        """
        Fill(ChFiDS_Map self, TopoDS_Shape S, TopAbs_ShapeEnum const T1, TopAbs_ShapeEnum const T2)

        Fills the map with the subshapes of type T1 as keys
        and the list of ancestors  of type T2 as items.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type T1: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type T2: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _ChFiDS.ChFiDS_Map_Fill(self, *args)


    def Contains(self, *args):
        """
        Contains(ChFiDS_Map self, TopoDS_Shape S) -> Standard_Boolean

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.ChFiDS_Map_Contains(self, *args)


    def FindFromKey(self, *args):
        """
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _ChFiDS.ChFiDS_Map_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _ChFiDS.ChFiDS_Map_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __call__(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _ChFiDS.ChFiDS_Map___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ChFiDS.delete_ChFiDS_Map
ChFiDS_Map_swigregister = _ChFiDS.ChFiDS_Map_swigregister
ChFiDS_Map_swigregister(ChFiDS_Map)

class NCollection_List_Handle_ChFiDS_HElSpine(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_Handle_ChFiDS_HElSpine self) -> NCollection_List< opencascade::handle< ChFiDS_HElSpine > >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _ChFiDS.NCollection_List_Handle_ChFiDS_HElSpine_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_Handle_ChFiDS_HElSpine self) -> NCollection_List< opencascade::handle< ChFiDS_HElSpine > >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _ChFiDS.NCollection_List_Handle_ChFiDS_HElSpine_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_Handle_ChFiDS_HElSpine self) -> NCollection_List< opencascade::handle< ChFiDS_HElSpine > >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _ChFiDS.NCollection_List_Handle_ChFiDS_HElSpine_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_Handle_ChFiDS_HElSpine self) -> NCollection_List< opencascade::handle< ChFiDS_HElSpine > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _ChFiDS.NCollection_List_Handle_ChFiDS_HElSpine_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _ChFiDS.new_NCollection_List_Handle_ChFiDS_HElSpine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_Handle_ChFiDS_HElSpine self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.NCollection_List_Handle_ChFiDS_HElSpine_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_Handle_ChFiDS_HElSpine self, NCollection_List_Handle_ChFiDS_HElSpine theOther) -> NCollection_List_Handle_ChFiDS_HElSpine

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _ChFiDS.NCollection_List_Handle_ChFiDS_HElSpine_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_Handle_ChFiDS_HElSpine self, NCollection_List_Handle_ChFiDS_HElSpine theOther) -> NCollection_List_Handle_ChFiDS_HElSpine

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _ChFiDS.NCollection_List_Handle_ChFiDS_HElSpine_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_Handle_ChFiDS_HElSpine self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _ChFiDS.NCollection_List_Handle_ChFiDS_HElSpine_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _ChFiDS.NCollection_List_Handle_ChFiDS_HElSpine_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _ChFiDS.NCollection_List_Handle_ChFiDS_HElSpine_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_Handle_ChFiDS_HElSpine self, Handle_ChFiDS_HElSpine theItem) -> Handle_ChFiDS_HElSpine
        Append(NCollection_List_Handle_ChFiDS_HElSpine self, Handle_ChFiDS_HElSpine theItem, NCollection_List< opencascade::handle< ChFiDS_HElSpine > >::Iterator & theIter)
        Append(NCollection_List_Handle_ChFiDS_HElSpine self, NCollection_List_Handle_ChFiDS_HElSpine theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _ChFiDS.NCollection_List_Handle_ChFiDS_HElSpine_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_Handle_ChFiDS_HElSpine self, Handle_ChFiDS_HElSpine theItem) -> Handle_ChFiDS_HElSpine
        Prepend(NCollection_List_Handle_ChFiDS_HElSpine self, NCollection_List_Handle_ChFiDS_HElSpine theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _ChFiDS.NCollection_List_Handle_ChFiDS_HElSpine_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_Handle_ChFiDS_HElSpine self)

        RemoveFirst item


        """
        return _ChFiDS.NCollection_List_Handle_ChFiDS_HElSpine_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_Handle_ChFiDS_HElSpine self, NCollection_List< opencascade::handle< ChFiDS_HElSpine > >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _ChFiDS.NCollection_List_Handle_ChFiDS_HElSpine_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_Handle_ChFiDS_HElSpine self, Handle_ChFiDS_HElSpine theItem, NCollection_List< opencascade::handle< ChFiDS_HElSpine > >::Iterator & theIter) -> Handle_ChFiDS_HElSpine
        InsertBefore(NCollection_List_Handle_ChFiDS_HElSpine self, NCollection_List_Handle_ChFiDS_HElSpine theOther, NCollection_List< opencascade::handle< ChFiDS_HElSpine > >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _ChFiDS.NCollection_List_Handle_ChFiDS_HElSpine_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_Handle_ChFiDS_HElSpine self, Handle_ChFiDS_HElSpine theItem, NCollection_List< opencascade::handle< ChFiDS_HElSpine > >::Iterator & theIter) -> Handle_ChFiDS_HElSpine
        InsertAfter(NCollection_List_Handle_ChFiDS_HElSpine self, NCollection_List_Handle_ChFiDS_HElSpine theOther, NCollection_List< opencascade::handle< ChFiDS_HElSpine > >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _ChFiDS.NCollection_List_Handle_ChFiDS_HElSpine_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_Handle_ChFiDS_HElSpine self)

        Reverse the list


        """
        return _ChFiDS.NCollection_List_Handle_ChFiDS_HElSpine_Reverse(self, *args)


    def __iter__(self):
        return _ChFiDS.NCollection_List_Handle_ChFiDS_HElSpine___iter__(self)
    __swig_destroy__ = _ChFiDS.delete_NCollection_List_Handle_ChFiDS_HElSpine
NCollection_List_Handle_ChFiDS_HElSpine_swigregister = _ChFiDS.NCollection_List_Handle_ChFiDS_HElSpine_swigregister
NCollection_List_Handle_ChFiDS_HElSpine_swigregister(NCollection_List_Handle_ChFiDS_HElSpine)

class NCollection_List_Handle_ChFiDS_HElSpine_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _ChFiDS.new_NCollection_List_Handle_ChFiDS_HElSpine_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ChFiDS.delete_NCollection_List_Handle_ChFiDS_HElSpine_IteratorHelper

    def __next__(self):
        return _ChFiDS.NCollection_List_Handle_ChFiDS_HElSpine_IteratorHelper___next__(self)
NCollection_List_Handle_ChFiDS_HElSpine_IteratorHelper_swigregister = _ChFiDS.NCollection_List_Handle_ChFiDS_HElSpine_IteratorHelper_swigregister
NCollection_List_Handle_ChFiDS_HElSpine_IteratorHelper_swigregister(NCollection_List_Handle_ChFiDS_HElSpine_IteratorHelper)


try:
	ChFiDS_ListOfHElSpine = NCollection_List_Handle_ChFiDS_HElSpine
except NameError:
	pass # does not exist, probably ignored

class Handle_ChFiDS_FilSpine(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ChFiDS_FilSpine self)

        Nullify the handle


        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ChFiDS_FilSpine self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ChFiDS_FilSpine self, ChFiDS_FilSpine thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ChFiDS_FilSpine self, Handle_ChFiDS_FilSpine theHandle) -> Handle_ChFiDS_FilSpine
        assign(Handle_ChFiDS_FilSpine self, ChFiDS_FilSpine thePtr) -> Handle_ChFiDS_FilSpine
        assign(Handle_ChFiDS_FilSpine self, Handle_ChFiDS_FilSpine theHandle) -> Handle_ChFiDS_FilSpine

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ChFiDS_FilSpine self) -> ChFiDS_FilSpine

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ChFiDS_FilSpine self) -> ChFiDS_FilSpine

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ChFiDS_FilSpine self) -> ChFiDS_FilSpine

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine___ref__(self, *args)


    def __hash__(self):
        return _ChFiDS.Handle_ChFiDS_FilSpine___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ChFiDS.Handle_ChFiDS_FilSpine___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ChFiDS.new_Handle_ChFiDS_FilSpine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ChFiDS.Handle_ChFiDS_FilSpine_DownCast)
    __swig_destroy__ = _ChFiDS.delete_Handle_ChFiDS_FilSpine

    def Reset(self, *args):
        """
        Reset(Handle_ChFiDS_FilSpine self, Standard_Boolean const AllData)

        :type AllData: bool

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_Reset(self, *args)


    def SetRadius(self, *args):
        """
        SetRadius(Handle_ChFiDS_FilSpine self, Standard_Real const Radius, TopoDS_Edge E)
        SetRadius(Handle_ChFiDS_FilSpine self, Standard_Real const Radius, TopoDS_Vertex V)
        SetRadius(Handle_ChFiDS_FilSpine self, gp_XY UandR, Standard_Integer const IinC)
        SetRadius(Handle_ChFiDS_FilSpine self, Standard_Real const Radius)
        SetRadius(Handle_ChFiDS_FilSpine self, Handle_Law_Function C, Standard_Integer const IinC)

        initializes the rule of evolution on all spine.

        :type C: OCC.wrapper.Law.Handle_Law_Function
        :type IinC: int

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_SetRadius(self, *args)


    def UnSetRadius(self, *args):
        """
        UnSetRadius(Handle_ChFiDS_FilSpine self, TopoDS_Edge E)
        UnSetRadius(Handle_ChFiDS_FilSpine self, TopoDS_Vertex V)

        resets the vector on Vertex V.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_UnSetRadius(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(Handle_ChFiDS_FilSpine self) -> Standard_Boolean
        IsConstant(Handle_ChFiDS_FilSpine self, Standard_Integer const IE) -> Standard_Boolean

        returns true if the radius is constant
        all along the edge E.

        :type IE: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_IsConstant(self, *args)


    def Radius(self, *args):
        """
        Radius(Handle_ChFiDS_FilSpine self) -> Standard_Real
        Radius(Handle_ChFiDS_FilSpine self, Standard_Integer const IE) -> Standard_Real
        Radius(Handle_ChFiDS_FilSpine self, TopoDS_Edge E) -> Standard_Real

        returns the radius if the fillet is constant
        all along the edge E.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_Radius(self, *args)


    def AppendElSpine(self, *args):
        """
        AppendElSpine(Handle_ChFiDS_FilSpine self, Handle_ChFiDS_HElSpine Els)

        :type Els: OCC.wrapper.ChFiDS.Handle_ChFiDS_HElSpine

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_AppendElSpine(self, *args)


    def Law_(self, *args):
        """
        Law_(Handle_ChFiDS_FilSpine self, Handle_ChFiDS_HElSpine Els) -> Handle_Law_Composite

        :type Els: OCC.wrapper.ChFiDS.Handle_ChFiDS_HElSpine
        :rtype: OCC.wrapper.Law.Handle_Law_Composite

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_Law_(self, *args)


    def ChangeLaw(self, *args):
        """
        ChangeLaw(Handle_ChFiDS_FilSpine self, TopoDS_Edge E) -> Handle_Law_Function

        returns the elementary law

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Law.Handle_Law_Function

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_ChangeLaw(self, *args)


    def MaxRadFromSeqAndLaws(self, *args):
        """
        MaxRadFromSeqAndLaws(Handle_ChFiDS_FilSpine self) -> Standard_Real

        returns the maximum radius if the fillet is non-constant

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_MaxRadFromSeqAndLaws(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ChFiDS_FilSpine self) -> char const *

        :rtype: const char *

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ChFiDS.Handle_ChFiDS_FilSpine_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ChFiDS.Handle_ChFiDS_FilSpine_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetEdges(self, *args):
        """
        SetEdges(Handle_ChFiDS_FilSpine self, TopoDS_Edge E)

        store edges composing the guideline

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_SetEdges(self, *args)


    def PutInFirst(self, *args):
        """
        PutInFirst(Handle_ChFiDS_FilSpine self, TopoDS_Edge E)

        store the edge at the first position before all others

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_PutInFirst(self, *args)


    def NbEdges(self, *args):
        """
        NbEdges(Handle_ChFiDS_FilSpine self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_NbEdges(self, *args)


    def Edges(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _ChFiDS.Handle_ChFiDS_FilSpine_Edges(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstStatus(self, *args):
        """
        SetFirstStatus(Handle_ChFiDS_FilSpine self, ChFiDS_State const S)

        stores if the start of a set of edges starts on a
        section of free border or forms  a closed contour

        :type S: OCC.wrapper.ChFiDS.ChFiDS_State

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_SetFirstStatus(self, *args)


    def SetLastStatus(self, *args):
        """
        SetLastStatus(Handle_ChFiDS_FilSpine self, ChFiDS_State const S)

        stores if the end of a set of edges starts on a
        section of free border or forms  a closed contour

        :type S: OCC.wrapper.ChFiDS.ChFiDS_State

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_SetLastStatus(self, *args)


    def ElSpine(self, *args):
        """
        ElSpine(Handle_ChFiDS_FilSpine self, Standard_Integer const IE) -> Handle_ChFiDS_HElSpine
        ElSpine(Handle_ChFiDS_FilSpine self, TopoDS_Edge E) -> Handle_ChFiDS_HElSpine
        ElSpine(Handle_ChFiDS_FilSpine self, Standard_Real const W) -> Handle_ChFiDS_HElSpine

        :type W: float
        :rtype: OCC.wrapper.ChFiDS.Handle_ChFiDS_HElSpine

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_ElSpine(self, *args)


    def ChangeElSpines(self, *args):
        """
        ChangeElSpines(Handle_ChFiDS_FilSpine self) -> NCollection_List_Handle_ChFiDS_HElSpine

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_ListOfHElSpine

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_ChangeElSpines(self, *args)


    def SplitDone(self, *args):
        """
        SplitDone(Handle_ChFiDS_FilSpine self) -> Standard_Boolean
        SplitDone(Handle_ChFiDS_FilSpine self, Standard_Boolean const B)

        :type B: bool

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_SplitDone(self, *args)


    def Load(self, *args):
        """
        Load(Handle_ChFiDS_FilSpine self)

        prepare the guideline depending on the edges that
        are elementary arks (take parameters from
        a single curvilinear abscissa); to be able to call
        methods on the geometry (first,last,value,d1,d2)
        it is necessary to start with preparation otherwise an
        exception will be raised


        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_Load(self, *args)


    def Resolution(self, *args):
        """
        Resolution(Handle_ChFiDS_FilSpine self, Standard_Real const R3d) -> Standard_Real

        :type R3d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_Resolution(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_ChFiDS_FilSpine self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_IsClosed(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_ChFiDS_FilSpine self) -> Standard_Real
        FirstParameter(Handle_ChFiDS_FilSpine self, Standard_Integer const IndexSpine) -> Standard_Real

        gives the total length of all arcs before the
        number IndexSp

        :type IndexSpine: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_ChFiDS_FilSpine self) -> Standard_Real
        LastParameter(Handle_ChFiDS_FilSpine self, Standard_Integer const IndexSpine) -> Standard_Real

        gives the total length till the ark with number
        IndexSpine (inclus)

        :type IndexSpine: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_LastParameter(self, *args)


    def SetFirstParameter(self, *args):
        """
        SetFirstParameter(Handle_ChFiDS_FilSpine self, Standard_Real const Par)

        :type Par: float

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_SetFirstParameter(self, *args)


    def SetLastParameter(self, *args):
        """
        SetLastParameter(Handle_ChFiDS_FilSpine self, Standard_Real const Par)

        :type Par: float

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_SetLastParameter(self, *args)


    def Length(self, *args):
        """
        Length(Handle_ChFiDS_FilSpine self, Standard_Integer const IndexSpine) -> Standard_Real

        gives the length of ark with number IndexSp

        :type IndexSpine: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_Length(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_ChFiDS_FilSpine self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_IsPeriodic(self, *args)


    def Period(self, *args):
        """
        Period(Handle_ChFiDS_FilSpine self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_Period(self, *args)


    def Absc(self, *args):
        """
        Absc(Handle_ChFiDS_FilSpine self, Standard_Real const U) -> Standard_Real
        Absc(Handle_ChFiDS_FilSpine self, Standard_Real const U, Standard_Integer const I) -> Standard_Real
        Absc(Handle_ChFiDS_FilSpine self, TopoDS_Vertex V) -> Standard_Real

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_Absc(self, *args)


    def Parameter(self, *args):
        """
        Parameter(Handle_ChFiDS_FilSpine self, Standard_Real const AbsC, Standard_Boolean const Oriented)
        Parameter(Handle_ChFiDS_FilSpine self, Standard_Integer const Index, Standard_Real const AbsC, Standard_Boolean const Oriented)

        :type Index: int
        :type AbsC: float
        :type U: float
        :type Oriented: bool

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_Parameter(self, *args)


    def Value(self, *args):
        """
        Value(Handle_ChFiDS_FilSpine self, Standard_Real const AbsC) -> gp_Pnt

        :type AbsC: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_Value(self, *args)


    def D0(self, *args):
        """
        D0(Handle_ChFiDS_FilSpine self, Standard_Real const AbsC, gp_Pnt P)

        :type AbsC: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_ChFiDS_FilSpine self, Standard_Real const AbsC, gp_Pnt P, gp_Vec V1)

        :type AbsC: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_ChFiDS_FilSpine self, Standard_Real const AbsC, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        :type AbsC: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_D2(self, *args)


    def SetCurrent(self, *args):
        """
        SetCurrent(Handle_ChFiDS_FilSpine self, Standard_Integer const Index)

        :type Index: int

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_SetCurrent(self, *args)


    def CurrentElementarySpine(self, *args):
        """
        sets the current curve and returns it

        :type Index: int
        :rtype: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve

        """
        res = _ChFiDS.Handle_ChFiDS_FilSpine_CurrentElementarySpine(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CurrentIndexOfElementarySpine(self, *args):
        """
        CurrentIndexOfElementarySpine(Handle_ChFiDS_FilSpine self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_CurrentIndexOfElementarySpine(self, *args)


    def GetType(self, *args):
        """
        GetType(Handle_ChFiDS_FilSpine self) -> GeomAbs_CurveType

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_GetType(self, *args)


    def Line(self, *args):
        """
        Line(Handle_ChFiDS_FilSpine self) -> gp_Lin

        :rtype: OCC.wrapper.gp.gp_Lin

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_Line(self, *args)


    def Circle(self, *args):
        """
        Circle(Handle_ChFiDS_FilSpine self) -> gp_Circ

        :rtype: OCC.wrapper.gp.gp_Circ

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_Circle(self, *args)


    def FirstStatus(self, *args):
        """
        FirstStatus(Handle_ChFiDS_FilSpine self) -> ChFiDS_State

        returns if the set of edges starts on a free boundary
        or if the first vertex is a breakpoint or if the set is
        closed

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_State

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_FirstStatus(self, *args)


    def LastStatus(self, *args):
        """
        LastStatus(Handle_ChFiDS_FilSpine self) -> ChFiDS_State

        returns the state at the end of the set

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_State

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_LastStatus(self, *args)


    def Status(self, *args):
        """
        Status(Handle_ChFiDS_FilSpine self, Standard_Boolean const IsFirst) -> ChFiDS_State

        :type IsFirst: bool
        :rtype: OCC.wrapper.ChFiDS.ChFiDS_State

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_Status(self, *args)


    def SetStatus(self, *args):
        """
        SetStatus(Handle_ChFiDS_FilSpine self, ChFiDS_State const S, Standard_Boolean const IsFirst)

        :type S: OCC.wrapper.ChFiDS.ChFiDS_State
        :type IsFirst: bool

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_SetStatus(self, *args)


    def IsTangencyExtremity(self, *args):
        """
        IsTangencyExtremity(Handle_ChFiDS_FilSpine self, Standard_Boolean const IsFirst) -> Standard_Boolean

        returns   if the  set  of  edges starts (or   end) on
        Tangency point.

        :type IsFirst: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_IsTangencyExtremity(self, *args)


    def SetTangencyExtremity(self, *args):
        """
        SetTangencyExtremity(Handle_ChFiDS_FilSpine self, Standard_Boolean const IsTangency, Standard_Boolean const IsFirst)

        :type IsTangency: bool
        :type IsFirst: bool

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_SetTangencyExtremity(self, *args)


    def FirstVertex(self, *args):
        """
        FirstVertex(Handle_ChFiDS_FilSpine self) -> TopoDS_Vertex

        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_FirstVertex(self, *args)


    def LastVertex(self, *args):
        """
        LastVertex(Handle_ChFiDS_FilSpine self) -> TopoDS_Vertex

        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_LastVertex(self, *args)


    def SetFirstTgt(self, *args):
        """
        SetFirstTgt(Handle_ChFiDS_FilSpine self, Standard_Real const W)

        :type W: float

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_SetFirstTgt(self, *args)


    def SetLastTgt(self, *args):
        """
        SetLastTgt(Handle_ChFiDS_FilSpine self, Standard_Real const W)

        :type W: float

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_SetLastTgt(self, *args)


    def HasFirstTgt(self, *args):
        """
        HasFirstTgt(Handle_ChFiDS_FilSpine self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_HasFirstTgt(self, *args)


    def HasLastTgt(self, *args):
        """
        HasLastTgt(Handle_ChFiDS_FilSpine self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_HasLastTgt(self, *args)


    def SetReference(self, *args):
        """
        SetReference(Handle_ChFiDS_FilSpine self, Standard_Real const W)
        SetReference(Handle_ChFiDS_FilSpine self, Standard_Integer const I)

        set  a  parameter  reference  for  the approx,  at the
        middle  of edge I.

        :type I: int

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_SetReference(self, *args)


    def Index(self, *args):
        """
        Index(Handle_ChFiDS_FilSpine self, Standard_Real const W, Standard_Boolean const Forward) -> Standard_Integer
        Index(Handle_ChFiDS_FilSpine self, TopoDS_Edge E) -> Standard_Integer

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_Index(self, *args)


    def UnsetReference(self, *args):
        """UnsetReference(Handle_ChFiDS_FilSpine self)"""
        return _ChFiDS.Handle_ChFiDS_FilSpine_UnsetReference(self, *args)


    def SetErrorStatus(self, *args):
        """
        SetErrorStatus(Handle_ChFiDS_FilSpine self, ChFiDS_ErrorStatus const state)

        :type state: OCC.wrapper.ChFiDS.ChFiDS_ErrorStatus

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_SetErrorStatus(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(Handle_ChFiDS_FilSpine self) -> ChFiDS_ErrorStatus

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_ErrorStatus

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_ErrorStatus(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ChFiDS_FilSpine self)

        Memory deallocator for transient classes


        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ChFiDS_FilSpine self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ChFiDS_FilSpine self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ChFiDS_FilSpine self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ChFiDS_FilSpine self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ChFiDS_FilSpine self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ChFiDS_FilSpine self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ChFiDS_FilSpine self)

        Increments the reference counter of this object


        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ChFiDS_FilSpine self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_FilSpine_DecrementRefCounter(self, *args)

Handle_ChFiDS_FilSpine_swigregister = _ChFiDS.Handle_ChFiDS_FilSpine_swigregister
Handle_ChFiDS_FilSpine_swigregister(Handle_ChFiDS_FilSpine)

def Handle_ChFiDS_FilSpine_DownCast(thing):
    return _ChFiDS.Handle_ChFiDS_FilSpine_DownCast(thing)
Handle_ChFiDS_FilSpine_DownCast = _ChFiDS.Handle_ChFiDS_FilSpine_DownCast

class Handle_ChFiDS_SurfData(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ChFiDS_SurfData self)

        Nullify the handle


        """
        return _ChFiDS.Handle_ChFiDS_SurfData_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ChFiDS_SurfData self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ChFiDS_SurfData self, ChFiDS_SurfData thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ChFiDS_SurfData self, Handle_ChFiDS_SurfData theHandle) -> Handle_ChFiDS_SurfData
        assign(Handle_ChFiDS_SurfData self, ChFiDS_SurfData thePtr) -> Handle_ChFiDS_SurfData
        assign(Handle_ChFiDS_SurfData self, Handle_ChFiDS_SurfData theHandle) -> Handle_ChFiDS_SurfData

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ChFiDS_SurfData self) -> ChFiDS_SurfData

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ChFiDS_SurfData self) -> ChFiDS_SurfData

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ChFiDS.Handle_ChFiDS_SurfData___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ChFiDS_SurfData self) -> ChFiDS_SurfData

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ChFiDS.Handle_ChFiDS_SurfData___ref__(self, *args)


    def __hash__(self):
        return _ChFiDS.Handle_ChFiDS_SurfData___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ChFiDS.Handle_ChFiDS_SurfData___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ChFiDS.new_Handle_ChFiDS_SurfData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ChFiDS.Handle_ChFiDS_SurfData_DownCast)
    __swig_destroy__ = _ChFiDS.delete_Handle_ChFiDS_SurfData

    def Copy(self, *args):
        """
        Copy(Handle_ChFiDS_SurfData self, Handle_ChFiDS_SurfData Other)

        :type Other: OCC.wrapper.ChFiDS.Handle_ChFiDS_SurfData

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_Copy(self, *args)


    def IndexOfS1(self, *args):
        """
        IndexOfS1(Handle_ChFiDS_SurfData self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_IndexOfS1(self, *args)


    def IndexOfS2(self, *args):
        """
        IndexOfS2(Handle_ChFiDS_SurfData self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_IndexOfS2(self, *args)


    def IsOnCurve1(self, *args):
        """
        IsOnCurve1(Handle_ChFiDS_SurfData self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_IsOnCurve1(self, *args)


    def IsOnCurve2(self, *args):
        """
        IsOnCurve2(Handle_ChFiDS_SurfData self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_IsOnCurve2(self, *args)


    def IndexOfC1(self, *args):
        """
        IndexOfC1(Handle_ChFiDS_SurfData self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_IndexOfC1(self, *args)


    def IndexOfC2(self, *args):
        """
        IndexOfC2(Handle_ChFiDS_SurfData self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_IndexOfC2(self, *args)


    def Surf(self, *args):
        """
        Surf(Handle_ChFiDS_SurfData self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_Surf(self, *args)


    def Orientation(self, *args):
        """
        Orientation(Handle_ChFiDS_SurfData self) -> TopAbs_Orientation

        :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_Orientation(self, *args)


    def InterferenceOnS1(self, *args):
        """
        :rtype: OCC.wrapper.ChFiDS.ChFiDS_FaceInterference

        """
        res = _ChFiDS.Handle_ChFiDS_SurfData_InterferenceOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InterferenceOnS2(self, *args):
        """
        :rtype: OCC.wrapper.ChFiDS.ChFiDS_FaceInterference

        """
        res = _ChFiDS.Handle_ChFiDS_SurfData_InterferenceOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def VertexFirstOnS1(self, *args):
        """
        :rtype: OCC.wrapper.ChFiDS.ChFiDS_CommonPoint

        """
        res = _ChFiDS.Handle_ChFiDS_SurfData_VertexFirstOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def VertexFirstOnS2(self, *args):
        """
        :rtype: OCC.wrapper.ChFiDS.ChFiDS_CommonPoint

        """
        res = _ChFiDS.Handle_ChFiDS_SurfData_VertexFirstOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def VertexLastOnS1(self, *args):
        """
        :rtype: OCC.wrapper.ChFiDS.ChFiDS_CommonPoint

        """
        res = _ChFiDS.Handle_ChFiDS_SurfData_VertexLastOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def VertexLastOnS2(self, *args):
        """
        :rtype: OCC.wrapper.ChFiDS.ChFiDS_CommonPoint

        """
        res = _ChFiDS.Handle_ChFiDS_SurfData_VertexLastOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeIndexOfS1(self, *args):
        """
        ChangeIndexOfS1(Handle_ChFiDS_SurfData self, Standard_Integer const Index)

        :type Index: int

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_ChangeIndexOfS1(self, *args)


    def ChangeIndexOfS2(self, *args):
        """
        ChangeIndexOfS2(Handle_ChFiDS_SurfData self, Standard_Integer const Index)

        :type Index: int

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_ChangeIndexOfS2(self, *args)


    def ChangeSurf(self, *args):
        """
        ChangeSurf(Handle_ChFiDS_SurfData self, Standard_Integer const Index)

        :type Index: int

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_ChangeSurf(self, *args)


    def SetIndexOfC1(self, *args):
        """
        SetIndexOfC1(Handle_ChFiDS_SurfData self, Standard_Integer const Index)

        :type Index: int

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_SetIndexOfC1(self, *args)


    def SetIndexOfC2(self, *args):
        """
        SetIndexOfC2(Handle_ChFiDS_SurfData self, Standard_Integer const Index)

        :type Index: int

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_SetIndexOfC2(self, *args)


    def ChangeOrientation(self, *args):
        """
        ChangeOrientation(Handle_ChFiDS_SurfData self) -> TopAbs_Orientation &

        :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_ChangeOrientation(self, *args)


    def ChangeInterferenceOnS1(self, *args):
        """
        ChangeInterferenceOnS1(Handle_ChFiDS_SurfData self) -> ChFiDS_FaceInterference

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_FaceInterference

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_ChangeInterferenceOnS1(self, *args)


    def ChangeInterferenceOnS2(self, *args):
        """
        ChangeInterferenceOnS2(Handle_ChFiDS_SurfData self) -> ChFiDS_FaceInterference

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_FaceInterference

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_ChangeInterferenceOnS2(self, *args)


    def ChangeVertexFirstOnS1(self, *args):
        """
        ChangeVertexFirstOnS1(Handle_ChFiDS_SurfData self) -> ChFiDS_CommonPoint

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_CommonPoint

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_ChangeVertexFirstOnS1(self, *args)


    def ChangeVertexFirstOnS2(self, *args):
        """
        ChangeVertexFirstOnS2(Handle_ChFiDS_SurfData self) -> ChFiDS_CommonPoint

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_CommonPoint

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_ChangeVertexFirstOnS2(self, *args)


    def ChangeVertexLastOnS1(self, *args):
        """
        ChangeVertexLastOnS1(Handle_ChFiDS_SurfData self) -> ChFiDS_CommonPoint

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_CommonPoint

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_ChangeVertexLastOnS1(self, *args)


    def ChangeVertexLastOnS2(self, *args):
        """
        ChangeVertexLastOnS2(Handle_ChFiDS_SurfData self) -> ChFiDS_CommonPoint

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_CommonPoint

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_ChangeVertexLastOnS2(self, *args)


    def Interference(self, *args):
        """
        :type OnS: int
        :rtype: OCC.wrapper.ChFiDS.ChFiDS_FaceInterference

        """
        res = _ChFiDS.Handle_ChFiDS_SurfData_Interference(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeInterference(self, *args):
        """
        ChangeInterference(Handle_ChFiDS_SurfData self, Standard_Integer const OnS) -> ChFiDS_FaceInterference

        :type OnS: int
        :rtype: OCC.wrapper.ChFiDS.ChFiDS_FaceInterference

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_ChangeInterference(self, *args)


    def Index(self, *args):
        """
        Index(Handle_ChFiDS_SurfData self, Standard_Integer const OfS) -> Standard_Integer

        :type OfS: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_Index(self, *args)


    def Vertex(self, *args):
        """
        returns one of the four vertices  wether First is true
        or wrong and OnS equals 1 or 2.

        :type First: bool
        :type OnS: int
        :rtype: OCC.wrapper.ChFiDS.ChFiDS_CommonPoint

        """
        res = _ChFiDS.Handle_ChFiDS_SurfData_Vertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeVertex(self, *args):
        """
        ChangeVertex(Handle_ChFiDS_SurfData self, Standard_Boolean const First, Standard_Integer const OnS) -> ChFiDS_CommonPoint

        returns one of the four vertices  wether First is true
        or wrong and OnS equals 1 or 2.

        :type First: bool
        :type OnS: int
        :rtype: OCC.wrapper.ChFiDS.ChFiDS_CommonPoint

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_ChangeVertex(self, *args)


    def IsOnCurve(self, *args):
        """
        IsOnCurve(Handle_ChFiDS_SurfData self, Standard_Integer const OnS) -> Standard_Boolean

        :type OnS: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_IsOnCurve(self, *args)


    def IndexOfC(self, *args):
        """
        IndexOfC(Handle_ChFiDS_SurfData self, Standard_Integer const OnS) -> Standard_Integer

        :type OnS: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_IndexOfC(self, *args)


    def FirstSpineParam(self, *args):
        """
        FirstSpineParam(Handle_ChFiDS_SurfData self) -> Standard_Real
        FirstSpineParam(Handle_ChFiDS_SurfData self, Standard_Real const Par)

        :type Par: float

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_FirstSpineParam(self, *args)


    def LastSpineParam(self, *args):
        """
        LastSpineParam(Handle_ChFiDS_SurfData self) -> Standard_Real
        LastSpineParam(Handle_ChFiDS_SurfData self, Standard_Real const Par)

        :type Par: float

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_LastSpineParam(self, *args)


    def FirstExtensionValue(self, *args):
        """
        FirstExtensionValue(Handle_ChFiDS_SurfData self) -> Standard_Real
        FirstExtensionValue(Handle_ChFiDS_SurfData self, Standard_Real const Extend)

        :type Extend: float

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_FirstExtensionValue(self, *args)


    def LastExtensionValue(self, *args):
        """
        LastExtensionValue(Handle_ChFiDS_SurfData self) -> Standard_Real
        LastExtensionValue(Handle_ChFiDS_SurfData self, Standard_Real const Extend)

        :type Extend: float

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_LastExtensionValue(self, *args)


    def Simul(self, *args):
        """
        Simul(Handle_ChFiDS_SurfData self) -> Handle_Standard_Transient

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_Simul(self, *args)


    def SetSimul(self, *args):
        """
        SetSimul(Handle_ChFiDS_SurfData self, Handle_Standard_Transient S)

        :type S: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_SetSimul(self, *args)


    def ResetSimul(self, *args):
        """ResetSimul(Handle_ChFiDS_SurfData self)"""
        return _ChFiDS.Handle_ChFiDS_SurfData_ResetSimul(self, *args)


    def Get2dPoints(self, *args):
        """
        Get2dPoints(Handle_ChFiDS_SurfData self, Standard_Boolean const First, Standard_Integer const OnS) -> gp_Pnt2d
        Get2dPoints(Handle_ChFiDS_SurfData self, gp_Pnt2d P2df1, gp_Pnt2d P2dl1, gp_Pnt2d P2df2, gp_Pnt2d P2dl2)

        :type P2df1: OCC.wrapper.gp.gp_Pnt2d
        :type P2dl1: OCC.wrapper.gp.gp_Pnt2d
        :type P2df2: OCC.wrapper.gp.gp_Pnt2d
        :type P2dl2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_Get2dPoints(self, *args)


    def Set2dPoints(self, *args):
        """
        Set2dPoints(Handle_ChFiDS_SurfData self, gp_Pnt2d P2df1, gp_Pnt2d P2dl1, gp_Pnt2d P2df2, gp_Pnt2d P2dl2)

        :type P2df1: OCC.wrapper.gp.gp_Pnt2d
        :type P2dl1: OCC.wrapper.gp.gp_Pnt2d
        :type P2df2: OCC.wrapper.gp.gp_Pnt2d
        :type P2dl2: OCC.wrapper.gp.gp_Pnt2d

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_Set2dPoints(self, *args)


    def TwistOnS1(self, *args):
        """
        TwistOnS1(Handle_ChFiDS_SurfData self) -> Standard_Boolean
        TwistOnS1(Handle_ChFiDS_SurfData self, Standard_Boolean const T)

        :type T: bool

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_TwistOnS1(self, *args)


    def TwistOnS2(self, *args):
        """
        TwistOnS2(Handle_ChFiDS_SurfData self) -> Standard_Boolean
        TwistOnS2(Handle_ChFiDS_SurfData self, Standard_Boolean const T)

        :type T: bool

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_TwistOnS2(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ChFiDS_SurfData self) -> char const *

        :rtype: const char *

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ChFiDS.Handle_ChFiDS_SurfData_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ChFiDS.Handle_ChFiDS_SurfData_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_ChFiDS_SurfData self)

        Memory deallocator for transient classes


        """
        return _ChFiDS.Handle_ChFiDS_SurfData_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ChFiDS_SurfData self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ChFiDS_SurfData self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ChFiDS_SurfData self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ChFiDS_SurfData self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ChFiDS_SurfData self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ChFiDS_SurfData self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ChFiDS_SurfData self)

        Increments the reference counter of this object


        """
        return _ChFiDS.Handle_ChFiDS_SurfData_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ChFiDS_SurfData self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_SurfData_DecrementRefCounter(self, *args)

Handle_ChFiDS_SurfData_swigregister = _ChFiDS.Handle_ChFiDS_SurfData_swigregister
Handle_ChFiDS_SurfData_swigregister(Handle_ChFiDS_SurfData)

def Handle_ChFiDS_SurfData_DownCast(thing):
    return _ChFiDS.Handle_ChFiDS_SurfData_DownCast(thing)
Handle_ChFiDS_SurfData_DownCast = _ChFiDS.Handle_ChFiDS_SurfData_DownCast

class Handle_ChFiDS_HElSpine(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ChFiDS_HElSpine self)

        Nullify the handle


        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ChFiDS_HElSpine self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ChFiDS_HElSpine self, ChFiDS_HElSpine thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ChFiDS_HElSpine self, Handle_ChFiDS_HElSpine theHandle) -> Handle_ChFiDS_HElSpine
        assign(Handle_ChFiDS_HElSpine self, ChFiDS_HElSpine thePtr) -> Handle_ChFiDS_HElSpine
        assign(Handle_ChFiDS_HElSpine self, Handle_ChFiDS_HElSpine theHandle) -> Handle_ChFiDS_HElSpine

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ChFiDS_HElSpine self) -> ChFiDS_HElSpine

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ChFiDS_HElSpine self) -> ChFiDS_HElSpine

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ChFiDS_HElSpine self) -> ChFiDS_HElSpine

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine___ref__(self, *args)


    def __hash__(self):
        return _ChFiDS.Handle_ChFiDS_HElSpine___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ChFiDS.Handle_ChFiDS_HElSpine___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ChFiDS.new_Handle_ChFiDS_HElSpine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ChFiDS.Handle_ChFiDS_HElSpine_DownCast)
    __swig_destroy__ = _ChFiDS.delete_Handle_ChFiDS_HElSpine

    def Set(self, *args):
        """
        Set(Handle_ChFiDS_HElSpine self, ChFiDS_ElSpine C)

        Sets the field of the GenHCurve.

        :type C: OCC.wrapper.ChFiDS.ChFiDS_ElSpine

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_Set(self, *args)


    def Curve(self, *args):
        """
        Returns the curve used to create the GenHCurve.
        This is redefined from HCurve, cannot be inline.

        :rtype: OCC.wrapper.Adaptor3d.Adaptor3d_Curve

        """
        res = _ChFiDS.Handle_ChFiDS_HElSpine_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetCurve(self, *args):
        """
        GetCurve(Handle_ChFiDS_HElSpine self) -> Adaptor3d_Curve

        Returns the curve used to create the GenHCurve.
        This is redefined from HCurve, cannot be inline.

        :rtype: OCC.wrapper.Adaptor3d.Adaptor3d_Curve

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_GetCurve(self, *args)


    def ChangeCurve(self, *args):
        """
        ChangeCurve(Handle_ChFiDS_HElSpine self) -> ChFiDS_ElSpine

        Returns the curve used to create the GenHCurve.

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_ElSpine

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_ChangeCurve(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ChFiDS_HElSpine self) -> char const *

        :rtype: const char *

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ChFiDS.Handle_ChFiDS_HElSpine_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ChFiDS.Handle_ChFiDS_HElSpine_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_ChFiDS_HElSpine self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_ChFiDS_HElSpine self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_LastParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_ChFiDS_HElSpine self) -> GeomAbs_Shape

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_Continuity(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_ChFiDS_HElSpine self, GeomAbs_Shape const S) -> Standard_Integer

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_ChFiDS_HElSpine self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_Intervals(self, *args)


    def Trim(self, *args):
        """
        Trim(Handle_ChFiDS_HElSpine self, Standard_Real const First, Standard_Real const Last, Standard_Real const Tol) -> Handle_Adaptor3d_HCurve

        Returns    a  curve equivalent   of  <me>  between
        parameters <First>  and <Last>. <Tol>  is used  to
        test for 3d points confusion.

        If <First> >= <Last>

        :type First: float
        :type Last: float
        :type Tol: float
        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_Trim(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_ChFiDS_HElSpine self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_ChFiDS_HElSpine self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_IsPeriodic(self, *args)


    def Period(self, *args):
        """
        Period(Handle_ChFiDS_HElSpine self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_Period(self, *args)


    def Value(self, *args):
        """
        Value(Handle_ChFiDS_HElSpine self, Standard_Real const U) -> gp_Pnt

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_Value(self, *args)


    def D0(self, *args):
        """
        D0(Handle_ChFiDS_HElSpine self, Standard_Real const U, gp_Pnt P)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_ChFiDS_HElSpine self, Standard_Real const U, gp_Pnt P, gp_Vec V)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V: OCC.wrapper.gp.gp_Vec

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_ChFiDS_HElSpine self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_ChFiDS_HElSpine self, Standard_Real const U, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_ChFiDS_HElSpine self, Standard_Real const U, Standard_Integer const N) -> gp_Vec

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_DN(self, *args)


    def Resolution(self, *args):
        """
        Resolution(Handle_ChFiDS_HElSpine self, Standard_Real const R3d) -> Standard_Real

        :type R3d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_Resolution(self, *args)


    def GetType(self, *args):
        """
        GetType(Handle_ChFiDS_HElSpine self) -> GeomAbs_CurveType

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_GetType(self, *args)


    def Line(self, *args):
        """
        Line(Handle_ChFiDS_HElSpine self) -> gp_Lin

        :rtype: OCC.wrapper.gp.gp_Lin

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_Line(self, *args)


    def Circle(self, *args):
        """
        Circle(Handle_ChFiDS_HElSpine self) -> gp_Circ

        :rtype: OCC.wrapper.gp.gp_Circ

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_Circle(self, *args)


    def Ellipse(self, *args):
        """
        Ellipse(Handle_ChFiDS_HElSpine self) -> gp_Elips

        :rtype: OCC.wrapper.gp.gp_Elips

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_Ellipse(self, *args)


    def Hyperbola(self, *args):
        """
        Hyperbola(Handle_ChFiDS_HElSpine self) -> gp_Hypr

        :rtype: OCC.wrapper.gp.gp_Hypr

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_Hyperbola(self, *args)


    def Parabola(self, *args):
        """
        Parabola(Handle_ChFiDS_HElSpine self) -> gp_Parab

        :rtype: OCC.wrapper.gp.gp_Parab

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_Parabola(self, *args)


    def Degree(self, *args):
        """
        Degree(Handle_ChFiDS_HElSpine self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_Degree(self, *args)


    def IsRational(self, *args):
        """
        IsRational(Handle_ChFiDS_HElSpine self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_IsRational(self, *args)


    def NbPoles(self, *args):
        """
        NbPoles(Handle_ChFiDS_HElSpine self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_NbPoles(self, *args)


    def NbKnots(self, *args):
        """
        NbKnots(Handle_ChFiDS_HElSpine self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_NbKnots(self, *args)


    def Bezier(self, *args):
        """
        Bezier(Handle_ChFiDS_HElSpine self) -> Handle_Geom_BezierCurve

        :rtype: OCC.wrapper.Geom.Handle_Geom_BezierCurve

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_Bezier(self, *args)


    def BSpline(self, *args):
        """
        BSpline(Handle_ChFiDS_HElSpine self) -> Handle_Geom_BSplineCurve

        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineCurve

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_BSpline(self, *args)


    def OffsetCurve(self, *args):
        """
        OffsetCurve(Handle_ChFiDS_HElSpine self) -> Handle_Geom_OffsetCurve

        :rtype: OCC.wrapper.Geom.Handle_Geom_OffsetCurve

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_OffsetCurve(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ChFiDS_HElSpine self)

        Memory deallocator for transient classes


        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ChFiDS_HElSpine self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ChFiDS_HElSpine self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ChFiDS_HElSpine self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ChFiDS_HElSpine self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ChFiDS_HElSpine self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ChFiDS_HElSpine self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ChFiDS_HElSpine self)

        Increments the reference counter of this object


        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ChFiDS_HElSpine self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_HElSpine_DecrementRefCounter(self, *args)

Handle_ChFiDS_HElSpine_swigregister = _ChFiDS.Handle_ChFiDS_HElSpine_swigregister
Handle_ChFiDS_HElSpine_swigregister(Handle_ChFiDS_HElSpine)

def Handle_ChFiDS_HElSpine_DownCast(thing):
    return _ChFiDS.Handle_ChFiDS_HElSpine_DownCast(thing)
Handle_ChFiDS_HElSpine_DownCast = _ChFiDS.Handle_ChFiDS_HElSpine_DownCast

class ChFiDS_ElSpine(Adaptor3d.Adaptor3d_Curve):
    """Elementary  Spine for cheminements and approximations."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ChFiDS_ElSpine self) -> ChFiDS_ElSpine

        Elementary  Spine for cheminements and approximations.
        """
        this = _ChFiDS.new_ChFiDS_ElSpine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetSavedFirstParameter(self, *args):
        """
        GetSavedFirstParameter(ChFiDS_ElSpine self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.ChFiDS_ElSpine_GetSavedFirstParameter(self, *args)


    def GetSavedLastParameter(self, *args):
        """
        GetSavedLastParameter(ChFiDS_ElSpine self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.ChFiDS_ElSpine_GetSavedLastParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(ChFiDS_ElSpine self) -> GeomAbs_Shape

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _ChFiDS.ChFiDS_ElSpine_Continuity(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(ChFiDS_ElSpine self, GeomAbs_Shape const S) -> Standard_Integer

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.ChFiDS_ElSpine_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(ChFiDS_ElSpine self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _ChFiDS.ChFiDS_ElSpine_Intervals(self, *args)


    def Trim(self, *args):
        """
        Trim(ChFiDS_ElSpine self, Standard_Real const First, Standard_Real const Last, Standard_Real const Tol) -> Handle_Adaptor3d_HCurve

        Returns    a  curve equivalent   of  <me>  between
        parameters <First>  and <Last>. <Tol>  is used  to
        test for 3d points confusion.

        :type First: float
        :type Last: float
        :type Tol: float
        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve

        """
        return _ChFiDS.ChFiDS_ElSpine_Trim(self, *args)


    def Resolution(self, *args):
        """
        Resolution(ChFiDS_ElSpine self, Standard_Real const R3d) -> Standard_Real

        :type R3d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.ChFiDS_ElSpine_Resolution(self, *args)


    def GetType(self, *args):
        """
        GetType(ChFiDS_ElSpine self) -> GeomAbs_CurveType

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

        """
        return _ChFiDS.ChFiDS_ElSpine_GetType(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(ChFiDS_ElSpine self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.ChFiDS_ElSpine_IsPeriodic(self, *args)


    def SetPeriodic(self, *args):
        """
        SetPeriodic(ChFiDS_ElSpine self, Standard_Boolean const I)

        :type I: bool

        """
        return _ChFiDS.ChFiDS_ElSpine_SetPeriodic(self, *args)


    def Period(self, *args):
        """
        Period(ChFiDS_ElSpine self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.ChFiDS_ElSpine_Period(self, *args)


    def Value(self, *args):
        """
        Value(ChFiDS_ElSpine self, Standard_Real const AbsC) -> gp_Pnt

        :type AbsC: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _ChFiDS.ChFiDS_ElSpine_Value(self, *args)


    def D0(self, *args):
        """
        D0(ChFiDS_ElSpine self, Standard_Real const AbsC, gp_Pnt P)

        :type AbsC: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _ChFiDS.ChFiDS_ElSpine_D0(self, *args)


    def D1(self, *args):
        """
        D1(ChFiDS_ElSpine self, Standard_Real const AbsC, gp_Pnt P, gp_Vec V1)

        :type AbsC: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec

        """
        return _ChFiDS.ChFiDS_ElSpine_D1(self, *args)


    def D2(self, *args):
        """
        D2(ChFiDS_ElSpine self, Standard_Real const AbsC, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        :type AbsC: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _ChFiDS.ChFiDS_ElSpine_D2(self, *args)


    def D3(self, *args):
        """
        D3(ChFiDS_ElSpine self, Standard_Real const AbsC, gp_Pnt P, gp_Vec V1, gp_Vec V2, gp_Vec V3)

        :type AbsC: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec
        :type V3: OCC.wrapper.gp.gp_Vec

        """
        return _ChFiDS.ChFiDS_ElSpine_D3(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(ChFiDS_ElSpine self) -> Standard_Real
        FirstParameter(ChFiDS_ElSpine self, Standard_Real const P)

        :type P: float

        """
        return _ChFiDS.ChFiDS_ElSpine_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(ChFiDS_ElSpine self) -> Standard_Real
        LastParameter(ChFiDS_ElSpine self, Standard_Real const P)

        :type P: float

        """
        return _ChFiDS.ChFiDS_ElSpine_LastParameter(self, *args)


    def SaveFirstParameter(self, *args):
        """SaveFirstParameter(ChFiDS_ElSpine self)"""
        return _ChFiDS.ChFiDS_ElSpine_SaveFirstParameter(self, *args)


    def SaveLastParameter(self, *args):
        """SaveLastParameter(ChFiDS_ElSpine self)"""
        return _ChFiDS.ChFiDS_ElSpine_SaveLastParameter(self, *args)


    def SetOrigin(self, *args):
        """
        SetOrigin(ChFiDS_ElSpine self, Standard_Real const O)

        :type O: float

        """
        return _ChFiDS.ChFiDS_ElSpine_SetOrigin(self, *args)


    def FirstPointAndTgt(self, *args):
        """
        FirstPointAndTgt(ChFiDS_ElSpine self, gp_Pnt P, gp_Vec T)

        :type P: OCC.wrapper.gp.gp_Pnt
        :type T: OCC.wrapper.gp.gp_Vec

        """
        return _ChFiDS.ChFiDS_ElSpine_FirstPointAndTgt(self, *args)


    def LastPointAndTgt(self, *args):
        """
        LastPointAndTgt(ChFiDS_ElSpine self, gp_Pnt P, gp_Vec T)

        :type P: OCC.wrapper.gp.gp_Pnt
        :type T: OCC.wrapper.gp.gp_Vec

        """
        return _ChFiDS.ChFiDS_ElSpine_LastPointAndTgt(self, *args)


    def NbVertices(self, *args):
        """
        NbVertices(ChFiDS_ElSpine self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.ChFiDS_ElSpine_NbVertices(self, *args)


    def VertexWithTangent(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Ax1

        """
        res = _ChFiDS.ChFiDS_ElSpine_VertexWithTangent(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstPointAndTgt(self, *args):
        """
        SetFirstPointAndTgt(ChFiDS_ElSpine self, gp_Pnt P, gp_Vec T)

        :type P: OCC.wrapper.gp.gp_Pnt
        :type T: OCC.wrapper.gp.gp_Vec

        """
        return _ChFiDS.ChFiDS_ElSpine_SetFirstPointAndTgt(self, *args)


    def SetLastPointAndTgt(self, *args):
        """
        SetLastPointAndTgt(ChFiDS_ElSpine self, gp_Pnt P, gp_Vec T)

        :type P: OCC.wrapper.gp.gp_Pnt
        :type T: OCC.wrapper.gp.gp_Vec

        """
        return _ChFiDS.ChFiDS_ElSpine_SetLastPointAndTgt(self, *args)


    def AddVertexWithTangent(self, *args):
        """
        AddVertexWithTangent(ChFiDS_ElSpine self, gp_Ax1 anAx1)

        :type anAx1: OCC.wrapper.gp.gp_Ax1

        """
        return _ChFiDS.ChFiDS_ElSpine_AddVertexWithTangent(self, *args)


    def SetCurve(self, *args):
        """
        SetCurve(ChFiDS_ElSpine self, Handle_Geom_Curve C)

        :type C: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _ChFiDS.ChFiDS_ElSpine_SetCurve(self, *args)


    def Previous(self, *args):
        """
        :rtype: OCC.wrapper.ChFiDS.Handle_ChFiDS_SurfData

        """
        res = _ChFiDS.ChFiDS_ElSpine_Previous(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangePrevious(self, *args):
        """
        ChangePrevious(ChFiDS_ElSpine self) -> Handle_ChFiDS_SurfData

        :rtype: OCC.wrapper.ChFiDS.Handle_ChFiDS_SurfData

        """
        return _ChFiDS.ChFiDS_ElSpine_ChangePrevious(self, *args)


    def Next(self, *args):
        """
        :rtype: OCC.wrapper.ChFiDS.Handle_ChFiDS_SurfData

        """
        res = _ChFiDS.ChFiDS_ElSpine_Next(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeNext(self, *args):
        """
        ChangeNext(ChFiDS_ElSpine self) -> Handle_ChFiDS_SurfData

        :rtype: OCC.wrapper.ChFiDS.Handle_ChFiDS_SurfData

        """
        return _ChFiDS.ChFiDS_ElSpine_ChangeNext(self, *args)


    def Line(self, *args):
        """
        Line(ChFiDS_ElSpine self) -> gp_Lin

        :rtype: OCC.wrapper.gp.gp_Lin

        """
        return _ChFiDS.ChFiDS_ElSpine_Line(self, *args)


    def Circle(self, *args):
        """
        Circle(ChFiDS_ElSpine self) -> gp_Circ

        :rtype: OCC.wrapper.gp.gp_Circ

        """
        return _ChFiDS.ChFiDS_ElSpine_Circle(self, *args)


    def Ellipse(self, *args):
        """
        Ellipse(ChFiDS_ElSpine self) -> gp_Elips

        :rtype: OCC.wrapper.gp.gp_Elips

        """
        return _ChFiDS.ChFiDS_ElSpine_Ellipse(self, *args)


    def Hyperbola(self, *args):
        """
        Hyperbola(ChFiDS_ElSpine self) -> gp_Hypr

        :rtype: OCC.wrapper.gp.gp_Hypr

        """
        return _ChFiDS.ChFiDS_ElSpine_Hyperbola(self, *args)


    def Parabola(self, *args):
        """
        Parabola(ChFiDS_ElSpine self) -> gp_Parab

        :rtype: OCC.wrapper.gp.gp_Parab

        """
        return _ChFiDS.ChFiDS_ElSpine_Parabola(self, *args)


    def Bezier(self, *args):
        """
        Bezier(ChFiDS_ElSpine self) -> Handle_Geom_BezierCurve

        :rtype: OCC.wrapper.Geom.Handle_Geom_BezierCurve

        """
        return _ChFiDS.ChFiDS_ElSpine_Bezier(self, *args)


    def BSpline(self, *args):
        """
        BSpline(ChFiDS_ElSpine self) -> Handle_Geom_BSplineCurve

        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineCurve

        """
        return _ChFiDS.ChFiDS_ElSpine_BSpline(self, *args)

    __swig_destroy__ = _ChFiDS.delete_ChFiDS_ElSpine
ChFiDS_ElSpine_swigregister = _ChFiDS.ChFiDS_ElSpine_swigregister
ChFiDS_ElSpine_swigregister(ChFiDS_ElSpine)

class Handle_ChFiDS_SecHArray1(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ChFiDS_SecHArray1 self)

        Nullify the handle


        """
        return _ChFiDS.Handle_ChFiDS_SecHArray1_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ChFiDS_SecHArray1 self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ChFiDS.Handle_ChFiDS_SecHArray1_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ChFiDS_SecHArray1 self, ChFiDS_SecHArray1 thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ChFiDS.Handle_ChFiDS_SecHArray1_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ChFiDS_SecHArray1 self, Handle_ChFiDS_SecHArray1 theHandle) -> Handle_ChFiDS_SecHArray1
        assign(Handle_ChFiDS_SecHArray1 self, ChFiDS_SecHArray1 thePtr) -> Handle_ChFiDS_SecHArray1
        assign(Handle_ChFiDS_SecHArray1 self, Handle_ChFiDS_SecHArray1 theHandle) -> Handle_ChFiDS_SecHArray1

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ChFiDS.Handle_ChFiDS_SecHArray1_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ChFiDS_SecHArray1 self) -> ChFiDS_SecHArray1

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ChFiDS.Handle_ChFiDS_SecHArray1_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ChFiDS_SecHArray1 self) -> ChFiDS_SecHArray1

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ChFiDS.Handle_ChFiDS_SecHArray1___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ChFiDS_SecHArray1 self) -> ChFiDS_SecHArray1

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ChFiDS.Handle_ChFiDS_SecHArray1___ref__(self, *args)


    def __hash__(self):
        return _ChFiDS.Handle_ChFiDS_SecHArray1___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ChFiDS.Handle_ChFiDS_SecHArray1___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ChFiDS.new_Handle_ChFiDS_SecHArray1(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ChFiDS.Handle_ChFiDS_SecHArray1_DownCast)
    __swig_destroy__ = _ChFiDS.delete_Handle_ChFiDS_SecHArray1

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.ChFiDS.ChFiDS_SecArray1

        """
        res = _ChFiDS.Handle_ChFiDS_SecHArray1_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_ChFiDS_SecHArray1 self) -> NCollection_Array1_ChFiDS_CircSection

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_SecArray1

        """
        return _ChFiDS.Handle_ChFiDS_SecHArray1_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ChFiDS_SecHArray1 self) -> char const *

        :rtype: const char *

        """
        return _ChFiDS.Handle_ChFiDS_SecHArray1_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ChFiDS.Handle_ChFiDS_SecHArray1_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ChFiDS.Handle_ChFiDS_SecHArray1_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_ChFiDS_SecHArray1 self)

        Memory deallocator for transient classes


        """
        return _ChFiDS.Handle_ChFiDS_SecHArray1_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ChFiDS_SecHArray1 self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ChFiDS_SecHArray1 self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_SecHArray1_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ChFiDS_SecHArray1 self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ChFiDS_SecHArray1 self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_SecHArray1_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ChFiDS_SecHArray1 self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ChFiDS.Handle_ChFiDS_SecHArray1_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ChFiDS_SecHArray1 self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_SecHArray1_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ChFiDS_SecHArray1 self)

        Increments the reference counter of this object


        """
        return _ChFiDS.Handle_ChFiDS_SecHArray1_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ChFiDS_SecHArray1 self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_SecHArray1_DecrementRefCounter(self, *args)

Handle_ChFiDS_SecHArray1_swigregister = _ChFiDS.Handle_ChFiDS_SecHArray1_swigregister
Handle_ChFiDS_SecHArray1_swigregister(Handle_ChFiDS_SecHArray1)

def Handle_ChFiDS_SecHArray1_DownCast(thing):
    return _ChFiDS.Handle_ChFiDS_SecHArray1_DownCast(thing)
Handle_ChFiDS_SecHArray1_DownCast = _ChFiDS.Handle_ChFiDS_SecHArray1_DownCast

class NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Vertex,ChFiDS_ListOfStripe,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _ChFiDS.NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Vertex,ChFiDS_ListOfStripe,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _ChFiDS.NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Vertex,ChFiDS_ListOfStripe,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _ChFiDS.NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Vertex,ChFiDS_ListOfStripe,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _ChFiDS.NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _ChFiDS.new_NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _ChFiDS.NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _ChFiDS.NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _ChFiDS.NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _ChFiDS.NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher self, TopoDS_Vertex theKey1, NCollection_List_Handle_ChFiDS_Stripe theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher self, TopoDS_Vertex theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher self, Standard_Integer const theIndex, TopoDS_Vertex theKey1, NCollection_List_Handle_ChFiDS_Stripe theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _ChFiDS.NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _ChFiDS.NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher self)

        RemoveLast


        """
        return _ChFiDS.NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _ChFiDS.NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher self, TopoDS_Vertex theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _ChFiDS.NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _ChFiDS.NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _ChFiDS.NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher self, Standard_Integer const theIndex) -> NCollection_List_Handle_ChFiDS_Stripe

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _ChFiDS.NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _ChFiDS.NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher self, TopoDS_Vertex theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher self, TopoDS_Vertex theKey1) -> NCollection_List_Handle_ChFiDS_Stripe

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _ChFiDS.NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher self, TopoDS_Vertex theKey1) -> NCollection_List_Handle_ChFiDS_Stripe

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _ChFiDS.NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher self, TopoDS_Vertex theKey1) -> NCollection_List_Handle_ChFiDS_Stripe

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _ChFiDS.NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _ChFiDS.NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _ChFiDS.NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _ChFiDS.NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _ChFiDS.delete_NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher
NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_swigregister = _ChFiDS.NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_swigregister
NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_swigregister(NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher)

class NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _ChFiDS.new_NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ChFiDS.delete_NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _ChFiDS.NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _ChFiDS.NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher_IteratorHelper)


try:
	ChFiDS_IndexedDataMapOfVertexListOfStripe = NCollection_IndexedDataMap_TopoDS_Vertex_ChFiDS_ListOfStripe_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_ChFiDS_Spine(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ChFiDS_Spine self)

        Nullify the handle


        """
        return _ChFiDS.Handle_ChFiDS_Spine_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ChFiDS_Spine self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ChFiDS.Handle_ChFiDS_Spine_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ChFiDS_Spine self, ChFiDS_Spine thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ChFiDS.Handle_ChFiDS_Spine_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ChFiDS_Spine self, Handle_ChFiDS_Spine theHandle) -> Handle_ChFiDS_Spine
        assign(Handle_ChFiDS_Spine self, ChFiDS_Spine thePtr) -> Handle_ChFiDS_Spine
        assign(Handle_ChFiDS_Spine self, Handle_ChFiDS_Spine theHandle) -> Handle_ChFiDS_Spine

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ChFiDS.Handle_ChFiDS_Spine_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ChFiDS_Spine self) -> ChFiDS_Spine

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ChFiDS.Handle_ChFiDS_Spine_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ChFiDS_Spine self) -> ChFiDS_Spine

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ChFiDS.Handle_ChFiDS_Spine___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ChFiDS_Spine self) -> ChFiDS_Spine

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ChFiDS.Handle_ChFiDS_Spine___ref__(self, *args)


    def __hash__(self):
        return _ChFiDS.Handle_ChFiDS_Spine___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ChFiDS.Handle_ChFiDS_Spine___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ChFiDS.new_Handle_ChFiDS_Spine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ChFiDS.Handle_ChFiDS_Spine_DownCast)
    __swig_destroy__ = _ChFiDS.delete_Handle_ChFiDS_Spine

    def SetEdges(self, *args):
        """
        SetEdges(Handle_ChFiDS_Spine self, TopoDS_Edge E)

        store edges composing the guideline

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _ChFiDS.Handle_ChFiDS_Spine_SetEdges(self, *args)


    def PutInFirst(self, *args):
        """
        PutInFirst(Handle_ChFiDS_Spine self, TopoDS_Edge E)

        store the edge at the first position before all others

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _ChFiDS.Handle_ChFiDS_Spine_PutInFirst(self, *args)


    def NbEdges(self, *args):
        """
        NbEdges(Handle_ChFiDS_Spine self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_Spine_NbEdges(self, *args)


    def Edges(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _ChFiDS.Handle_ChFiDS_Spine_Edges(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetFirstStatus(self, *args):
        """
        SetFirstStatus(Handle_ChFiDS_Spine self, ChFiDS_State const S)

        stores if the start of a set of edges starts on a
        section of free border or forms  a closed contour

        :type S: OCC.wrapper.ChFiDS.ChFiDS_State

        """
        return _ChFiDS.Handle_ChFiDS_Spine_SetFirstStatus(self, *args)


    def SetLastStatus(self, *args):
        """
        SetLastStatus(Handle_ChFiDS_Spine self, ChFiDS_State const S)

        stores if the end of a set of edges starts on a
        section of free border or forms  a closed contour

        :type S: OCC.wrapper.ChFiDS.ChFiDS_State

        """
        return _ChFiDS.Handle_ChFiDS_Spine_SetLastStatus(self, *args)


    def AppendElSpine(self, *args):
        """
        AppendElSpine(Handle_ChFiDS_Spine self, Handle_ChFiDS_HElSpine Els)

        :type Els: OCC.wrapper.ChFiDS.Handle_ChFiDS_HElSpine

        """
        return _ChFiDS.Handle_ChFiDS_Spine_AppendElSpine(self, *args)


    def ElSpine(self, *args):
        """
        ElSpine(Handle_ChFiDS_Spine self, Standard_Integer const IE) -> Handle_ChFiDS_HElSpine
        ElSpine(Handle_ChFiDS_Spine self, TopoDS_Edge E) -> Handle_ChFiDS_HElSpine
        ElSpine(Handle_ChFiDS_Spine self, Standard_Real const W) -> Handle_ChFiDS_HElSpine

        :type W: float
        :rtype: OCC.wrapper.ChFiDS.Handle_ChFiDS_HElSpine

        """
        return _ChFiDS.Handle_ChFiDS_Spine_ElSpine(self, *args)


    def ChangeElSpines(self, *args):
        """
        ChangeElSpines(Handle_ChFiDS_Spine self) -> NCollection_List_Handle_ChFiDS_HElSpine

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_ListOfHElSpine

        """
        return _ChFiDS.Handle_ChFiDS_Spine_ChangeElSpines(self, *args)


    def Reset(self, *args):
        """
        Reset(Handle_ChFiDS_Spine self, Standard_Boolean const AllData)

        :type AllData: bool

        """
        return _ChFiDS.Handle_ChFiDS_Spine_Reset(self, *args)


    def SplitDone(self, *args):
        """
        SplitDone(Handle_ChFiDS_Spine self) -> Standard_Boolean
        SplitDone(Handle_ChFiDS_Spine self, Standard_Boolean const B)

        :type B: bool

        """
        return _ChFiDS.Handle_ChFiDS_Spine_SplitDone(self, *args)


    def Load(self, *args):
        """
        Load(Handle_ChFiDS_Spine self)

        prepare the guideline depending on the edges that
        are elementary arks (take parameters from
        a single curvilinear abscissa); to be able to call
        methods on the geometry (first,last,value,d1,d2)
        it is necessary to start with preparation otherwise an
        exception will be raised


        """
        return _ChFiDS.Handle_ChFiDS_Spine_Load(self, *args)


    def Resolution(self, *args):
        """
        Resolution(Handle_ChFiDS_Spine self, Standard_Real const R3d) -> Standard_Real

        :type R3d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.Handle_ChFiDS_Spine_Resolution(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_ChFiDS_Spine self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_Spine_IsClosed(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_ChFiDS_Spine self) -> Standard_Real
        FirstParameter(Handle_ChFiDS_Spine self, Standard_Integer const IndexSpine) -> Standard_Real

        gives the total length of all arcs before the
        number IndexSp

        :type IndexSpine: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.Handle_ChFiDS_Spine_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_ChFiDS_Spine self) -> Standard_Real
        LastParameter(Handle_ChFiDS_Spine self, Standard_Integer const IndexSpine) -> Standard_Real

        gives the total length till the ark with number
        IndexSpine (inclus)

        :type IndexSpine: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.Handle_ChFiDS_Spine_LastParameter(self, *args)


    def SetFirstParameter(self, *args):
        """
        SetFirstParameter(Handle_ChFiDS_Spine self, Standard_Real const Par)

        :type Par: float

        """
        return _ChFiDS.Handle_ChFiDS_Spine_SetFirstParameter(self, *args)


    def SetLastParameter(self, *args):
        """
        SetLastParameter(Handle_ChFiDS_Spine self, Standard_Real const Par)

        :type Par: float

        """
        return _ChFiDS.Handle_ChFiDS_Spine_SetLastParameter(self, *args)


    def Length(self, *args):
        """
        Length(Handle_ChFiDS_Spine self, Standard_Integer const IndexSpine) -> Standard_Real

        gives the length of ark with number IndexSp

        :type IndexSpine: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.Handle_ChFiDS_Spine_Length(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_ChFiDS_Spine self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_Spine_IsPeriodic(self, *args)


    def Period(self, *args):
        """
        Period(Handle_ChFiDS_Spine self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.Handle_ChFiDS_Spine_Period(self, *args)


    def Absc(self, *args):
        """
        Absc(Handle_ChFiDS_Spine self, Standard_Real const U) -> Standard_Real
        Absc(Handle_ChFiDS_Spine self, Standard_Real const U, Standard_Integer const I) -> Standard_Real
        Absc(Handle_ChFiDS_Spine self, TopoDS_Vertex V) -> Standard_Real

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ChFiDS.Handle_ChFiDS_Spine_Absc(self, *args)


    def Parameter(self, *args):
        """
        Parameter(Handle_ChFiDS_Spine self, Standard_Real const AbsC, Standard_Boolean const Oriented)
        Parameter(Handle_ChFiDS_Spine self, Standard_Integer const Index, Standard_Real const AbsC, Standard_Boolean const Oriented)

        :type Index: int
        :type AbsC: float
        :type U: float
        :type Oriented: bool

        """
        return _ChFiDS.Handle_ChFiDS_Spine_Parameter(self, *args)


    def Value(self, *args):
        """
        Value(Handle_ChFiDS_Spine self, Standard_Real const AbsC) -> gp_Pnt

        :type AbsC: float
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _ChFiDS.Handle_ChFiDS_Spine_Value(self, *args)


    def D0(self, *args):
        """
        D0(Handle_ChFiDS_Spine self, Standard_Real const AbsC, gp_Pnt P)

        :type AbsC: float
        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _ChFiDS.Handle_ChFiDS_Spine_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_ChFiDS_Spine self, Standard_Real const AbsC, gp_Pnt P, gp_Vec V1)

        :type AbsC: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec

        """
        return _ChFiDS.Handle_ChFiDS_Spine_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_ChFiDS_Spine self, Standard_Real const AbsC, gp_Pnt P, gp_Vec V1, gp_Vec V2)

        :type AbsC: float
        :type P: OCC.wrapper.gp.gp_Pnt
        :type V1: OCC.wrapper.gp.gp_Vec
        :type V2: OCC.wrapper.gp.gp_Vec

        """
        return _ChFiDS.Handle_ChFiDS_Spine_D2(self, *args)


    def SetCurrent(self, *args):
        """
        SetCurrent(Handle_ChFiDS_Spine self, Standard_Integer const Index)

        :type Index: int

        """
        return _ChFiDS.Handle_ChFiDS_Spine_SetCurrent(self, *args)


    def CurrentElementarySpine(self, *args):
        """
        sets the current curve and returns it

        :type Index: int
        :rtype: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve

        """
        res = _ChFiDS.Handle_ChFiDS_Spine_CurrentElementarySpine(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CurrentIndexOfElementarySpine(self, *args):
        """
        CurrentIndexOfElementarySpine(Handle_ChFiDS_Spine self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_Spine_CurrentIndexOfElementarySpine(self, *args)


    def GetType(self, *args):
        """
        GetType(Handle_ChFiDS_Spine self) -> GeomAbs_CurveType

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

        """
        return _ChFiDS.Handle_ChFiDS_Spine_GetType(self, *args)


    def Line(self, *args):
        """
        Line(Handle_ChFiDS_Spine self) -> gp_Lin

        :rtype: OCC.wrapper.gp.gp_Lin

        """
        return _ChFiDS.Handle_ChFiDS_Spine_Line(self, *args)


    def Circle(self, *args):
        """
        Circle(Handle_ChFiDS_Spine self) -> gp_Circ

        :rtype: OCC.wrapper.gp.gp_Circ

        """
        return _ChFiDS.Handle_ChFiDS_Spine_Circle(self, *args)


    def FirstStatus(self, *args):
        """
        FirstStatus(Handle_ChFiDS_Spine self) -> ChFiDS_State

        returns if the set of edges starts on a free boundary
        or if the first vertex is a breakpoint or if the set is
        closed

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_State

        """
        return _ChFiDS.Handle_ChFiDS_Spine_FirstStatus(self, *args)


    def LastStatus(self, *args):
        """
        LastStatus(Handle_ChFiDS_Spine self) -> ChFiDS_State

        returns the state at the end of the set

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_State

        """
        return _ChFiDS.Handle_ChFiDS_Spine_LastStatus(self, *args)


    def Status(self, *args):
        """
        Status(Handle_ChFiDS_Spine self, Standard_Boolean const IsFirst) -> ChFiDS_State

        :type IsFirst: bool
        :rtype: OCC.wrapper.ChFiDS.ChFiDS_State

        """
        return _ChFiDS.Handle_ChFiDS_Spine_Status(self, *args)


    def SetStatus(self, *args):
        """
        SetStatus(Handle_ChFiDS_Spine self, ChFiDS_State const S, Standard_Boolean const IsFirst)

        :type S: OCC.wrapper.ChFiDS.ChFiDS_State
        :type IsFirst: bool

        """
        return _ChFiDS.Handle_ChFiDS_Spine_SetStatus(self, *args)


    def IsTangencyExtremity(self, *args):
        """
        IsTangencyExtremity(Handle_ChFiDS_Spine self, Standard_Boolean const IsFirst) -> Standard_Boolean

        returns   if the  set  of  edges starts (or   end) on
        Tangency point.

        :type IsFirst: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_Spine_IsTangencyExtremity(self, *args)


    def SetTangencyExtremity(self, *args):
        """
        SetTangencyExtremity(Handle_ChFiDS_Spine self, Standard_Boolean const IsTangency, Standard_Boolean const IsFirst)

        :type IsTangency: bool
        :type IsFirst: bool

        """
        return _ChFiDS.Handle_ChFiDS_Spine_SetTangencyExtremity(self, *args)


    def FirstVertex(self, *args):
        """
        FirstVertex(Handle_ChFiDS_Spine self) -> TopoDS_Vertex

        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _ChFiDS.Handle_ChFiDS_Spine_FirstVertex(self, *args)


    def LastVertex(self, *args):
        """
        LastVertex(Handle_ChFiDS_Spine self) -> TopoDS_Vertex

        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _ChFiDS.Handle_ChFiDS_Spine_LastVertex(self, *args)


    def SetFirstTgt(self, *args):
        """
        SetFirstTgt(Handle_ChFiDS_Spine self, Standard_Real const W)

        :type W: float

        """
        return _ChFiDS.Handle_ChFiDS_Spine_SetFirstTgt(self, *args)


    def SetLastTgt(self, *args):
        """
        SetLastTgt(Handle_ChFiDS_Spine self, Standard_Real const W)

        :type W: float

        """
        return _ChFiDS.Handle_ChFiDS_Spine_SetLastTgt(self, *args)


    def HasFirstTgt(self, *args):
        """
        HasFirstTgt(Handle_ChFiDS_Spine self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_Spine_HasFirstTgt(self, *args)


    def HasLastTgt(self, *args):
        """
        HasLastTgt(Handle_ChFiDS_Spine self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_Spine_HasLastTgt(self, *args)


    def SetReference(self, *args):
        """
        SetReference(Handle_ChFiDS_Spine self, Standard_Real const W)
        SetReference(Handle_ChFiDS_Spine self, Standard_Integer const I)

        set  a  parameter  reference  for  the approx,  at the
        middle  of edge I.

        :type I: int

        """
        return _ChFiDS.Handle_ChFiDS_Spine_SetReference(self, *args)


    def Index(self, *args):
        """
        Index(Handle_ChFiDS_Spine self, Standard_Real const W, Standard_Boolean const Forward) -> Standard_Integer
        Index(Handle_ChFiDS_Spine self, TopoDS_Edge E) -> Standard_Integer

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_Spine_Index(self, *args)


    def UnsetReference(self, *args):
        """UnsetReference(Handle_ChFiDS_Spine self)"""
        return _ChFiDS.Handle_ChFiDS_Spine_UnsetReference(self, *args)


    def SetErrorStatus(self, *args):
        """
        SetErrorStatus(Handle_ChFiDS_Spine self, ChFiDS_ErrorStatus const state)

        :type state: OCC.wrapper.ChFiDS.ChFiDS_ErrorStatus

        """
        return _ChFiDS.Handle_ChFiDS_Spine_SetErrorStatus(self, *args)


    def ErrorStatus(self, *args):
        """
        ErrorStatus(Handle_ChFiDS_Spine self) -> ChFiDS_ErrorStatus

        :rtype: OCC.wrapper.ChFiDS.ChFiDS_ErrorStatus

        """
        return _ChFiDS.Handle_ChFiDS_Spine_ErrorStatus(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ChFiDS_Spine self) -> char const *

        :rtype: const char *

        """
        return _ChFiDS.Handle_ChFiDS_Spine_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ChFiDS.Handle_ChFiDS_Spine_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ChFiDS.Handle_ChFiDS_Spine_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_ChFiDS_Spine self)

        Memory deallocator for transient classes


        """
        return _ChFiDS.Handle_ChFiDS_Spine_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ChFiDS_Spine self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ChFiDS_Spine self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_Spine_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ChFiDS_Spine self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ChFiDS_Spine self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ChFiDS.Handle_ChFiDS_Spine_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ChFiDS_Spine self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ChFiDS.Handle_ChFiDS_Spine_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ChFiDS_Spine self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_Spine_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ChFiDS_Spine self)

        Increments the reference counter of this object


        """
        return _ChFiDS.Handle_ChFiDS_Spine_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ChFiDS_Spine self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ChFiDS.Handle_ChFiDS_Spine_DecrementRefCounter(self, *args)

Handle_ChFiDS_Spine_swigregister = _ChFiDS.Handle_ChFiDS_Spine_swigregister
Handle_ChFiDS_Spine_swigregister(Handle_ChFiDS_Spine)

def Handle_ChFiDS_Spine_DownCast(thing):
    return _ChFiDS.Handle_ChFiDS_Spine_DownCast(thing)
Handle_ChFiDS_Spine_DownCast = _ChFiDS.Handle_ChFiDS_Spine_DownCast




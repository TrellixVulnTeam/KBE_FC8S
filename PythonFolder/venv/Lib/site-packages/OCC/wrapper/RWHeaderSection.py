# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_RWHeaderSection')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_RWHeaderSection')
    _RWHeaderSection = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_RWHeaderSection', [dirname(__file__)])
        except ImportError:
            import _RWHeaderSection
            return _RWHeaderSection
        try:
            _mod = imp.load_module('_RWHeaderSection', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _RWHeaderSection = swig_import_helper()
    del swig_import_helper
else:
    import _RWHeaderSection
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _RWHeaderSection.delete_SwigPyIterator

    def value(self):
        return _RWHeaderSection.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _RWHeaderSection.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _RWHeaderSection.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _RWHeaderSection.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _RWHeaderSection.SwigPyIterator_equal(self, x)

    def copy(self):
        return _RWHeaderSection.SwigPyIterator_copy(self)

    def next(self):
        return _RWHeaderSection.SwigPyIterator_next(self)

    def __next__(self):
        return _RWHeaderSection.SwigPyIterator___next__(self)

    def previous(self):
        return _RWHeaderSection.SwigPyIterator_previous(self)

    def advance(self, n):
        return _RWHeaderSection.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _RWHeaderSection.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _RWHeaderSection.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _RWHeaderSection.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _RWHeaderSection.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _RWHeaderSection.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _RWHeaderSection.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _RWHeaderSection.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _RWHeaderSection.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_RWHeaderSection.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _RWHeaderSection.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _RWHeaderSection.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _RWHeaderSection.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _RWHeaderSection.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _RWHeaderSection.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _RWHeaderSection.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _RWHeaderSection.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_RWHeaderSection.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _RWHeaderSection.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _RWHeaderSection.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _RWHeaderSection.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _RWHeaderSection.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _RWHeaderSection.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _RWHeaderSection.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _RWHeaderSection.ptr_to_number(item)
ptr_to_number = _RWHeaderSection.ptr_to_number

def HashCode(*args):
    return _RWHeaderSection.HashCode(*args)
HashCode = _RWHeaderSection.HashCode

def ptr_equal(a, b):
    return _RWHeaderSection.ptr_equal(a, b)
ptr_equal = _RWHeaderSection.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import HeaderSection
else:
    import HeaderSection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Interface
else:
    import Interface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import MoniTool
else:
    import MoniTool
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import OSD
else:
    import OSD
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepData
else:
    import StepData
del _swig_python_version_info
class RWHeaderSection_RWFileSchema(object):
    """Read & Write Module for FileSchema"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(RWHeaderSection_RWFileSchema self) -> RWHeaderSection_RWFileSchema

        Read & Write Module for FileSchema
        """
        this = _RWHeaderSection.new_RWHeaderSection_RWFileSchema(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ReadStep(self, *args):
        """
        ReadStep(RWHeaderSection_RWFileSchema self, Handle_StepData_StepReaderData data, Standard_Integer const num, Handle_Interface_Check ach, Handle_HeaderSection_FileSchema ent)

        :type data: OCC.wrapper.StepData.Handle_StepData_StepReaderData
        :type num: int
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type ent: OCC.wrapper.HeaderSection.Handle_HeaderSection_FileSchema

        """
        return _RWHeaderSection.RWHeaderSection_RWFileSchema_ReadStep(self, *args)


    def WriteStep(self, *args):
        """
        WriteStep(RWHeaderSection_RWFileSchema self, StepData_StepWriter SW, Handle_HeaderSection_FileSchema ent)

        :type SW: OCC.wrapper.StepData.StepData_StepWriter
        :type ent: OCC.wrapper.HeaderSection.Handle_HeaderSection_FileSchema

        """
        return _RWHeaderSection.RWHeaderSection_RWFileSchema_WriteStep(self, *args)

    __swig_destroy__ = _RWHeaderSection.delete_RWHeaderSection_RWFileSchema
RWHeaderSection_RWFileSchema_swigregister = _RWHeaderSection.RWHeaderSection_RWFileSchema_swigregister
RWHeaderSection_RWFileSchema_swigregister(RWHeaderSection_RWFileSchema)

class RWHeaderSection_GeneralModule(StepData.StepData_GeneralModule):
    """
    Defines General Services for HeaderSection Entities
    (Share,Check,Copy; Trace already inherited)
    Depends (for case numbers) of Protocol from HeaderSection
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_RWHeaderSection_GeneralModule
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_RWHeaderSection_GeneralModule(self) 
            return h


    def __init__(self, *args):
        """
        __init__(RWHeaderSection_GeneralModule self) -> RWHeaderSection_GeneralModule

        Creates a GeneralModule


        """
        this = _RWHeaderSection.new_RWHeaderSection_GeneralModule(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def FillSharedCase(self, *args):
        """
        FillSharedCase(RWHeaderSection_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_EntityIterator iter)

        Specific filling of the list of Entities shared by an Entity
        <ent>, according to a Case Number <CN> (provided by HeaderSection
        Protocol).

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _RWHeaderSection.RWHeaderSection_GeneralModule_FillSharedCase(self, *args)


    def CheckCase(self, *args):
        """
        CheckCase(RWHeaderSection_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_ShareTool shares, Handle_Interface_Check ach)

        Specific Checking of an Entity <ent>

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type shares: OCC.wrapper.Interface.Interface_ShareTool
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _RWHeaderSection.RWHeaderSection_GeneralModule_CheckCase(self, *args)


    def CopyCase(self, *args):
        """
        CopyCase(RWHeaderSection_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient entfrom, Handle_Standard_Transient entto, Interface_CopyTool TC)

        Specific Copy ("Deep") from <entfrom> to <entto> (same type)
        by using a CopyTool which provides its working Map.
        Use method Transferred from CopyTool to work

        :type CN: int
        :type entfrom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TC: OCC.wrapper.Interface.Interface_CopyTool

        """
        return _RWHeaderSection.RWHeaderSection_GeneralModule_CopyCase(self, *args)


    def NewVoid(self, *args):
        """
        NewVoid(RWHeaderSection_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient ent) -> Standard_Boolean

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _RWHeaderSection.RWHeaderSection_GeneralModule_NewVoid(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _RWHeaderSection.RWHeaderSection_GeneralModule_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _RWHeaderSection.RWHeaderSection_GeneralModule_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _RWHeaderSection.RWHeaderSection_GeneralModule_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _RWHeaderSection.delete_RWHeaderSection_GeneralModule
RWHeaderSection_GeneralModule_swigregister = _RWHeaderSection.RWHeaderSection_GeneralModule_swigregister
RWHeaderSection_GeneralModule_swigregister(RWHeaderSection_GeneralModule)

def RWHeaderSection_GeneralModule_get_type_name(*args):
    """
    RWHeaderSection_GeneralModule_get_type_name() -> char const *

    :rtype: const char *

    """
    return _RWHeaderSection.RWHeaderSection_GeneralModule_get_type_name(*args)

def RWHeaderSection_GeneralModule_get_type_descriptor(*args):
    """
    RWHeaderSection_GeneralModule_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _RWHeaderSection.RWHeaderSection_GeneralModule_get_type_descriptor(*args)

class Handle_RWHeaderSection_GeneralModule(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_RWHeaderSection_GeneralModule self)

        Nullify the handle


        """
        return _RWHeaderSection.Handle_RWHeaderSection_GeneralModule_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_RWHeaderSection_GeneralModule self) -> bool

        Check for being null

        :rtype: bool

        """
        return _RWHeaderSection.Handle_RWHeaderSection_GeneralModule_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_RWHeaderSection_GeneralModule self, RWHeaderSection_GeneralModule thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _RWHeaderSection.Handle_RWHeaderSection_GeneralModule_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_RWHeaderSection_GeneralModule self, Handle_RWHeaderSection_GeneralModule theHandle) -> Handle_RWHeaderSection_GeneralModule
        assign(Handle_RWHeaderSection_GeneralModule self, RWHeaderSection_GeneralModule thePtr) -> Handle_RWHeaderSection_GeneralModule
        assign(Handle_RWHeaderSection_GeneralModule self, Handle_RWHeaderSection_GeneralModule theHandle) -> Handle_RWHeaderSection_GeneralModule

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _RWHeaderSection.Handle_RWHeaderSection_GeneralModule_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_RWHeaderSection_GeneralModule self) -> RWHeaderSection_GeneralModule

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _RWHeaderSection.Handle_RWHeaderSection_GeneralModule_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_RWHeaderSection_GeneralModule self) -> RWHeaderSection_GeneralModule

        Member access operator (note non-const)

        :rtype: T *

        """
        return _RWHeaderSection.Handle_RWHeaderSection_GeneralModule___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_RWHeaderSection_GeneralModule self) -> RWHeaderSection_GeneralModule

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _RWHeaderSection.Handle_RWHeaderSection_GeneralModule___ref__(self, *args)


    def __hash__(self):
        return _RWHeaderSection.Handle_RWHeaderSection_GeneralModule___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _RWHeaderSection.Handle_RWHeaderSection_GeneralModule___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _RWHeaderSection.new_Handle_RWHeaderSection_GeneralModule(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_RWHeaderSection.Handle_RWHeaderSection_GeneralModule_DownCast)
    __swig_destroy__ = _RWHeaderSection.delete_Handle_RWHeaderSection_GeneralModule

    def FillSharedCase(self, *args):
        """
        FillSharedCase(Handle_RWHeaderSection_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_EntityIterator iter)

        Specific filling of the list of Entities shared by an Entity
        <ent>, according to a Case Number <CN> (provided by HeaderSection
        Protocol).

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _RWHeaderSection.Handle_RWHeaderSection_GeneralModule_FillSharedCase(self, *args)


    def CheckCase(self, *args):
        """
        CheckCase(Handle_RWHeaderSection_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_ShareTool shares, Handle_Interface_Check ach)

        Specific Checking of an Entity <ent>

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type shares: OCC.wrapper.Interface.Interface_ShareTool
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check

        """
        return _RWHeaderSection.Handle_RWHeaderSection_GeneralModule_CheckCase(self, *args)


    def CopyCase(self, *args):
        """
        CopyCase(Handle_RWHeaderSection_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient entfrom, Handle_Standard_Transient entto, Interface_CopyTool TC)

        Specific Copy ("Deep") from <entfrom> to <entto> (same type)
        by using a CopyTool which provides its working Map.
        Use method Transferred from CopyTool to work

        :type CN: int
        :type entfrom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TC: OCC.wrapper.Interface.Interface_CopyTool

        """
        return _RWHeaderSection.Handle_RWHeaderSection_GeneralModule_CopyCase(self, *args)


    def NewVoid(self, *args):
        """
        NewVoid(Handle_RWHeaderSection_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient ent) -> Standard_Boolean

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _RWHeaderSection.Handle_RWHeaderSection_GeneralModule_NewVoid(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_RWHeaderSection_GeneralModule self) -> char const *

        :rtype: const char *

        """
        return _RWHeaderSection.Handle_RWHeaderSection_GeneralModule_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _RWHeaderSection.Handle_RWHeaderSection_GeneralModule_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _RWHeaderSection.Handle_RWHeaderSection_GeneralModule_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FillShared(self, *args):
        """
        FillShared(Handle_RWHeaderSection_GeneralModule self, Handle_Interface_InterfaceModel model, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_EntityIterator iter)

        Specific filling of the list of Entities shared by an Entity
        <ent>, according a Case Number <CN> (formerly computed by
        CaseNum), considered in the context of a Model <model>
        Default calls FillSharedCase (i.e., ignores the model)
        Can be redefined to use the model for working

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _RWHeaderSection.Handle_RWHeaderSection_GeneralModule_FillShared(self, *args)


    def Share(self, *args):
        """
        Share(Handle_RWHeaderSection_GeneralModule self, Interface_EntityIterator iter, Handle_Standard_Transient shared)

        Adds an Entity to a Shared List (uses GetOneItem on <iter>)

        :type iter: OCC.wrapper.Interface.Interface_EntityIterator
        :type shared: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _RWHeaderSection.Handle_RWHeaderSection_GeneralModule_Share(self, *args)


    def ListImplied(self, *args):
        """
        ListImplied(Handle_RWHeaderSection_GeneralModule self, Handle_Interface_InterfaceModel model, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_EntityIterator iter)

        List the Implied References of <ent> considered in the context
        of a Model <model> : i.e. the Entities which are Referenced
        while not considered as Shared (not copied if <ent> is,
        references not renewed by CopyCase but by ImpliedCase, only
        if referenced Entities have been Copied too)
        FillShared + ListImplied give the complete list of References
        Default calls ListImpliedCase (i.e. ignores the model)
        Can be redefined to use the model for working

        :type model: OCC.wrapper.Interface.Handle_Interface_InterfaceModel
        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _RWHeaderSection.Handle_RWHeaderSection_GeneralModule_ListImplied(self, *args)


    def ListImpliedCase(self, *args):
        """
        ListImpliedCase(Handle_RWHeaderSection_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_EntityIterator iter)

        List the Implied References of <ent> (see above)
        are Referenced while not considered as Shared (not copied if
        <ent> is, references not renewed by CopyCase but by
        ImpliedCase, only if referenced Entities have been Copied too)
        FillSharedCase + ListImpliedCase give the complete list of
        Referenced Entities
        The provided default method does nothing (Implied References
        are specific of a little amount of Entity Classes).

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type iter: OCC.wrapper.Interface.Interface_EntityIterator

        """
        return _RWHeaderSection.Handle_RWHeaderSection_GeneralModule_ListImpliedCase(self, *args)


    def CanCopy(self, *args):
        """
        CanCopy(Handle_RWHeaderSection_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient ent) -> Standard_Boolean

        Specific answer to the question "is Copy properly implemented"
        Remark that it should be in phase with the implementation of
        NewVoid+CopyCase/NewCopyCase
        Default returns always False, can be redefined

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _RWHeaderSection.Handle_RWHeaderSection_GeneralModule_CanCopy(self, *args)


    def Dispatch(self, *args):
        """
        Dispatch(Handle_RWHeaderSection_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient entfrom, Handle_Standard_Transient entto, Interface_CopyTool TC) -> Standard_Boolean

        Dispatches an entity
        Returns True if it works by copy, False if it just duplicates
        the starting Handle

        Dispatching means producing a new entity, image of the
        starting one, in order to be put into a new Model, this Model
        being itself the result of a dispatch from an original Model

        According to the cases, dispatch can either
        * just return <entto> as equating <entfrom>
        -> the new model designates the starting entity : it is
        lighter, but the dispatched entity being shared might not be
        modified for dispatch
        * copy <entfrom> to <entto>
        by calling NewVoid+CopyCase (two steps) or NewCopiedCase (1)
        -> the dispatched entity is a COPY, hence it can be modified

        The provided default just duplicates the handle without
        copying, then returns False. Can be redefined

        :type CN: int
        :type entfrom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TC: OCC.wrapper.Interface.Interface_CopyTool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _RWHeaderSection.Handle_RWHeaderSection_GeneralModule_Dispatch(self, *args)


    def NewCopiedCase(self, *args):
        """
        NewCopiedCase(Handle_RWHeaderSection_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient entfrom, Handle_Standard_Transient entto, Interface_CopyTool TC) -> Standard_Boolean

        Specific operator (create+copy) defaulted to do nothing.
        It can be redefined : When it is not possible to work in two
        steps (NewVoid then CopyCase). This can occur when there is
        no default constructor : hence the result <entto> must be
        created with an effective definition.
        Remark : if NewCopiedCase is defined, CopyCase has nothing to do
        Returns True if it has produced something, false else

        :type CN: int
        :type entfrom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TC: OCC.wrapper.Interface.Interface_CopyTool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _RWHeaderSection.Handle_RWHeaderSection_GeneralModule_NewCopiedCase(self, *args)


    def RenewImpliedCase(self, *args):
        """
        RenewImpliedCase(Handle_RWHeaderSection_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient entfrom, Handle_Standard_Transient entto, Interface_CopyTool TC)

        Specific Copying of Implied References
        A Default is provided which does nothing (must current case !)
        Already copied references (by CopyFrom) must remain unchanged
        Use method Search from CopyTool to work

        :type CN: int
        :type entfrom: OCC.wrapper.Standard.Handle_Standard_Transient
        :type entto: OCC.wrapper.Standard.Handle_Standard_Transient
        :type TC: OCC.wrapper.Interface.Interface_CopyTool

        """
        return _RWHeaderSection.Handle_RWHeaderSection_GeneralModule_RenewImpliedCase(self, *args)


    def WhenDeleteCase(self, *args):
        """
        WhenDeleteCase(Handle_RWHeaderSection_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient ent, Standard_Boolean const dispatched)

        Prepares an entity to be deleted. What does it mean :
        Basically, any class of entity may define its own destructor
        By default, it does nothing but calling destructors on fields
        With the Memory Manager, it is useless to call destructor,
        it is done automatically when the Handle is nullified(cleared)
        BUT this is ineffective in looping structures (whatever these
        are "Implied" references or not).

        THUS : if no loop may appear in definitions, a class which
        inherits from TShared is correctly managed by automatic way
        BUT if there can be loops (or simply back pointers), they must
        be broken, for instance by clearing fields of one of the nodes
        The default does nothing, to be redefined if a loop can occur
        (Implied generally requires WhenDelete, but other cases can
        occur)

        Warning : <dispatched> tells if the entity to be deleted has been
        produced by Dispatch or not. Hence WhenDelete must be in
        coherence with Dispatch
        Dispatch can either copy or not.
        If it copies the entity, this one should be deleted
        If it doesnt (i.e. duplicates the handle) nothing to do

        If <dispatch> is False, normal deletion is to be performed

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type dispatched: bool

        """
        return _RWHeaderSection.Handle_RWHeaderSection_GeneralModule_WhenDeleteCase(self, *args)


    def CategoryNumber(self, *args):
        """
        CategoryNumber(Handle_RWHeaderSection_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_ShareTool shares) -> Standard_Integer

        Returns a category number which characterizes an entity
        Category Numbers are managed by the class Category
        <shares> can be used to evaluate this number in the context
        Default returns 0 which means "unspecified"

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type shares: OCC.wrapper.Interface.Interface_ShareTool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _RWHeaderSection.Handle_RWHeaderSection_GeneralModule_CategoryNumber(self, *args)


    def Name(self, *args):
        """
        Name(Handle_RWHeaderSection_GeneralModule self, Standard_Integer const CN, Handle_Standard_Transient ent, Interface_ShareTool shares) -> Handle_TCollection_HAsciiString

        Determines if an entity brings a Name (or widerly, if a Name
        can be attached to it, through the ShareTool
        By default, returns a Null Handle (no name can be produced)
        Can be redefined

        Warning : While this string may be edited on the spot, if it is a read
        field, the returned value must be copied before.

        :type CN: int
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :type shares: OCC.wrapper.Interface.Interface_ShareTool
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _RWHeaderSection.Handle_RWHeaderSection_GeneralModule_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_RWHeaderSection_GeneralModule self)

        Memory deallocator for transient classes


        """
        return _RWHeaderSection.Handle_RWHeaderSection_GeneralModule_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_RWHeaderSection_GeneralModule self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_RWHeaderSection_GeneralModule self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _RWHeaderSection.Handle_RWHeaderSection_GeneralModule_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_RWHeaderSection_GeneralModule self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_RWHeaderSection_GeneralModule self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _RWHeaderSection.Handle_RWHeaderSection_GeneralModule_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_RWHeaderSection_GeneralModule self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _RWHeaderSection.Handle_RWHeaderSection_GeneralModule_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_RWHeaderSection_GeneralModule self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _RWHeaderSection.Handle_RWHeaderSection_GeneralModule_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_RWHeaderSection_GeneralModule self)

        Increments the reference counter of this object


        """
        return _RWHeaderSection.Handle_RWHeaderSection_GeneralModule_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_RWHeaderSection_GeneralModule self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _RWHeaderSection.Handle_RWHeaderSection_GeneralModule_DecrementRefCounter(self, *args)

Handle_RWHeaderSection_GeneralModule_swigregister = _RWHeaderSection.Handle_RWHeaderSection_GeneralModule_swigregister
Handle_RWHeaderSection_GeneralModule_swigregister(Handle_RWHeaderSection_GeneralModule)

def Handle_RWHeaderSection_GeneralModule_DownCast(thing):
    return _RWHeaderSection.Handle_RWHeaderSection_GeneralModule_DownCast(thing)
Handle_RWHeaderSection_GeneralModule_DownCast = _RWHeaderSection.Handle_RWHeaderSection_GeneralModule_DownCast

class RWHeaderSection_(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Init(*args):
        """
        Init()

        enforced the initialisation of the  libraries


        """
        return _RWHeaderSection.RWHeaderSection__Init(*args)

    Init = staticmethod(Init)

    def __init__(self):
        this = _RWHeaderSection.new_RWHeaderSection_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _RWHeaderSection.delete_RWHeaderSection_
RWHeaderSection__swigregister = _RWHeaderSection.RWHeaderSection__swigregister
RWHeaderSection__swigregister(RWHeaderSection_)

def RWHeaderSection__Init(*args):
    """
    RWHeaderSection__Init()

    enforced the initialisation of the  libraries


    """
    return _RWHeaderSection.RWHeaderSection__Init(*args)

class RWHeaderSection_RWFileDescription(object):
    """Read & Write Module for FileDescription"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(RWHeaderSection_RWFileDescription self) -> RWHeaderSection_RWFileDescription

        Read & Write Module for FileDescription
        """
        this = _RWHeaderSection.new_RWHeaderSection_RWFileDescription(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ReadStep(self, *args):
        """
        ReadStep(RWHeaderSection_RWFileDescription self, Handle_StepData_StepReaderData data, Standard_Integer const num, Handle_Interface_Check ach, Handle_HeaderSection_FileDescription ent)

        :type data: OCC.wrapper.StepData.Handle_StepData_StepReaderData
        :type num: int
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type ent: OCC.wrapper.HeaderSection.Handle_HeaderSection_FileDescription

        """
        return _RWHeaderSection.RWHeaderSection_RWFileDescription_ReadStep(self, *args)


    def WriteStep(self, *args):
        """
        WriteStep(RWHeaderSection_RWFileDescription self, StepData_StepWriter SW, Handle_HeaderSection_FileDescription ent)

        :type SW: OCC.wrapper.StepData.StepData_StepWriter
        :type ent: OCC.wrapper.HeaderSection.Handle_HeaderSection_FileDescription

        """
        return _RWHeaderSection.RWHeaderSection_RWFileDescription_WriteStep(self, *args)

    __swig_destroy__ = _RWHeaderSection.delete_RWHeaderSection_RWFileDescription
RWHeaderSection_RWFileDescription_swigregister = _RWHeaderSection.RWHeaderSection_RWFileDescription_swigregister
RWHeaderSection_RWFileDescription_swigregister(RWHeaderSection_RWFileDescription)

class RWHeaderSection_RWFileName(object):
    """Read & Write Module for FileName"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(RWHeaderSection_RWFileName self) -> RWHeaderSection_RWFileName

        Read & Write Module for FileName
        """
        this = _RWHeaderSection.new_RWHeaderSection_RWFileName(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ReadStep(self, *args):
        """
        ReadStep(RWHeaderSection_RWFileName self, Handle_StepData_StepReaderData data, Standard_Integer const num, Handle_Interface_Check ach, Handle_HeaderSection_FileName ent)

        :type data: OCC.wrapper.StepData.Handle_StepData_StepReaderData
        :type num: int
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type ent: OCC.wrapper.HeaderSection.Handle_HeaderSection_FileName

        """
        return _RWHeaderSection.RWHeaderSection_RWFileName_ReadStep(self, *args)


    def WriteStep(self, *args):
        """
        WriteStep(RWHeaderSection_RWFileName self, StepData_StepWriter SW, Handle_HeaderSection_FileName ent)

        :type SW: OCC.wrapper.StepData.StepData_StepWriter
        :type ent: OCC.wrapper.HeaderSection.Handle_HeaderSection_FileName

        """
        return _RWHeaderSection.RWHeaderSection_RWFileName_WriteStep(self, *args)

    __swig_destroy__ = _RWHeaderSection.delete_RWHeaderSection_RWFileName
RWHeaderSection_RWFileName_swigregister = _RWHeaderSection.RWHeaderSection_RWFileName_swigregister
RWHeaderSection_RWFileName_swigregister(RWHeaderSection_RWFileName)

class RWHeaderSection_ReadWriteModule(StepData.StepData_ReadWriteModule):
    """General module to read and write HeaderSection entities"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_RWHeaderSection_ReadWriteModule
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_RWHeaderSection_ReadWriteModule(self) 
            return h


    def __init__(self, *args):
        """
        __init__(RWHeaderSection_ReadWriteModule self) -> RWHeaderSection_ReadWriteModule

        General module to read and write HeaderSection entities
        """
        this = _RWHeaderSection.new_RWHeaderSection_ReadWriteModule(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def CaseStep(self, *args):
        """
        CaseStep(RWHeaderSection_ReadWriteModule self, TCollection_AsciiString atype) -> Standard_Integer
        CaseStep(RWHeaderSection_ReadWriteModule self, NCollection_Sequence_TCollection_AsciiString types) -> Standard_Integer

        associates a positive Case Number to each type of HeaderSection Complex entity,
        given as a String defined in the EXPRESS form

        :type types: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _RWHeaderSection.RWHeaderSection_ReadWriteModule_CaseStep(self, *args)


    def IsComplex(self, *args):
        """
        IsComplex(RWHeaderSection_ReadWriteModule self, Standard_Integer const CN) -> Standard_Boolean

        returns True if the Case Number corresponds to a Complex Type

        :type CN: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _RWHeaderSection.RWHeaderSection_ReadWriteModule_IsComplex(self, *args)


    def StepType(self, *args):
        """
        returns a StepType (defined in EXPRESS form which belongs to a
        Type of Entity, identified by its CaseNumber determined by Protocol

        :type CN: int
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _RWHeaderSection.RWHeaderSection_ReadWriteModule_StepType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ReadStep(self, *args):
        """
        ReadStep(RWHeaderSection_ReadWriteModule self, Standard_Integer const CN, Handle_StepData_StepReaderData data, Standard_Integer const num, Handle_Interface_Check ach, Handle_Standard_Transient ent)

        :type CN: int
        :type data: OCC.wrapper.StepData.Handle_StepData_StepReaderData
        :type num: int
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _RWHeaderSection.RWHeaderSection_ReadWriteModule_ReadStep(self, *args)


    def WriteStep(self, *args):
        """
        WriteStep(RWHeaderSection_ReadWriteModule self, Standard_Integer const CN, StepData_StepWriter SW, Handle_Standard_Transient ent)

        :type CN: int
        :type SW: OCC.wrapper.StepData.StepData_StepWriter
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _RWHeaderSection.RWHeaderSection_ReadWriteModule_WriteStep(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _RWHeaderSection.RWHeaderSection_ReadWriteModule_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _RWHeaderSection.RWHeaderSection_ReadWriteModule_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _RWHeaderSection.RWHeaderSection_ReadWriteModule_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _RWHeaderSection.delete_RWHeaderSection_ReadWriteModule
RWHeaderSection_ReadWriteModule_swigregister = _RWHeaderSection.RWHeaderSection_ReadWriteModule_swigregister
RWHeaderSection_ReadWriteModule_swigregister(RWHeaderSection_ReadWriteModule)

def RWHeaderSection_ReadWriteModule_get_type_name(*args):
    """
    RWHeaderSection_ReadWriteModule_get_type_name() -> char const *

    :rtype: const char *

    """
    return _RWHeaderSection.RWHeaderSection_ReadWriteModule_get_type_name(*args)

def RWHeaderSection_ReadWriteModule_get_type_descriptor(*args):
    """
    RWHeaderSection_ReadWriteModule_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _RWHeaderSection.RWHeaderSection_ReadWriteModule_get_type_descriptor(*args)

class Handle_RWHeaderSection_ReadWriteModule(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_RWHeaderSection_ReadWriteModule self)

        Nullify the handle


        """
        return _RWHeaderSection.Handle_RWHeaderSection_ReadWriteModule_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_RWHeaderSection_ReadWriteModule self) -> bool

        Check for being null

        :rtype: bool

        """
        return _RWHeaderSection.Handle_RWHeaderSection_ReadWriteModule_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_RWHeaderSection_ReadWriteModule self, RWHeaderSection_ReadWriteModule thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _RWHeaderSection.Handle_RWHeaderSection_ReadWriteModule_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_RWHeaderSection_ReadWriteModule self, Handle_RWHeaderSection_ReadWriteModule theHandle) -> Handle_RWHeaderSection_ReadWriteModule
        assign(Handle_RWHeaderSection_ReadWriteModule self, RWHeaderSection_ReadWriteModule thePtr) -> Handle_RWHeaderSection_ReadWriteModule
        assign(Handle_RWHeaderSection_ReadWriteModule self, Handle_RWHeaderSection_ReadWriteModule theHandle) -> Handle_RWHeaderSection_ReadWriteModule

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _RWHeaderSection.Handle_RWHeaderSection_ReadWriteModule_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_RWHeaderSection_ReadWriteModule self) -> RWHeaderSection_ReadWriteModule

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _RWHeaderSection.Handle_RWHeaderSection_ReadWriteModule_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_RWHeaderSection_ReadWriteModule self) -> RWHeaderSection_ReadWriteModule

        Member access operator (note non-const)

        :rtype: T *

        """
        return _RWHeaderSection.Handle_RWHeaderSection_ReadWriteModule___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_RWHeaderSection_ReadWriteModule self) -> RWHeaderSection_ReadWriteModule

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _RWHeaderSection.Handle_RWHeaderSection_ReadWriteModule___ref__(self, *args)


    def __hash__(self):
        return _RWHeaderSection.Handle_RWHeaderSection_ReadWriteModule___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _RWHeaderSection.Handle_RWHeaderSection_ReadWriteModule___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _RWHeaderSection.new_Handle_RWHeaderSection_ReadWriteModule(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_RWHeaderSection.Handle_RWHeaderSection_ReadWriteModule_DownCast)
    __swig_destroy__ = _RWHeaderSection.delete_Handle_RWHeaderSection_ReadWriteModule

    def CaseStep(self, *args):
        """
        CaseStep(Handle_RWHeaderSection_ReadWriteModule self, TCollection_AsciiString atype) -> Standard_Integer
        CaseStep(Handle_RWHeaderSection_ReadWriteModule self, NCollection_Sequence_TCollection_AsciiString types) -> Standard_Integer

        associates a positive Case Number to each type of HeaderSection Complex entity,
        given as a String defined in the EXPRESS form

        :type types: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _RWHeaderSection.Handle_RWHeaderSection_ReadWriteModule_CaseStep(self, *args)


    def IsComplex(self, *args):
        """
        IsComplex(Handle_RWHeaderSection_ReadWriteModule self, Standard_Integer const CN) -> Standard_Boolean

        returns True if the Case Number corresponds to a Complex Type

        :type CN: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _RWHeaderSection.Handle_RWHeaderSection_ReadWriteModule_IsComplex(self, *args)


    def StepType(self, *args):
        """
        returns a StepType (defined in EXPRESS form which belongs to a
        Type of Entity, identified by its CaseNumber determined by Protocol

        :type CN: int
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _RWHeaderSection.Handle_RWHeaderSection_ReadWriteModule_StepType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ReadStep(self, *args):
        """
        ReadStep(Handle_RWHeaderSection_ReadWriteModule self, Standard_Integer const CN, Handle_StepData_StepReaderData data, Standard_Integer const num, Handle_Interface_Check ach, Handle_Standard_Transient ent)

        :type CN: int
        :type data: OCC.wrapper.StepData.Handle_StepData_StepReaderData
        :type num: int
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _RWHeaderSection.Handle_RWHeaderSection_ReadWriteModule_ReadStep(self, *args)


    def WriteStep(self, *args):
        """
        WriteStep(Handle_RWHeaderSection_ReadWriteModule self, Standard_Integer const CN, StepData_StepWriter SW, Handle_Standard_Transient ent)

        :type CN: int
        :type SW: OCC.wrapper.StepData.StepData_StepWriter
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _RWHeaderSection.Handle_RWHeaderSection_ReadWriteModule_WriteStep(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_RWHeaderSection_ReadWriteModule self) -> char const *

        :rtype: const char *

        """
        return _RWHeaderSection.Handle_RWHeaderSection_ReadWriteModule_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _RWHeaderSection.Handle_RWHeaderSection_ReadWriteModule_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _RWHeaderSection.Handle_RWHeaderSection_ReadWriteModule_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CaseNum(self, *args):
        """
        CaseNum(Handle_RWHeaderSection_ReadWriteModule self, Handle_Interface_FileReaderData data, Standard_Integer const num) -> Standard_Integer

        Translate the Type of record <num> in <data> to a positive
        Case Number, or 0 if failed.
        Works with a StepReaderData, in which the Type of an Entity
        is defined as a String : Reads the RecordType <num> then calls
        CaseNum (this type)
        Warning : The methods CaseStep, StepType and Recognize,
        must be in phase (triplets CaseNum-StepType-Type of Object)

        :type data: OCC.wrapper.Interface.Handle_Interface_FileReaderData
        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _RWHeaderSection.Handle_RWHeaderSection_ReadWriteModule_CaseNum(self, *args)


    def ShortType(self, *args):
        """
        ShortType(Handle_RWHeaderSection_ReadWriteModule self, Standard_Integer const CN) -> TCollection_AsciiString

        Function specific to STEP. Some STEP Types have a short form
        This method can be redefined to fill it
        By default, returns an empty string, which is then interpreted
        to take normal form from StepType

        :type CN: int
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _RWHeaderSection.Handle_RWHeaderSection_ReadWriteModule_ShortType(self, *args)


    def ComplexType(self, *args):
        """
        ComplexType(Handle_RWHeaderSection_ReadWriteModule self, Standard_Integer const CN, NCollection_Sequence_TCollection_AsciiString types) -> Standard_Boolean

        Function specific to STEP, which delivers the list of types
        which corresponds to a complex type. If <CN> is not for a
        complex type, this method returns False. Else it returns True
        and fills the list in alphabetic order.
        The default returns False. To be redefined as required.

        :type CN: int
        :type types: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _RWHeaderSection.Handle_RWHeaderSection_ReadWriteModule_ComplexType(self, *args)


    def Read(self, *args):
        """
        Read(Handle_RWHeaderSection_ReadWriteModule self, Standard_Integer const CN, Handle_Interface_FileReaderData data, Standard_Integer const num, Handle_Interface_Check ach, Handle_Standard_Transient ent)

        General Read Function, calls ReadStep

        :type CN: int
        :type data: OCC.wrapper.Interface.Handle_Interface_FileReaderData
        :type num: int
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _RWHeaderSection.Handle_RWHeaderSection_ReadWriteModule_Read(self, *args)


    def NewRead(self, *args):
        """
        NewRead(Handle_RWHeaderSection_ReadWriteModule self, Standard_Integer const casenum, Handle_Interface_FileReaderData data, Standard_Integer const num, Handle_Interface_Check ach, Handle_Standard_Transient ent) -> Standard_Boolean

        Specific operator (create+read) defaulted to do nothing.
        It can be redefined when it is not possible to work in two
        steps (NewVoid then Read). This occurs when no default
        constructor is defined : hence the result <ent> must be
        created with an effective definition from the reader.
        Remark : if NewRead is defined, Copy has nothing to do.

        Returns True if it has produced something, false else.
        If nothing was produced, <ach> should be filled : it will be
        treated as "Unrecognized case" by reader tool.

        :type casenum: int
        :type data: OCC.wrapper.Interface.Handle_Interface_FileReaderData
        :type num: int
        :type ach: OCC.wrapper.Interface.Handle_Interface_Check
        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _RWHeaderSection.Handle_RWHeaderSection_ReadWriteModule_NewRead(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_RWHeaderSection_ReadWriteModule self)

        Memory deallocator for transient classes


        """
        return _RWHeaderSection.Handle_RWHeaderSection_ReadWriteModule_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_RWHeaderSection_ReadWriteModule self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_RWHeaderSection_ReadWriteModule self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _RWHeaderSection.Handle_RWHeaderSection_ReadWriteModule_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_RWHeaderSection_ReadWriteModule self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_RWHeaderSection_ReadWriteModule self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _RWHeaderSection.Handle_RWHeaderSection_ReadWriteModule_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_RWHeaderSection_ReadWriteModule self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _RWHeaderSection.Handle_RWHeaderSection_ReadWriteModule_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_RWHeaderSection_ReadWriteModule self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _RWHeaderSection.Handle_RWHeaderSection_ReadWriteModule_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_RWHeaderSection_ReadWriteModule self)

        Increments the reference counter of this object


        """
        return _RWHeaderSection.Handle_RWHeaderSection_ReadWriteModule_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_RWHeaderSection_ReadWriteModule self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _RWHeaderSection.Handle_RWHeaderSection_ReadWriteModule_DecrementRefCounter(self, *args)

Handle_RWHeaderSection_ReadWriteModule_swigregister = _RWHeaderSection.Handle_RWHeaderSection_ReadWriteModule_swigregister
Handle_RWHeaderSection_ReadWriteModule_swigregister(Handle_RWHeaderSection_ReadWriteModule)

def Handle_RWHeaderSection_ReadWriteModule_DownCast(thing):
    return _RWHeaderSection.Handle_RWHeaderSection_ReadWriteModule_DownCast(thing)
Handle_RWHeaderSection_ReadWriteModule_DownCast = _RWHeaderSection.Handle_RWHeaderSection_ReadWriteModule_DownCast




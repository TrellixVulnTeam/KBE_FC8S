# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_GccAna')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_GccAna')
    _GccAna = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_GccAna', [dirname(__file__)])
        except ImportError:
            import _GccAna
            return _GccAna
        try:
            _mod = imp.load_module('_GccAna', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _GccAna = swig_import_helper()
    del swig_import_helper
else:
    import _GccAna
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _GccAna.delete_SwigPyIterator

    def value(self):
        return _GccAna.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _GccAna.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _GccAna.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _GccAna.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _GccAna.SwigPyIterator_equal(self, x)

    def copy(self):
        return _GccAna.SwigPyIterator_copy(self)

    def next(self):
        return _GccAna.SwigPyIterator_next(self)

    def __next__(self):
        return _GccAna.SwigPyIterator___next__(self)

    def previous(self):
        return _GccAna.SwigPyIterator_previous(self)

    def advance(self, n):
        return _GccAna.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _GccAna.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _GccAna.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _GccAna.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _GccAna.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _GccAna.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _GccAna.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _GccAna.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _GccAna.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_GccAna.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _GccAna.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _GccAna.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GccAna.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _GccAna.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _GccAna.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _GccAna.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _GccAna.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_GccAna.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _GccAna.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _GccAna.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GccAna.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _GccAna.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _GccAna.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _GccAna.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _GccAna.ptr_to_number(item)
ptr_to_number = _GccAna.ptr_to_number

def HashCode(*args):
    return _GccAna.HashCode(*args)
HashCode = _GccAna.HashCode

def ptr_equal(a, b):
    return _GccAna.ptr_equal(a, b)
ptr_equal = _GccAna.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GccInt
else:
    import GccInt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GccEnt
else:
    import GccEnt
del _swig_python_version_info
class GccAna_NoSolution(Standard.Standard_Failure):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_GccAna_NoSolution
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_GccAna_NoSolution(self) 
            return h


    def __init__(self, *args):
        """
        __init__(GccAna_NoSolution self) -> GccAna_NoSolution
        __init__(GccAna_NoSolution self, Standard_CString const theMessage) -> GccAna_NoSolution

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _GccAna.new_GccAna_NoSolution(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_GccAna_NoSolution

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.GccAna.Handle_GccAna_NoSolution

        """
        return _GccAna.GccAna_NoSolution_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _GccAna.GccAna_NoSolution_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _GccAna.GccAna_NoSolution_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GccAna.GccAna_NoSolution_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GccAna.delete_GccAna_NoSolution
GccAna_NoSolution_swigregister = _GccAna.GccAna_NoSolution_swigregister
GccAna_NoSolution_swigregister(GccAna_NoSolution)

def GccAna_NoSolution_NewInstance(*args):
    """
    GccAna_NoSolution_NewInstance(Standard_CString const theMessage) -> Handle_GccAna_NoSolution

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.GccAna.Handle_GccAna_NoSolution

    """
    return _GccAna.GccAna_NoSolution_NewInstance(*args)

def GccAna_NoSolution_get_type_name(*args):
    """
    GccAna_NoSolution_get_type_name() -> char const *

    :rtype: const char *

    """
    return _GccAna.GccAna_NoSolution_get_type_name(*args)

def GccAna_NoSolution_get_type_descriptor(*args):
    """
    GccAna_NoSolution_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _GccAna.GccAna_NoSolution_get_type_descriptor(*args)

class GccAna_Circ2dTanOnRad(object):
    """
    This class implements the algorithms used to
    create a 2d circle tangent to a 2d entity,
    centered on a curv and with a given radius.
    The arguments of all construction methods are :
    - The qualified element for the tangency constrains
    (QualifiedCirc, QualifiedLin, Points).
    - The Center element (circle, line).
    - A real Tolerance.
    Tolerance is only used in the limits cases.
    For example :
    We want to create a circle tangent to an OutsideCirc C1
    centered on a line OnLine with a radius Radius and with
    a tolerance Tolerance.
    If we did not use Tolerance it is impossible to
    find a solution in the the following case : OnLine is
    outside C1. There is no intersection point between C1
    and OnLine. The distance between the line and the
    circle is greater than Radius.
    With Tolerance we will give a solution if the
    distance between C1 and OnLine is lower than or
    equal Tolerance.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GccAna_Circ2dTanOnRad self, GccEnt_QualifiedCirc Qualified1, gp_Lin2d OnLine, Standard_Real const Radius, Standard_Real const Tolerance) -> GccAna_Circ2dTanOnRad
        __init__(GccAna_Circ2dTanOnRad self, GccEnt_QualifiedLin Qualified1, gp_Lin2d OnLine, Standard_Real const Radius, Standard_Real const Tolerance) -> GccAna_Circ2dTanOnRad
        __init__(GccAna_Circ2dTanOnRad self, gp_Pnt2d Point1, gp_Lin2d OnLine, Standard_Real const Radius, Standard_Real const Tolerance) -> GccAna_Circ2dTanOnRad
        __init__(GccAna_Circ2dTanOnRad self, GccEnt_QualifiedCirc Qualified1, gp_Circ2d OnCirc, Standard_Real const Radius, Standard_Real const Tolerance) -> GccAna_Circ2dTanOnRad
        __init__(GccAna_Circ2dTanOnRad self, GccEnt_QualifiedLin Qualified1, gp_Circ2d OnCirc, Standard_Real const Radius, Standard_Real const Tolerance) -> GccAna_Circ2dTanOnRad
        __init__(GccAna_Circ2dTanOnRad self, gp_Pnt2d Point1, gp_Circ2d OnCirc, Standard_Real const Radius, Standard_Real const Tolerance) -> GccAna_Circ2dTanOnRad

        This methods implements the algorithms used to create
        2d Circles passing through a 2d Point and centered on a
        2d Line with a given radius.
        Tolerance is used to find solution in every limit cases.
        raises NegativeValue in case of NegativeRadius.

        :type Point1: OCC.wrapper.gp.gp_Pnt2d
        :type OnCirc: OCC.wrapper.gp.gp_Circ2d
        :type Radius: float
        :type Tolerance: float

        """
        this = _GccAna.new_GccAna_Circ2dTanOnRad(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(GccAna_Circ2dTanOnRad self) -> Standard_Boolean

        Returns true if the construction algorithm does not fail
        (even if it finds no solution).
        Note: IsDone protects against a failure arising from a
        more internal intersection algorithm, which has
        reached its numeric limits.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GccAna.GccAna_Circ2dTanOnRad_IsDone(self, *args)


    def NbSolutions(self, *args):
        """
        NbSolutions(GccAna_Circ2dTanOnRad self) -> Standard_Integer

        This method returns the number of circles, representing solutions.
        Raises NotDone if the construction algorithm didn't succeed.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GccAna.GccAna_Circ2dTanOnRad_NbSolutions(self, *args)


    def ThisSolution(self, *args):
        """
        ThisSolution(GccAna_Circ2dTanOnRad self, Standard_Integer const Index) -> gp_Circ2d

        Returns the solution number Index and raises OutOfRange
        exception if Index is greater than the number of solutions.
        Be careful: the Index is only a way to get all the
        solutions, but is not associated to theses outside the
        context of the algorithm-object.
        Raises NotDone if the construction algorithm  didn't succeed.
        It raises OutOfRange if Index is greater than the
        number of solutions

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _GccAna.GccAna_Circ2dTanOnRad_ThisSolution(self, *args)


    def WhichQualifier(self, *args):
        """
        WhichQualifier(GccAna_Circ2dTanOnRad self, Standard_Integer const Index)

        Returns the qualifier Qualif1 of the tangency argument
        for the solution of index Index computed by this algorithm.
        The returned qualifier is:
        -   that specified at the start of construction when the
        solutions are defined as enclosed, enclosing or
        outside with respect to the argument, or
        -   that computed during construction (i.e. enclosed,
        enclosing or outside) when the solutions are defined
        as unqualified with respect to the argument, or
        -   GccEnt_noqualifier if the tangency argument is a point.
        Exceptions
        Standard_OutOfRange if Index is less than zero or
        greater than the number of solutions computed by this algorithm.
        StdFail_NotDone if the construction fails.

        :type Index: int
        :type Qualif1: OCC.wrapper.GccEnt.GccEnt_Position

        """
        return _GccAna.GccAna_Circ2dTanOnRad_WhichQualifier(self, *args)


    def Tangency1(self, *args):
        """
        Tangency1(GccAna_Circ2dTanOnRad self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns informations about the tangency point between the
        result number Index and the first argument.
        ParSol is the intrinsic parameter of the point on the
        solution curv.
        ParArg is the intrinsic parameter of the point on the
        argument curv.
        PntSol is the tangency point on the solution curv.
        PntArg is the tangency point on the argument curv.
        Raises NotDone if the construction algorithm didn't succeed.
        It raises OutOfRange if Index is greater than the
        number of solutions.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _GccAna.GccAna_Circ2dTanOnRad_Tangency1(self, *args)


    def CenterOn3(self, *args):
        """
        CenterOn3(GccAna_Circ2dTanOnRad self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns informations about the center (on the curv)
        of the result.
        ParArg is the intrinsic parameter of the point on
        the argument curv.
        PntSol is the center point of the solution curv.
        Raises NotDone if the construction algorithm  didn't succeed.
        It raises OutOfRange if Index is greater than the
        number of solutions.

        :type Index: int
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _GccAna.GccAna_Circ2dTanOnRad_CenterOn3(self, *args)


    def IsTheSame1(self, *args):
        """
        IsTheSame1(GccAna_Circ2dTanOnRad self, Standard_Integer const Index) -> Standard_Boolean

        Returns True if the solution number Index is equal to
        the first argument and False in the other cases.
        Raises NotDone if the construction algorithm  didn't succeed.
        It raises OutOfRange if Index is greater than the
        number of solutions.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GccAna.GccAna_Circ2dTanOnRad_IsTheSame1(self, *args)

    __swig_destroy__ = _GccAna.delete_GccAna_Circ2dTanOnRad
GccAna_Circ2dTanOnRad_swigregister = _GccAna.GccAna_Circ2dTanOnRad_swigregister
GccAna_Circ2dTanOnRad_swigregister(GccAna_Circ2dTanOnRad)

class GccAna_LinPnt2dBisec(object):
    """
    Describes functions for building bisecting curves between a 2D line and a point.
    A bisecting curve between a line and a point is such a
    curve that each of its points is at the same distance from
    the circle and the point. It can be a parabola or a line,
    depending on the relative position of the line and the
    circle. There is always one unique solution.
    A LinPnt2dBisec object provides a framework for:
    - defining the construction of the bisecting curve,
    - implementing the construction algorithm, and
    - consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GccAna_LinPnt2dBisec self, gp_Lin2d Line1, gp_Pnt2d Point2) -> GccAna_LinPnt2dBisec

        Constructs a bisecting curve between the line Line1 and the point Point2.

        :type Line1: OCC.wrapper.gp.gp_Lin2d
        :type Point2: OCC.wrapper.gp.gp_Pnt2d

        """
        this = _GccAna.new_GccAna_LinPnt2dBisec(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(GccAna_LinPnt2dBisec self) -> Standard_Boolean

        Returns True if the algorithm succeeded.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GccAna.GccAna_LinPnt2dBisec_IsDone(self, *args)


    def ThisSolution(self, *args):
        """
        ThisSolution(GccAna_LinPnt2dBisec self) -> Handle_GccInt_Bisec

        Returns the number of solutions.
        It raises NotDone if the construction algorithm didn't succeed.

        :rtype: OCC.wrapper.GccInt.Handle_GccInt_Bisec

        """
        return _GccAna.GccAna_LinPnt2dBisec_ThisSolution(self, *args)

    __swig_destroy__ = _GccAna.delete_GccAna_LinPnt2dBisec
GccAna_LinPnt2dBisec_swigregister = _GccAna.GccAna_LinPnt2dBisec_swigregister
GccAna_LinPnt2dBisec_swigregister(GccAna_LinPnt2dBisec)

class GccAna_Lin2d2Tan(object):
    """
    This class implements the algorithms used to
    create 2d lines tangent to 2 other elements which
    can be circles or points.
    Describes functions for building a 2D line:
    -   tangential to 2 circles, or
    -   tangential to a circle and passing through a point, or
    -   passing through 2 points.
    A Lin2d2Tan object provides a framework for:
    -   defining the construction of 2D line(s),
    -   implementing the construction algorithm, and
    consulting the result(s).
    Some constructors may check the type of the qualified argument
    and raise BadQualifier Error in case of incorrect couple (qualifier,
    curv).
    For example: "EnclosedCirc".
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GccAna_Lin2d2Tan self, gp_Pnt2d ThePoint1, gp_Pnt2d ThePoint2, Standard_Real const Tolerance) -> GccAna_Lin2d2Tan
        __init__(GccAna_Lin2d2Tan self, GccEnt_QualifiedCirc Qualified1, gp_Pnt2d ThePoint, Standard_Real const Tolerance) -> GccAna_Lin2d2Tan
        __init__(GccAna_Lin2d2Tan self, GccEnt_QualifiedCirc Qualified1, GccEnt_QualifiedCirc Qualified2, Standard_Real const Tolerance) -> GccAna_Lin2d2Tan

        This methods implements the algorithms used to
        create 2d lines tangent to 2 circles.
        Exception BadQualifier is raised in the case of
        EnclosedCirc

        :type Qualified1: OCC.wrapper.GccEnt.GccEnt_QualifiedCirc
        :type Qualified2: OCC.wrapper.GccEnt.GccEnt_QualifiedCirc
        :type Tolerance: float

        """
        this = _GccAna.new_GccAna_Lin2d2Tan(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(GccAna_Lin2d2Tan self) -> Standard_Boolean

        This method returns true when there is a solution
        and false in the other cases.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GccAna.GccAna_Lin2d2Tan_IsDone(self, *args)


    def NbSolutions(self, *args):
        """
        NbSolutions(GccAna_Lin2d2Tan self) -> Standard_Integer

        This method returns the number of solutions.
        Raises NotDone if the construction algorithm didn't succeed.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GccAna.GccAna_Lin2d2Tan_NbSolutions(self, *args)


    def ThisSolution(self, *args):
        """
        ThisSolution(GccAna_Lin2d2Tan self, Standard_Integer const Index) -> gp_Lin2d

        Returns the solution number Index and raises OutOfRange
        exception if Index is greater than the number of solutions.
        Be carefull: the Index is only a way to get all the
        solutions, but is not associated to theses outside the
        context of the algorithm-object. Raises OutOfRange is raised if Index is greater than
        the number of solutions.
        It raises NotDone if the algorithm failed.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _GccAna.GccAna_Lin2d2Tan_ThisSolution(self, *args)


    def WhichQualifier(self, *args):
        """
        WhichQualifier(GccAna_Lin2d2Tan self, Standard_Integer const Index)

        Returns the qualifiers Qualif1 and Qualif2 of the
        tangency arguments for the solution of index Index
        computed by this algorithm.
        The returned qualifiers are:
        -   those specified at the start of construction when the
        solutions are defined as enclosing or outside with
        respect to the arguments, or
        -   those computed during construction (i.e. enclosing or
        outside) when the solutions are defined as unqualified
        with respect to the arguments, or
        -   GccEnt_noqualifier if the tangency argument is a point.
        Exceptions
        Standard_OutOfRange if Index is less than zero or
        greater than the number of solutions computed by this algorithm.
        StdFail_NotDone if the construction fails.

        :type Index: int
        :type Qualif1: OCC.wrapper.GccEnt.GccEnt_Position
        :type Qualif2: OCC.wrapper.GccEnt.GccEnt_Position

        """
        return _GccAna.GccAna_Lin2d2Tan_WhichQualifier(self, *args)


    def Tangency1(self, *args):
        """
        Tangency1(GccAna_Lin2d2Tan self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns informations about the tangency point between the
        result number Index and the first argument.
        ParSol is the intrinsic parameter of the point PntSol on
        the solution curv.
        ParArg is the intrinsic parameter of the point PntSol on
        the argument curv. Raises OutOfRange is raised if Index is greater than
        the number of solutions.
        It raises NotDone if the algorithm failed.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _GccAna.GccAna_Lin2d2Tan_Tangency1(self, *args)


    def Tangency2(self, *args):
        """
        Tangency2(GccAna_Lin2d2Tan self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns informations about the tangency point between the
        result number Index and the second argument.
        ParSol is the intrinsic parameter of the point ParSol on
        the solution curv.
        ParArg is the intrinsic parameter of the point PntSol on
        the argument curv. Raises OutOfRange is raised if Index is greater than
        the number of solutions.
        It raises NotDone if the algorithm failed.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _GccAna.GccAna_Lin2d2Tan_Tangency2(self, *args)

    __swig_destroy__ = _GccAna.delete_GccAna_Lin2d2Tan
GccAna_Lin2d2Tan_swigregister = _GccAna.GccAna_Lin2d2Tan_swigregister
GccAna_Lin2d2Tan_swigregister(GccAna_Lin2d2Tan)

class GccAna_Lin2dTanPer(object):
    """
    This class implements the algorithms used to
    create 2d lines tangent to a circle or a point and
    perpendicular to a line or a circle.
    Describes functions for building a 2D line perpendicular
    to a line and:
    -   tangential to a circle, or
    -   passing through a point.
    A Lin2dTanPer object provides a framework for:
    -   defining the construction of 2D line(s),
    -   implementing the construction algorithm, and
    -   consulting the result(s).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GccAna_Lin2dTanPer self, gp_Pnt2d ThePnt, gp_Lin2d TheLin) -> GccAna_Lin2dTanPer
        __init__(GccAna_Lin2dTanPer self, gp_Pnt2d ThePnt, gp_Circ2d TheCircle) -> GccAna_Lin2dTanPer
        __init__(GccAna_Lin2dTanPer self, GccEnt_QualifiedCirc Qualified1, gp_Lin2d TheLin) -> GccAna_Lin2dTanPer
        __init__(GccAna_Lin2dTanPer self, GccEnt_QualifiedCirc Qualified1, gp_Circ2d TheCircle) -> GccAna_Lin2dTanPer

        This method implements the algorithms used to
        create 2d lines tangent to a circle and
        perpendicular to a circle.

        :type Qualified1: OCC.wrapper.GccEnt.GccEnt_QualifiedCirc
        :type TheCircle: OCC.wrapper.gp.gp_Circ2d

        """
        this = _GccAna.new_GccAna_Lin2dTanPer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(GccAna_Lin2dTanPer self) -> Standard_Boolean

        Returns True if the algorithm succeeded.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GccAna.GccAna_Lin2dTanPer_IsDone(self, *args)


    def NbSolutions(self, *args):
        """
        NbSolutions(GccAna_Lin2dTanPer self) -> Standard_Integer

        Returns the number of solutions.
        Raises NotDone if the construction algorithm didn't succeed.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GccAna.GccAna_Lin2dTanPer_NbSolutions(self, *args)


    def WhichQualifier(self, *args):
        """
        WhichQualifier(GccAna_Lin2dTanPer self, Standard_Integer const Index)

        Returns the qualifier Qualif1 of the tangency argument
        for the solution of index Index computed by this algorithm.
        The returned qualifier is:
        -   that specified at the start of construction when the
        solutions are defined as enclosing or outside with
        respect to the argument, or
        -   that computed during construction (i.e. enclosing or
        outside) when the solutions are defined as unqualified
        with respect to the argument, or
        -   GccEnt_noqualifier if the tangency argument is a point.
        Exceptions
        Standard_OutOfRange if Index is less than zero or
        greater than the number of solutions computed by this algorithm.
        StdFail_NotDone if the construction fails.

        :type Index: int
        :type Qualif1: OCC.wrapper.GccEnt.GccEnt_Position

        """
        return _GccAna.GccAna_Lin2dTanPer_WhichQualifier(self, *args)


    def ThisSolution(self, *args):
        """
        ThisSolution(GccAna_Lin2dTanPer self, Standard_Integer const Index) -> gp_Lin2d

        Returns the solution number Index and raises OutOfRange
        exception if Index is greater than the number of solutions.
        Be careful: the Index is only a way to get all the
        solutions, but is not associated to those outside the
        context of the algorithm-object.
        Raises NotDone if the construction algorithm
        didn't succeed.
        It raises OutOfRange if Index is greater than the
        number of solutions.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _GccAna.GccAna_Lin2dTanPer_ThisSolution(self, *args)


    def Tangency1(self, *args):
        """
        Tangency1(GccAna_Lin2dTanPer self, Standard_Integer const Index, gp_Pnt2d Pnt)

        Returns informations about the tangency point between the
        result number Index and the first argument.
        ParSol is the intrinsic parameter of the point on the
        solution curv.
        ParArg is the intrinsic parameter of the point on the
        argument curv.
        If the first argument is a point ParArg is equal zero.
        raises NotDone if the construction algorithm didn't succeed.
        It raises OutOfRange if Index is greater than the
        number of solutions.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type Pnt: OCC.wrapper.gp.gp_Pnt2d

        """
        return _GccAna.GccAna_Lin2dTanPer_Tangency1(self, *args)


    def Intersection2(self, *args):
        """
        Intersection2(GccAna_Lin2dTanPer self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns informations about the intersection between the
        solution number Index and the second argument.
        It returns the first intersection in a case of
        Lin2dTanPer which is perpendicular to a circle .
        ParSol is the intrinsic parameter of the point on the
        solution curv.
        ParArg is the intrinsic parameter of the point on the
        argument curv. Raises NotDone if the construction algorithm
        didn't succeed.
        It raises OutOfRange if Index is greater than the
        number of solutions.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _GccAna.GccAna_Lin2dTanPer_Intersection2(self, *args)

    __swig_destroy__ = _GccAna.delete_GccAna_Lin2dTanPer
GccAna_Lin2dTanPer_swigregister = _GccAna.GccAna_Lin2dTanPer_swigregister
GccAna_Lin2dTanPer_swigregister(GccAna_Lin2dTanPer)

class GccAna_Circ2d2TanRad(object):
    """
    This class implements the algorithms used to
    create 2d circles tangent to 2
    points/lines/circles and with a given radius.
    For each construction methods arguments are:
    - Two Qualified elements for tangency constraints.
    (for example EnclosedCirc if we want the
    solution inside the argument EnclosedCirc).
    - Two Reals. One (Radius) for the radius and the
    other (Tolerance) for the tolerance.
    Tolerance is only used for the limit cases.
    For example :
    We want to create a circle inside a circle C1 and
    inside a circle C2 with a radius Radius and a
    tolerance Tolerance.
    If we do not use Tolerance it is impossible to
    find a solution in the following case : C2 is
    inside C1 and there is no intersection point
    between the two circles.
    With Tolerance it gives a solution if the lowest
    distance between C1 and C2 is lower than or equal
    Tolerance.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GccAna_Circ2d2TanRad self, GccEnt_QualifiedCirc Qualified1, GccEnt_QualifiedCirc Qualified2, Standard_Real const Radius, Standard_Real const Tolerance) -> GccAna_Circ2d2TanRad
        __init__(GccAna_Circ2d2TanRad self, GccEnt_QualifiedCirc Qualified1, GccEnt_QualifiedLin Qualified2, Standard_Real const Radius, Standard_Real const Tolerance) -> GccAna_Circ2d2TanRad
        __init__(GccAna_Circ2d2TanRad self, GccEnt_QualifiedCirc Qualified1, gp_Pnt2d Point2, Standard_Real const Radius, Standard_Real const Tolerance) -> GccAna_Circ2d2TanRad
        __init__(GccAna_Circ2d2TanRad self, GccEnt_QualifiedLin Qualified1, gp_Pnt2d Point2, Standard_Real const Radius, Standard_Real const Tolerance) -> GccAna_Circ2d2TanRad
        __init__(GccAna_Circ2d2TanRad self, GccEnt_QualifiedLin Qualified1, GccEnt_QualifiedLin Qualified2, Standard_Real const Radius, Standard_Real const Tolerance) -> GccAna_Circ2d2TanRad
        __init__(GccAna_Circ2d2TanRad self, gp_Pnt2d Point1, gp_Pnt2d Point2, Standard_Real const Radius, Standard_Real const Tolerance) -> GccAna_Circ2d2TanRad

        This method implements the algorithms used to
        create 2d circles passing through two points with a
        radius of Radius.
        It raises NegativeValue if Radius is lower than zero.

        :type Point1: OCC.wrapper.gp.gp_Pnt2d
        :type Point2: OCC.wrapper.gp.gp_Pnt2d
        :type Radius: float
        :type Tolerance: float

        """
        this = _GccAna.new_GccAna_Circ2d2TanRad(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(GccAna_Circ2d2TanRad self) -> Standard_Boolean

        This method returns True if the algorithm succeeded.
        Note: IsDone protects against a failure arising from a
        more internal intersection algorithm, which has reached its numeric limits.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GccAna.GccAna_Circ2d2TanRad_IsDone(self, *args)


    def NbSolutions(self, *args):
        """
        NbSolutions(GccAna_Circ2d2TanRad self) -> Standard_Integer

        This method returns the number of circles, representing solutions computed by this algorithm.
        Exceptions
        StdFail_NotDone if the construction fails. of solutions.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GccAna.GccAna_Circ2d2TanRad_NbSolutions(self, *args)


    def ThisSolution(self, *args):
        """
        ThisSolution(GccAna_Circ2d2TanRad self, Standard_Integer const Index) -> gp_Circ2d

        Returns the solution number Index.
        Be careful: the Index is only a way to get all the
        solutions, but is not associated to those outside the context
        of the algorithm-object. Raises OutOfRange exception if Index is greater
        than the number of solutions.
        It raises NotDone if the construction algorithm did not
        succeed.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _GccAna.GccAna_Circ2d2TanRad_ThisSolution(self, *args)


    def WhichQualifier(self, *args):
        """
        WhichQualifier(GccAna_Circ2d2TanRad self, Standard_Integer const Index)

        Returns the information about the qualifiers of
        the tangency arguments concerning the solution number Index.
        It returns the real qualifiers (the qualifiers given to the
        constructor method in case of enclosed, enclosing and outside
        and the qualifiers computedin case of unqualified).

        :type Index: int
        :type Qualif1: OCC.wrapper.GccEnt.GccEnt_Position
        :type Qualif2: OCC.wrapper.GccEnt.GccEnt_Position

        """
        return _GccAna.GccAna_Circ2d2TanRad_WhichQualifier(self, *args)


    def Tangency1(self, *args):
        """
        Tangency1(GccAna_Circ2d2TanRad self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns information about the tangency point between the
        result number Index and the first argument.
        ParSol is the intrinsic parameter of the point PntSol on the solution.
        ParArg is the intrinsic parameter of the point PntSol on the first
        argument. Raises OutOfRange if Index is greater than the number
        of solutions.
        It raises NotDone if the construction algorithm did not succeed

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _GccAna.GccAna_Circ2d2TanRad_Tangency1(self, *args)


    def Tangency2(self, *args):
        """
        Tangency2(GccAna_Circ2d2TanRad self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns information about the tangency point between the
        result number Index and the second argument.
        ParSol is the intrinsic parameter of the point PntSol on
        the solution.
        ParArg is the intrinsic parameter of the point PntArg on
        the second argument. Raises OutOfRange if Index is greater than the number
        of solutions.
        It raises NotDone if the construction algorithm did not succeed.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _GccAna.GccAna_Circ2d2TanRad_Tangency2(self, *args)


    def IsTheSame1(self, *args):
        """
        IsTheSame1(GccAna_Circ2d2TanRad self, Standard_Integer const Index) -> Standard_Boolean

        Returns True if the solution number Index is equal to
        the first argument. Raises OutOfRange if Index is greater than the number
        of solutions.
        It raises NotDone if the construction algorithm did not
        succeed.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GccAna.GccAna_Circ2d2TanRad_IsTheSame1(self, *args)


    def IsTheSame2(self, *args):
        """
        IsTheSame2(GccAna_Circ2d2TanRad self, Standard_Integer const Index) -> Standard_Boolean

        Returns True if the solution number Index is equal to
        the second argument. Raises OutOfRange if Index is greater than the number
        of solutions.
        It raises NotDone if the construction algorithm did not  succeed.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GccAna.GccAna_Circ2d2TanRad_IsTheSame2(self, *args)

    __swig_destroy__ = _GccAna.delete_GccAna_Circ2d2TanRad
GccAna_Circ2d2TanRad_swigregister = _GccAna.GccAna_Circ2d2TanRad_swigregister
GccAna_Circ2d2TanRad_swigregister(GccAna_Circ2d2TanRad)

class GccAna_Lin2dTanObl(object):
    """
    This class implements the algorithms used to
    create 2d line tangent to a circle or a point and
    making an angle with a line.
    The angle is in radians.
    The origin of the solution is the tangency point
    with the first argument.
    Its direction is making an angle Angle with the
    second argument.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GccAna_Lin2dTanObl self, gp_Pnt2d ThePoint, gp_Lin2d TheLine, Standard_Real const TheAngle) -> GccAna_Lin2dTanObl
        __init__(GccAna_Lin2dTanObl self, GccEnt_QualifiedCirc Qualified1, gp_Lin2d TheLine, Standard_Real const TheAngle) -> GccAna_Lin2dTanObl

        This class implements the algorithms used to
        create 2d line tangent to a circle and
        making an angle with a line.
        Exceptions
        GccEnt_BadQualifier if a qualifier is inconsistent with
        the argument it qualifies (for example, enclosed for a circle).

        :type Qualified1: OCC.wrapper.GccEnt.GccEnt_QualifiedCirc
        :type TheLine: OCC.wrapper.gp.gp_Lin2d
        :type TheAngle: float

        """
        this = _GccAna.new_GccAna_Lin2dTanObl(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(GccAna_Lin2dTanObl self) -> Standard_Boolean

        Returns True if the algorithm succeeded.
        Note: IsDone protects against a failure arising from a
        more internal intersection algorithm, which has reached
        its numeric limits.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GccAna.GccAna_Lin2dTanObl_IsDone(self, *args)


    def NbSolutions(self, *args):
        """
        NbSolutions(GccAna_Lin2dTanObl self) -> Standard_Integer

        Returns the number of  of lines, representing solutions computed by this algorithm.
        Raises NotDone if the construction algorithm didn't succeed.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GccAna.GccAna_Lin2dTanObl_NbSolutions(self, *args)


    def ThisSolution(self, *args):
        """
        ThisSolution(GccAna_Lin2dTanObl self, Standard_Integer const Index) -> gp_Lin2d

        Returns the solution number Index.
        Be careful: the Index is only a way to get all the
        solutions, but is not associated to theses outside the
        context of the algorithm-object.
        raises NotDone if the construction algorithm didn't succeed.
        It raises OutOfRange if Index is greater than the   number of solutions.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _GccAna.GccAna_Lin2dTanObl_ThisSolution(self, *args)


    def WhichQualifier(self, *args):
        """
        WhichQualifier(GccAna_Lin2dTanObl self, Standard_Integer const Index)

        Returns the qualifier Qualif1 of the tangency argument
        for the solution of index Index computed by this algorithm.
        The returned qualifier is:
        -   that specified at the start of construction when the
        solutions are defined as enclosing or outside with
        respect to the argument, or
        -   that computed during construction (i.e. enclosing or
        outside) when the solutions are defined as unqualified
        with respect to the argument, or
        -   GccEnt_noqualifier if the tangency argument is a point.
        Exceptions
        Standard_OutOfRange if Index is less than zero or
        greater than the number of solutions computed by this algorithm.
        StdFail_NotDone if the construction fails.

        :type Index: int
        :type Qualif1: OCC.wrapper.GccEnt.GccEnt_Position

        """
        return _GccAna.GccAna_Lin2dTanObl_WhichQualifier(self, *args)


    def Tangency1(self, *args):
        """
        Tangency1(GccAna_Lin2dTanObl self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns informations about the tangency point between the
        result number Index and the first argument.
        ParSol is the intrinsic parameter of the point ParSol on
        the solution curv.
        ParArg is the intrinsic parameter of the point ParArg on
        the argument curv. Raises NotDone if the construction algorithm
        didn't succeed.
        It raises OutOfRange if Index is greater than the  number of solutions.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _GccAna.GccAna_Lin2dTanObl_Tangency1(self, *args)


    def Intersection2(self, *args):
        """
        Intersection2(GccAna_Lin2dTanObl self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns informations about the intersection between the
        result number Index and the third argument.
        Raises NotDone if the construction algorithm  didn't succeed.
        It raises OutOfRange if Index is greater than the number of solutions.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _GccAna.GccAna_Lin2dTanObl_Intersection2(self, *args)

    __swig_destroy__ = _GccAna.delete_GccAna_Lin2dTanObl
GccAna_Lin2dTanObl_swigregister = _GccAna.GccAna_Lin2dTanObl_swigregister
GccAna_Lin2dTanObl_swigregister(GccAna_Lin2dTanObl)

class GccAna_CircLin2dBisec(object):
    """
    Describes functions for building bisecting curves between a 2D line and a 2D circle.
    A bisecting curve between a circle and a line is a curve
    such that each of its points is at the same distance from
    the circle and the line. It can be a parabola or a line,
    depending of the relative position of the line and the
    circle. The algorithm computes all the elementary curves which are solutions.
    A CircLin2dBisec object provides a framework for:
    -   defining the construction of the bisecting curves,
    -   implementing the construction algorithm, and
    -   consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GccAna_CircLin2dBisec self, gp_Circ2d Circle, gp_Lin2d Line) -> GccAna_CircLin2dBisec

        Constructs bisecting curves between the circle Circle and the line Line.

        :type Circle: OCC.wrapper.gp.gp_Circ2d
        :type Line: OCC.wrapper.gp.gp_Lin2d

        """
        this = _GccAna.new_GccAna_CircLin2dBisec(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(GccAna_CircLin2dBisec self) -> Standard_Boolean

        Returns true (this construction algorithm never fails).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GccAna.GccAna_CircLin2dBisec_IsDone(self, *args)


    def NbSolutions(self, *args):
        """
        NbSolutions(GccAna_CircLin2dBisec self) -> Standard_Integer

        Returns the number of curves, representing solutions computed by this algorithm.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GccAna.GccAna_CircLin2dBisec_NbSolutions(self, *args)


    def ThisSolution(self, *args):
        """
        ThisSolution(GccAna_CircLin2dBisec self, Standard_Integer const Index) -> Handle_GccInt_Bisec

        Returns the solution number Index and raises OutOfRange
        exception if Index is greater than the number of solutions
        Exceptions
        Standard_OutOfRange if Index is less than zero or
        greater than the number of solutions computed by this algorithm.

        :type Index: int
        :rtype: OCC.wrapper.GccInt.Handle_GccInt_Bisec

        """
        return _GccAna.GccAna_CircLin2dBisec_ThisSolution(self, *args)

    __swig_destroy__ = _GccAna.delete_GccAna_CircLin2dBisec
GccAna_CircLin2dBisec_swigregister = _GccAna.GccAna_CircLin2dBisec_swigregister
GccAna_CircLin2dBisec_swigregister(GccAna_CircLin2dBisec)

class GccAna_Pnt2dBisec(object):
    """
    This class implements the algorithms used to
    create the bisecting line between two 2d points
    Describes functions for building a bisecting line between two 2D points.
    The bisecting line between two points is the bisector of
    the segment which joins the two points, if these are not coincident.
    The algorithm does not find a solution if the two points are coincident.
    A Pnt2dBisec object provides a framework for:
    -   defining the construction of the bisecting line,
    -   implementing the construction algorithm, and consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GccAna_Pnt2dBisec self, gp_Pnt2d Point1, gp_Pnt2d Point2) -> GccAna_Pnt2dBisec

        Constructs a bisecting line between the points Point1 and Point2.

        :type Point1: OCC.wrapper.gp.gp_Pnt2d
        :type Point2: OCC.wrapper.gp.gp_Pnt2d

        """
        this = _GccAna.new_GccAna_Pnt2dBisec(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(GccAna_Pnt2dBisec self) -> Standard_Boolean

        Returns true (this construction algorithm never fails).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GccAna.GccAna_Pnt2dBisec_IsDone(self, *args)


    def HasSolution(self, *args):
        """
        HasSolution(GccAna_Pnt2dBisec self) -> Standard_Boolean

        Returns true if this algorithm has a solution, i.e. if the
        two points are not coincident.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GccAna.GccAna_Pnt2dBisec_HasSolution(self, *args)


    def ThisSolution(self, *args):
        """
        ThisSolution(GccAna_Pnt2dBisec self) -> gp_Lin2d

        Returns a line, representing the solution computed by this algorithm.

        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _GccAna.GccAna_Pnt2dBisec_ThisSolution(self, *args)

    __swig_destroy__ = _GccAna.delete_GccAna_Pnt2dBisec
GccAna_Pnt2dBisec_swigregister = _GccAna.GccAna_Pnt2dBisec_swigregister
GccAna_Pnt2dBisec_swigregister(GccAna_Pnt2dBisec)

class GccAna_Circ2d3Tan(object):
    """
    This class implements the algorithms used to
    create 2d circles tangent to 3 points/lines/circles.
    The arguments of all construction methods are :
    - The three qualified elements for the
    tangency constraints (QualifiedCirc, QualifiedLine,
    Points).
    - A real Tolerance.
    Tolerance is only used in the limit cases.
    For example :
    We want to create a circle tangent to an UnqualifiedCirc
    C1 and an UnqualifiedCirc C2 and an UnqualifiedCirc C3
    with a tolerance Tolerance.
    If we do not use Tolerance it is impossible to find
    a solution in the following case : C2 is inside C1
    and there is no intersection point between the two
    circles, and C3 is completly outside C1.
    With Tolerance we will find a solution if the
    lowest distance between C1 and C2 is lower than or
    equal Tolerance.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GccAna_Circ2d3Tan self, GccEnt_QualifiedCirc Qualified1, GccEnt_QualifiedCirc Qualified2, GccEnt_QualifiedCirc Qualified3, Standard_Real const Tolerance) -> GccAna_Circ2d3Tan
        __init__(GccAna_Circ2d3Tan self, GccEnt_QualifiedCirc Qualified1, GccEnt_QualifiedCirc Qualified2, GccEnt_QualifiedLin Qualified3, Standard_Real const Tolerance) -> GccAna_Circ2d3Tan
        __init__(GccAna_Circ2d3Tan self, GccEnt_QualifiedCirc Qualified1, GccEnt_QualifiedLin Qualified2, GccEnt_QualifiedLin Qualified3, Standard_Real const Tolerance) -> GccAna_Circ2d3Tan
        __init__(GccAna_Circ2d3Tan self, GccEnt_QualifiedLin Qualified1, GccEnt_QualifiedLin Qualified2, GccEnt_QualifiedLin Qualified3, Standard_Real const Tolerance) -> GccAna_Circ2d3Tan
        __init__(GccAna_Circ2d3Tan self, GccEnt_QualifiedCirc Qualified1, GccEnt_QualifiedCirc Qualified2, gp_Pnt2d Point3, Standard_Real const Tolerance) -> GccAna_Circ2d3Tan
        __init__(GccAna_Circ2d3Tan self, GccEnt_QualifiedCirc Qualified1, GccEnt_QualifiedLin Qualified2, gp_Pnt2d Point3, Standard_Real const Tolerance) -> GccAna_Circ2d3Tan
        __init__(GccAna_Circ2d3Tan self, GccEnt_QualifiedLin Qualified1, GccEnt_QualifiedLin Qualified2, gp_Pnt2d Point3, Standard_Real const Tolerance) -> GccAna_Circ2d3Tan
        __init__(GccAna_Circ2d3Tan self, GccEnt_QualifiedCirc Qualified1, gp_Pnt2d Point2, gp_Pnt2d Point3, Standard_Real const Tolerance) -> GccAna_Circ2d3Tan
        __init__(GccAna_Circ2d3Tan self, GccEnt_QualifiedLin Qualified1, gp_Pnt2d Point2, gp_Pnt2d Point3, Standard_Real const Tolerance) -> GccAna_Circ2d3Tan
        __init__(GccAna_Circ2d3Tan self, gp_Pnt2d Point1, gp_Pnt2d Point2, gp_Pnt2d Point3, Standard_Real const Tolerance) -> GccAna_Circ2d3Tan

        This method implements the algorithms used to
        create 2d circles passing thrue 3 Points.
        ConstructionError is raised if there is a problem during
        the computation.

        :type Point1: OCC.wrapper.gp.gp_Pnt2d
        :type Point2: OCC.wrapper.gp.gp_Pnt2d
        :type Point3: OCC.wrapper.gp.gp_Pnt2d
        :type Tolerance: float

        """
        this = _GccAna.new_GccAna_Circ2d3Tan(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(GccAna_Circ2d3Tan self) -> Standard_Boolean

        This method returns True if the construction
        algorithm succeeded.
        Note: IsDone protects against a failure arising from a
        more internal intersection algorithm, which has
        reached its numeric limits.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GccAna.GccAna_Circ2d3Tan_IsDone(self, *args)


    def NbSolutions(self, *args):
        """
        NbSolutions(GccAna_Circ2d3Tan self) -> Standard_Integer

        This method returns the number of solutions.
        Raises NotDone if the construction algorithm didn't succeed.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GccAna.GccAna_Circ2d3Tan_NbSolutions(self, *args)


    def ThisSolution(self, *args):
        """
        ThisSolution(GccAna_Circ2d3Tan self, Standard_Integer const Index) -> gp_Circ2d

        Returns the solution number Index and raises OutOfRange
        exception if Index is greater than the number of
        solutions.
        Be careful: the Index is only a way to get all the
        solutions, but is not associated to those outside the
        context of the algorithm-object.
        Raises OutOfRange if Index is greater than
        the number of solutions.
        It raises NotDone if the algorithm failed.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _GccAna.GccAna_Circ2d3Tan_ThisSolution(self, *args)


    def WhichQualifier(self, *args):
        """
        WhichQualifier(GccAna_Circ2d3Tan self, Standard_Integer const Index)

        Returns the informations about the qualifiers of the
        tangency
        arguments concerning the solution number Index.
        It returns the real qualifiers (the qualifiers given to the
        constructor method in case of enclosed, enclosing and outside
        and the qualifiers computedin case of unqualified).

        :type Index: int
        :type Qualif1: OCC.wrapper.GccEnt.GccEnt_Position
        :type Qualif2: OCC.wrapper.GccEnt.GccEnt_Position
        :type Qualif3: OCC.wrapper.GccEnt.GccEnt_Position

        """
        return _GccAna.GccAna_Circ2d3Tan_WhichQualifier(self, *args)


    def Tangency1(self, *args):
        """
        Tangency1(GccAna_Circ2d3Tan self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns informations about the tangency point between the
        result number Index and the first argument.
        ParSol is the intrinsic parameter of the point PntSol
        on the solution curv.
        ParArg is the intrinsic parameter of the point PntArg
        on the argument curv. Raises OutOfRange if Index is greater than
        the number of solutions.
        It raises NotDone if the algorithm failed.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _GccAna.GccAna_Circ2d3Tan_Tangency1(self, *args)


    def Tangency2(self, *args):
        """
        Tangency2(GccAna_Circ2d3Tan self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns informations about the tangency point between the
        result number Index and the first argument.
        ParSol is the intrinsic parameter of the point PntSol
        on the solution curv.
        ParArg is the intrinsic parameter of the point Pntsol
        on the argument curv. Raises OutOfRange if Index is greater than
        the number of solutions.
        It raises NotDone if the algorithm failed.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _GccAna.GccAna_Circ2d3Tan_Tangency2(self, *args)


    def Tangency3(self, *args):
        """
        Tangency3(GccAna_Circ2d3Tan self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns informations about the tangency point between the
        result number Index and the first argument.
        ParSol is the intrinsic parameter of the point PntSol
        on the solution curv.
        ParArg is the intrinsic parameter of the point Pntsol
        on the argument curv. Raises OutOfRange if Index is greater than
        the number of solutions.
        It raises NotDone if the algorithm failed.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _GccAna.GccAna_Circ2d3Tan_Tangency3(self, *args)


    def IsTheSame1(self, *args):
        """
        IsTheSame1(GccAna_Circ2d3Tan self, Standard_Integer const Index) -> Standard_Boolean

        Returns True if the solution number Index is equal to
        the first argument. Raises OutOfRange if Index is greater than
        the number of solutions.
        It raises NotDone if the algorithm failed.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GccAna.GccAna_Circ2d3Tan_IsTheSame1(self, *args)


    def IsTheSame2(self, *args):
        """
        IsTheSame2(GccAna_Circ2d3Tan self, Standard_Integer const Index) -> Standard_Boolean

        Returns True if the solution number Index is equal to
        the second argument. Raises OutOfRange Index is greater than
        the number of solutions.
        It raises NotDone if the algorithm failed.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GccAna.GccAna_Circ2d3Tan_IsTheSame2(self, *args)


    def IsTheSame3(self, *args):
        """
        IsTheSame3(GccAna_Circ2d3Tan self, Standard_Integer const Index) -> Standard_Boolean

        Returns True if the solution number Index is equal to
        the third argument. Raises OutOfRange if Index is greater than
        the number of solutions.
        It raises NotDone if the algorithm failed.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GccAna.GccAna_Circ2d3Tan_IsTheSame3(self, *args)

    __swig_destroy__ = _GccAna.delete_GccAna_Circ2d3Tan
GccAna_Circ2d3Tan_swigregister = _GccAna.GccAna_Circ2d3Tan_swigregister
GccAna_Circ2d3Tan_swigregister(GccAna_Circ2d3Tan)

class GccAna_Lin2dTanPar(object):
    """
    This class implements the algorithms used to create 2d
    line tangent to a circle or a point and parallel to
    another line.
    The solution has the same orientation as the
    second argument.
    Describes functions for building a 2D line parallel to a line and:
    -   tangential to a circle, or
    -   passing through a point.
    A Lin2dTanPar object provides a framework for:
    -   defining the construction of 2D line(s),
    -   implementing the construction algorithm, and consulting the result(s).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GccAna_Lin2dTanPar self, gp_Pnt2d ThePoint, gp_Lin2d Lin1) -> GccAna_Lin2dTanPar
        __init__(GccAna_Lin2dTanPar self, GccEnt_QualifiedCirc Qualified1, gp_Lin2d Lin1) -> GccAna_Lin2dTanPar

        This method implements the algorithms used to create a 2d
        line tangent to a circle and parallel to another line.
        It raises BadQualifier in case of EnclosedCirc.
        Exceptions
        GccEnt_BadQualifier if a qualifier is inconsistent with
        the argument it qualifies (for example, enclosed for a circle).

        :type Qualified1: OCC.wrapper.GccEnt.GccEnt_QualifiedCirc
        :type Lin1: OCC.wrapper.gp.gp_Lin2d

        """
        this = _GccAna.new_GccAna_Lin2dTanPar(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(GccAna_Lin2dTanPar self) -> Standard_Boolean

        Returns True if the algorithm succeeded.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GccAna.GccAna_Lin2dTanPar_IsDone(self, *args)


    def NbSolutions(self, *args):
        """
        NbSolutions(GccAna_Lin2dTanPar self) -> Standard_Integer

        Returns the number of solutions.
        Raises NotDone if the construction algorithm  didn't succeed.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GccAna.GccAna_Lin2dTanPar_NbSolutions(self, *args)


    def ThisSolution(self, *args):
        """
        ThisSolution(GccAna_Lin2dTanPar self, Standard_Integer const Index) -> gp_Lin2d

        Returns the solution number Index and raises OutOfRange
        exception if Index is greater than the number of solutions.
        Be careful: the Index is only a way to get all the
        solutions, but is not associated to those outside the
        context of the algorithm-object.
        raises NotDone if the construction algorithm
        didn't succeed.
        It raises OutOfRange if Index is greater than the
        number of solutions.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _GccAna.GccAna_Lin2dTanPar_ThisSolution(self, *args)


    def WhichQualifier(self, *args):
        """
        WhichQualifier(GccAna_Lin2dTanPar self, Standard_Integer const Index)

        Returns the informations about the qualifiers of the
        tangency arguments concerning the solution number Index.
        It returns the real qualifiers (the qualifiers given to the
        constructor method in case of enclosed, enclosing and outside
        and the qualifiers computed in case of unqualified).
        Raises NotDone if the construction algorithm
        didn't succeed.
        It raises OutOfRange if Index is greater than the
        number of solutions.

        :type Index: int
        :type Qualif1: OCC.wrapper.GccEnt.GccEnt_Position

        """
        return _GccAna.GccAna_Lin2dTanPar_WhichQualifier(self, *args)


    def Tangency1(self, *args):
        """
        Tangency1(GccAna_Lin2dTanPar self, Standard_Integer const Index, gp_Pnt2d Pnt)

        Returns informations about the tangency point between the
        result number Index and the first argument.
        ParSol is the intrinsic parameter of the point on the
        solution curv.
        ParArg is the intrinsic parameter of the point on the
        argument curv.
        ParArg is equal 0 when the solution is passing thrue
        a point. Raises NotDone if the construction algorithm
        didn't succeed.
        It raises OutOfRange if Index is greater than the
        number of solutions.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type Pnt: OCC.wrapper.gp.gp_Pnt2d

        """
        return _GccAna.GccAna_Lin2dTanPar_Tangency1(self, *args)

    __swig_destroy__ = _GccAna.delete_GccAna_Lin2dTanPar
GccAna_Lin2dTanPar_swigregister = _GccAna.GccAna_Lin2dTanPar_swigregister
GccAna_Lin2dTanPar_swigregister(GccAna_Lin2dTanPar)

class GccAna_Circ2d2TanOn(object):
    """
    Describes functions for building a 2D circle
    -   tangential to 2 curves, or
    -   tangential to a curve and passing through a point, or
    -   passing through 2 points,
    and with its center on a curve. For these analytic
    algorithms, curves are circles or lines.
    A Circ2d2TanOn object provides a framework for:
    -   defining the construction of 2D circles(s),
    -   implementing the construction algorithm, and
    -   consulting the result(s).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GccAna_Circ2d2TanOn self, GccEnt_QualifiedCirc Qualified1, GccEnt_QualifiedCirc Qualified2, gp_Lin2d OnLine, Standard_Real const Tolerance) -> GccAna_Circ2d2TanOn
        __init__(GccAna_Circ2d2TanOn self, GccEnt_QualifiedCirc Qualified1, GccEnt_QualifiedLin Qualified2, gp_Lin2d OnLine, Standard_Real const Tolerance) -> GccAna_Circ2d2TanOn
        __init__(GccAna_Circ2d2TanOn self, GccEnt_QualifiedLin Qualified1, GccEnt_QualifiedLin Qualified2, gp_Lin2d OnLine, Standard_Real const Tolerance) -> GccAna_Circ2d2TanOn
        __init__(GccAna_Circ2d2TanOn self, GccEnt_QualifiedCirc Qualified1, gp_Pnt2d Point2, gp_Lin2d OnLine, Standard_Real const Tolerance) -> GccAna_Circ2d2TanOn
        __init__(GccAna_Circ2d2TanOn self, GccEnt_QualifiedLin Qualified1, gp_Pnt2d Point2, gp_Lin2d OnLine, Standard_Real const Tolerance) -> GccAna_Circ2d2TanOn
        __init__(GccAna_Circ2d2TanOn self, gp_Pnt2d Point1, gp_Pnt2d Point2, gp_Lin2d OnLine, Standard_Real const Tolerance) -> GccAna_Circ2d2TanOn
        __init__(GccAna_Circ2d2TanOn self, GccEnt_QualifiedCirc Qualified1, GccEnt_QualifiedCirc Qualified2, gp_Circ2d OnCirc, Standard_Real const Tolerance) -> GccAna_Circ2d2TanOn
        __init__(GccAna_Circ2d2TanOn self, GccEnt_QualifiedCirc Qualified1, GccEnt_QualifiedLin Qualified2, gp_Circ2d OnCirc, Standard_Real const Tolerance) -> GccAna_Circ2d2TanOn
        __init__(GccAna_Circ2d2TanOn self, GccEnt_QualifiedCirc Qualified1, gp_Pnt2d Point2, gp_Circ2d OnCirc, Standard_Real const Tolerance) -> GccAna_Circ2d2TanOn
        __init__(GccAna_Circ2d2TanOn self, GccEnt_QualifiedLin Qualified1, GccEnt_QualifiedLin Qualified2, gp_Circ2d OnCirc, Standard_Real const Tolerance) -> GccAna_Circ2d2TanOn
        __init__(GccAna_Circ2d2TanOn self, GccEnt_QualifiedLin Qualified1, gp_Pnt2d Point2, gp_Circ2d OnCirc, Standard_Real const Tolerance) -> GccAna_Circ2d2TanOn
        __init__(GccAna_Circ2d2TanOn self, gp_Pnt2d Point1, gp_Pnt2d Point2, gp_Circ2d OnCirc, Standard_Real const Tolerance) -> GccAna_Circ2d2TanOn

        This method implements the algorithms used to create
        2d circles TANgent to two points having the center ON
        a 2d circle.

        :type Point1: OCC.wrapper.gp.gp_Pnt2d
        :type Point2: OCC.wrapper.gp.gp_Pnt2d
        :type OnCirc: OCC.wrapper.gp.gp_Circ2d
        :type Tolerance: float

        """
        this = _GccAna.new_GccAna_Circ2d2TanOn(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(GccAna_Circ2d2TanOn self) -> Standard_Boolean

        Returns true if the construction algorithm does not fail
        (even if it finds no solution).
        Note: IsDone protects against a failure arising from a
        more internal intersection algorithm, which has reached its numeric limits.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GccAna.GccAna_Circ2d2TanOn_IsDone(self, *args)


    def NbSolutions(self, *args):
        """
        NbSolutions(GccAna_Circ2d2TanOn self) -> Standard_Integer

        Returns the number of circles, representing solutions
        computed by this algorithm.
        Exceptions
        StdFail_NotDone if the construction fails.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GccAna.GccAna_Circ2d2TanOn_NbSolutions(self, *args)


    def ThisSolution(self, *args):
        """
        ThisSolution(GccAna_Circ2d2TanOn self, Standard_Integer const Index) -> gp_Circ2d

        Returns the solution number Index and raises OutOfRange
        exception if Index is greater than the number of solutions.
        Be careful: the Index is only a way to get all the
        solutions, but is not associated to those outside the context
        of the algorithm-object.
        Exceptions
        Standard_OutOfRange if Index is less than zero or
        greater than the number of solutions computed by this algorithm.
        StdFail_NotDone if the construction fails.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _GccAna.GccAna_Circ2d2TanOn_ThisSolution(self, *args)


    def WhichQualifier(self, *args):
        """
        WhichQualifier(GccAna_Circ2d2TanOn self, Standard_Integer const Index)

        Returns the qualifiers Qualif1 and Qualif2 of the
        tangency arguments for the solution of index Index
        computed by this algorithm.
        The returned qualifiers are:
        -   those specified at the start of construction when the
        solutions are defined as enclosed, enclosing or
        outside with respect to the arguments, or
        -   those computed during construction (i.e. enclosed,
        enclosing or outside) when the solutions are defined
        as unqualified with respect to the arguments, or
        -   GccEnt_noqualifier if the tangency argument is a point.
        Exceptions
        Standard_OutOfRange if Index is less than zero or
        greater than the number of solutions computed by this algorithm.
        StdFail_NotDone if the construction fails.

        :type Index: int
        :type Qualif1: OCC.wrapper.GccEnt.GccEnt_Position
        :type Qualif2: OCC.wrapper.GccEnt.GccEnt_Position

        """
        return _GccAna.GccAna_Circ2d2TanOn_WhichQualifier(self, *args)


    def Tangency1(self, *args):
        """
        Tangency1(GccAna_Circ2d2TanOn self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns the informations about the tangency point between the
        result number Index and the first argument.
        ParSol is the intrinsic parameter of the point PntSol on
        the solution
        ParArg is the intrinsic parameter of the point PntSol on
        the first argument. Raises OutOfRange if Index is greater than the number
        of solutions and NotDone if IsDone returns false.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _GccAna.GccAna_Circ2d2TanOn_Tangency1(self, *args)


    def Tangency2(self, *args):
        """
        Tangency2(GccAna_Circ2d2TanOn self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns the informations about the tangency point between the
        result number Index and the second argument.
        ParSol is the intrinsic parameter of the point PntSol on
        the solution.
        ParArg is the intrinsic parameter of the point PntSol on
        the second argument. Raises OutOfRange if Index is greater than the number
        of solutions and NotDone if IsDone returns false.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _GccAna.GccAna_Circ2d2TanOn_Tangency2(self, *args)


    def CenterOn3(self, *args):
        """
        CenterOn3(GccAna_Circ2d2TanOn self, Standard_Integer const Index, gp_Pnt2d PntArg)

        Returns the informations about the center (on the curv) of
        the result number Index and the third argument.
        ParArg is the intrinsic parameter of the point PntArg on
        the third argument.
        Exceptions
        Standard_OutOfRange if Index is less than zero or
        greater than the number of solutions computed by this algorithm.
        StdFail_NotDone if the construction fails.

        :type Index: int
        :type ParArg: float
        :type PntArg: OCC.wrapper.gp.gp_Pnt2d

        """
        return _GccAna.GccAna_Circ2d2TanOn_CenterOn3(self, *args)


    def IsTheSame1(self, *args):
        """
        IsTheSame1(GccAna_Circ2d2TanOn self, Standard_Integer const Index) -> Standard_Boolean

        True if the solution and the first argument are the same
        (2 circles).
        If R1 is the radius of the first argument and Rsol the radius
        of the solution and dist the distance between the two centers,
        we concider the two circles are identical if R1+dist-Rsol is
        less than Tolerance.
        False in the other cases.
        Raises OutOfRange if Index is greater than the number
        of solutions and NotDone if IsDone returns false.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GccAna.GccAna_Circ2d2TanOn_IsTheSame1(self, *args)


    def IsTheSame2(self, *args):
        """
        IsTheSame2(GccAna_Circ2d2TanOn self, Standard_Integer const Index) -> Standard_Boolean

        True if the solution and the second argument are the same
        (2 circles).
        If R2 is the radius of the second argument and Rsol the radius
        of the solution and dist the distance between the two centers,
        we concider the two circles are identical if R2+dist-Rsol is
        less than Tolerance.
        False in the other cases.
        Raises OutOfRange if Index is greater than the number
        of solutions and NotDone if IsDone returns false.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GccAna.GccAna_Circ2d2TanOn_IsTheSame2(self, *args)

    __swig_destroy__ = _GccAna.delete_GccAna_Circ2d2TanOn
GccAna_Circ2d2TanOn_swigregister = _GccAna.GccAna_Circ2d2TanOn_swigregister
GccAna_Circ2d2TanOn_swigregister(GccAna_Circ2d2TanOn)

class GccAna_CircPnt2dBisec(object):
    """
    Describes functions for building a bisecting curve
    between a 2D circle and a point.
    A bisecting curve between a circle and a point is such a
    curve that each of its points is at the same distance from
    the circle and the point. It can be an ellipse, hyperbola,
    circle or line, depending on the relative position of the
    point and the circle. The algorithm computes all the
    elementary curves which are solutions.
    A CircPnt2dBisec object provides a framework for:
    -   defining the construction of the bisecting curves,
    -   implementing the construction algorithm, and
    -   consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GccAna_CircPnt2dBisec self, gp_Circ2d Circle1, gp_Pnt2d Point2) -> GccAna_CircPnt2dBisec
        __init__(GccAna_CircPnt2dBisec self, gp_Circ2d Circle1, gp_Pnt2d Point2, Standard_Real const Tolerance) -> GccAna_CircPnt2dBisec

        Constructs bisecting curves between the circle Circle1 and the point Point2.
        Tolerance is used.

        :type Circle1: OCC.wrapper.gp.gp_Circ2d
        :type Point2: OCC.wrapper.gp.gp_Pnt2d
        :type Tolerance: float

        """
        this = _GccAna.new_GccAna_CircPnt2dBisec(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(GccAna_CircPnt2dBisec self) -> Standard_Boolean

        Returns true (this construction algorithm never fails).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GccAna.GccAna_CircPnt2dBisec_IsDone(self, *args)


    def NbSolutions(self, *args):
        """
        NbSolutions(GccAna_CircPnt2dBisec self) -> Standard_Integer

        Returns the number of curves, representing solutions computed by this algorithm.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GccAna.GccAna_CircPnt2dBisec_NbSolutions(self, *args)


    def ThisSolution(self, *args):
        """
        ThisSolution(GccAna_CircPnt2dBisec self, Standard_Integer const Index) -> Handle_GccInt_Bisec

        Returns the solution number Index and raises OutOfRange
        exception if Index is greater than the number of solutions.
        Exceptions
        Standard_OutOfRange if Index is less than zero or
        greater than the number of solutions computed by this algorithm.

        :type Index: int
        :rtype: OCC.wrapper.GccInt.Handle_GccInt_Bisec

        """
        return _GccAna.GccAna_CircPnt2dBisec_ThisSolution(self, *args)

    __swig_destroy__ = _GccAna.delete_GccAna_CircPnt2dBisec
GccAna_CircPnt2dBisec_swigregister = _GccAna.GccAna_CircPnt2dBisec_swigregister
GccAna_CircPnt2dBisec_swigregister(GccAna_CircPnt2dBisec)

class Handle_GccAna_NoSolution(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_GccAna_NoSolution self)

        Nullify the handle


        """
        return _GccAna.Handle_GccAna_NoSolution_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_GccAna_NoSolution self) -> bool

        Check for being null

        :rtype: bool

        """
        return _GccAna.Handle_GccAna_NoSolution_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_GccAna_NoSolution self, GccAna_NoSolution thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _GccAna.Handle_GccAna_NoSolution_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_GccAna_NoSolution self, Handle_GccAna_NoSolution theHandle) -> Handle_GccAna_NoSolution
        assign(Handle_GccAna_NoSolution self, GccAna_NoSolution thePtr) -> Handle_GccAna_NoSolution
        assign(Handle_GccAna_NoSolution self, Handle_GccAna_NoSolution theHandle) -> Handle_GccAna_NoSolution

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _GccAna.Handle_GccAna_NoSolution_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_GccAna_NoSolution self) -> GccAna_NoSolution

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _GccAna.Handle_GccAna_NoSolution_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_GccAna_NoSolution self) -> GccAna_NoSolution

        Member access operator (note non-const)

        :rtype: T *

        """
        return _GccAna.Handle_GccAna_NoSolution___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_GccAna_NoSolution self) -> GccAna_NoSolution

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _GccAna.Handle_GccAna_NoSolution___ref__(self, *args)


    def __hash__(self):
        return _GccAna.Handle_GccAna_NoSolution___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _GccAna.Handle_GccAna_NoSolution___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _GccAna.new_Handle_GccAna_NoSolution(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_GccAna.Handle_GccAna_NoSolution_DownCast)
    __swig_destroy__ = _GccAna.delete_Handle_GccAna_NoSolution

    def NewInstance(self, *args):
        """
        NewInstance(Handle_GccAna_NoSolution self, Standard_CString const theMessage) -> Handle_GccAna_NoSolution

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.GccAna.Handle_GccAna_NoSolution

        """
        return _GccAna.Handle_GccAna_NoSolution_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_GccAna_NoSolution self) -> char const *

        :rtype: const char *

        """
        return _GccAna.Handle_GccAna_NoSolution_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GccAna.Handle_GccAna_NoSolution_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _GccAna.Handle_GccAna_NoSolution_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_GccAna_NoSolution self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _GccAna.Handle_GccAna_NoSolution_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_GccAna_NoSolution self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _GccAna.Handle_GccAna_NoSolution_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_GccAna_NoSolution self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _GccAna.Handle_GccAna_NoSolution_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_GccAna_NoSolution self)
        Reraise(Handle_GccAna_NoSolution self, Standard_CString const aMessage)
        Reraise(Handle_GccAna_NoSolution self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _GccAna.Handle_GccAna_NoSolution_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_GccAna_NoSolution self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _GccAna.Handle_GccAna_NoSolution_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_GccAna_NoSolution self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _GccAna.Handle_GccAna_NoSolution_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_GccAna_NoSolution self)

        Memory deallocator for transient classes


        """
        return _GccAna.Handle_GccAna_NoSolution_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_GccAna_NoSolution self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_GccAna_NoSolution self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GccAna.Handle_GccAna_NoSolution_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_GccAna_NoSolution self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_GccAna_NoSolution self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GccAna.Handle_GccAna_NoSolution_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_GccAna_NoSolution self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _GccAna.Handle_GccAna_NoSolution_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_GccAna_NoSolution self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GccAna.Handle_GccAna_NoSolution_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_GccAna_NoSolution self)

        Increments the reference counter of this object


        """
        return _GccAna.Handle_GccAna_NoSolution_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_GccAna_NoSolution self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GccAna.Handle_GccAna_NoSolution_DecrementRefCounter(self, *args)

Handle_GccAna_NoSolution_swigregister = _GccAna.Handle_GccAna_NoSolution_swigregister
Handle_GccAna_NoSolution_swigregister(Handle_GccAna_NoSolution)

def Handle_GccAna_NoSolution_DownCast(thing):
    return _GccAna.Handle_GccAna_NoSolution_DownCast(thing)
Handle_GccAna_NoSolution_DownCast = _GccAna.Handle_GccAna_NoSolution_DownCast

class GccAna_Lin2dBisec(object):
    """
    Describes functions for building bisecting lines between two 2D lines.
    A bisecting line between two lines is such that each of its
    points is at the same distance from the two lines.
    If the two lines are secant, there are two orthogonal
    bisecting lines which share the angles made by the two
    straight lines in two equal parts. If D1 and D2 are the
    unit vectors of the two straight lines, those of the two
    bisecting lines are collinear with the following vectors:
    -   D1 + D2 for the "internal" bisecting line,
    -   D1 - D2 for the "external" bisecting line.
    If the two lines are parallel, the (unique) bisecting line is
    the straight line equidistant from the two straight lines. If
    the two straight lines are coincident, the algorithm
    returns the first straight line as the solution.
    A Lin2dTanObl object provides a framework for:
    -   defining the construction of the bisecting lines,
    -   implementing the construction algorithm, and
    -   consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GccAna_Lin2dBisec self, gp_Lin2d Lin1, gp_Lin2d Lin2) -> GccAna_Lin2dBisec

        Constructs bisecting lines between the two lines Lin1 and Lin2.

        :type Lin1: OCC.wrapper.gp.gp_Lin2d
        :type Lin2: OCC.wrapper.gp.gp_Lin2d

        """
        this = _GccAna.new_GccAna_Lin2dBisec(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(GccAna_Lin2dBisec self) -> Standard_Boolean

        Returns True when the algorithm succeded.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GccAna.GccAna_Lin2dBisec_IsDone(self, *args)


    def NbSolutions(self, *args):
        """
        NbSolutions(GccAna_Lin2dBisec self) -> Standard_Integer

        Returns the number of solutions and raise NotDone if
        the constructor wasn't called before.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GccAna.GccAna_Lin2dBisec_NbSolutions(self, *args)


    def ThisSolution(self, *args):
        """
        ThisSolution(GccAna_Lin2dBisec self, Standard_Integer const Index) -> gp_Lin2d

        Returns the solution number Index .
        The first solution is the inside one and the second is the
        outside one.
        For the first solution the direction is D1+D2 (D1 is
        the direction of the first argument and D2 the
        direction of the second argument).
        For the second solution the direction is D1-D2.
        Raises NotDone if the construction algorithm
        didn't succeed.
        It raises OutOfRange if Index is greater than the
        number of solutions.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _GccAna.GccAna_Lin2dBisec_ThisSolution(self, *args)


    def Intersection1(self, *args):
        """
        Intersection1(GccAna_Lin2dBisec self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns informations about the intersection point between
        the result number Index and the first argument.
        Raises NotDone if the construction algorithm  didn't succeed.
        It raises OutOfRange if Index is greater than the
        number of solutions.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _GccAna.GccAna_Lin2dBisec_Intersection1(self, *args)


    def Intersection2(self, *args):
        """
        Intersection2(GccAna_Lin2dBisec self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns informations about the intersection point between
        the result number Index and the second argument.
        Raises NotDone if the construction algorithm
        didn't succeed.
        It raises OutOfRange if Index is greater than the
        number of solutions.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _GccAna.GccAna_Lin2dBisec_Intersection2(self, *args)

    __swig_destroy__ = _GccAna.delete_GccAna_Lin2dBisec
GccAna_Lin2dBisec_swigregister = _GccAna.GccAna_Lin2dBisec_swigregister
GccAna_Lin2dBisec_swigregister(GccAna_Lin2dBisec)

class GccAna_Circ2dTanCen(object):
    """
    This class implements the algorithms used to
    create 2d circles tangent to an entity and
    centered on a point.
    The arguments of all construction methods are :
    - The qualified element for the tangency constrains
    (QualifiedCirc, Line, Point).
    - The center point Pcenter.
    - A real Tolerance.
    Tolerance is only used in the limits cases.
    For example :
    We want to create a circle tangent to an EnclosedCirc C1
    with a tolerance Tolerance.
    If we did not used Tolerance it is impossible to
    find a solution in the the following case : Pcenter is
    outside C1.
    With Tolerance we will give a solution if the distance
    between C1 and Pcenter is lower than or equal Tolerance.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GccAna_Circ2dTanCen self, GccEnt_QualifiedCirc Qualified1, gp_Pnt2d Pcenter, Standard_Real const Tolerance) -> GccAna_Circ2dTanCen
        __init__(GccAna_Circ2dTanCen self, gp_Lin2d Linetan, gp_Pnt2d Pcenter) -> GccAna_Circ2dTanCen
        __init__(GccAna_Circ2dTanCen self, gp_Pnt2d Point1, gp_Pnt2d Pcenter) -> GccAna_Circ2dTanCen

        This method implements the algorithms used to
        create 2d circles passing thrue a point and
        centered on a point.
        Tolerance is a tolerance criterion used by the algorithm
        to find a solution when, mathematically, the problem
        posed does not have a solution, but where there is
        numeric uncertainty attached to the arguments.
        In these algorithms Tolerance is only used in very
        specific cases where the center of the solution is very
        close to the circle to which it is tangential, and where the
        solution is therefore a very small circle.
        Exceptions
        GccEnt_BadQualifier if a qualifier is inconsistent with
        the argument it qualifies (for example, enclosing for a line).

        :type Point1: OCC.wrapper.gp.gp_Pnt2d
        :type Pcenter: OCC.wrapper.gp.gp_Pnt2d

        """
        this = _GccAna.new_GccAna_Circ2dTanCen(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(GccAna_Circ2dTanCen self) -> Standard_Boolean

        This method returns True if the construction
        algorithm succeeded.
        Note: IsDone protects against a failure arising from a
        more internal intersection algorithm, which has reached
        its numeric limits.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GccAna.GccAna_Circ2dTanCen_IsDone(self, *args)


    def NbSolutions(self, *args):
        """
        NbSolutions(GccAna_Circ2dTanCen self) -> Standard_Integer

        Returns the number of circles, representing solutions
        computed by this algorithm and raises NotDone
        exception if the algorithm didn't succeed.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GccAna.GccAna_Circ2dTanCen_NbSolutions(self, *args)


    def ThisSolution(self, *args):
        """
        ThisSolution(GccAna_Circ2dTanCen self, Standard_Integer const Index) -> gp_Circ2d

        Returns the circle, representing the solution number Index and raises OutOfRange
        exception if Index is greater than the number of solutions.
        Be carefull: the Index is only a way to get all the
        solutions, but is not associated to theses outside the
        context of the algorithm-object.
        Raises NotDone if the construction algorithm didn't succeed.
        It raises OutOfRange if Index is greater than the
        number of solutions or less than zer

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _GccAna.GccAna_Circ2dTanCen_ThisSolution(self, *args)


    def WhichQualifier(self, *args):
        """
        WhichQualifier(GccAna_Circ2dTanCen self, Standard_Integer const Index)

        Returns the qualifier Qualif1 of the tangency argument
        for the solution of index Index computed by this algorithm.
        The returned qualifier is:
        -   that specified at the start of construction when the
        solutions are defined as enclosed, enclosing or
        It returns the real qualifiers (the qualifiers given to the
        constructor method in case of enclosed, enclosing and outside
        and the qualifiers computedin case of unqualified).

        :type Index: int
        :type Qualif1: OCC.wrapper.GccEnt.GccEnt_Position

        """
        return _GccAna.GccAna_Circ2dTanCen_WhichQualifier(self, *args)


    def Tangency1(self, *args):
        """
        Tangency1(GccAna_Circ2dTanCen self, Standard_Integer const Index, gp_Pnt2d PntSol)

        Returns informations about the tangency point between the
        result number Index and the first argument.
        ParSol is the intrinsic parameter of the point PntSol
        on the solution curv.
        ParArg is the intrinsic parameter of the point PntArg
        on the argument curv.
        It raises NotDone if the construction algorithm
        didn't succeed.
        It raises OutOfRange if Index is greater than the
        number of solutions or less than zero.

        :type Index: int
        :type ParSol: float
        :type ParArg: float
        :type PntSol: OCC.wrapper.gp.gp_Pnt2d

        """
        return _GccAna.GccAna_Circ2dTanCen_Tangency1(self, *args)


    def IsTheSame1(self, *args):
        """
        IsTheSame1(GccAna_Circ2dTanCen self, Standard_Integer const Index) -> Standard_Boolean

        Returns True if the solution number Index is equal to
        the first argument.
        It raises NotDone if the construction algorithm
        didn't succeed.
        It raises OutOfRange if Index is greater than the
        number of solutions or less than zero.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GccAna.GccAna_Circ2dTanCen_IsTheSame1(self, *args)

    __swig_destroy__ = _GccAna.delete_GccAna_Circ2dTanCen
GccAna_Circ2dTanCen_swigregister = _GccAna.GccAna_Circ2dTanCen_swigregister
GccAna_Circ2dTanCen_swigregister(GccAna_Circ2dTanCen)

class GccAna_Circ2dBisec(object):
    """
    This class describes functions for building bisecting curves between two 2D circles.
    A bisecting curve between two circles is a curve such
    that each of its points is at the same distance from the
    two circles. It can be an ellipse, hyperbola, circle or line,
    depending on the relative position of the two circles.
    The algorithm computes all the elementary curves which
    are solutions. There is no solution if the two circles are coincident.
    A Circ2dBisec object provides a framework for:
    -   defining the construction of the bisecting curves,
    -   implementing the construction algorithm, and consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GccAna_Circ2dBisec self, gp_Circ2d Circ1, gp_Circ2d Circ2) -> GccAna_Circ2dBisec

        Constructs bisecting curves between the two circles Circ1 and Circ2.

        :type Circ1: OCC.wrapper.gp.gp_Circ2d
        :type Circ2: OCC.wrapper.gp.gp_Circ2d

        """
        this = _GccAna.new_GccAna_Circ2dBisec(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(GccAna_Circ2dBisec self) -> Standard_Boolean

        This method returns True if the construction algorithm succeeded.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GccAna.GccAna_Circ2dBisec_IsDone(self, *args)


    def NbSolutions(self, *args):
        """
        NbSolutions(GccAna_Circ2dBisec self) -> Standard_Integer

        This method returns the number of solutions.
        Raises NotDone if the construction algorithm  didn't succeed.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GccAna.GccAna_Circ2dBisec_NbSolutions(self, *args)


    def ThisSolution(self, *args):
        """
        ThisSolution(GccAna_Circ2dBisec self, Standard_Integer const Index) -> Handle_GccInt_Bisec

        Returns the solution number Index
        Raises OutOfRange exception if Index is greater than
        the number of solutions.
        It raises NotDone if the construction algorithm
        didn't succeed.

        :type Index: int
        :rtype: OCC.wrapper.GccInt.Handle_GccInt_Bisec

        """
        return _GccAna.GccAna_Circ2dBisec_ThisSolution(self, *args)

    __swig_destroy__ = _GccAna.delete_GccAna_Circ2dBisec
GccAna_Circ2dBisec_swigregister = _GccAna.GccAna_Circ2dBisec_swigregister
GccAna_Circ2dBisec_swigregister(GccAna_Circ2dBisec)




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_ShapeUpgrade')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_ShapeUpgrade')
    _ShapeUpgrade = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ShapeUpgrade', [dirname(__file__)])
        except ImportError:
            import _ShapeUpgrade
            return _ShapeUpgrade
        try:
            _mod = imp.load_module('_ShapeUpgrade', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _ShapeUpgrade = swig_import_helper()
    del swig_import_helper
else:
    import _ShapeUpgrade
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ShapeUpgrade.delete_SwigPyIterator

    def value(self):
        return _ShapeUpgrade.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _ShapeUpgrade.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _ShapeUpgrade.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _ShapeUpgrade.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _ShapeUpgrade.SwigPyIterator_equal(self, x)

    def copy(self):
        return _ShapeUpgrade.SwigPyIterator_copy(self)

    def next(self):
        return _ShapeUpgrade.SwigPyIterator_next(self)

    def __next__(self):
        return _ShapeUpgrade.SwigPyIterator___next__(self)

    def previous(self):
        return _ShapeUpgrade.SwigPyIterator_previous(self)

    def advance(self, n):
        return _ShapeUpgrade.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _ShapeUpgrade.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _ShapeUpgrade.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _ShapeUpgrade.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _ShapeUpgrade.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _ShapeUpgrade.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _ShapeUpgrade.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _ShapeUpgrade.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _ShapeUpgrade.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_ShapeUpgrade.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _ShapeUpgrade.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _ShapeUpgrade.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ShapeUpgrade.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _ShapeUpgrade.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _ShapeUpgrade.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _ShapeUpgrade.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _ShapeUpgrade.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_ShapeUpgrade.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _ShapeUpgrade.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _ShapeUpgrade.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ShapeUpgrade.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _ShapeUpgrade.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _ShapeUpgrade.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _ShapeUpgrade.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _ShapeUpgrade.ptr_to_number(item)
ptr_to_number = _ShapeUpgrade.ptr_to_number

def HashCode(*args):
    return _ShapeUpgrade.HashCode(*args)
HashCode = _ShapeUpgrade.HashCode

def ptr_equal(a, b):
    return _ShapeUpgrade.ptr_equal(a, b)
ptr_equal = _ShapeUpgrade.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColGeom2d
else:
    import TColGeom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import ShapeBuild
else:
    import ShapeBuild
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import ShapeExtend
else:
    import ShapeExtend
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColGeom
else:
    import TColGeom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepTools
else:
    import BRepTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Poly
else:
    import Poly
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TShort
else:
    import TShort
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRep
else:
    import BRep
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import ShapeAnalysis
else:
    import ShapeAnalysis
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntRes2d
else:
    import IntRes2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
class ShapeUpgrade_SplitSurface(Standard.Standard_Transient):
    """Splits a Surface with a criterion."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeUpgrade_SplitSurface
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeUpgrade_SplitSurface(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeUpgrade_SplitSurface self) -> ShapeUpgrade_SplitSurface

        Empty constructor.


        """
        this = _ShapeUpgrade.new_ShapeUpgrade_SplitSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(ShapeUpgrade_SplitSurface self, Handle_Geom_Surface S)
        Init(ShapeUpgrade_SplitSurface self, Handle_Geom_Surface S, Standard_Real const UFirst, Standard_Real const ULast, Standard_Real const VFirst, Standard_Real const VLast)

        Initializes with single supporting surface with bounding parameters.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type UFirst: float
        :type ULast: float
        :type VFirst: float
        :type VLast: float

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitSurface_Init(self, *args)


    def SetUSplitValues(self, *args):
        """
        SetUSplitValues(ShapeUpgrade_SplitSurface self, Handle_TColStd_HSequenceOfReal UValues)

        Sets U parameters where splitting has to be done

        :type UValues: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitSurface_SetUSplitValues(self, *args)


    def SetVSplitValues(self, *args):
        """
        SetVSplitValues(ShapeUpgrade_SplitSurface self, Handle_TColStd_HSequenceOfReal VValues)

        Sets V parameters where splitting has to be done

        :type VValues: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitSurface_SetVSplitValues(self, *args)


    def Build(self, *args):
        """
        Build(ShapeUpgrade_SplitSurface self, Standard_Boolean const Segment)

        Performs splitting of the supporting surface.
        If resulting surface is B-Spline and Segment is True,
        the result is composed with segments of the surface bounded
        by the U and V SplitValues (method Geom_BSplineSurface::Segment
        is used).
        If Segment is False, the result is composed with
        Geom_RectangularTrimmedSurface all based on the same complete
        surface.
        Fields myNbResultingRow and myNbResultingCol must be set to
        specify the size of resulting grid of surfaces.

        :type Segment: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitSurface_Build(self, *args)


    def Compute(self, *args):
        """
        Compute(ShapeUpgrade_SplitSurface self, Standard_Boolean const Segment)

        Calculates points for correction/splitting of the surface.

        :type Segment: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitSurface_Compute(self, *args)


    def Perform(self, *args):
        """
        Perform(ShapeUpgrade_SplitSurface self, Standard_Boolean const Segment)

        Performs correction/splitting of the surface.
        First defines splitting values by method Compute(), then calls method Build().

        :type Segment: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitSurface_Perform(self, *args)


    def USplitValues(self, *args):
        """
        returns all the U splitting values including the
        First and Last parameters of the input surface

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        res = _ShapeUpgrade.ShapeUpgrade_SplitSurface_USplitValues(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def VSplitValues(self, *args):
        """
        returns all the splitting V values including the
        First and Last parameters of the input surface

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        res = _ShapeUpgrade.ShapeUpgrade_SplitSurface_VSplitValues(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Status(self, *args):
        """
        Status(ShapeUpgrade_SplitSurface self, ShapeExtend_Status const status) -> Standard_Boolean

        Returns the status
        OK    - no splitting is needed
        DONE1 - splitting required and gives more than one patch
        DONE2 - splitting is required, but gives only single patch (initial)
        DONE3 - geometric form of the surface or parametrisation is modified

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitSurface_Status(self, *args)


    def ResSurfaces(self, *args):
        """
        Returns obtained surfaces after splitting as CompositeSurface

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_CompositeSurface

        """
        res = _ShapeUpgrade.ShapeUpgrade_SplitSurface_ResSurfaces(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitSurface_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitSurface_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.ShapeUpgrade_SplitSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeUpgrade.delete_ShapeUpgrade_SplitSurface
ShapeUpgrade_SplitSurface_swigregister = _ShapeUpgrade.ShapeUpgrade_SplitSurface_swigregister
ShapeUpgrade_SplitSurface_swigregister(ShapeUpgrade_SplitSurface)

def ShapeUpgrade_SplitSurface_get_type_name(*args):
    """
    ShapeUpgrade_SplitSurface_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeUpgrade.ShapeUpgrade_SplitSurface_get_type_name(*args)

def ShapeUpgrade_SplitSurface_get_type_descriptor(*args):
    """
    ShapeUpgrade_SplitSurface_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeUpgrade.ShapeUpgrade_SplitSurface_get_type_descriptor(*args)

class ShapeUpgrade_SplitCurve(Standard.Standard_Transient):
    """Splits a  curve with a  criterion."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeUpgrade_SplitCurve
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeUpgrade_SplitCurve(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeUpgrade_SplitCurve self) -> ShapeUpgrade_SplitCurve

        Empty constructor.


        """
        this = _ShapeUpgrade.new_ShapeUpgrade_SplitCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(ShapeUpgrade_SplitCurve self, Standard_Real const First, Standard_Real const Last)

        Initializes with curve first and last parameters.

        :type First: float
        :type Last: float

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitCurve_Init(self, *args)


    def SetSplitValues(self, *args):
        """
        SetSplitValues(ShapeUpgrade_SplitCurve self, Handle_TColStd_HSequenceOfReal SplitValues)

        Sets the parameters where splitting has to be done.

        :type SplitValues: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitCurve_SetSplitValues(self, *args)


    def Build(self, *args):
        """
        Build(ShapeUpgrade_SplitCurve self, Standard_Boolean const Segment)

        If Segment is True, the result is composed with
        segments of the curve bounded by the SplitValues.  If
        Segment is False, the result is composed with trimmed
        Curves all based on the same complete curve.

        :type Segment: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitCurve_Build(self, *args)


    def SplitValues(self, *args):
        """
        returns all the splitting values including the
        First and Last parameters of the input curve
        Merges input split values and new ones into myGlobalKnots

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        res = _ShapeUpgrade.ShapeUpgrade_SplitCurve_SplitValues(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Compute(self, *args):
        """
        Compute(ShapeUpgrade_SplitCurve self)

        Calculates points for correction/splitting of the curve


        """
        return _ShapeUpgrade.ShapeUpgrade_SplitCurve_Compute(self, *args)


    def Perform(self, *args):
        """
        Perform(ShapeUpgrade_SplitCurve self, Standard_Boolean const Segment)

        Performs correction/splitting of the curve.
        First defines splitting values by method Compute(), then calls method Build().

        :type Segment: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitCurve_Perform(self, *args)


    def Status(self, *args):
        """
        Status(ShapeUpgrade_SplitCurve self, ShapeExtend_Status const status) -> Standard_Boolean

        Returns the status
        OK    - no splitting is needed
        DONE1 - splitting required and gives more than one segment
        DONE2 - splitting is required, but gives only one segment (initial)
        DONE3 - geometric form of the curve or parametrisation is modified

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitCurve_Status(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitCurve_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitCurve_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.ShapeUpgrade_SplitCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeUpgrade.delete_ShapeUpgrade_SplitCurve
ShapeUpgrade_SplitCurve_swigregister = _ShapeUpgrade.ShapeUpgrade_SplitCurve_swigregister
ShapeUpgrade_SplitCurve_swigregister(ShapeUpgrade_SplitCurve)

def ShapeUpgrade_SplitCurve_get_type_name(*args):
    """
    ShapeUpgrade_SplitCurve_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeUpgrade.ShapeUpgrade_SplitCurve_get_type_name(*args)

def ShapeUpgrade_SplitCurve_get_type_descriptor(*args):
    """
    ShapeUpgrade_SplitCurve_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeUpgrade.ShapeUpgrade_SplitCurve_get_type_descriptor(*args)

class ShapeUpgrade_SplitCurve3d(ShapeUpgrade_SplitCurve):
    """Splits a 3d curve with a criterion."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeUpgrade_SplitCurve3d
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeUpgrade_SplitCurve3d(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeUpgrade_SplitCurve3d self) -> ShapeUpgrade_SplitCurve3d

        Empty constructor.


        """
        this = _ShapeUpgrade.new_ShapeUpgrade_SplitCurve3d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(ShapeUpgrade_SplitCurve3d self, Handle_Geom_Curve C)
        Init(ShapeUpgrade_SplitCurve3d self, Handle_Geom_Curve C, Standard_Real const First, Standard_Real const Last)

        Initializes with curve with its parameters.

        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type First: float
        :type Last: float

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitCurve3d_Init(self, *args)


    def Build(self, *args):
        """
        Build(ShapeUpgrade_SplitCurve3d self, Standard_Boolean const Segment)

        If Segment is True, the result is composed with
        segments of the curve bounded by the SplitValues.  If
        Segment is False, the result is composed with trimmed
        Curves all based on the same complete curve.

        :type Segment: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitCurve3d_Build(self, *args)


    def GetCurves(self, *args):
        """
        :rtype: OCC.wrapper.TColGeom.Handle_TColGeom_HArray1OfCurve

        """
        res = _ShapeUpgrade.ShapeUpgrade_SplitCurve3d_GetCurves(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitCurve3d_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitCurve3d_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.ShapeUpgrade_SplitCurve3d_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeUpgrade.delete_ShapeUpgrade_SplitCurve3d
ShapeUpgrade_SplitCurve3d_swigregister = _ShapeUpgrade.ShapeUpgrade_SplitCurve3d_swigregister
ShapeUpgrade_SplitCurve3d_swigregister(ShapeUpgrade_SplitCurve3d)

def ShapeUpgrade_SplitCurve3d_get_type_name(*args):
    """
    ShapeUpgrade_SplitCurve3d_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeUpgrade.ShapeUpgrade_SplitCurve3d_get_type_name(*args)

def ShapeUpgrade_SplitCurve3d_get_type_descriptor(*args):
    """
    ShapeUpgrade_SplitCurve3d_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeUpgrade.ShapeUpgrade_SplitCurve3d_get_type_descriptor(*args)

class ShapeUpgrade_Tool(Standard.Standard_Transient):
    """
    Tool is a root class for splitting classes
    Provides context for recording changes, basic
    precision value and limit (minimal and maximal)
    values for tolerances
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeUpgrade_Tool
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeUpgrade_Tool(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeUpgrade_Tool self) -> ShapeUpgrade_Tool

        Empty constructor


        """
        this = _ShapeUpgrade.new_ShapeUpgrade_Tool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Set(self, *args):
        """
        Set(ShapeUpgrade_Tool self, Handle_ShapeUpgrade_Tool tool)

        Copy all fields from another Root object

        :type tool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_Tool

        """
        return _ShapeUpgrade.ShapeUpgrade_Tool_Set(self, *args)


    def SetContext(self, *args):
        """
        SetContext(ShapeUpgrade_Tool self, Handle_ShapeBuild_ReShape context)

        Sets context

        :type context: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeUpgrade.ShapeUpgrade_Tool_SetContext(self, *args)


    def Context(self, *args):
        """
        Context(ShapeUpgrade_Tool self) -> Handle_ShapeBuild_ReShape

        Returns context

        :rtype: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeUpgrade.ShapeUpgrade_Tool_Context(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(ShapeUpgrade_Tool self, Standard_Real const preci)

        Sets basic precision value

        :type preci: float

        """
        return _ShapeUpgrade.ShapeUpgrade_Tool_SetPrecision(self, *args)


    def Precision(self, *args):
        """
        Precision(ShapeUpgrade_Tool self) -> Standard_Real

        Returns basic precision value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.ShapeUpgrade_Tool_Precision(self, *args)


    def SetMinTolerance(self, *args):
        """
        SetMinTolerance(ShapeUpgrade_Tool self, Standard_Real const mintol)

        Sets minimal allowed tolerance

        :type mintol: float

        """
        return _ShapeUpgrade.ShapeUpgrade_Tool_SetMinTolerance(self, *args)


    def MinTolerance(self, *args):
        """
        MinTolerance(ShapeUpgrade_Tool self) -> Standard_Real

        Returns minimal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.ShapeUpgrade_Tool_MinTolerance(self, *args)


    def SetMaxTolerance(self, *args):
        """
        SetMaxTolerance(ShapeUpgrade_Tool self, Standard_Real const maxtol)

        Sets maximal allowed tolerance

        :type maxtol: float

        """
        return _ShapeUpgrade.ShapeUpgrade_Tool_SetMaxTolerance(self, *args)


    def MaxTolerance(self, *args):
        """
        MaxTolerance(ShapeUpgrade_Tool self) -> Standard_Real

        Returns maximal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.ShapeUpgrade_Tool_MaxTolerance(self, *args)


    def LimitTolerance(self, *args):
        """
        LimitTolerance(ShapeUpgrade_Tool self, Standard_Real const toler) -> Standard_Real

        Returns tolerance limited by [myMinTol,myMaxTol]

        :type toler: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.ShapeUpgrade_Tool_LimitTolerance(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.ShapeUpgrade_Tool_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeUpgrade.ShapeUpgrade_Tool_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.ShapeUpgrade_Tool_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeUpgrade.delete_ShapeUpgrade_Tool
ShapeUpgrade_Tool_swigregister = _ShapeUpgrade.ShapeUpgrade_Tool_swigregister
ShapeUpgrade_Tool_swigregister(ShapeUpgrade_Tool)

def ShapeUpgrade_Tool_get_type_name(*args):
    """
    ShapeUpgrade_Tool_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeUpgrade.ShapeUpgrade_Tool_get_type_name(*args)

def ShapeUpgrade_Tool_get_type_descriptor(*args):
    """
    ShapeUpgrade_Tool_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeUpgrade.ShapeUpgrade_Tool_get_type_descriptor(*args)

class ShapeUpgrade_SplitCurve2d(ShapeUpgrade_SplitCurve):
    """Splits a 2d curve with a criterion."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeUpgrade_SplitCurve2d
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeUpgrade_SplitCurve2d(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeUpgrade_SplitCurve2d self) -> ShapeUpgrade_SplitCurve2d

        Empty constructor.


        """
        this = _ShapeUpgrade.new_ShapeUpgrade_SplitCurve2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(ShapeUpgrade_SplitCurve2d self, Handle_Geom2d_Curve C)
        Init(ShapeUpgrade_SplitCurve2d self, Handle_Geom2d_Curve C, Standard_Real const First, Standard_Real const Last)

        Initializes with pcurve with its parameters.

        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type First: float
        :type Last: float

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitCurve2d_Init(self, *args)


    def Build(self, *args):
        """
        Build(ShapeUpgrade_SplitCurve2d self, Standard_Boolean const Segment)

        If Segment is True, the result is composed with
        segments of the curve bounded by the SplitValues.  If
        Segment is False, the result is composed with trimmed
        Curves all based on the same complete curve.

        :type Segment: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitCurve2d_Build(self, *args)


    def GetCurves(self, *args):
        """
        :rtype: OCC.wrapper.TColGeom2d.Handle_TColGeom2d_HArray1OfCurve

        """
        res = _ShapeUpgrade.ShapeUpgrade_SplitCurve2d_GetCurves(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitCurve2d_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitCurve2d_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.ShapeUpgrade_SplitCurve2d_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeUpgrade.delete_ShapeUpgrade_SplitCurve2d
ShapeUpgrade_SplitCurve2d_swigregister = _ShapeUpgrade.ShapeUpgrade_SplitCurve2d_swigregister
ShapeUpgrade_SplitCurve2d_swigregister(ShapeUpgrade_SplitCurve2d)

def ShapeUpgrade_SplitCurve2d_get_type_name(*args):
    """
    ShapeUpgrade_SplitCurve2d_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeUpgrade.ShapeUpgrade_SplitCurve2d_get_type_name(*args)

def ShapeUpgrade_SplitCurve2d_get_type_descriptor(*args):
    """
    ShapeUpgrade_SplitCurve2d_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeUpgrade.ShapeUpgrade_SplitCurve2d_get_type_descriptor(*args)

class ShapeUpgrade_FaceDivide(ShapeUpgrade_Tool):
    """
    Divides a Face (both edges in the wires, by splitting
    curves and pcurves, and the face itself, by splitting
    supporting surface) according to splitting criteria.
    * The domain of the face to divide is defined by the PCurves
    of the wires on the Face.

    * all the PCurves are supposed to be defined (in the parametric
    space of the supporting surface).

    The result is available after the call to the Build method.
    It is a Shell containing all the resulting Faces.

    All the modifications made during splitting are recorded in the
    external context (ShapeBuild_ReShape).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeUpgrade_FaceDivide
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeUpgrade_FaceDivide(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeUpgrade_FaceDivide self) -> ShapeUpgrade_FaceDivide
        __init__(ShapeUpgrade_FaceDivide self, TopoDS_Face F) -> ShapeUpgrade_FaceDivide

        Initialize by a Face.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        this = _ShapeUpgrade.new_ShapeUpgrade_FaceDivide(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(ShapeUpgrade_FaceDivide self, TopoDS_Face F)

        Initialize by a Face.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _ShapeUpgrade.ShapeUpgrade_FaceDivide_Init(self, *args)


    def SetSurfaceSegmentMode(self, *args):
        """
        SetSurfaceSegmentMode(ShapeUpgrade_FaceDivide self, Standard_Boolean const Segment)

        Purpose sets mode for trimming (segment) surface by
        wire UV bounds.

        :type Segment: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_FaceDivide_SetSurfaceSegmentMode(self, *args)


    def Perform(self, *args):
        """
        Perform(ShapeUpgrade_FaceDivide self) -> Standard_Boolean

        Performs splitting and computes the resulting shell
        The context is used to keep track of former splittings
        in order to keep sharings. It is updated according to
        modifications made.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_FaceDivide_Perform(self, *args)


    def SplitSurface(self, *args):
        """
        SplitSurface(ShapeUpgrade_FaceDivide self) -> Standard_Boolean

        Performs splitting of surface and computes the shell
        from source face.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_FaceDivide_SplitSurface(self, *args)


    def SplitCurves(self, *args):
        """
        SplitCurves(ShapeUpgrade_FaceDivide self) -> Standard_Boolean

        Performs splitting of curves of all the edges in the
        shape and divides these edges.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_FaceDivide_SplitCurves(self, *args)


    def Result(self, *args):
        """
        Result(ShapeUpgrade_FaceDivide self) -> TopoDS_Shape

        Gives the resulting Shell, or Face, or Null shape if not done.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeUpgrade.ShapeUpgrade_FaceDivide_Result(self, *args)


    def Status(self, *args):
        """
        Status(ShapeUpgrade_FaceDivide self, ShapeExtend_Status const status) -> Standard_Boolean

        Queries the status of last call to Perform
        OK   : no splitting was done (or no call to Perform)
        DONE1: some edges were splitted
        DONE2: surface was splitted
        DONE3: surface was modified without splitting
        FAIL1: some fails encountered during splitting wires
        FAIL2: face cannot be splitted

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_FaceDivide_Status(self, *args)


    def SetSplitSurfaceTool(self, *args):
        """
        SetSplitSurfaceTool(ShapeUpgrade_FaceDivide self, Handle_ShapeUpgrade_SplitSurface splitSurfaceTool)

        Sets the tool for splitting surfaces.

        :type splitSurfaceTool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface

        """
        return _ShapeUpgrade.ShapeUpgrade_FaceDivide_SetSplitSurfaceTool(self, *args)


    def SetWireDivideTool(self, *args):
        """
        SetWireDivideTool(ShapeUpgrade_FaceDivide self, Handle_ShapeUpgrade_WireDivide wireDivideTool)

        Sets the tool for dividing edges on Face.

        :type wireDivideTool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_WireDivide

        """
        return _ShapeUpgrade.ShapeUpgrade_FaceDivide_SetWireDivideTool(self, *args)


    def GetSplitSurfaceTool(self, *args):
        """
        GetSplitSurfaceTool(ShapeUpgrade_FaceDivide self) -> Handle_ShapeUpgrade_SplitSurface

        Returns the tool for splitting surfaces.
        This tool must be already initialized.

        :rtype: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface

        """
        return _ShapeUpgrade.ShapeUpgrade_FaceDivide_GetSplitSurfaceTool(self, *args)


    def GetWireDivideTool(self, *args):
        """
        GetWireDivideTool(ShapeUpgrade_FaceDivide self) -> Handle_ShapeUpgrade_WireDivide

        Returns the tool for dividing edges on Face.
        This tool must be already initialized.

        :rtype: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_WireDivide

        """
        return _ShapeUpgrade.ShapeUpgrade_FaceDivide_GetWireDivideTool(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.ShapeUpgrade_FaceDivide_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeUpgrade.ShapeUpgrade_FaceDivide_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.ShapeUpgrade_FaceDivide_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeUpgrade.delete_ShapeUpgrade_FaceDivide
ShapeUpgrade_FaceDivide_swigregister = _ShapeUpgrade.ShapeUpgrade_FaceDivide_swigregister
ShapeUpgrade_FaceDivide_swigregister(ShapeUpgrade_FaceDivide)

def ShapeUpgrade_FaceDivide_get_type_name(*args):
    """
    ShapeUpgrade_FaceDivide_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeUpgrade.ShapeUpgrade_FaceDivide_get_type_name(*args)

def ShapeUpgrade_FaceDivide_get_type_descriptor(*args):
    """
    ShapeUpgrade_FaceDivide_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeUpgrade.ShapeUpgrade_FaceDivide_get_type_descriptor(*args)

class ShapeUpgrade_RemoveLocations(Standard.Standard_Transient):
    """Removes all locations sub-shapes of specified shape"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeUpgrade_RemoveLocations
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeUpgrade_RemoveLocations(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeUpgrade_RemoveLocations self) -> ShapeUpgrade_RemoveLocations

        Empy constructor


        """
        this = _ShapeUpgrade.new_ShapeUpgrade_RemoveLocations(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Remove(self, *args):
        """
        Remove(ShapeUpgrade_RemoveLocations self, TopoDS_Shape theShape) -> Standard_Boolean

        Removes all location correspodingly to RemoveLevel.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_RemoveLocations_Remove(self, *args)


    def GetResult(self, *args):
        """
        GetResult(ShapeUpgrade_RemoveLocations self) -> TopoDS_Shape

        Returns shape with removed locatins.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeUpgrade.ShapeUpgrade_RemoveLocations_GetResult(self, *args)


    def SetRemoveLevel(self, *args):
        """
        SetRemoveLevel(ShapeUpgrade_RemoveLocations self, TopAbs_ShapeEnum const theLevel)

        sets level starting with that location will be removed,
        by default TopAbs_SHAPE. In this case locations will be kept for specified shape
        and if specified shape is TopAbs_COMPOUND for sub-shapes of first level.

        :type theLevel: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _ShapeUpgrade.ShapeUpgrade_RemoveLocations_SetRemoveLevel(self, *args)


    def RemoveLevel(self, *args):
        """
        RemoveLevel(ShapeUpgrade_RemoveLocations self) -> TopAbs_ShapeEnum

        sets level starting with that location will be removed.Value of level can be set to
        TopAbs_SHAPE,TopAbs_COMPOUND,TopAbs_SOLID,TopAbs_SHELL,TopAbs_FACE.By default TopAbs_SHAPE.
        In this case location will be removed for all shape types for exception of compound.

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _ShapeUpgrade.ShapeUpgrade_RemoveLocations_RemoveLevel(self, *args)


    def ModifiedShape(self, *args):
        """
        ModifiedShape(ShapeUpgrade_RemoveLocations self, TopoDS_Shape theInitShape) -> TopoDS_Shape

        Returns modified shape obtained from initial shape.

        :type theInitShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeUpgrade.ShapeUpgrade_RemoveLocations_ModifiedShape(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.ShapeUpgrade_RemoveLocations_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeUpgrade.ShapeUpgrade_RemoveLocations_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.ShapeUpgrade_RemoveLocations_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeUpgrade.delete_ShapeUpgrade_RemoveLocations
ShapeUpgrade_RemoveLocations_swigregister = _ShapeUpgrade.ShapeUpgrade_RemoveLocations_swigregister
ShapeUpgrade_RemoveLocations_swigregister(ShapeUpgrade_RemoveLocations)

def ShapeUpgrade_RemoveLocations_get_type_name(*args):
    """
    ShapeUpgrade_RemoveLocations_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeUpgrade.ShapeUpgrade_RemoveLocations_get_type_name(*args)

def ShapeUpgrade_RemoveLocations_get_type_descriptor(*args):
    """
    ShapeUpgrade_RemoveLocations_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeUpgrade.ShapeUpgrade_RemoveLocations_get_type_descriptor(*args)

class ShapeUpgrade_ShapeDivide(object):
    """Divides a all faces in shell with given criteria Shell."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ShapeUpgrade_ShapeDivide self) -> ShapeUpgrade_ShapeDivide
        __init__(ShapeUpgrade_ShapeDivide self, TopoDS_Shape S) -> ShapeUpgrade_ShapeDivide

        Initialize by a Shape.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _ShapeUpgrade.new_ShapeUpgrade_ShapeDivide(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(ShapeUpgrade_ShapeDivide self, TopoDS_Shape S)

        Initialize by a Shape.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeDivide_Init(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(ShapeUpgrade_ShapeDivide self, Standard_Real const Prec)

        Defines the spatial precision used for splitting

        :type Prec: float

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeDivide_SetPrecision(self, *args)


    def SetMaxTolerance(self, *args):
        """
        SetMaxTolerance(ShapeUpgrade_ShapeDivide self, Standard_Real const maxtol)

        Sets maximal allowed tolerance

        :type maxtol: float

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeDivide_SetMaxTolerance(self, *args)


    def SetMinTolerance(self, *args):
        """
        SetMinTolerance(ShapeUpgrade_ShapeDivide self, Standard_Real const mintol)

        Sets minimal allowed tolerance

        :type mintol: float

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeDivide_SetMinTolerance(self, *args)


    def SetSurfaceSegmentMode(self, *args):
        """
        SetSurfaceSegmentMode(ShapeUpgrade_ShapeDivide self, Standard_Boolean const Segment)

        Purpose sets mode for trimming (segment) surface by
        wire UV bounds.

        :type Segment: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeDivide_SetSurfaceSegmentMode(self, *args)


    def Perform(self, *args):
        """
        Perform(ShapeUpgrade_ShapeDivide self, Standard_Boolean const newContext) -> Standard_Boolean

        Performs splitting and computes the resulting shape
        If newContext is True (default), the internal context
        will be cleared at start, else previous substitutions
        will be acting.

        :type newContext: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeDivide_Perform(self, *args)


    def Result(self, *args):
        """
        Result(ShapeUpgrade_ShapeDivide self) -> TopoDS_Shape

        Gives the resulting Shape, or Null shape if not done.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeDivide_Result(self, *args)


    def GetContext(self, *args):
        """
        GetContext(ShapeUpgrade_ShapeDivide self) -> Handle_ShapeBuild_ReShape

        Returns context with all the modifications made during
        last call(s) to Perform() recorded

        :rtype: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeDivide_GetContext(self, *args)


    def SetContext(self, *args):
        """
        SetContext(ShapeUpgrade_ShapeDivide self, Handle_ShapeBuild_ReShape context)

        Sets context with recorded modifications to be applied
        during next call(s) to Perform(shape,Standard_False)

        :type context: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeDivide_SetContext(self, *args)


    def SetMsgRegistrator(self, *args):
        """
        SetMsgRegistrator(ShapeUpgrade_ShapeDivide self, Handle_ShapeExtend_BasicMsgRegistrator msgreg)

        Sets message registrator

        :type msgreg: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeDivide_SetMsgRegistrator(self, *args)


    def MsgRegistrator(self, *args):
        """
        MsgRegistrator(ShapeUpgrade_ShapeDivide self) -> Handle_ShapeExtend_BasicMsgRegistrator

        Returns message registrator

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeDivide_MsgRegistrator(self, *args)


    def SendMsg(self, *args):
        """
        SendMsg(ShapeUpgrade_ShapeDivide self, TopoDS_Shape shape, Message_Msg message, Message_Gravity const gravity=Message_Info)

        Sends a message to be attached to the shape.
        Calls corresponding message of message registrator.

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type message: OCC.wrapper.Message.Message_Msg
        :type gravity: OCC.wrapper.Message.Message_Gravity

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeDivide_SendMsg(self, *args)


    def Status(self, *args):
        """
        Status(ShapeUpgrade_ShapeDivide self, ShapeExtend_Status const status) -> Standard_Boolean

        Queries the status of last call to Perform
        OK   : no splitting was done (or no call to Perform)
        DONE1: some edges were splitted
        DONE2: surface was splitted
        FAIL1: some errors occured

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeDivide_Status(self, *args)


    def SetSplitFaceTool(self, *args):
        """
        SetSplitFaceTool(ShapeUpgrade_ShapeDivide self, Handle_ShapeUpgrade_FaceDivide splitFaceTool)

        Sets the tool for splitting faces.

        :type splitFaceTool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeDivide_SetSplitFaceTool(self, *args)


    def SetEdgeMode(self, *args):
        """
        SetEdgeMode(ShapeUpgrade_ShapeDivide self, Standard_Integer const aEdgeMode)

        Sets mode for splitting 3d curves from edges.
        0 - only curve 3d from free edges.
        1 - only curve 3d from shared edges.
        2 -  all curve 3d.

        :type aEdgeMode: int

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeDivide_SetEdgeMode(self, *args)

    __swig_destroy__ = _ShapeUpgrade.delete_ShapeUpgrade_ShapeDivide
ShapeUpgrade_ShapeDivide_swigregister = _ShapeUpgrade.ShapeUpgrade_ShapeDivide_swigregister
ShapeUpgrade_ShapeDivide_swigregister(ShapeUpgrade_ShapeDivide)

class ShapeUpgrade_SplitSurfaceContinuity(ShapeUpgrade_SplitSurface):
    """
    Splits a Surface with a continuity criterion.
    At the present moment C1 criterion is used only.
    This tool works with tolerance. If C0 surface can be corrected
    at a knot with given tolerance then the surface is corrected,
    otherwise it is spltted at that knot.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeUpgrade_SplitSurfaceContinuity
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeUpgrade_SplitSurfaceContinuity(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeUpgrade_SplitSurfaceContinuity self) -> ShapeUpgrade_SplitSurfaceContinuity

        Empty constructor.


        """
        this = _ShapeUpgrade.new_ShapeUpgrade_SplitSurfaceContinuity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetCriterion(self, *args):
        """
        SetCriterion(ShapeUpgrade_SplitSurfaceContinuity self, GeomAbs_Shape const Criterion)

        Sets criterion for splitting.

        :type Criterion: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitSurfaceContinuity_SetCriterion(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(ShapeUpgrade_SplitSurfaceContinuity self, Standard_Real const Tol)

        Sets tolerance.

        :type Tol: float

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitSurfaceContinuity_SetTolerance(self, *args)


    def Compute(self, *args):
        """
        Compute(ShapeUpgrade_SplitSurfaceContinuity self, Standard_Boolean const Segment)

        :type Segment: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitSurfaceContinuity_Compute(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitSurfaceContinuity_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitSurfaceContinuity_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.ShapeUpgrade_SplitSurfaceContinuity_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeUpgrade.delete_ShapeUpgrade_SplitSurfaceContinuity
ShapeUpgrade_SplitSurfaceContinuity_swigregister = _ShapeUpgrade.ShapeUpgrade_SplitSurfaceContinuity_swigregister
ShapeUpgrade_SplitSurfaceContinuity_swigregister(ShapeUpgrade_SplitSurfaceContinuity)

def ShapeUpgrade_SplitSurfaceContinuity_get_type_name(*args):
    """
    ShapeUpgrade_SplitSurfaceContinuity_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeUpgrade.ShapeUpgrade_SplitSurfaceContinuity_get_type_name(*args)

def ShapeUpgrade_SplitSurfaceContinuity_get_type_descriptor(*args):
    """
    ShapeUpgrade_SplitSurfaceContinuity_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeUpgrade.ShapeUpgrade_SplitSurfaceContinuity_get_type_descriptor(*args)

class ShapeUpgrade_RemoveInternalWires(ShapeUpgrade_Tool):
    """Removes all internal wires having area less than specified min area"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeUpgrade_RemoveInternalWires
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeUpgrade_RemoveInternalWires(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeUpgrade_RemoveInternalWires self) -> ShapeUpgrade_RemoveInternalWires
        __init__(ShapeUpgrade_RemoveInternalWires self, TopoDS_Shape theShape) -> ShapeUpgrade_RemoveInternalWires

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _ShapeUpgrade.new_ShapeUpgrade_RemoveInternalWires(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(ShapeUpgrade_RemoveInternalWires self, TopoDS_Shape theShape)

        Initialize by a Shape.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeUpgrade.ShapeUpgrade_RemoveInternalWires_Init(self, *args)


    def Perform(self, *args):
        """
        Perform(ShapeUpgrade_RemoveInternalWires self) -> Standard_Boolean
        Perform(ShapeUpgrade_RemoveInternalWires self, NCollection_Sequence_TopoDS_Shape theSeqShapes) -> Standard_Boolean

        If specified sequence of shape contains -
        1.wires then these wires will be removed if they have area less than allowed min area.
        2.faces than internal wires from these faces will be removed if they have area less than allowed min area.

        :type theSeqShapes: OCC.wrapper.TopTools.TopTools_SequenceOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_RemoveInternalWires_Perform(self, *args)


    def GetResult(self, *args):
        """
        GetResult(ShapeUpgrade_RemoveInternalWires self) -> TopoDS_Shape

        Get result shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeUpgrade.ShapeUpgrade_RemoveInternalWires_GetResult(self, *args)


    def MinArea(self, *args):
        """
        MinArea(ShapeUpgrade_RemoveInternalWires self) -> Standard_Real &

        Set min area allowed for holes( all holes having area less than mi area will be removed)

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.ShapeUpgrade_RemoveInternalWires_MinArea(self, *args)


    def RemoveFaceMode(self, *args):
        """
        RemoveFaceMode(ShapeUpgrade_RemoveInternalWires self) -> Standard_Boolean &

        Set mode which manage removing faces which have outer wires consisting only from edges
        belonginig to removed internal wires.
        By default it is equal to true.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_RemoveInternalWires_RemoveFaceMode(self, *args)


    def RemovedFaces(self, *args):
        """
        Returns sequence of removed faces.

        :rtype: OCC.wrapper.TopTools.TopTools_SequenceOfShape

        """
        res = _ShapeUpgrade.ShapeUpgrade_RemoveInternalWires_RemovedFaces(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RemovedWires(self, *args):
        """
        Returns sequence of removed faces.

        :rtype: OCC.wrapper.TopTools.TopTools_SequenceOfShape

        """
        res = _ShapeUpgrade.ShapeUpgrade_RemoveInternalWires_RemovedWires(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Status(self, *args):
        """
        Status(ShapeUpgrade_RemoveInternalWires self, ShapeExtend_Status const theStatus) -> Standard_Boolean

        Queries status of last call to Perform()
        : OK - nothing was done
        :DONE1 - internal wires were removed
        :DONE2 - small faces were removed.
        :FAIL1 - initial shape is not specified
        :FAIL2 - specified sub-shape is not belonged to inotial shape.

        :type theStatus: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_RemoveInternalWires_Status(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.ShapeUpgrade_RemoveInternalWires_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeUpgrade.ShapeUpgrade_RemoveInternalWires_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.ShapeUpgrade_RemoveInternalWires_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeUpgrade.delete_ShapeUpgrade_RemoveInternalWires
ShapeUpgrade_RemoveInternalWires_swigregister = _ShapeUpgrade.ShapeUpgrade_RemoveInternalWires_swigregister
ShapeUpgrade_RemoveInternalWires_swigregister(ShapeUpgrade_RemoveInternalWires)

def ShapeUpgrade_RemoveInternalWires_get_type_name(*args):
    """
    ShapeUpgrade_RemoveInternalWires_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeUpgrade.ShapeUpgrade_RemoveInternalWires_get_type_name(*args)

def ShapeUpgrade_RemoveInternalWires_get_type_descriptor(*args):
    """
    ShapeUpgrade_RemoveInternalWires_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeUpgrade.ShapeUpgrade_RemoveInternalWires_get_type_descriptor(*args)

class ShapeUpgrade_ClosedFaceDivide(ShapeUpgrade_FaceDivide):
    """
    Divides a Face with one or more seam edge to avoid closed faces.
    Splitting is performed by U and V direction. The number of
    resulting faces can be defined by user.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeUpgrade_ClosedFaceDivide
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeUpgrade_ClosedFaceDivide(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeUpgrade_ClosedFaceDivide self) -> ShapeUpgrade_ClosedFaceDivide
        __init__(ShapeUpgrade_ClosedFaceDivide self, TopoDS_Face F) -> ShapeUpgrade_ClosedFaceDivide

        Initialize by a Face.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        this = _ShapeUpgrade.new_ShapeUpgrade_ClosedFaceDivide(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SplitSurface(self, *args):
        """
        SplitSurface(ShapeUpgrade_ClosedFaceDivide self) -> Standard_Boolean

        Performs splitting of surface and computes the shell
        from source face.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_ClosedFaceDivide_SplitSurface(self, *args)


    def SetNbSplitPoints(self, *args):
        """
        SetNbSplitPoints(ShapeUpgrade_ClosedFaceDivide self, Standard_Integer const num)

        Sets the number of cutting lines by which closed face
        will be splitted. The resulting faces will be num+1.

        :type num: int

        """
        return _ShapeUpgrade.ShapeUpgrade_ClosedFaceDivide_SetNbSplitPoints(self, *args)


    def GetNbSplitPoints(self, *args):
        """
        GetNbSplitPoints(ShapeUpgrade_ClosedFaceDivide self) -> Standard_Integer

        Returns the number of splitting points

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.ShapeUpgrade_ClosedFaceDivide_GetNbSplitPoints(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.ShapeUpgrade_ClosedFaceDivide_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeUpgrade.ShapeUpgrade_ClosedFaceDivide_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.ShapeUpgrade_ClosedFaceDivide_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeUpgrade.delete_ShapeUpgrade_ClosedFaceDivide
ShapeUpgrade_ClosedFaceDivide_swigregister = _ShapeUpgrade.ShapeUpgrade_ClosedFaceDivide_swigregister
ShapeUpgrade_ClosedFaceDivide_swigregister(ShapeUpgrade_ClosedFaceDivide)

def ShapeUpgrade_ClosedFaceDivide_get_type_name(*args):
    """
    ShapeUpgrade_ClosedFaceDivide_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeUpgrade.ShapeUpgrade_ClosedFaceDivide_get_type_name(*args)

def ShapeUpgrade_ClosedFaceDivide_get_type_descriptor(*args):
    """
    ShapeUpgrade_ClosedFaceDivide_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeUpgrade.ShapeUpgrade_ClosedFaceDivide_get_type_descriptor(*args)

class ShapeUpgrade_ConvertSurfaceToBezierBasis(ShapeUpgrade_SplitSurface):
    """
    Converts a plane, bspline surface, surface of revolution, surface
    of extrusion, offset surface to grid of bezier basis surface (
    bezier surface,
    surface of revolution based on bezier curve,
    offset surface based on any previous type).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeUpgrade_ConvertSurfaceToBezierBasis self) -> ShapeUpgrade_ConvertSurfaceToBezierBasis

        Empty constructor.


        """
        this = _ShapeUpgrade.new_ShapeUpgrade_ConvertSurfaceToBezierBasis(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Build(self, *args):
        """
        Build(ShapeUpgrade_ConvertSurfaceToBezierBasis self, Standard_Boolean const Segment)

        Splits a list of beziers computed by Compute method according
        the split values and splitting parameters.

        :type Segment: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_ConvertSurfaceToBezierBasis_Build(self, *args)


    def Compute(self, *args):
        """
        Compute(ShapeUpgrade_ConvertSurfaceToBezierBasis self, Standard_Boolean const Segment)

        Converts surface into a grid of bezier based surfaces, and
        stores this grid.

        :type Segment: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_ConvertSurfaceToBezierBasis_Compute(self, *args)


    def Segments(self, *args):
        """
        Segments(ShapeUpgrade_ConvertSurfaceToBezierBasis self) -> Handle_ShapeExtend_CompositeSurface

        Returns the grid of bezier based surfaces correspondent to
        original surface.

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_CompositeSurface

        """
        return _ShapeUpgrade.ShapeUpgrade_ConvertSurfaceToBezierBasis_Segments(self, *args)


    def SetPlaneMode(self, *args):
        """
        SetPlaneMode(ShapeUpgrade_ConvertSurfaceToBezierBasis self, Standard_Boolean const mode)

        Sets mode for conversion Geom_Plane to Bezier

        :type mode: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_ConvertSurfaceToBezierBasis_SetPlaneMode(self, *args)


    def GetPlaneMode(self, *args):
        """
        GetPlaneMode(ShapeUpgrade_ConvertSurfaceToBezierBasis self) -> Standard_Boolean

        Returns the Geom_Pline conversion mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_ConvertSurfaceToBezierBasis_GetPlaneMode(self, *args)


    def SetRevolutionMode(self, *args):
        """
        SetRevolutionMode(ShapeUpgrade_ConvertSurfaceToBezierBasis self, Standard_Boolean const mode)

        Sets mode for conversion Geom_SurfaceOfRevolution to Bezier

        :type mode: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_ConvertSurfaceToBezierBasis_SetRevolutionMode(self, *args)


    def GetRevolutionMode(self, *args):
        """
        GetRevolutionMode(ShapeUpgrade_ConvertSurfaceToBezierBasis self) -> Standard_Boolean

        Returns the Geom_SurfaceOfRevolution conversion mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_ConvertSurfaceToBezierBasis_GetRevolutionMode(self, *args)


    def SetExtrusionMode(self, *args):
        """
        SetExtrusionMode(ShapeUpgrade_ConvertSurfaceToBezierBasis self, Standard_Boolean const mode)

        Sets mode for conversion Geom_SurfaceOfLinearExtrusion to Bezier

        :type mode: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_ConvertSurfaceToBezierBasis_SetExtrusionMode(self, *args)


    def GetExtrusionMode(self, *args):
        """
        GetExtrusionMode(ShapeUpgrade_ConvertSurfaceToBezierBasis self) -> Standard_Boolean

        Returns the Geom_SurfaceOfLinearExtrusion conversion mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_ConvertSurfaceToBezierBasis_GetExtrusionMode(self, *args)


    def SetBSplineMode(self, *args):
        """
        SetBSplineMode(ShapeUpgrade_ConvertSurfaceToBezierBasis self, Standard_Boolean const mode)

        Sets mode for conversion Geom_BSplineSurface to Bezier

        :type mode: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_ConvertSurfaceToBezierBasis_SetBSplineMode(self, *args)


    def GetBSplineMode(self, *args):
        """
        GetBSplineMode(ShapeUpgrade_ConvertSurfaceToBezierBasis self) -> Standard_Boolean

        Returns the Geom_BSplineSurface conversion mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_ConvertSurfaceToBezierBasis_GetBSplineMode(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.ShapeUpgrade_ConvertSurfaceToBezierBasis_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeUpgrade.ShapeUpgrade_ConvertSurfaceToBezierBasis_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.ShapeUpgrade_ConvertSurfaceToBezierBasis_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeUpgrade.delete_ShapeUpgrade_ConvertSurfaceToBezierBasis
ShapeUpgrade_ConvertSurfaceToBezierBasis_swigregister = _ShapeUpgrade.ShapeUpgrade_ConvertSurfaceToBezierBasis_swigregister
ShapeUpgrade_ConvertSurfaceToBezierBasis_swigregister(ShapeUpgrade_ConvertSurfaceToBezierBasis)

def ShapeUpgrade_ConvertSurfaceToBezierBasis_get_type_name(*args):
    """
    ShapeUpgrade_ConvertSurfaceToBezierBasis_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeUpgrade.ShapeUpgrade_ConvertSurfaceToBezierBasis_get_type_name(*args)

def ShapeUpgrade_ConvertSurfaceToBezierBasis_get_type_descriptor(*args):
    """
    ShapeUpgrade_ConvertSurfaceToBezierBasis_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeUpgrade.ShapeUpgrade_ConvertSurfaceToBezierBasis_get_type_descriptor(*args)

class ShapeUpgrade_ConvertCurve3dToBezier(ShapeUpgrade_SplitCurve3d):
    """converts/splits a 3d curve of any type to a list of beziers"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeUpgrade_ConvertCurve3dToBezier
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeUpgrade_ConvertCurve3dToBezier(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeUpgrade_ConvertCurve3dToBezier self) -> ShapeUpgrade_ConvertCurve3dToBezier

        Empty constructor


        """
        this = _ShapeUpgrade.new_ShapeUpgrade_ConvertCurve3dToBezier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetLineMode(self, *args):
        """
        SetLineMode(ShapeUpgrade_ConvertCurve3dToBezier self, Standard_Boolean const mode)

        Sets mode for conversion Geom_Line to bezier.

        :type mode: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_ConvertCurve3dToBezier_SetLineMode(self, *args)


    def GetLineMode(self, *args):
        """
        GetLineMode(ShapeUpgrade_ConvertCurve3dToBezier self) -> Standard_Boolean

        Returns the Geom_Line conversion mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_ConvertCurve3dToBezier_GetLineMode(self, *args)


    def SetCircleMode(self, *args):
        """
        SetCircleMode(ShapeUpgrade_ConvertCurve3dToBezier self, Standard_Boolean const mode)

        Sets mode for conversion Geom_Circle to bezier.

        :type mode: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_ConvertCurve3dToBezier_SetCircleMode(self, *args)


    def GetCircleMode(self, *args):
        """
        GetCircleMode(ShapeUpgrade_ConvertCurve3dToBezier self) -> Standard_Boolean

        Returns the Geom_Circle conversion mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_ConvertCurve3dToBezier_GetCircleMode(self, *args)


    def SetConicMode(self, *args):
        """
        SetConicMode(ShapeUpgrade_ConvertCurve3dToBezier self, Standard_Boolean const mode)

        Returns the Geom_Conic conversion mode.

        :type mode: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_ConvertCurve3dToBezier_SetConicMode(self, *args)


    def GetConicMode(self, *args):
        """
        GetConicMode(ShapeUpgrade_ConvertCurve3dToBezier self) -> Standard_Boolean

        Performs converting and computes the resulting shape.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_ConvertCurve3dToBezier_GetConicMode(self, *args)


    def Compute(self, *args):
        """
        Compute(ShapeUpgrade_ConvertCurve3dToBezier self)

        Converts curve into a list of beziers, and stores the
        splitting parameters on original curve.


        """
        return _ShapeUpgrade.ShapeUpgrade_ConvertCurve3dToBezier_Compute(self, *args)


    def Build(self, *args):
        """
        Build(ShapeUpgrade_ConvertCurve3dToBezier self, Standard_Boolean const Segment)

        Splits a list of beziers computed by Compute method according
        the split values and splitting parameters.

        :type Segment: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_ConvertCurve3dToBezier_Build(self, *args)


    def SplitParams(self, *args):
        """
        SplitParams(ShapeUpgrade_ConvertCurve3dToBezier self) -> Handle_TColStd_HSequenceOfReal

        Returns the list of splitted parameters in original curve
        parametrisation.

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        return _ShapeUpgrade.ShapeUpgrade_ConvertCurve3dToBezier_SplitParams(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.ShapeUpgrade_ConvertCurve3dToBezier_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeUpgrade.ShapeUpgrade_ConvertCurve3dToBezier_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.ShapeUpgrade_ConvertCurve3dToBezier_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeUpgrade.delete_ShapeUpgrade_ConvertCurve3dToBezier
ShapeUpgrade_ConvertCurve3dToBezier_swigregister = _ShapeUpgrade.ShapeUpgrade_ConvertCurve3dToBezier_swigregister
ShapeUpgrade_ConvertCurve3dToBezier_swigregister(ShapeUpgrade_ConvertCurve3dToBezier)

def ShapeUpgrade_ConvertCurve3dToBezier_get_type_name(*args):
    """
    ShapeUpgrade_ConvertCurve3dToBezier_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeUpgrade.ShapeUpgrade_ConvertCurve3dToBezier_get_type_name(*args)

def ShapeUpgrade_ConvertCurve3dToBezier_get_type_descriptor(*args):
    """
    ShapeUpgrade_ConvertCurve3dToBezier_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeUpgrade.ShapeUpgrade_ConvertCurve3dToBezier_get_type_descriptor(*args)

class ShapeUpgrade_WireDivide(ShapeUpgrade_Tool):
    """
    Divides edges in the wire lying on the face or free wires or
    free edges with a criterion.
    Splits 3D curve and pcurve(s) of the edge on the face.
    Other pcurves which may be associated with the edge are simply
    copied.
    If 3D curve is splitted then pcurve on the face is splitted as
    well, and wice-versa.
    Input shape is not modified.
    The modifications made are recorded in external context
    (ShapeBuild_ReShape). This tool is applied to all edges
    before splitting them in order to keep sharing.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeUpgrade_WireDivide
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeUpgrade_WireDivide(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeUpgrade_WireDivide self) -> ShapeUpgrade_WireDivide

        Empty constructor


        """
        this = _ShapeUpgrade.new_ShapeUpgrade_WireDivide(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(ShapeUpgrade_WireDivide self, TopoDS_Wire W, TopoDS_Face F)
        Init(ShapeUpgrade_WireDivide self, TopoDS_Wire W, Handle_Geom_Surface S)

        Initializes by wire and surface

        :type W: OCC.wrapper.TopoDS.TopoDS_Wire
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _ShapeUpgrade.ShapeUpgrade_WireDivide_Init(self, *args)


    def Load(self, *args):
        """
        Load(ShapeUpgrade_WireDivide self, TopoDS_Wire W)
        Load(ShapeUpgrade_WireDivide self, TopoDS_Edge E)

        Creates wire of one edge and calls Load for wire

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _ShapeUpgrade.ShapeUpgrade_WireDivide_Load(self, *args)


    def SetFace(self, *args):
        """
        SetFace(ShapeUpgrade_WireDivide self, TopoDS_Face F)

        Sets supporting surface by face

        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _ShapeUpgrade.ShapeUpgrade_WireDivide_SetFace(self, *args)


    def SetSurface(self, *args):
        """
        SetSurface(ShapeUpgrade_WireDivide self, Handle_Geom_Surface S)
        SetSurface(ShapeUpgrade_WireDivide self, Handle_Geom_Surface S, TopLoc_Location L)

        Sets supporting surface with location

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _ShapeUpgrade.ShapeUpgrade_WireDivide_SetSurface(self, *args)


    def Perform(self, *args):
        """
        Perform(ShapeUpgrade_WireDivide self)

        Computes the resulting wire by splitting all the edges
        according to splitting criteria.
        All the modifications made are recorded in context
        (ShapeBuild_ReShape). This tool is applied to all edges
        before splitting them in order to keep sharings.
        If no supporting face or surface is defined, only 3d
        splitting criteria are used.


        """
        return _ShapeUpgrade.ShapeUpgrade_WireDivide_Perform(self, *args)


    def Wire(self, *args):
        """
        Gives the resulting Wire (equal to initial one if not done
        or Null if not loaded)

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        res = _ShapeUpgrade.ShapeUpgrade_WireDivide_Wire(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Status(self, *args):
        """
        Status(ShapeUpgrade_WireDivide self, ShapeExtend_Status const status) -> Standard_Boolean

        Queries status of last call to Perform()
        OK - no edges were splitted, wire left untouched
        DONE1 - some edges were splitted
        FAIL1 - some edges have no 3d curve (skipped)
        FAIL2 - some edges have no pcurve (skipped)

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_WireDivide_Status(self, *args)


    def SetSplitCurve3dTool(self, *args):
        """
        SetSplitCurve3dTool(ShapeUpgrade_WireDivide self, Handle_ShapeUpgrade_SplitCurve3d splitCurve3dTool)

        Sets the tool for splitting 3D curves.

        :type splitCurve3dTool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d

        """
        return _ShapeUpgrade.ShapeUpgrade_WireDivide_SetSplitCurve3dTool(self, *args)


    def SetSplitCurve2dTool(self, *args):
        """
        SetSplitCurve2dTool(ShapeUpgrade_WireDivide self, Handle_ShapeUpgrade_SplitCurve2d splitCurve2dTool)

        Sets the tool for splitting pcurves.

        :type splitCurve2dTool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d

        """
        return _ShapeUpgrade.ShapeUpgrade_WireDivide_SetSplitCurve2dTool(self, *args)


    def SetTransferParamTool(self, *args):
        """
        SetTransferParamTool(ShapeUpgrade_WireDivide self, Handle_ShapeAnalysis_TransferParameters TransferParam)

        Sets the tool for Transfer parameters between curves and pcurves.

        :type TransferParam: OCC.wrapper.ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters

        """
        return _ShapeUpgrade.ShapeUpgrade_WireDivide_SetTransferParamTool(self, *args)


    def SetEdgeDivideTool(self, *args):
        """
        SetEdgeDivideTool(ShapeUpgrade_WireDivide self, Handle_ShapeUpgrade_EdgeDivide edgeDivideTool)

        Sets tool for splitting edge

        :type edgeDivideTool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide

        """
        return _ShapeUpgrade.ShapeUpgrade_WireDivide_SetEdgeDivideTool(self, *args)


    def GetEdgeDivideTool(self, *args):
        """
        GetEdgeDivideTool(ShapeUpgrade_WireDivide self) -> Handle_ShapeUpgrade_EdgeDivide

        returns tool for splitting edges

        :rtype: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide

        """
        return _ShapeUpgrade.ShapeUpgrade_WireDivide_GetEdgeDivideTool(self, *args)


    def GetTransferParamTool(self, *args):
        """
        GetTransferParamTool(ShapeUpgrade_WireDivide self) -> Handle_ShapeAnalysis_TransferParameters

        Returns the tool for Transfer of parameters.

        :rtype: OCC.wrapper.ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters

        """
        return _ShapeUpgrade.ShapeUpgrade_WireDivide_GetTransferParamTool(self, *args)


    def SetEdgeMode(self, *args):
        """
        SetEdgeMode(ShapeUpgrade_WireDivide self, Standard_Integer const EdgeMode)

        Sets mode for splitting 3d curves from edges.
        0 - only curve 3d from free edges.
        1 - only curve 3d from shared edges.
        2 -  all curve 3d.

        :type EdgeMode: int

        """
        return _ShapeUpgrade.ShapeUpgrade_WireDivide_SetEdgeMode(self, *args)


    def SetFixSmallCurveTool(self, *args):
        """
        SetFixSmallCurveTool(ShapeUpgrade_WireDivide self, Handle_ShapeUpgrade_FixSmallCurves FixSmallCurvesTool)

        Sets tool for fixing small curves with specified min tolerance;

        :type FixSmallCurvesTool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves

        """
        return _ShapeUpgrade.ShapeUpgrade_WireDivide_SetFixSmallCurveTool(self, *args)


    def GetFixSmallCurveTool(self, *args):
        """
        GetFixSmallCurveTool(ShapeUpgrade_WireDivide self) -> Handle_ShapeUpgrade_FixSmallCurves

        Returns tool for fixing small curves

        :rtype: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves

        """
        return _ShapeUpgrade.ShapeUpgrade_WireDivide_GetFixSmallCurveTool(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.ShapeUpgrade_WireDivide_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeUpgrade.ShapeUpgrade_WireDivide_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.ShapeUpgrade_WireDivide_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeUpgrade.delete_ShapeUpgrade_WireDivide
ShapeUpgrade_WireDivide_swigregister = _ShapeUpgrade.ShapeUpgrade_WireDivide_swigregister
ShapeUpgrade_WireDivide_swigregister(ShapeUpgrade_WireDivide)

def ShapeUpgrade_WireDivide_get_type_name(*args):
    """
    ShapeUpgrade_WireDivide_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeUpgrade.ShapeUpgrade_WireDivide_get_type_name(*args)

def ShapeUpgrade_WireDivide_get_type_descriptor(*args):
    """
    ShapeUpgrade_WireDivide_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeUpgrade.ShapeUpgrade_WireDivide_get_type_descriptor(*args)

class ShapeUpgrade_SplitCurve3dContinuity(ShapeUpgrade_SplitCurve3d):
    """
    Corrects/splits a 2d curve with a continuity criterion.
    Tolerance is used to correct the curve at a knot that respects
    geometrically the criterion, in order to reduce the
    multiplicity of the knot.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeUpgrade_SplitCurve3dContinuity
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeUpgrade_SplitCurve3dContinuity(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeUpgrade_SplitCurve3dContinuity self) -> ShapeUpgrade_SplitCurve3dContinuity

        Empty constructor.


        """
        this = _ShapeUpgrade.new_ShapeUpgrade_SplitCurve3dContinuity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetCriterion(self, *args):
        """
        SetCriterion(ShapeUpgrade_SplitCurve3dContinuity self, GeomAbs_Shape const Criterion)

        Sets criterion for splitting.

        :type Criterion: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitCurve3dContinuity_SetCriterion(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(ShapeUpgrade_SplitCurve3dContinuity self, Standard_Real const Tol)

        Sets tolerance.

        :type Tol: float

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitCurve3dContinuity_SetTolerance(self, *args)


    def Compute(self, *args):
        """
        Compute(ShapeUpgrade_SplitCurve3dContinuity self)

        Calculates points for correction/splitting of the curve


        """
        return _ShapeUpgrade.ShapeUpgrade_SplitCurve3dContinuity_Compute(self, *args)


    def GetCurve(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _ShapeUpgrade.ShapeUpgrade_SplitCurve3dContinuity_GetCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitCurve3dContinuity_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitCurve3dContinuity_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.ShapeUpgrade_SplitCurve3dContinuity_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeUpgrade.delete_ShapeUpgrade_SplitCurve3dContinuity
ShapeUpgrade_SplitCurve3dContinuity_swigregister = _ShapeUpgrade.ShapeUpgrade_SplitCurve3dContinuity_swigregister
ShapeUpgrade_SplitCurve3dContinuity_swigregister(ShapeUpgrade_SplitCurve3dContinuity)

def ShapeUpgrade_SplitCurve3dContinuity_get_type_name(*args):
    """
    ShapeUpgrade_SplitCurve3dContinuity_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeUpgrade.ShapeUpgrade_SplitCurve3dContinuity_get_type_name(*args)

def ShapeUpgrade_SplitCurve3dContinuity_get_type_descriptor(*args):
    """
    ShapeUpgrade_SplitCurve3dContinuity_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeUpgrade.ShapeUpgrade_SplitCurve3dContinuity_get_type_descriptor(*args)

class ShapeUpgrade_SplitCurve2dContinuity(ShapeUpgrade_SplitCurve2d):
    """
    Corrects/splits a 2d curve with a continuity criterion.
    Tolerance is used to correct the curve at a knot that respects
    geometrically the criterion, in order to reduce the
    multiplicity of the knot.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeUpgrade_SplitCurve2dContinuity
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeUpgrade_SplitCurve2dContinuity(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeUpgrade_SplitCurve2dContinuity self) -> ShapeUpgrade_SplitCurve2dContinuity

        Empty constructor.


        """
        this = _ShapeUpgrade.new_ShapeUpgrade_SplitCurve2dContinuity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetCriterion(self, *args):
        """
        SetCriterion(ShapeUpgrade_SplitCurve2dContinuity self, GeomAbs_Shape const Criterion)

        Sets criterion for splitting.

        :type Criterion: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitCurve2dContinuity_SetCriterion(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(ShapeUpgrade_SplitCurve2dContinuity self, Standard_Real const Tol)

        Sets tolerance.

        :type Tol: float

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitCurve2dContinuity_SetTolerance(self, *args)


    def Compute(self, *args):
        """
        Compute(ShapeUpgrade_SplitCurve2dContinuity self)

        Calculates points for correction/splitting of the curve


        """
        return _ShapeUpgrade.ShapeUpgrade_SplitCurve2dContinuity_Compute(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitCurve2dContinuity_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitCurve2dContinuity_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.ShapeUpgrade_SplitCurve2dContinuity_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeUpgrade.delete_ShapeUpgrade_SplitCurve2dContinuity
ShapeUpgrade_SplitCurve2dContinuity_swigregister = _ShapeUpgrade.ShapeUpgrade_SplitCurve2dContinuity_swigregister
ShapeUpgrade_SplitCurve2dContinuity_swigregister(ShapeUpgrade_SplitCurve2dContinuity)

def ShapeUpgrade_SplitCurve2dContinuity_get_type_name(*args):
    """
    ShapeUpgrade_SplitCurve2dContinuity_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeUpgrade.ShapeUpgrade_SplitCurve2dContinuity_get_type_name(*args)

def ShapeUpgrade_SplitCurve2dContinuity_get_type_descriptor(*args):
    """
    ShapeUpgrade_SplitCurve2dContinuity_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeUpgrade.ShapeUpgrade_SplitCurve2dContinuity_get_type_descriptor(*args)

class Handle_ShapeUpgrade_SplitCurve(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeUpgrade_SplitCurve self)

        Nullify the handle


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeUpgrade_SplitCurve self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeUpgrade_SplitCurve self, ShapeUpgrade_SplitCurve thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeUpgrade_SplitCurve self, Handle_ShapeUpgrade_SplitCurve theHandle) -> Handle_ShapeUpgrade_SplitCurve
        assign(Handle_ShapeUpgrade_SplitCurve self, ShapeUpgrade_SplitCurve thePtr) -> Handle_ShapeUpgrade_SplitCurve
        assign(Handle_ShapeUpgrade_SplitCurve self, Handle_ShapeUpgrade_SplitCurve theHandle) -> Handle_ShapeUpgrade_SplitCurve

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeUpgrade_SplitCurve self) -> ShapeUpgrade_SplitCurve

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeUpgrade_SplitCurve self) -> ShapeUpgrade_SplitCurve

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeUpgrade_SplitCurve self) -> ShapeUpgrade_SplitCurve

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve___ref__(self, *args)


    def __hash__(self):
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeUpgrade.new_Handle_ShapeUpgrade_SplitCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve_DownCast)
    __swig_destroy__ = _ShapeUpgrade.delete_Handle_ShapeUpgrade_SplitCurve

    def Init(self, *args):
        """
        Init(Handle_ShapeUpgrade_SplitCurve self, Standard_Real const First, Standard_Real const Last)

        Initializes with curve first and last parameters.

        :type First: float
        :type Last: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve_Init(self, *args)


    def SetSplitValues(self, *args):
        """
        SetSplitValues(Handle_ShapeUpgrade_SplitCurve self, Handle_TColStd_HSequenceOfReal SplitValues)

        Sets the parameters where splitting has to be done.

        :type SplitValues: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve_SetSplitValues(self, *args)


    def Build(self, *args):
        """
        Build(Handle_ShapeUpgrade_SplitCurve self, Standard_Boolean const Segment)

        If Segment is True, the result is composed with
        segments of the curve bounded by the SplitValues.  If
        Segment is False, the result is composed with trimmed
        Curves all based on the same complete curve.

        :type Segment: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve_Build(self, *args)


    def SplitValues(self, *args):
        """
        returns all the splitting values including the
        First and Last parameters of the input curve
        Merges input split values and new ones into myGlobalKnots

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve_SplitValues(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Compute(self, *args):
        """
        Compute(Handle_ShapeUpgrade_SplitCurve self)

        Calculates points for correction/splitting of the curve


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve_Compute(self, *args)


    def Perform(self, *args):
        """
        Perform(Handle_ShapeUpgrade_SplitCurve self, Standard_Boolean const Segment)

        Performs correction/splitting of the curve.
        First defines splitting values by method Compute(), then calls method Build().

        :type Segment: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve_Perform(self, *args)


    def Status(self, *args):
        """
        Status(Handle_ShapeUpgrade_SplitCurve self, ShapeExtend_Status const status) -> Standard_Boolean

        Returns the status
        OK    - no splitting is needed
        DONE1 - splitting required and gives more than one segment
        DONE2 - splitting is required, but gives only one segment (initial)
        DONE3 - geometric form of the curve or parametrisation is modified

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve_Status(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeUpgrade_SplitCurve self) -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_ShapeUpgrade_SplitCurve self)

        Memory deallocator for transient classes


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeUpgrade_SplitCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeUpgrade_SplitCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeUpgrade_SplitCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeUpgrade_SplitCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeUpgrade_SplitCurve self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeUpgrade_SplitCurve self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeUpgrade_SplitCurve self)

        Increments the reference counter of this object


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeUpgrade_SplitCurve self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve_DecrementRefCounter(self, *args)

Handle_ShapeUpgrade_SplitCurve_swigregister = _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve_swigregister
Handle_ShapeUpgrade_SplitCurve_swigregister(Handle_ShapeUpgrade_SplitCurve)

def Handle_ShapeUpgrade_SplitCurve_DownCast(thing):
    return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve_DownCast(thing)
Handle_ShapeUpgrade_SplitCurve_DownCast = _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve_DownCast

class ShapeUpgrade_FixSmallCurves(ShapeUpgrade_Tool):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeUpgrade_FixSmallCurves
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeUpgrade_FixSmallCurves(self) 
            return h


    def __init__(self, *args):
        """__init__(ShapeUpgrade_FixSmallCurves self) -> ShapeUpgrade_FixSmallCurves"""
        this = _ShapeUpgrade.new_ShapeUpgrade_FixSmallCurves(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(ShapeUpgrade_FixSmallCurves self, TopoDS_Edge theEdge, TopoDS_Face theFace)

        :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _ShapeUpgrade.ShapeUpgrade_FixSmallCurves_Init(self, *args)


    def Approx(self, *args):
        """
        Approx(ShapeUpgrade_FixSmallCurves self, Handle_Geom_Curve Curve3d, Handle_Geom2d_Curve Curve2d, Handle_Geom2d_Curve Curve2dR) -> Standard_Boolean

        :type Curve3d: OCC.wrapper.Geom.Handle_Geom_Curve
        :type Curve2d: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Curve2dR: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type First: float
        :type Last: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_FixSmallCurves_Approx(self, *args)


    def SetSplitCurve3dTool(self, *args):
        """
        SetSplitCurve3dTool(ShapeUpgrade_FixSmallCurves self, Handle_ShapeUpgrade_SplitCurve3d splitCurve3dTool)

        Sets the tool for splitting 3D curves.

        :type splitCurve3dTool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d

        """
        return _ShapeUpgrade.ShapeUpgrade_FixSmallCurves_SetSplitCurve3dTool(self, *args)


    def SetSplitCurve2dTool(self, *args):
        """
        SetSplitCurve2dTool(ShapeUpgrade_FixSmallCurves self, Handle_ShapeUpgrade_SplitCurve2d splitCurve2dTool)

        Sets the tool for splitting pcurves.

        :type splitCurve2dTool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d

        """
        return _ShapeUpgrade.ShapeUpgrade_FixSmallCurves_SetSplitCurve2dTool(self, *args)


    def Status(self, *args):
        """
        Status(ShapeUpgrade_FixSmallCurves self, ShapeExtend_Status const status) -> Standard_Boolean

        Queries the status of last call to Perform
        OK   :
        DONE1:
        DONE2:
        FAIL1:

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_FixSmallCurves_Status(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.ShapeUpgrade_FixSmallCurves_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeUpgrade.ShapeUpgrade_FixSmallCurves_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.ShapeUpgrade_FixSmallCurves_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeUpgrade.delete_ShapeUpgrade_FixSmallCurves
ShapeUpgrade_FixSmallCurves_swigregister = _ShapeUpgrade.ShapeUpgrade_FixSmallCurves_swigregister
ShapeUpgrade_FixSmallCurves_swigregister(ShapeUpgrade_FixSmallCurves)

def ShapeUpgrade_FixSmallCurves_get_type_name(*args):
    """
    ShapeUpgrade_FixSmallCurves_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeUpgrade.ShapeUpgrade_FixSmallCurves_get_type_name(*args)

def ShapeUpgrade_FixSmallCurves_get_type_descriptor(*args):
    """
    ShapeUpgrade_FixSmallCurves_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeUpgrade.ShapeUpgrade_FixSmallCurves_get_type_descriptor(*args)

class ShapeUpgrade_EdgeDivide(ShapeUpgrade_Tool):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeUpgrade_EdgeDivide
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeUpgrade_EdgeDivide(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeUpgrade_EdgeDivide self) -> ShapeUpgrade_EdgeDivide

        Empty constructor


        """
        this = _ShapeUpgrade.new_ShapeUpgrade_EdgeDivide(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Clear(self, *args):
        """Clear(ShapeUpgrade_EdgeDivide self)"""
        return _ShapeUpgrade.ShapeUpgrade_EdgeDivide_Clear(self, *args)


    def SetFace(self, *args):
        """
        SetFace(ShapeUpgrade_EdgeDivide self, TopoDS_Face F)

        Sets supporting surface by face

        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _ShapeUpgrade.ShapeUpgrade_EdgeDivide_SetFace(self, *args)


    def Compute(self, *args):
        """
        Compute(ShapeUpgrade_EdgeDivide self, TopoDS_Edge E) -> Standard_Boolean

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_EdgeDivide_Compute(self, *args)


    def HasCurve2d(self, *args):
        """
        HasCurve2d(ShapeUpgrade_EdgeDivide self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_EdgeDivide_HasCurve2d(self, *args)


    def HasCurve3d(self, *args):
        """
        HasCurve3d(ShapeUpgrade_EdgeDivide self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_EdgeDivide_HasCurve3d(self, *args)


    def Knots2d(self, *args):
        """
        Knots2d(ShapeUpgrade_EdgeDivide self) -> Handle_TColStd_HSequenceOfReal

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        return _ShapeUpgrade.ShapeUpgrade_EdgeDivide_Knots2d(self, *args)


    def Knots3d(self, *args):
        """
        Knots3d(ShapeUpgrade_EdgeDivide self) -> Handle_TColStd_HSequenceOfReal

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        return _ShapeUpgrade.ShapeUpgrade_EdgeDivide_Knots3d(self, *args)


    def SetSplitCurve2dTool(self, *args):
        """
        SetSplitCurve2dTool(ShapeUpgrade_EdgeDivide self, Handle_ShapeUpgrade_SplitCurve2d splitCurve2dTool)

        Sets the tool for splitting pcurves.

        :type splitCurve2dTool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d

        """
        return _ShapeUpgrade.ShapeUpgrade_EdgeDivide_SetSplitCurve2dTool(self, *args)


    def SetSplitCurve3dTool(self, *args):
        """
        SetSplitCurve3dTool(ShapeUpgrade_EdgeDivide self, Handle_ShapeUpgrade_SplitCurve3d splitCurve3dTool)

        Sets the tool for splitting 3D curves.

        :type splitCurve3dTool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d

        """
        return _ShapeUpgrade.ShapeUpgrade_EdgeDivide_SetSplitCurve3dTool(self, *args)


    def GetSplitCurve2dTool(self, *args):
        """
        GetSplitCurve2dTool(ShapeUpgrade_EdgeDivide self) -> Handle_ShapeUpgrade_SplitCurve2d

        Returns the tool for splitting pcurves.

        :rtype: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d

        """
        return _ShapeUpgrade.ShapeUpgrade_EdgeDivide_GetSplitCurve2dTool(self, *args)


    def GetSplitCurve3dTool(self, *args):
        """
        GetSplitCurve3dTool(ShapeUpgrade_EdgeDivide self) -> Handle_ShapeUpgrade_SplitCurve3d

        Returns the tool for splitting 3D curves.

        :rtype: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d

        """
        return _ShapeUpgrade.ShapeUpgrade_EdgeDivide_GetSplitCurve3dTool(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.ShapeUpgrade_EdgeDivide_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeUpgrade.ShapeUpgrade_EdgeDivide_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.ShapeUpgrade_EdgeDivide_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeUpgrade.delete_ShapeUpgrade_EdgeDivide
ShapeUpgrade_EdgeDivide_swigregister = _ShapeUpgrade.ShapeUpgrade_EdgeDivide_swigregister
ShapeUpgrade_EdgeDivide_swigregister(ShapeUpgrade_EdgeDivide)

def ShapeUpgrade_EdgeDivide_get_type_name(*args):
    """
    ShapeUpgrade_EdgeDivide_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeUpgrade.ShapeUpgrade_EdgeDivide_get_type_name(*args)

def ShapeUpgrade_EdgeDivide_get_type_descriptor(*args):
    """
    ShapeUpgrade_EdgeDivide_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeUpgrade.ShapeUpgrade_EdgeDivide_get_type_descriptor(*args)

class ShapeUpgrade_ShellSewing(object):
    """
    This class provides a tool for applying sewing algorithm from
    BRepBuilderAPI: it takes a shape, calls sewing for each shell,
    and then replaces sewed shells with use of ShapeBuild_ReShape
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ShapeUpgrade_ShellSewing self) -> ShapeUpgrade_ShellSewing

        Creates a ShellSewing, empty


        """
        this = _ShapeUpgrade.new_ShapeUpgrade_ShellSewing(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ApplySewing(self, *args):
        """
        ApplySewing(ShapeUpgrade_ShellSewing self, TopoDS_Shape shape, Standard_Real const tol=0.0) -> TopoDS_Shape

        Builds a new shape from a former one, by calling Sewing from
        BRepBuilderAPI. Rebuilt solids are oriented to be "not infinite"

        If <tol> is not given (i.e. value 0. by default), it is
        computed as the mean tolerance recorded in <shape>

        If no shell has been sewed, this method returns the input
        shape

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type tol: float
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeUpgrade.ShapeUpgrade_ShellSewing_ApplySewing(self, *args)

    __swig_destroy__ = _ShapeUpgrade.delete_ShapeUpgrade_ShellSewing
ShapeUpgrade_ShellSewing_swigregister = _ShapeUpgrade.ShapeUpgrade_ShellSewing_swigregister
ShapeUpgrade_ShellSewing_swigregister(ShapeUpgrade_ShellSewing)

class Handle_ShapeUpgrade_SplitCurve3dContinuity(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeUpgrade_SplitCurve3dContinuity self)

        Nullify the handle


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3dContinuity_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeUpgrade_SplitCurve3dContinuity self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3dContinuity_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeUpgrade_SplitCurve3dContinuity self, ShapeUpgrade_SplitCurve3dContinuity thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3dContinuity_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeUpgrade_SplitCurve3dContinuity self, Handle_ShapeUpgrade_SplitCurve3dContinuity theHandle) -> Handle_ShapeUpgrade_SplitCurve3dContinuity
        assign(Handle_ShapeUpgrade_SplitCurve3dContinuity self, ShapeUpgrade_SplitCurve3dContinuity thePtr) -> Handle_ShapeUpgrade_SplitCurve3dContinuity
        assign(Handle_ShapeUpgrade_SplitCurve3dContinuity self, Handle_ShapeUpgrade_SplitCurve3dContinuity theHandle) -> Handle_ShapeUpgrade_SplitCurve3dContinuity

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3dContinuity_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeUpgrade_SplitCurve3dContinuity self) -> ShapeUpgrade_SplitCurve3dContinuity

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3dContinuity_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeUpgrade_SplitCurve3dContinuity self) -> ShapeUpgrade_SplitCurve3dContinuity

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3dContinuity___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeUpgrade_SplitCurve3dContinuity self) -> ShapeUpgrade_SplitCurve3dContinuity

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3dContinuity___ref__(self, *args)


    def __hash__(self):
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3dContinuity___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3dContinuity___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeUpgrade.new_Handle_ShapeUpgrade_SplitCurve3dContinuity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3dContinuity_DownCast)
    __swig_destroy__ = _ShapeUpgrade.delete_Handle_ShapeUpgrade_SplitCurve3dContinuity

    def SetCriterion(self, *args):
        """
        SetCriterion(Handle_ShapeUpgrade_SplitCurve3dContinuity self, GeomAbs_Shape const Criterion)

        Sets criterion for splitting.

        :type Criterion: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3dContinuity_SetCriterion(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(Handle_ShapeUpgrade_SplitCurve3dContinuity self, Standard_Real const Tol)

        Sets tolerance.

        :type Tol: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3dContinuity_SetTolerance(self, *args)


    def Compute(self, *args):
        """
        Compute(Handle_ShapeUpgrade_SplitCurve3dContinuity self)

        Calculates points for correction/splitting of the curve


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3dContinuity_Compute(self, *args)


    def GetCurve(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3dContinuity_GetCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeUpgrade_SplitCurve3dContinuity self) -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3dContinuity_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3dContinuity_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3dContinuity_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_ShapeUpgrade_SplitCurve3dContinuity self, Handle_Geom_Curve C)
        Init(Handle_ShapeUpgrade_SplitCurve3dContinuity self, Handle_Geom_Curve C, Standard_Real const First, Standard_Real const Last)

        Initializes with curve with its parameters.

        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type First: float
        :type Last: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3dContinuity_Init(self, *args)


    def Build(self, *args):
        """
        Build(Handle_ShapeUpgrade_SplitCurve3dContinuity self, Standard_Boolean const Segment)

        If Segment is True, the result is composed with
        segments of the curve bounded by the SplitValues.  If
        Segment is False, the result is composed with trimmed
        Curves all based on the same complete curve.

        :type Segment: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3dContinuity_Build(self, *args)


    def GetCurves(self, *args):
        """
        :rtype: OCC.wrapper.TColGeom.Handle_TColGeom_HArray1OfCurve

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3dContinuity_GetCurves(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSplitValues(self, *args):
        """
        SetSplitValues(Handle_ShapeUpgrade_SplitCurve3dContinuity self, Handle_TColStd_HSequenceOfReal SplitValues)

        Sets the parameters where splitting has to be done.

        :type SplitValues: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3dContinuity_SetSplitValues(self, *args)


    def SplitValues(self, *args):
        """
        returns all the splitting values including the
        First and Last parameters of the input curve
        Merges input split values and new ones into myGlobalKnots

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3dContinuity_SplitValues(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Perform(self, *args):
        """
        Perform(Handle_ShapeUpgrade_SplitCurve3dContinuity self, Standard_Boolean const Segment)

        Performs correction/splitting of the curve.
        First defines splitting values by method Compute(), then calls method Build().

        :type Segment: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3dContinuity_Perform(self, *args)


    def Status(self, *args):
        """
        Status(Handle_ShapeUpgrade_SplitCurve3dContinuity self, ShapeExtend_Status const status) -> Standard_Boolean

        Returns the status
        OK    - no splitting is needed
        DONE1 - splitting required and gives more than one segment
        DONE2 - splitting is required, but gives only one segment (initial)
        DONE3 - geometric form of the curve or parametrisation is modified

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3dContinuity_Status(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeUpgrade_SplitCurve3dContinuity self)

        Memory deallocator for transient classes


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3dContinuity_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeUpgrade_SplitCurve3dContinuity self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeUpgrade_SplitCurve3dContinuity self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3dContinuity_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeUpgrade_SplitCurve3dContinuity self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeUpgrade_SplitCurve3dContinuity self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3dContinuity_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeUpgrade_SplitCurve3dContinuity self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3dContinuity_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeUpgrade_SplitCurve3dContinuity self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3dContinuity_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeUpgrade_SplitCurve3dContinuity self)

        Increments the reference counter of this object


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3dContinuity_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeUpgrade_SplitCurve3dContinuity self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3dContinuity_DecrementRefCounter(self, *args)

Handle_ShapeUpgrade_SplitCurve3dContinuity_swigregister = _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3dContinuity_swigregister
Handle_ShapeUpgrade_SplitCurve3dContinuity_swigregister(Handle_ShapeUpgrade_SplitCurve3dContinuity)

def Handle_ShapeUpgrade_SplitCurve3dContinuity_DownCast(thing):
    return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3dContinuity_DownCast(thing)
Handle_ShapeUpgrade_SplitCurve3dContinuity_DownCast = _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3dContinuity_DownCast

class Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self)

        Nullify the handle


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self, ShapeUpgrade_ConvertSurfaceToBezierBasis thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self, Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis theHandle) -> Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis
        assign(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self, ShapeUpgrade_ConvertSurfaceToBezierBasis thePtr) -> Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis
        assign(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self, Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis theHandle) -> Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self) -> ShapeUpgrade_ConvertSurfaceToBezierBasis

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self) -> ShapeUpgrade_ConvertSurfaceToBezierBasis

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self) -> ShapeUpgrade_ConvertSurfaceToBezierBasis

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis___ref__(self, *args)


    def __hash__(self):
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeUpgrade.new_Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_DownCast)
    __swig_destroy__ = _ShapeUpgrade.delete_Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis

    def Build(self, *args):
        """
        Build(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self, Standard_Boolean const Segment)

        Splits a list of beziers computed by Compute method according
        the split values and splitting parameters.

        :type Segment: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_Build(self, *args)


    def Compute(self, *args):
        """
        Compute(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self, Standard_Boolean const Segment)

        Converts surface into a grid of bezier based surfaces, and
        stores this grid.

        :type Segment: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_Compute(self, *args)


    def Segments(self, *args):
        """
        Segments(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self) -> Handle_ShapeExtend_CompositeSurface

        Returns the grid of bezier based surfaces correspondent to
        original surface.

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_CompositeSurface

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_Segments(self, *args)


    def SetPlaneMode(self, *args):
        """
        SetPlaneMode(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self, Standard_Boolean const mode)

        Sets mode for conversion Geom_Plane to Bezier

        :type mode: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_SetPlaneMode(self, *args)


    def GetPlaneMode(self, *args):
        """
        GetPlaneMode(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self) -> Standard_Boolean

        Returns the Geom_Pline conversion mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_GetPlaneMode(self, *args)


    def SetRevolutionMode(self, *args):
        """
        SetRevolutionMode(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self, Standard_Boolean const mode)

        Sets mode for conversion Geom_SurfaceOfRevolution to Bezier

        :type mode: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_SetRevolutionMode(self, *args)


    def GetRevolutionMode(self, *args):
        """
        GetRevolutionMode(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self) -> Standard_Boolean

        Returns the Geom_SurfaceOfRevolution conversion mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_GetRevolutionMode(self, *args)


    def SetExtrusionMode(self, *args):
        """
        SetExtrusionMode(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self, Standard_Boolean const mode)

        Sets mode for conversion Geom_SurfaceOfLinearExtrusion to Bezier

        :type mode: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_SetExtrusionMode(self, *args)


    def GetExtrusionMode(self, *args):
        """
        GetExtrusionMode(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self) -> Standard_Boolean

        Returns the Geom_SurfaceOfLinearExtrusion conversion mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_GetExtrusionMode(self, *args)


    def SetBSplineMode(self, *args):
        """
        SetBSplineMode(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self, Standard_Boolean const mode)

        Sets mode for conversion Geom_BSplineSurface to Bezier

        :type mode: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_SetBSplineMode(self, *args)


    def GetBSplineMode(self, *args):
        """
        GetBSplineMode(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self) -> Standard_Boolean

        Returns the Geom_BSplineSurface conversion mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_GetBSplineMode(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self) -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self, Handle_Geom_Surface S)
        Init(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self, Handle_Geom_Surface S, Standard_Real const UFirst, Standard_Real const ULast, Standard_Real const VFirst, Standard_Real const VLast)

        Initializes with single supporting surface with bounding parameters.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type UFirst: float
        :type ULast: float
        :type VFirst: float
        :type VLast: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_Init(self, *args)


    def SetUSplitValues(self, *args):
        """
        SetUSplitValues(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self, Handle_TColStd_HSequenceOfReal UValues)

        Sets U parameters where splitting has to be done

        :type UValues: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_SetUSplitValues(self, *args)


    def SetVSplitValues(self, *args):
        """
        SetVSplitValues(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self, Handle_TColStd_HSequenceOfReal VValues)

        Sets V parameters where splitting has to be done

        :type VValues: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_SetVSplitValues(self, *args)


    def Perform(self, *args):
        """
        Perform(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self, Standard_Boolean const Segment)

        Performs correction/splitting of the surface.
        First defines splitting values by method Compute(), then calls method Build().

        :type Segment: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_Perform(self, *args)


    def USplitValues(self, *args):
        """
        returns all the U splitting values including the
        First and Last parameters of the input surface

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_USplitValues(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def VSplitValues(self, *args):
        """
        returns all the splitting V values including the
        First and Last parameters of the input surface

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_VSplitValues(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Status(self, *args):
        """
        Status(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self, ShapeExtend_Status const status) -> Standard_Boolean

        Returns the status
        OK    - no splitting is needed
        DONE1 - splitting required and gives more than one patch
        DONE2 - splitting is required, but gives only single patch (initial)
        DONE3 - geometric form of the surface or parametrisation is modified

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_Status(self, *args)


    def ResSurfaces(self, *args):
        """
        Returns obtained surfaces after splitting as CompositeSurface

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_CompositeSurface

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_ResSurfaces(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self)

        Memory deallocator for transient classes


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self)

        Increments the reference counter of this object


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_DecrementRefCounter(self, *args)

Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_swigregister = _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_swigregister
Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_swigregister(Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis)

def Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_DownCast(thing):
    return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_DownCast(thing)
Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_DownCast = _ShapeUpgrade.Handle_ShapeUpgrade_ConvertSurfaceToBezierBasis_DownCast

class ShapeUpgrade_ClosedEdgeDivide(ShapeUpgrade_EdgeDivide):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeUpgrade_ClosedEdgeDivide
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeUpgrade_ClosedEdgeDivide(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeUpgrade_ClosedEdgeDivide self) -> ShapeUpgrade_ClosedEdgeDivide

        Empty constructor.


        """
        this = _ShapeUpgrade.new_ShapeUpgrade_ClosedEdgeDivide(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Compute(self, *args):
        """
        Compute(ShapeUpgrade_ClosedEdgeDivide self, TopoDS_Edge anEdge) -> Standard_Boolean

        :type anEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_ClosedEdgeDivide_Compute(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.ShapeUpgrade_ClosedEdgeDivide_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeUpgrade.ShapeUpgrade_ClosedEdgeDivide_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.ShapeUpgrade_ClosedEdgeDivide_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeUpgrade.delete_ShapeUpgrade_ClosedEdgeDivide
ShapeUpgrade_ClosedEdgeDivide_swigregister = _ShapeUpgrade.ShapeUpgrade_ClosedEdgeDivide_swigregister
ShapeUpgrade_ClosedEdgeDivide_swigregister(ShapeUpgrade_ClosedEdgeDivide)

def ShapeUpgrade_ClosedEdgeDivide_get_type_name(*args):
    """
    ShapeUpgrade_ClosedEdgeDivide_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeUpgrade.ShapeUpgrade_ClosedEdgeDivide_get_type_name(*args)

def ShapeUpgrade_ClosedEdgeDivide_get_type_descriptor(*args):
    """
    ShapeUpgrade_ClosedEdgeDivide_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeUpgrade.ShapeUpgrade_ClosedEdgeDivide_get_type_descriptor(*args)

class ShapeUpgrade_UnifySameDomain(Standard.Standard_Transient):
    """
    This tool tries to unify faces and edges of the shape which lie on the same geometry.
    Faces/edges are considering as 'same-domain' if a group of neighbouring faces/edges
    are lying on coincident surfaces/curves.
    In this case these faces/edges can be unified into one face/edge.
    ShapeUpgrade_UnifySameDomain is initialized by a shape and the next optional parameters:
    UnifyFaces - tries to unify all possible faces
    UnifyEdges - tries to unify all possible edges
    ConcatBSplines - if this flag is set to true then all neighbouring edges, which lay
    on BSpline or Bezier curves with C1 continuity on their common vertices,
    will be merged into one common edge.

    The input shape can be of any type containing faces or edges - compsolid, solid, shell, 
    wire, compound of any kind of shapes. The algorithm preserves the structure of compsolids,
    solids, shells and wires. E.g., if two shells have a common edge and the faces sharing
    this edge lie on the same surface the algorithm will not unify these faces, otherwise 
    the structure of shells would be broken. However, if such faces belong to different
    compounds of faces they will be unified.

    The output result of the tool is the unified shape.

    All the modifications of initial shape are recorded during unifying.
    Methods History are intended to: <br>
    - set a place holder for the history of modifications of sub-shapes of
    the initial shape; <br>
    - get the collected history. <br>
    The algorithm provides a place holder for the history and collects the
    history by default.
    To avoid collecting of the history the place holder should be set to null handle.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeUpgrade_UnifySameDomain
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeUpgrade_UnifySameDomain(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeUpgrade_UnifySameDomain self) -> ShapeUpgrade_UnifySameDomain
        __init__(ShapeUpgrade_UnifySameDomain self, TopoDS_Shape aShape, Standard_Boolean const UnifyEdges, Standard_Boolean const UnifyFaces, Standard_Boolean const ConcatBSplines) -> ShapeUpgrade_UnifySameDomain

        Constructor defining input shape and necessary flags.
        It does not perform unification.

        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type UnifyEdges: bool
        :type UnifyFaces: bool
        :type ConcatBSplines: bool

        """
        this = _ShapeUpgrade.new_ShapeUpgrade_UnifySameDomain(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Initialize(self, *args):
        """
        Initialize(ShapeUpgrade_UnifySameDomain self, TopoDS_Shape aShape, Standard_Boolean const UnifyEdges, Standard_Boolean const UnifyFaces, Standard_Boolean const ConcatBSplines)

        Initializes with a shape and necessary flags.
        It does not perform unification.
        If you intend to nullify the History place holder do it after
        initialization.

        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type UnifyEdges: bool
        :type UnifyFaces: bool
        :type ConcatBSplines: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_UnifySameDomain_Initialize(self, *args)


    def AllowInternalEdges(self, *args):
        """
        AllowInternalEdges(ShapeUpgrade_UnifySameDomain self, Standard_Boolean const theValue)

        Sets the flag defining whether it is allowed to create
        internal edges inside merged faces in the case of non-manifold
        topology. Without this flag merging through multi connected edge
        is forbidden. Default value is false.

        :type theValue: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_UnifySameDomain_AllowInternalEdges(self, *args)


    def KeepShape(self, *args):
        """
        KeepShape(ShapeUpgrade_UnifySameDomain self, TopoDS_Shape theShape)

        Sets the shape for avoid merging of the faces/edges.
        This shape can be vertex or edge.
        If the shape is a vertex it forbids merging of connected edges.
        If the shape is a edge it forbids merging of connected faces.
        This method can be called several times to keep several shapes.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeUpgrade.ShapeUpgrade_UnifySameDomain_KeepShape(self, *args)


    def KeepShapes(self, *args):
        """
        KeepShapes(ShapeUpgrade_UnifySameDomain self, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theShapes)

        Sets the map of shapes for avoid merging of the faces/edges.
        It allows passing a ready to use map instead of calling many times
        the method KeepShape.

        :type theShapes: OCC.wrapper.TopTools.TopTools_MapOfShape

        """
        return _ShapeUpgrade.ShapeUpgrade_UnifySameDomain_KeepShapes(self, *args)


    def SetSafeInputMode(self, *args):
        """
        SetSafeInputMode(ShapeUpgrade_UnifySameDomain self, Standard_Boolean theValue)

        Sets the flag defining the behavior of the algorithm regarding 
        modification of input shape.
        If this flag is equal to True then the input (original) shape can't be
        modified during modification process. Default value is true.

        :type theValue: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_UnifySameDomain_SetSafeInputMode(self, *args)


    def SetLinearTolerance(self, *args):
        """
        SetLinearTolerance(ShapeUpgrade_UnifySameDomain self, Standard_Real const theValue)

        Sets the linear tolerance. It plays the role of chord error when
        taking decision about merging of shapes. Default value is Precision::Confusion().

        :type theValue: float

        """
        return _ShapeUpgrade.ShapeUpgrade_UnifySameDomain_SetLinearTolerance(self, *args)


    def SetAngularTolerance(self, *args):
        """
        SetAngularTolerance(ShapeUpgrade_UnifySameDomain self, Standard_Real const theValue)

        Sets the angular tolerance. If two shapes form a connection angle greater than 
        this value they will not be merged. Default value is Precision::Angular().

        :type theValue: float

        """
        return _ShapeUpgrade.ShapeUpgrade_UnifySameDomain_SetAngularTolerance(self, *args)


    def Build(self, *args):
        """
        Build(ShapeUpgrade_UnifySameDomain self)

        Performs unification and builds the resulting shape.


        """
        return _ShapeUpgrade.ShapeUpgrade_UnifySameDomain_Build(self, *args)


    def Shape(self, *args):
        """
        Gives the resulting shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _ShapeUpgrade.ShapeUpgrade_UnifySameDomain_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def History(self, *args):
        """
        Returns the history of the processed shapes.

        :rtype: OCC.wrapper.BRepTools.Handle_BRepTools_History

        """
        res = _ShapeUpgrade.ShapeUpgrade_UnifySameDomain_History(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.ShapeUpgrade_UnifySameDomain_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeUpgrade.ShapeUpgrade_UnifySameDomain_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.ShapeUpgrade_UnifySameDomain_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeUpgrade.delete_ShapeUpgrade_UnifySameDomain
ShapeUpgrade_UnifySameDomain_swigregister = _ShapeUpgrade.ShapeUpgrade_UnifySameDomain_swigregister
ShapeUpgrade_UnifySameDomain_swigregister(ShapeUpgrade_UnifySameDomain)

def ShapeUpgrade_UnifySameDomain_get_type_name(*args):
    """
    ShapeUpgrade_UnifySameDomain_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeUpgrade.ShapeUpgrade_UnifySameDomain_get_type_name(*args)

def ShapeUpgrade_UnifySameDomain_get_type_descriptor(*args):
    """
    ShapeUpgrade_UnifySameDomain_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeUpgrade.ShapeUpgrade_UnifySameDomain_get_type_descriptor(*args)

class ShapeUpgrade_ConvertCurve2dToBezier(ShapeUpgrade_SplitCurve2d):
    """converts/splits a 2d curve to a list of beziers"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeUpgrade_ConvertCurve2dToBezier
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeUpgrade_ConvertCurve2dToBezier(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeUpgrade_ConvertCurve2dToBezier self) -> ShapeUpgrade_ConvertCurve2dToBezier

        Empty constructor.


        """
        this = _ShapeUpgrade.new_ShapeUpgrade_ConvertCurve2dToBezier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Compute(self, *args):
        """
        Compute(ShapeUpgrade_ConvertCurve2dToBezier self)

        Converts curve into a list of beziers, and stores the
        splitting parameters on original curve.


        """
        return _ShapeUpgrade.ShapeUpgrade_ConvertCurve2dToBezier_Compute(self, *args)


    def Build(self, *args):
        """
        Build(ShapeUpgrade_ConvertCurve2dToBezier self, Standard_Boolean const Segment)

        Splits a list of beziers computed by Compute method according
        the split values and splitting parameters.

        :type Segment: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_ConvertCurve2dToBezier_Build(self, *args)


    def SplitParams(self, *args):
        """
        SplitParams(ShapeUpgrade_ConvertCurve2dToBezier self) -> Handle_TColStd_HSequenceOfReal

        Returns the list of splitted parameters in original curve
        parametrisation.

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        return _ShapeUpgrade.ShapeUpgrade_ConvertCurve2dToBezier_SplitParams(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.ShapeUpgrade_ConvertCurve2dToBezier_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeUpgrade.ShapeUpgrade_ConvertCurve2dToBezier_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.ShapeUpgrade_ConvertCurve2dToBezier_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeUpgrade.delete_ShapeUpgrade_ConvertCurve2dToBezier
ShapeUpgrade_ConvertCurve2dToBezier_swigregister = _ShapeUpgrade.ShapeUpgrade_ConvertCurve2dToBezier_swigregister
ShapeUpgrade_ConvertCurve2dToBezier_swigregister(ShapeUpgrade_ConvertCurve2dToBezier)

def ShapeUpgrade_ConvertCurve2dToBezier_get_type_name(*args):
    """
    ShapeUpgrade_ConvertCurve2dToBezier_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeUpgrade.ShapeUpgrade_ConvertCurve2dToBezier_get_type_name(*args)

def ShapeUpgrade_ConvertCurve2dToBezier_get_type_descriptor(*args):
    """
    ShapeUpgrade_ConvertCurve2dToBezier_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeUpgrade.ShapeUpgrade_ConvertCurve2dToBezier_get_type_descriptor(*args)

class Handle_ShapeUpgrade_ClosedFaceDivide(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeUpgrade_ClosedFaceDivide self)

        Nullify the handle


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeUpgrade_ClosedFaceDivide self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeUpgrade_ClosedFaceDivide self, ShapeUpgrade_ClosedFaceDivide thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeUpgrade_ClosedFaceDivide self, Handle_ShapeUpgrade_ClosedFaceDivide theHandle) -> Handle_ShapeUpgrade_ClosedFaceDivide
        assign(Handle_ShapeUpgrade_ClosedFaceDivide self, ShapeUpgrade_ClosedFaceDivide thePtr) -> Handle_ShapeUpgrade_ClosedFaceDivide
        assign(Handle_ShapeUpgrade_ClosedFaceDivide self, Handle_ShapeUpgrade_ClosedFaceDivide theHandle) -> Handle_ShapeUpgrade_ClosedFaceDivide

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeUpgrade_ClosedFaceDivide self) -> ShapeUpgrade_ClosedFaceDivide

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeUpgrade_ClosedFaceDivide self) -> ShapeUpgrade_ClosedFaceDivide

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeUpgrade_ClosedFaceDivide self) -> ShapeUpgrade_ClosedFaceDivide

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide___ref__(self, *args)


    def __hash__(self):
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeUpgrade.new_Handle_ShapeUpgrade_ClosedFaceDivide(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_DownCast)
    __swig_destroy__ = _ShapeUpgrade.delete_Handle_ShapeUpgrade_ClosedFaceDivide

    def SplitSurface(self, *args):
        """
        SplitSurface(Handle_ShapeUpgrade_ClosedFaceDivide self) -> Standard_Boolean

        Performs splitting of surface and computes the shell
        from source face.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_SplitSurface(self, *args)


    def SetNbSplitPoints(self, *args):
        """
        SetNbSplitPoints(Handle_ShapeUpgrade_ClosedFaceDivide self, Standard_Integer const num)

        Sets the number of cutting lines by which closed face
        will be splitted. The resulting faces will be num+1.

        :type num: int

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_SetNbSplitPoints(self, *args)


    def GetNbSplitPoints(self, *args):
        """
        GetNbSplitPoints(Handle_ShapeUpgrade_ClosedFaceDivide self) -> Standard_Integer

        Returns the number of splitting points

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_GetNbSplitPoints(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeUpgrade_ClosedFaceDivide self) -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_ShapeUpgrade_ClosedFaceDivide self, TopoDS_Face F)

        Initialize by a Face.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_Init(self, *args)


    def SetSurfaceSegmentMode(self, *args):
        """
        SetSurfaceSegmentMode(Handle_ShapeUpgrade_ClosedFaceDivide self, Standard_Boolean const Segment)

        Purpose sets mode for trimming (segment) surface by
        wire UV bounds.

        :type Segment: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_SetSurfaceSegmentMode(self, *args)


    def Perform(self, *args):
        """
        Perform(Handle_ShapeUpgrade_ClosedFaceDivide self) -> Standard_Boolean

        Performs splitting and computes the resulting shell
        The context is used to keep track of former splittings
        in order to keep sharings. It is updated according to
        modifications made.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_Perform(self, *args)


    def SplitCurves(self, *args):
        """
        SplitCurves(Handle_ShapeUpgrade_ClosedFaceDivide self) -> Standard_Boolean

        Performs splitting of curves of all the edges in the
        shape and divides these edges.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_SplitCurves(self, *args)


    def Result(self, *args):
        """
        Result(Handle_ShapeUpgrade_ClosedFaceDivide self) -> TopoDS_Shape

        Gives the resulting Shell, or Face, or Null shape if not done.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_Result(self, *args)


    def Status(self, *args):
        """
        Status(Handle_ShapeUpgrade_ClosedFaceDivide self, ShapeExtend_Status const status) -> Standard_Boolean

        Queries the status of last call to Perform
        OK   : no splitting was done (or no call to Perform)
        DONE1: some edges were splitted
        DONE2: surface was splitted
        DONE3: surface was modified without splitting
        FAIL1: some fails encountered during splitting wires
        FAIL2: face cannot be splitted

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_Status(self, *args)


    def SetSplitSurfaceTool(self, *args):
        """
        SetSplitSurfaceTool(Handle_ShapeUpgrade_ClosedFaceDivide self, Handle_ShapeUpgrade_SplitSurface splitSurfaceTool)

        Sets the tool for splitting surfaces.

        :type splitSurfaceTool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_SetSplitSurfaceTool(self, *args)


    def SetWireDivideTool(self, *args):
        """
        SetWireDivideTool(Handle_ShapeUpgrade_ClosedFaceDivide self, Handle_ShapeUpgrade_WireDivide wireDivideTool)

        Sets the tool for dividing edges on Face.

        :type wireDivideTool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_WireDivide

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_SetWireDivideTool(self, *args)


    def GetSplitSurfaceTool(self, *args):
        """
        GetSplitSurfaceTool(Handle_ShapeUpgrade_ClosedFaceDivide self) -> Handle_ShapeUpgrade_SplitSurface

        Returns the tool for splitting surfaces.
        This tool must be already initialized.

        :rtype: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_GetSplitSurfaceTool(self, *args)


    def GetWireDivideTool(self, *args):
        """
        GetWireDivideTool(Handle_ShapeUpgrade_ClosedFaceDivide self) -> Handle_ShapeUpgrade_WireDivide

        Returns the tool for dividing edges on Face.
        This tool must be already initialized.

        :rtype: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_WireDivide

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_GetWireDivideTool(self, *args)


    def Set(self, *args):
        """
        Set(Handle_ShapeUpgrade_ClosedFaceDivide self, Handle_ShapeUpgrade_Tool tool)

        Copy all fields from another Root object

        :type tool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_Tool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_Set(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_ShapeUpgrade_ClosedFaceDivide self, Handle_ShapeBuild_ReShape context)

        Sets context

        :type context: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_SetContext(self, *args)


    def Context(self, *args):
        """
        Context(Handle_ShapeUpgrade_ClosedFaceDivide self) -> Handle_ShapeBuild_ReShape

        Returns context

        :rtype: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_Context(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(Handle_ShapeUpgrade_ClosedFaceDivide self, Standard_Real const preci)

        Sets basic precision value

        :type preci: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_SetPrecision(self, *args)


    def Precision(self, *args):
        """
        Precision(Handle_ShapeUpgrade_ClosedFaceDivide self) -> Standard_Real

        Returns basic precision value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_Precision(self, *args)


    def SetMinTolerance(self, *args):
        """
        SetMinTolerance(Handle_ShapeUpgrade_ClosedFaceDivide self, Standard_Real const mintol)

        Sets minimal allowed tolerance

        :type mintol: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_SetMinTolerance(self, *args)


    def MinTolerance(self, *args):
        """
        MinTolerance(Handle_ShapeUpgrade_ClosedFaceDivide self) -> Standard_Real

        Returns minimal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_MinTolerance(self, *args)


    def SetMaxTolerance(self, *args):
        """
        SetMaxTolerance(Handle_ShapeUpgrade_ClosedFaceDivide self, Standard_Real const maxtol)

        Sets maximal allowed tolerance

        :type maxtol: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_SetMaxTolerance(self, *args)


    def MaxTolerance(self, *args):
        """
        MaxTolerance(Handle_ShapeUpgrade_ClosedFaceDivide self) -> Standard_Real

        Returns maximal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_MaxTolerance(self, *args)


    def LimitTolerance(self, *args):
        """
        LimitTolerance(Handle_ShapeUpgrade_ClosedFaceDivide self, Standard_Real const toler) -> Standard_Real

        Returns tolerance limited by [myMinTol,myMaxTol]

        :type toler: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_LimitTolerance(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeUpgrade_ClosedFaceDivide self)

        Memory deallocator for transient classes


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeUpgrade_ClosedFaceDivide self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeUpgrade_ClosedFaceDivide self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeUpgrade_ClosedFaceDivide self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeUpgrade_ClosedFaceDivide self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeUpgrade_ClosedFaceDivide self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeUpgrade_ClosedFaceDivide self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeUpgrade_ClosedFaceDivide self)

        Increments the reference counter of this object


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeUpgrade_ClosedFaceDivide self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_DecrementRefCounter(self, *args)

Handle_ShapeUpgrade_ClosedFaceDivide_swigregister = _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_swigregister
Handle_ShapeUpgrade_ClosedFaceDivide_swigregister(Handle_ShapeUpgrade_ClosedFaceDivide)

def Handle_ShapeUpgrade_ClosedFaceDivide_DownCast(thing):
    return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_DownCast(thing)
Handle_ShapeUpgrade_ClosedFaceDivide_DownCast = _ShapeUpgrade.Handle_ShapeUpgrade_ClosedFaceDivide_DownCast

class Handle_ShapeUpgrade_SplitSurfaceContinuity(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeUpgrade_SplitSurfaceContinuity self)

        Nullify the handle


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeUpgrade_SplitSurfaceContinuity self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeUpgrade_SplitSurfaceContinuity self, ShapeUpgrade_SplitSurfaceContinuity thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeUpgrade_SplitSurfaceContinuity self, Handle_ShapeUpgrade_SplitSurfaceContinuity theHandle) -> Handle_ShapeUpgrade_SplitSurfaceContinuity
        assign(Handle_ShapeUpgrade_SplitSurfaceContinuity self, ShapeUpgrade_SplitSurfaceContinuity thePtr) -> Handle_ShapeUpgrade_SplitSurfaceContinuity
        assign(Handle_ShapeUpgrade_SplitSurfaceContinuity self, Handle_ShapeUpgrade_SplitSurfaceContinuity theHandle) -> Handle_ShapeUpgrade_SplitSurfaceContinuity

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeUpgrade_SplitSurfaceContinuity self) -> ShapeUpgrade_SplitSurfaceContinuity

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeUpgrade_SplitSurfaceContinuity self) -> ShapeUpgrade_SplitSurfaceContinuity

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeUpgrade_SplitSurfaceContinuity self) -> ShapeUpgrade_SplitSurfaceContinuity

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity___ref__(self, *args)


    def __hash__(self):
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeUpgrade.new_Handle_ShapeUpgrade_SplitSurfaceContinuity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity_DownCast)
    __swig_destroy__ = _ShapeUpgrade.delete_Handle_ShapeUpgrade_SplitSurfaceContinuity

    def SetCriterion(self, *args):
        """
        SetCriterion(Handle_ShapeUpgrade_SplitSurfaceContinuity self, GeomAbs_Shape const Criterion)

        Sets criterion for splitting.

        :type Criterion: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity_SetCriterion(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(Handle_ShapeUpgrade_SplitSurfaceContinuity self, Standard_Real const Tol)

        Sets tolerance.

        :type Tol: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity_SetTolerance(self, *args)


    def Compute(self, *args):
        """
        Compute(Handle_ShapeUpgrade_SplitSurfaceContinuity self, Standard_Boolean const Segment)

        :type Segment: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity_Compute(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeUpgrade_SplitSurfaceContinuity self) -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_ShapeUpgrade_SplitSurfaceContinuity self, Handle_Geom_Surface S)
        Init(Handle_ShapeUpgrade_SplitSurfaceContinuity self, Handle_Geom_Surface S, Standard_Real const UFirst, Standard_Real const ULast, Standard_Real const VFirst, Standard_Real const VLast)

        Initializes with single supporting surface with bounding parameters.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type UFirst: float
        :type ULast: float
        :type VFirst: float
        :type VLast: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity_Init(self, *args)


    def SetUSplitValues(self, *args):
        """
        SetUSplitValues(Handle_ShapeUpgrade_SplitSurfaceContinuity self, Handle_TColStd_HSequenceOfReal UValues)

        Sets U parameters where splitting has to be done

        :type UValues: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity_SetUSplitValues(self, *args)


    def SetVSplitValues(self, *args):
        """
        SetVSplitValues(Handle_ShapeUpgrade_SplitSurfaceContinuity self, Handle_TColStd_HSequenceOfReal VValues)

        Sets V parameters where splitting has to be done

        :type VValues: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity_SetVSplitValues(self, *args)


    def Build(self, *args):
        """
        Build(Handle_ShapeUpgrade_SplitSurfaceContinuity self, Standard_Boolean const Segment)

        Performs splitting of the supporting surface.
        If resulting surface is B-Spline and Segment is True,
        the result is composed with segments of the surface bounded
        by the U and V SplitValues (method Geom_BSplineSurface::Segment
        is used).
        If Segment is False, the result is composed with
        Geom_RectangularTrimmedSurface all based on the same complete
        surface.
        Fields myNbResultingRow and myNbResultingCol must be set to
        specify the size of resulting grid of surfaces.

        :type Segment: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity_Build(self, *args)


    def Perform(self, *args):
        """
        Perform(Handle_ShapeUpgrade_SplitSurfaceContinuity self, Standard_Boolean const Segment)

        Performs correction/splitting of the surface.
        First defines splitting values by method Compute(), then calls method Build().

        :type Segment: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity_Perform(self, *args)


    def USplitValues(self, *args):
        """
        returns all the U splitting values including the
        First and Last parameters of the input surface

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity_USplitValues(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def VSplitValues(self, *args):
        """
        returns all the splitting V values including the
        First and Last parameters of the input surface

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity_VSplitValues(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Status(self, *args):
        """
        Status(Handle_ShapeUpgrade_SplitSurfaceContinuity self, ShapeExtend_Status const status) -> Standard_Boolean

        Returns the status
        OK    - no splitting is needed
        DONE1 - splitting required and gives more than one patch
        DONE2 - splitting is required, but gives only single patch (initial)
        DONE3 - geometric form of the surface or parametrisation is modified

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity_Status(self, *args)


    def ResSurfaces(self, *args):
        """
        Returns obtained surfaces after splitting as CompositeSurface

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_CompositeSurface

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity_ResSurfaces(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_ShapeUpgrade_SplitSurfaceContinuity self)

        Memory deallocator for transient classes


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeUpgrade_SplitSurfaceContinuity self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeUpgrade_SplitSurfaceContinuity self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeUpgrade_SplitSurfaceContinuity self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeUpgrade_SplitSurfaceContinuity self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeUpgrade_SplitSurfaceContinuity self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeUpgrade_SplitSurfaceContinuity self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeUpgrade_SplitSurfaceContinuity self)

        Increments the reference counter of this object


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeUpgrade_SplitSurfaceContinuity self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity_DecrementRefCounter(self, *args)

Handle_ShapeUpgrade_SplitSurfaceContinuity_swigregister = _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity_swigregister
Handle_ShapeUpgrade_SplitSurfaceContinuity_swigregister(Handle_ShapeUpgrade_SplitSurfaceContinuity)

def Handle_ShapeUpgrade_SplitSurfaceContinuity_DownCast(thing):
    return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity_DownCast(thing)
Handle_ShapeUpgrade_SplitSurfaceContinuity_DownCast = _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceContinuity_DownCast

class Handle_ShapeUpgrade_Tool(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeUpgrade_Tool self)

        Nullify the handle


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_Tool_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeUpgrade_Tool self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_Tool_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeUpgrade_Tool self, ShapeUpgrade_Tool thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_Tool_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeUpgrade_Tool self, Handle_ShapeUpgrade_Tool theHandle) -> Handle_ShapeUpgrade_Tool
        assign(Handle_ShapeUpgrade_Tool self, ShapeUpgrade_Tool thePtr) -> Handle_ShapeUpgrade_Tool
        assign(Handle_ShapeUpgrade_Tool self, Handle_ShapeUpgrade_Tool theHandle) -> Handle_ShapeUpgrade_Tool

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_Tool_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeUpgrade_Tool self) -> ShapeUpgrade_Tool

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_Tool_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeUpgrade_Tool self) -> ShapeUpgrade_Tool

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_Tool___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeUpgrade_Tool self) -> ShapeUpgrade_Tool

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_Tool___ref__(self, *args)


    def __hash__(self):
        return _ShapeUpgrade.Handle_ShapeUpgrade_Tool___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeUpgrade.Handle_ShapeUpgrade_Tool___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeUpgrade.new_Handle_ShapeUpgrade_Tool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeUpgrade.Handle_ShapeUpgrade_Tool_DownCast)
    __swig_destroy__ = _ShapeUpgrade.delete_Handle_ShapeUpgrade_Tool

    def Set(self, *args):
        """
        Set(Handle_ShapeUpgrade_Tool self, Handle_ShapeUpgrade_Tool tool)

        Copy all fields from another Root object

        :type tool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_Tool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_Tool_Set(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_ShapeUpgrade_Tool self, Handle_ShapeBuild_ReShape context)

        Sets context

        :type context: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_Tool_SetContext(self, *args)


    def Context(self, *args):
        """
        Context(Handle_ShapeUpgrade_Tool self) -> Handle_ShapeBuild_ReShape

        Returns context

        :rtype: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_Tool_Context(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(Handle_ShapeUpgrade_Tool self, Standard_Real const preci)

        Sets basic precision value

        :type preci: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_Tool_SetPrecision(self, *args)


    def Precision(self, *args):
        """
        Precision(Handle_ShapeUpgrade_Tool self) -> Standard_Real

        Returns basic precision value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_Tool_Precision(self, *args)


    def SetMinTolerance(self, *args):
        """
        SetMinTolerance(Handle_ShapeUpgrade_Tool self, Standard_Real const mintol)

        Sets minimal allowed tolerance

        :type mintol: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_Tool_SetMinTolerance(self, *args)


    def MinTolerance(self, *args):
        """
        MinTolerance(Handle_ShapeUpgrade_Tool self) -> Standard_Real

        Returns minimal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_Tool_MinTolerance(self, *args)


    def SetMaxTolerance(self, *args):
        """
        SetMaxTolerance(Handle_ShapeUpgrade_Tool self, Standard_Real const maxtol)

        Sets maximal allowed tolerance

        :type maxtol: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_Tool_SetMaxTolerance(self, *args)


    def MaxTolerance(self, *args):
        """
        MaxTolerance(Handle_ShapeUpgrade_Tool self) -> Standard_Real

        Returns maximal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_Tool_MaxTolerance(self, *args)


    def LimitTolerance(self, *args):
        """
        LimitTolerance(Handle_ShapeUpgrade_Tool self, Standard_Real const toler) -> Standard_Real

        Returns tolerance limited by [myMinTol,myMaxTol]

        :type toler: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_Tool_LimitTolerance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeUpgrade_Tool self) -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_Tool_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_Tool_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_Tool_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_ShapeUpgrade_Tool self)

        Memory deallocator for transient classes


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_Tool_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeUpgrade_Tool self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeUpgrade_Tool self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_Tool_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeUpgrade_Tool self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeUpgrade_Tool self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_Tool_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeUpgrade_Tool self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_Tool_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeUpgrade_Tool self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_Tool_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeUpgrade_Tool self)

        Increments the reference counter of this object


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_Tool_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeUpgrade_Tool self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_Tool_DecrementRefCounter(self, *args)

Handle_ShapeUpgrade_Tool_swigregister = _ShapeUpgrade.Handle_ShapeUpgrade_Tool_swigregister
Handle_ShapeUpgrade_Tool_swigregister(Handle_ShapeUpgrade_Tool)

def Handle_ShapeUpgrade_Tool_DownCast(thing):
    return _ShapeUpgrade.Handle_ShapeUpgrade_Tool_DownCast(thing)
Handle_ShapeUpgrade_Tool_DownCast = _ShapeUpgrade.Handle_ShapeUpgrade_Tool_DownCast

class ShapeUpgrade_ShapeDivideArea(ShapeUpgrade_ShapeDivide):
    """Divides faces from sprcified shape  by max area criterium."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ShapeUpgrade_ShapeDivideArea self) -> ShapeUpgrade_ShapeDivideArea
        __init__(ShapeUpgrade_ShapeDivideArea self, TopoDS_Shape S) -> ShapeUpgrade_ShapeDivideArea

        Initialize by a Shape.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _ShapeUpgrade.new_ShapeUpgrade_ShapeDivideArea(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def MaxArea(self, *args):
        """
        MaxArea(ShapeUpgrade_ShapeDivideArea self) -> Standard_Real &

        Set max area allowed for faces

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeDivideArea_MaxArea(self, *args)

    __swig_destroy__ = _ShapeUpgrade.delete_ShapeUpgrade_ShapeDivideArea
ShapeUpgrade_ShapeDivideArea_swigregister = _ShapeUpgrade.ShapeUpgrade_ShapeDivideArea_swigregister
ShapeUpgrade_ShapeDivideArea_swigregister(ShapeUpgrade_ShapeDivideArea)

class ShapeUpgrade_FixSmallBezierCurves(ShapeUpgrade_FixSmallCurves):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeUpgrade_FixSmallBezierCurves
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeUpgrade_FixSmallBezierCurves(self) 
            return h


    def __init__(self, *args):
        """__init__(ShapeUpgrade_FixSmallBezierCurves self) -> ShapeUpgrade_FixSmallBezierCurves"""
        this = _ShapeUpgrade.new_ShapeUpgrade_FixSmallBezierCurves(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Approx(self, *args):
        """
        Approx(ShapeUpgrade_FixSmallBezierCurves self, Handle_Geom_Curve Curve3d, Handle_Geom2d_Curve Curve2d, Handle_Geom2d_Curve Curve2dR) -> Standard_Boolean

        :type Curve3d: OCC.wrapper.Geom.Handle_Geom_Curve
        :type Curve2d: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Curve2dR: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type First: float
        :type Last: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_FixSmallBezierCurves_Approx(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.ShapeUpgrade_FixSmallBezierCurves_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeUpgrade.ShapeUpgrade_FixSmallBezierCurves_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.ShapeUpgrade_FixSmallBezierCurves_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeUpgrade.delete_ShapeUpgrade_FixSmallBezierCurves
ShapeUpgrade_FixSmallBezierCurves_swigregister = _ShapeUpgrade.ShapeUpgrade_FixSmallBezierCurves_swigregister
ShapeUpgrade_FixSmallBezierCurves_swigregister(ShapeUpgrade_FixSmallBezierCurves)

def ShapeUpgrade_FixSmallBezierCurves_get_type_name(*args):
    """
    ShapeUpgrade_FixSmallBezierCurves_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeUpgrade.ShapeUpgrade_FixSmallBezierCurves_get_type_name(*args)

def ShapeUpgrade_FixSmallBezierCurves_get_type_descriptor(*args):
    """
    ShapeUpgrade_FixSmallBezierCurves_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeUpgrade.ShapeUpgrade_FixSmallBezierCurves_get_type_descriptor(*args)

class Handle_ShapeUpgrade_RemoveLocations(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeUpgrade_RemoveLocations self)

        Nullify the handle


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveLocations_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeUpgrade_RemoveLocations self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveLocations_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeUpgrade_RemoveLocations self, ShapeUpgrade_RemoveLocations thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveLocations_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeUpgrade_RemoveLocations self, Handle_ShapeUpgrade_RemoveLocations theHandle) -> Handle_ShapeUpgrade_RemoveLocations
        assign(Handle_ShapeUpgrade_RemoveLocations self, ShapeUpgrade_RemoveLocations thePtr) -> Handle_ShapeUpgrade_RemoveLocations
        assign(Handle_ShapeUpgrade_RemoveLocations self, Handle_ShapeUpgrade_RemoveLocations theHandle) -> Handle_ShapeUpgrade_RemoveLocations

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveLocations_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeUpgrade_RemoveLocations self) -> ShapeUpgrade_RemoveLocations

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveLocations_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeUpgrade_RemoveLocations self) -> ShapeUpgrade_RemoveLocations

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveLocations___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeUpgrade_RemoveLocations self) -> ShapeUpgrade_RemoveLocations

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveLocations___ref__(self, *args)


    def __hash__(self):
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveLocations___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveLocations___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeUpgrade.new_Handle_ShapeUpgrade_RemoveLocations(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeUpgrade.Handle_ShapeUpgrade_RemoveLocations_DownCast)
    __swig_destroy__ = _ShapeUpgrade.delete_Handle_ShapeUpgrade_RemoveLocations

    def Remove(self, *args):
        """
        Remove(Handle_ShapeUpgrade_RemoveLocations self, TopoDS_Shape theShape) -> Standard_Boolean

        Removes all location correspodingly to RemoveLevel.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveLocations_Remove(self, *args)


    def GetResult(self, *args):
        """
        GetResult(Handle_ShapeUpgrade_RemoveLocations self) -> TopoDS_Shape

        Returns shape with removed locatins.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveLocations_GetResult(self, *args)


    def SetRemoveLevel(self, *args):
        """
        SetRemoveLevel(Handle_ShapeUpgrade_RemoveLocations self, TopAbs_ShapeEnum const theLevel)

        sets level starting with that location will be removed,
        by default TopAbs_SHAPE. In this case locations will be kept for specified shape
        and if specified shape is TopAbs_COMPOUND for sub-shapes of first level.

        :type theLevel: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveLocations_SetRemoveLevel(self, *args)


    def RemoveLevel(self, *args):
        """
        RemoveLevel(Handle_ShapeUpgrade_RemoveLocations self) -> TopAbs_ShapeEnum

        sets level starting with that location will be removed.Value of level can be set to
        TopAbs_SHAPE,TopAbs_COMPOUND,TopAbs_SOLID,TopAbs_SHELL,TopAbs_FACE.By default TopAbs_SHAPE.
        In this case location will be removed for all shape types for exception of compound.

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveLocations_RemoveLevel(self, *args)


    def ModifiedShape(self, *args):
        """
        ModifiedShape(Handle_ShapeUpgrade_RemoveLocations self, TopoDS_Shape theInitShape) -> TopoDS_Shape

        Returns modified shape obtained from initial shape.

        :type theInitShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveLocations_ModifiedShape(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeUpgrade_RemoveLocations self) -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveLocations_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_RemoveLocations_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_RemoveLocations_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_ShapeUpgrade_RemoveLocations self)

        Memory deallocator for transient classes


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveLocations_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeUpgrade_RemoveLocations self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeUpgrade_RemoveLocations self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveLocations_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeUpgrade_RemoveLocations self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeUpgrade_RemoveLocations self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveLocations_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeUpgrade_RemoveLocations self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveLocations_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeUpgrade_RemoveLocations self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveLocations_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeUpgrade_RemoveLocations self)

        Increments the reference counter of this object


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveLocations_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeUpgrade_RemoveLocations self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveLocations_DecrementRefCounter(self, *args)

Handle_ShapeUpgrade_RemoveLocations_swigregister = _ShapeUpgrade.Handle_ShapeUpgrade_RemoveLocations_swigregister
Handle_ShapeUpgrade_RemoveLocations_swigregister(Handle_ShapeUpgrade_RemoveLocations)

def Handle_ShapeUpgrade_RemoveLocations_DownCast(thing):
    return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveLocations_DownCast(thing)
Handle_ShapeUpgrade_RemoveLocations_DownCast = _ShapeUpgrade.Handle_ShapeUpgrade_RemoveLocations_DownCast

class Handle_ShapeUpgrade_SplitSurface(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeUpgrade_SplitSurface self)

        Nullify the handle


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeUpgrade_SplitSurface self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeUpgrade_SplitSurface self, ShapeUpgrade_SplitSurface thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeUpgrade_SplitSurface self, Handle_ShapeUpgrade_SplitSurface theHandle) -> Handle_ShapeUpgrade_SplitSurface
        assign(Handle_ShapeUpgrade_SplitSurface self, ShapeUpgrade_SplitSurface thePtr) -> Handle_ShapeUpgrade_SplitSurface
        assign(Handle_ShapeUpgrade_SplitSurface self, Handle_ShapeUpgrade_SplitSurface theHandle) -> Handle_ShapeUpgrade_SplitSurface

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeUpgrade_SplitSurface self) -> ShapeUpgrade_SplitSurface

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeUpgrade_SplitSurface self) -> ShapeUpgrade_SplitSurface

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeUpgrade_SplitSurface self) -> ShapeUpgrade_SplitSurface

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface___ref__(self, *args)


    def __hash__(self):
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeUpgrade.new_Handle_ShapeUpgrade_SplitSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface_DownCast)
    __swig_destroy__ = _ShapeUpgrade.delete_Handle_ShapeUpgrade_SplitSurface

    def Init(self, *args):
        """
        Init(Handle_ShapeUpgrade_SplitSurface self, Handle_Geom_Surface S)
        Init(Handle_ShapeUpgrade_SplitSurface self, Handle_Geom_Surface S, Standard_Real const UFirst, Standard_Real const ULast, Standard_Real const VFirst, Standard_Real const VLast)

        Initializes with single supporting surface with bounding parameters.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type UFirst: float
        :type ULast: float
        :type VFirst: float
        :type VLast: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface_Init(self, *args)


    def SetUSplitValues(self, *args):
        """
        SetUSplitValues(Handle_ShapeUpgrade_SplitSurface self, Handle_TColStd_HSequenceOfReal UValues)

        Sets U parameters where splitting has to be done

        :type UValues: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface_SetUSplitValues(self, *args)


    def SetVSplitValues(self, *args):
        """
        SetVSplitValues(Handle_ShapeUpgrade_SplitSurface self, Handle_TColStd_HSequenceOfReal VValues)

        Sets V parameters where splitting has to be done

        :type VValues: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface_SetVSplitValues(self, *args)


    def Build(self, *args):
        """
        Build(Handle_ShapeUpgrade_SplitSurface self, Standard_Boolean const Segment)

        Performs splitting of the supporting surface.
        If resulting surface is B-Spline and Segment is True,
        the result is composed with segments of the surface bounded
        by the U and V SplitValues (method Geom_BSplineSurface::Segment
        is used).
        If Segment is False, the result is composed with
        Geom_RectangularTrimmedSurface all based on the same complete
        surface.
        Fields myNbResultingRow and myNbResultingCol must be set to
        specify the size of resulting grid of surfaces.

        :type Segment: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface_Build(self, *args)


    def Compute(self, *args):
        """
        Compute(Handle_ShapeUpgrade_SplitSurface self, Standard_Boolean const Segment)

        Calculates points for correction/splitting of the surface.

        :type Segment: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface_Compute(self, *args)


    def Perform(self, *args):
        """
        Perform(Handle_ShapeUpgrade_SplitSurface self, Standard_Boolean const Segment)

        Performs correction/splitting of the surface.
        First defines splitting values by method Compute(), then calls method Build().

        :type Segment: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface_Perform(self, *args)


    def USplitValues(self, *args):
        """
        returns all the U splitting values including the
        First and Last parameters of the input surface

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface_USplitValues(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def VSplitValues(self, *args):
        """
        returns all the splitting V values including the
        First and Last parameters of the input surface

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface_VSplitValues(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Status(self, *args):
        """
        Status(Handle_ShapeUpgrade_SplitSurface self, ShapeExtend_Status const status) -> Standard_Boolean

        Returns the status
        OK    - no splitting is needed
        DONE1 - splitting required and gives more than one patch
        DONE2 - splitting is required, but gives only single patch (initial)
        DONE3 - geometric form of the surface or parametrisation is modified

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface_Status(self, *args)


    def ResSurfaces(self, *args):
        """
        Returns obtained surfaces after splitting as CompositeSurface

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_CompositeSurface

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface_ResSurfaces(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeUpgrade_SplitSurface self) -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_ShapeUpgrade_SplitSurface self)

        Memory deallocator for transient classes


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeUpgrade_SplitSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeUpgrade_SplitSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeUpgrade_SplitSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeUpgrade_SplitSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeUpgrade_SplitSurface self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeUpgrade_SplitSurface self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeUpgrade_SplitSurface self)

        Increments the reference counter of this object


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeUpgrade_SplitSurface self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface_DecrementRefCounter(self, *args)

Handle_ShapeUpgrade_SplitSurface_swigregister = _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface_swigregister
Handle_ShapeUpgrade_SplitSurface_swigregister(Handle_ShapeUpgrade_SplitSurface)

def Handle_ShapeUpgrade_SplitSurface_DownCast(thing):
    return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface_DownCast(thing)
Handle_ShapeUpgrade_SplitSurface_DownCast = _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface_DownCast

class Handle_ShapeUpgrade_WireDivide(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeUpgrade_WireDivide self)

        Nullify the handle


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeUpgrade_WireDivide self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeUpgrade_WireDivide self, ShapeUpgrade_WireDivide thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeUpgrade_WireDivide self, Handle_ShapeUpgrade_WireDivide theHandle) -> Handle_ShapeUpgrade_WireDivide
        assign(Handle_ShapeUpgrade_WireDivide self, ShapeUpgrade_WireDivide thePtr) -> Handle_ShapeUpgrade_WireDivide
        assign(Handle_ShapeUpgrade_WireDivide self, Handle_ShapeUpgrade_WireDivide theHandle) -> Handle_ShapeUpgrade_WireDivide

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeUpgrade_WireDivide self) -> ShapeUpgrade_WireDivide

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeUpgrade_WireDivide self) -> ShapeUpgrade_WireDivide

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeUpgrade_WireDivide self) -> ShapeUpgrade_WireDivide

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide___ref__(self, *args)


    def __hash__(self):
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeUpgrade.new_Handle_ShapeUpgrade_WireDivide(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_DownCast)
    __swig_destroy__ = _ShapeUpgrade.delete_Handle_ShapeUpgrade_WireDivide

    def Init(self, *args):
        """
        Init(Handle_ShapeUpgrade_WireDivide self, TopoDS_Wire W, TopoDS_Face F)
        Init(Handle_ShapeUpgrade_WireDivide self, TopoDS_Wire W, Handle_Geom_Surface S)

        Initializes by wire and surface

        :type W: OCC.wrapper.TopoDS.TopoDS_Wire
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_Init(self, *args)


    def Load(self, *args):
        """
        Load(Handle_ShapeUpgrade_WireDivide self, TopoDS_Wire W)
        Load(Handle_ShapeUpgrade_WireDivide self, TopoDS_Edge E)

        Creates wire of one edge and calls Load for wire

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_Load(self, *args)


    def SetFace(self, *args):
        """
        SetFace(Handle_ShapeUpgrade_WireDivide self, TopoDS_Face F)

        Sets supporting surface by face

        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_SetFace(self, *args)


    def SetSurface(self, *args):
        """
        SetSurface(Handle_ShapeUpgrade_WireDivide self, Handle_Geom_Surface S)
        SetSurface(Handle_ShapeUpgrade_WireDivide self, Handle_Geom_Surface S, TopLoc_Location L)

        Sets supporting surface with location

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_SetSurface(self, *args)


    def Perform(self, *args):
        """
        Perform(Handle_ShapeUpgrade_WireDivide self)

        Computes the resulting wire by splitting all the edges
        according to splitting criteria.
        All the modifications made are recorded in context
        (ShapeBuild_ReShape). This tool is applied to all edges
        before splitting them in order to keep sharings.
        If no supporting face or surface is defined, only 3d
        splitting criteria are used.


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_Perform(self, *args)


    def Wire(self, *args):
        """
        Gives the resulting Wire (equal to initial one if not done
        or Null if not loaded)

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_Wire(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Status(self, *args):
        """
        Status(Handle_ShapeUpgrade_WireDivide self, ShapeExtend_Status const status) -> Standard_Boolean

        Queries status of last call to Perform()
        OK - no edges were splitted, wire left untouched
        DONE1 - some edges were splitted
        FAIL1 - some edges have no 3d curve (skipped)
        FAIL2 - some edges have no pcurve (skipped)

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_Status(self, *args)


    def SetSplitCurve3dTool(self, *args):
        """
        SetSplitCurve3dTool(Handle_ShapeUpgrade_WireDivide self, Handle_ShapeUpgrade_SplitCurve3d splitCurve3dTool)

        Sets the tool for splitting 3D curves.

        :type splitCurve3dTool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_SetSplitCurve3dTool(self, *args)


    def SetSplitCurve2dTool(self, *args):
        """
        SetSplitCurve2dTool(Handle_ShapeUpgrade_WireDivide self, Handle_ShapeUpgrade_SplitCurve2d splitCurve2dTool)

        Sets the tool for splitting pcurves.

        :type splitCurve2dTool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_SetSplitCurve2dTool(self, *args)


    def SetTransferParamTool(self, *args):
        """
        SetTransferParamTool(Handle_ShapeUpgrade_WireDivide self, Handle_ShapeAnalysis_TransferParameters TransferParam)

        Sets the tool for Transfer parameters between curves and pcurves.

        :type TransferParam: OCC.wrapper.ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_SetTransferParamTool(self, *args)


    def SetEdgeDivideTool(self, *args):
        """
        SetEdgeDivideTool(Handle_ShapeUpgrade_WireDivide self, Handle_ShapeUpgrade_EdgeDivide edgeDivideTool)

        Sets tool for splitting edge

        :type edgeDivideTool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_SetEdgeDivideTool(self, *args)


    def GetEdgeDivideTool(self, *args):
        """
        GetEdgeDivideTool(Handle_ShapeUpgrade_WireDivide self) -> Handle_ShapeUpgrade_EdgeDivide

        returns tool for splitting edges

        :rtype: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_GetEdgeDivideTool(self, *args)


    def GetTransferParamTool(self, *args):
        """
        GetTransferParamTool(Handle_ShapeUpgrade_WireDivide self) -> Handle_ShapeAnalysis_TransferParameters

        Returns the tool for Transfer of parameters.

        :rtype: OCC.wrapper.ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_GetTransferParamTool(self, *args)


    def SetEdgeMode(self, *args):
        """
        SetEdgeMode(Handle_ShapeUpgrade_WireDivide self, Standard_Integer const EdgeMode)

        Sets mode for splitting 3d curves from edges.
        0 - only curve 3d from free edges.
        1 - only curve 3d from shared edges.
        2 -  all curve 3d.

        :type EdgeMode: int

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_SetEdgeMode(self, *args)


    def SetFixSmallCurveTool(self, *args):
        """
        SetFixSmallCurveTool(Handle_ShapeUpgrade_WireDivide self, Handle_ShapeUpgrade_FixSmallCurves FixSmallCurvesTool)

        Sets tool for fixing small curves with specified min tolerance;

        :type FixSmallCurvesTool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_SetFixSmallCurveTool(self, *args)


    def GetFixSmallCurveTool(self, *args):
        """
        GetFixSmallCurveTool(Handle_ShapeUpgrade_WireDivide self) -> Handle_ShapeUpgrade_FixSmallCurves

        Returns tool for fixing small curves

        :rtype: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_GetFixSmallCurveTool(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeUpgrade_WireDivide self) -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_ShapeUpgrade_WireDivide self, Handle_ShapeUpgrade_Tool tool)

        Copy all fields from another Root object

        :type tool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_Tool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_Set(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_ShapeUpgrade_WireDivide self, Handle_ShapeBuild_ReShape context)

        Sets context

        :type context: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_SetContext(self, *args)


    def Context(self, *args):
        """
        Context(Handle_ShapeUpgrade_WireDivide self) -> Handle_ShapeBuild_ReShape

        Returns context

        :rtype: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_Context(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(Handle_ShapeUpgrade_WireDivide self, Standard_Real const preci)

        Sets basic precision value

        :type preci: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_SetPrecision(self, *args)


    def Precision(self, *args):
        """
        Precision(Handle_ShapeUpgrade_WireDivide self) -> Standard_Real

        Returns basic precision value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_Precision(self, *args)


    def SetMinTolerance(self, *args):
        """
        SetMinTolerance(Handle_ShapeUpgrade_WireDivide self, Standard_Real const mintol)

        Sets minimal allowed tolerance

        :type mintol: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_SetMinTolerance(self, *args)


    def MinTolerance(self, *args):
        """
        MinTolerance(Handle_ShapeUpgrade_WireDivide self) -> Standard_Real

        Returns minimal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_MinTolerance(self, *args)


    def SetMaxTolerance(self, *args):
        """
        SetMaxTolerance(Handle_ShapeUpgrade_WireDivide self, Standard_Real const maxtol)

        Sets maximal allowed tolerance

        :type maxtol: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_SetMaxTolerance(self, *args)


    def MaxTolerance(self, *args):
        """
        MaxTolerance(Handle_ShapeUpgrade_WireDivide self) -> Standard_Real

        Returns maximal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_MaxTolerance(self, *args)


    def LimitTolerance(self, *args):
        """
        LimitTolerance(Handle_ShapeUpgrade_WireDivide self, Standard_Real const toler) -> Standard_Real

        Returns tolerance limited by [myMinTol,myMaxTol]

        :type toler: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_LimitTolerance(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeUpgrade_WireDivide self)

        Memory deallocator for transient classes


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeUpgrade_WireDivide self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeUpgrade_WireDivide self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeUpgrade_WireDivide self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeUpgrade_WireDivide self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeUpgrade_WireDivide self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeUpgrade_WireDivide self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeUpgrade_WireDivide self)

        Increments the reference counter of this object


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeUpgrade_WireDivide self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_DecrementRefCounter(self, *args)

Handle_ShapeUpgrade_WireDivide_swigregister = _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_swigregister
Handle_ShapeUpgrade_WireDivide_swigregister(Handle_ShapeUpgrade_WireDivide)

def Handle_ShapeUpgrade_WireDivide_DownCast(thing):
    return _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_DownCast(thing)
Handle_ShapeUpgrade_WireDivide_DownCast = _ShapeUpgrade.Handle_ShapeUpgrade_WireDivide_DownCast

class Handle_ShapeUpgrade_ConvertCurve2dToBezier(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeUpgrade_ConvertCurve2dToBezier self)

        Nullify the handle


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve2dToBezier_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeUpgrade_ConvertCurve2dToBezier self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve2dToBezier_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeUpgrade_ConvertCurve2dToBezier self, ShapeUpgrade_ConvertCurve2dToBezier thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve2dToBezier_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeUpgrade_ConvertCurve2dToBezier self, Handle_ShapeUpgrade_ConvertCurve2dToBezier theHandle) -> Handle_ShapeUpgrade_ConvertCurve2dToBezier
        assign(Handle_ShapeUpgrade_ConvertCurve2dToBezier self, ShapeUpgrade_ConvertCurve2dToBezier thePtr) -> Handle_ShapeUpgrade_ConvertCurve2dToBezier
        assign(Handle_ShapeUpgrade_ConvertCurve2dToBezier self, Handle_ShapeUpgrade_ConvertCurve2dToBezier theHandle) -> Handle_ShapeUpgrade_ConvertCurve2dToBezier

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve2dToBezier_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeUpgrade_ConvertCurve2dToBezier self) -> ShapeUpgrade_ConvertCurve2dToBezier

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve2dToBezier_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeUpgrade_ConvertCurve2dToBezier self) -> ShapeUpgrade_ConvertCurve2dToBezier

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve2dToBezier___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeUpgrade_ConvertCurve2dToBezier self) -> ShapeUpgrade_ConvertCurve2dToBezier

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve2dToBezier___ref__(self, *args)


    def __hash__(self):
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve2dToBezier___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve2dToBezier___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeUpgrade.new_Handle_ShapeUpgrade_ConvertCurve2dToBezier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve2dToBezier_DownCast)
    __swig_destroy__ = _ShapeUpgrade.delete_Handle_ShapeUpgrade_ConvertCurve2dToBezier

    def Compute(self, *args):
        """
        Compute(Handle_ShapeUpgrade_ConvertCurve2dToBezier self)

        Converts curve into a list of beziers, and stores the
        splitting parameters on original curve.


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve2dToBezier_Compute(self, *args)


    def Build(self, *args):
        """
        Build(Handle_ShapeUpgrade_ConvertCurve2dToBezier self, Standard_Boolean const Segment)

        Splits a list of beziers computed by Compute method according
        the split values and splitting parameters.

        :type Segment: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve2dToBezier_Build(self, *args)


    def SplitParams(self, *args):
        """
        SplitParams(Handle_ShapeUpgrade_ConvertCurve2dToBezier self) -> Handle_TColStd_HSequenceOfReal

        Returns the list of splitted parameters in original curve
        parametrisation.

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve2dToBezier_SplitParams(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeUpgrade_ConvertCurve2dToBezier self) -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve2dToBezier_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve2dToBezier_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve2dToBezier_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_ShapeUpgrade_ConvertCurve2dToBezier self, Handle_Geom2d_Curve C)
        Init(Handle_ShapeUpgrade_ConvertCurve2dToBezier self, Handle_Geom2d_Curve C, Standard_Real const First, Standard_Real const Last)

        Initializes with pcurve with its parameters.

        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type First: float
        :type Last: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve2dToBezier_Init(self, *args)


    def GetCurves(self, *args):
        """
        :rtype: OCC.wrapper.TColGeom2d.Handle_TColGeom2d_HArray1OfCurve

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve2dToBezier_GetCurves(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSplitValues(self, *args):
        """
        SetSplitValues(Handle_ShapeUpgrade_ConvertCurve2dToBezier self, Handle_TColStd_HSequenceOfReal SplitValues)

        Sets the parameters where splitting has to be done.

        :type SplitValues: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve2dToBezier_SetSplitValues(self, *args)


    def SplitValues(self, *args):
        """
        returns all the splitting values including the
        First and Last parameters of the input curve
        Merges input split values and new ones into myGlobalKnots

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve2dToBezier_SplitValues(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Perform(self, *args):
        """
        Perform(Handle_ShapeUpgrade_ConvertCurve2dToBezier self, Standard_Boolean const Segment)

        Performs correction/splitting of the curve.
        First defines splitting values by method Compute(), then calls method Build().

        :type Segment: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve2dToBezier_Perform(self, *args)


    def Status(self, *args):
        """
        Status(Handle_ShapeUpgrade_ConvertCurve2dToBezier self, ShapeExtend_Status const status) -> Standard_Boolean

        Returns the status
        OK    - no splitting is needed
        DONE1 - splitting required and gives more than one segment
        DONE2 - splitting is required, but gives only one segment (initial)
        DONE3 - geometric form of the curve or parametrisation is modified

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve2dToBezier_Status(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeUpgrade_ConvertCurve2dToBezier self)

        Memory deallocator for transient classes


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve2dToBezier_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeUpgrade_ConvertCurve2dToBezier self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeUpgrade_ConvertCurve2dToBezier self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve2dToBezier_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeUpgrade_ConvertCurve2dToBezier self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeUpgrade_ConvertCurve2dToBezier self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve2dToBezier_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeUpgrade_ConvertCurve2dToBezier self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve2dToBezier_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeUpgrade_ConvertCurve2dToBezier self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve2dToBezier_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeUpgrade_ConvertCurve2dToBezier self)

        Increments the reference counter of this object


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve2dToBezier_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeUpgrade_ConvertCurve2dToBezier self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve2dToBezier_DecrementRefCounter(self, *args)

Handle_ShapeUpgrade_ConvertCurve2dToBezier_swigregister = _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve2dToBezier_swigregister
Handle_ShapeUpgrade_ConvertCurve2dToBezier_swigregister(Handle_ShapeUpgrade_ConvertCurve2dToBezier)

def Handle_ShapeUpgrade_ConvertCurve2dToBezier_DownCast(thing):
    return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve2dToBezier_DownCast(thing)
Handle_ShapeUpgrade_ConvertCurve2dToBezier_DownCast = _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve2dToBezier_DownCast

class Handle_ShapeUpgrade_FixSmallCurves(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeUpgrade_FixSmallCurves self)

        Nullify the handle


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeUpgrade_FixSmallCurves self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeUpgrade_FixSmallCurves self, ShapeUpgrade_FixSmallCurves thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeUpgrade_FixSmallCurves self, Handle_ShapeUpgrade_FixSmallCurves theHandle) -> Handle_ShapeUpgrade_FixSmallCurves
        assign(Handle_ShapeUpgrade_FixSmallCurves self, ShapeUpgrade_FixSmallCurves thePtr) -> Handle_ShapeUpgrade_FixSmallCurves
        assign(Handle_ShapeUpgrade_FixSmallCurves self, Handle_ShapeUpgrade_FixSmallCurves theHandle) -> Handle_ShapeUpgrade_FixSmallCurves

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeUpgrade_FixSmallCurves self) -> ShapeUpgrade_FixSmallCurves

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeUpgrade_FixSmallCurves self) -> ShapeUpgrade_FixSmallCurves

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeUpgrade_FixSmallCurves self) -> ShapeUpgrade_FixSmallCurves

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves___ref__(self, *args)


    def __hash__(self):
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeUpgrade.new_Handle_ShapeUpgrade_FixSmallCurves(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves_DownCast)
    __swig_destroy__ = _ShapeUpgrade.delete_Handle_ShapeUpgrade_FixSmallCurves

    def Init(self, *args):
        """
        Init(Handle_ShapeUpgrade_FixSmallCurves self, TopoDS_Edge theEdge, TopoDS_Face theFace)

        :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves_Init(self, *args)


    def Approx(self, *args):
        """
        Approx(Handle_ShapeUpgrade_FixSmallCurves self, Handle_Geom_Curve Curve3d, Handle_Geom2d_Curve Curve2d, Handle_Geom2d_Curve Curve2dR) -> Standard_Boolean

        :type Curve3d: OCC.wrapper.Geom.Handle_Geom_Curve
        :type Curve2d: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Curve2dR: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type First: float
        :type Last: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves_Approx(self, *args)


    def SetSplitCurve3dTool(self, *args):
        """
        SetSplitCurve3dTool(Handle_ShapeUpgrade_FixSmallCurves self, Handle_ShapeUpgrade_SplitCurve3d splitCurve3dTool)

        Sets the tool for splitting 3D curves.

        :type splitCurve3dTool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves_SetSplitCurve3dTool(self, *args)


    def SetSplitCurve2dTool(self, *args):
        """
        SetSplitCurve2dTool(Handle_ShapeUpgrade_FixSmallCurves self, Handle_ShapeUpgrade_SplitCurve2d splitCurve2dTool)

        Sets the tool for splitting pcurves.

        :type splitCurve2dTool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves_SetSplitCurve2dTool(self, *args)


    def Status(self, *args):
        """
        Status(Handle_ShapeUpgrade_FixSmallCurves self, ShapeExtend_Status const status) -> Standard_Boolean

        Queries the status of last call to Perform
        OK   :
        DONE1:
        DONE2:
        FAIL1:

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves_Status(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeUpgrade_FixSmallCurves self) -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_ShapeUpgrade_FixSmallCurves self, Handle_ShapeUpgrade_Tool tool)

        Copy all fields from another Root object

        :type tool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_Tool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves_Set(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_ShapeUpgrade_FixSmallCurves self, Handle_ShapeBuild_ReShape context)

        Sets context

        :type context: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves_SetContext(self, *args)


    def Context(self, *args):
        """
        Context(Handle_ShapeUpgrade_FixSmallCurves self) -> Handle_ShapeBuild_ReShape

        Returns context

        :rtype: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves_Context(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(Handle_ShapeUpgrade_FixSmallCurves self, Standard_Real const preci)

        Sets basic precision value

        :type preci: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves_SetPrecision(self, *args)


    def Precision(self, *args):
        """
        Precision(Handle_ShapeUpgrade_FixSmallCurves self) -> Standard_Real

        Returns basic precision value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves_Precision(self, *args)


    def SetMinTolerance(self, *args):
        """
        SetMinTolerance(Handle_ShapeUpgrade_FixSmallCurves self, Standard_Real const mintol)

        Sets minimal allowed tolerance

        :type mintol: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves_SetMinTolerance(self, *args)


    def MinTolerance(self, *args):
        """
        MinTolerance(Handle_ShapeUpgrade_FixSmallCurves self) -> Standard_Real

        Returns minimal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves_MinTolerance(self, *args)


    def SetMaxTolerance(self, *args):
        """
        SetMaxTolerance(Handle_ShapeUpgrade_FixSmallCurves self, Standard_Real const maxtol)

        Sets maximal allowed tolerance

        :type maxtol: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves_SetMaxTolerance(self, *args)


    def MaxTolerance(self, *args):
        """
        MaxTolerance(Handle_ShapeUpgrade_FixSmallCurves self) -> Standard_Real

        Returns maximal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves_MaxTolerance(self, *args)


    def LimitTolerance(self, *args):
        """
        LimitTolerance(Handle_ShapeUpgrade_FixSmallCurves self, Standard_Real const toler) -> Standard_Real

        Returns tolerance limited by [myMinTol,myMaxTol]

        :type toler: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves_LimitTolerance(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeUpgrade_FixSmallCurves self)

        Memory deallocator for transient classes


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeUpgrade_FixSmallCurves self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeUpgrade_FixSmallCurves self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeUpgrade_FixSmallCurves self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeUpgrade_FixSmallCurves self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeUpgrade_FixSmallCurves self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeUpgrade_FixSmallCurves self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeUpgrade_FixSmallCurves self)

        Increments the reference counter of this object


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeUpgrade_FixSmallCurves self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves_DecrementRefCounter(self, *args)

Handle_ShapeUpgrade_FixSmallCurves_swigregister = _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves_swigregister
Handle_ShapeUpgrade_FixSmallCurves_swigregister(Handle_ShapeUpgrade_FixSmallCurves)

def Handle_ShapeUpgrade_FixSmallCurves_DownCast(thing):
    return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves_DownCast(thing)
Handle_ShapeUpgrade_FixSmallCurves_DownCast = _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallCurves_DownCast

class ShapeUpgrade_ShapeDivideAngle(ShapeUpgrade_ShapeDivide):
    """
    Splits all surfaces of revolution, cylindrical, toroidal,
    conical, spherical surfaces in the given shape so that
    each resulting segment covers not more than defined number
    of degrees (to segments less than 90).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ShapeUpgrade_ShapeDivideAngle self, Standard_Real const MaxAngle) -> ShapeUpgrade_ShapeDivideAngle
        __init__(ShapeUpgrade_ShapeDivideAngle self, Standard_Real const MaxAngle, TopoDS_Shape S) -> ShapeUpgrade_ShapeDivideAngle

        Initialize by a Shape.

        :type MaxAngle: float
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _ShapeUpgrade.new_ShapeUpgrade_ShapeDivideAngle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def InitTool(self, *args):
        """
        InitTool(ShapeUpgrade_ShapeDivideAngle self, Standard_Real const MaxAngle)

        Resets tool for splitting face with given angle

        :type MaxAngle: float

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeDivideAngle_InitTool(self, *args)


    def SetMaxAngle(self, *args):
        """
        SetMaxAngle(ShapeUpgrade_ShapeDivideAngle self, Standard_Real const MaxAngle)

        Set maximal angle (calls InitTool)

        :type MaxAngle: float

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeDivideAngle_SetMaxAngle(self, *args)


    def MaxAngle(self, *args):
        """
        MaxAngle(ShapeUpgrade_ShapeDivideAngle self) -> Standard_Real

        Returns maximal angle

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeDivideAngle_MaxAngle(self, *args)

    __swig_destroy__ = _ShapeUpgrade.delete_ShapeUpgrade_ShapeDivideAngle
ShapeUpgrade_ShapeDivideAngle_swigregister = _ShapeUpgrade.ShapeUpgrade_ShapeDivideAngle_swigregister
ShapeUpgrade_ShapeDivideAngle_swigregister(ShapeUpgrade_ShapeDivideAngle)

class ShapeUpgrade_FaceDivideArea(ShapeUpgrade_FaceDivide):
    """Divides face by max area criterium."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeUpgrade_FaceDivideArea
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeUpgrade_FaceDivideArea(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeUpgrade_FaceDivideArea self) -> ShapeUpgrade_FaceDivideArea
        __init__(ShapeUpgrade_FaceDivideArea self, TopoDS_Face F) -> ShapeUpgrade_FaceDivideArea

        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        this = _ShapeUpgrade.new_ShapeUpgrade_FaceDivideArea(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Perform(self, *args):
        """
        Perform(ShapeUpgrade_FaceDivideArea self) -> Standard_Boolean

        Performs splitting and computes the resulting shell
        The context is used to keep track of former splittings

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_FaceDivideArea_Perform(self, *args)


    def MaxArea(self, *args):
        """
        MaxArea(ShapeUpgrade_FaceDivideArea self) -> Standard_Real &

        Set max area allowed for faces

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.ShapeUpgrade_FaceDivideArea_MaxArea(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.ShapeUpgrade_FaceDivideArea_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeUpgrade.ShapeUpgrade_FaceDivideArea_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.ShapeUpgrade_FaceDivideArea_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeUpgrade.delete_ShapeUpgrade_FaceDivideArea
ShapeUpgrade_FaceDivideArea_swigregister = _ShapeUpgrade.ShapeUpgrade_FaceDivideArea_swigregister
ShapeUpgrade_FaceDivideArea_swigregister(ShapeUpgrade_FaceDivideArea)

def ShapeUpgrade_FaceDivideArea_get_type_name(*args):
    """
    ShapeUpgrade_FaceDivideArea_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeUpgrade.ShapeUpgrade_FaceDivideArea_get_type_name(*args)

def ShapeUpgrade_FaceDivideArea_get_type_descriptor(*args):
    """
    ShapeUpgrade_FaceDivideArea_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeUpgrade.ShapeUpgrade_FaceDivideArea_get_type_descriptor(*args)

class ShapeUpgrade_SplitSurfaceAngle(ShapeUpgrade_SplitSurface):
    """
    Splits a surfaces of revolution, cylindrical, toroidal,
    conical, spherical so that each resulting segment covers
    not more than defined number of degrees.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeUpgrade_SplitSurfaceAngle
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeUpgrade_SplitSurfaceAngle(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeUpgrade_SplitSurfaceAngle self, Standard_Real const MaxAngle) -> ShapeUpgrade_SplitSurfaceAngle

        Empty constructor.

        :type MaxAngle: float

        """
        this = _ShapeUpgrade.new_ShapeUpgrade_SplitSurfaceAngle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetMaxAngle(self, *args):
        """
        SetMaxAngle(ShapeUpgrade_SplitSurfaceAngle self, Standard_Real const MaxAngle)

        Set maximal angle

        :type MaxAngle: float

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitSurfaceAngle_SetMaxAngle(self, *args)


    def MaxAngle(self, *args):
        """
        MaxAngle(ShapeUpgrade_SplitSurfaceAngle self) -> Standard_Real

        Returns maximal angle

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitSurfaceAngle_MaxAngle(self, *args)


    def Compute(self, *args):
        """
        Compute(ShapeUpgrade_SplitSurfaceAngle self, Standard_Boolean const Segment)

        Performs splitting of the supporting surface(s).
        First defines splitting values, then calls inherited method.

        :type Segment: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitSurfaceAngle_Compute(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitSurfaceAngle_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitSurfaceAngle_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.ShapeUpgrade_SplitSurfaceAngle_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeUpgrade.delete_ShapeUpgrade_SplitSurfaceAngle
ShapeUpgrade_SplitSurfaceAngle_swigregister = _ShapeUpgrade.ShapeUpgrade_SplitSurfaceAngle_swigregister
ShapeUpgrade_SplitSurfaceAngle_swigregister(ShapeUpgrade_SplitSurfaceAngle)

def ShapeUpgrade_SplitSurfaceAngle_get_type_name(*args):
    """
    ShapeUpgrade_SplitSurfaceAngle_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeUpgrade.ShapeUpgrade_SplitSurfaceAngle_get_type_name(*args)

def ShapeUpgrade_SplitSurfaceAngle_get_type_descriptor(*args):
    """
    ShapeUpgrade_SplitSurfaceAngle_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeUpgrade.ShapeUpgrade_SplitSurfaceAngle_get_type_descriptor(*args)

class ShapeUpgrade_SplitSurfaceArea(ShapeUpgrade_SplitSurface):
    """
    Split surface in the parametric space
    in according specified number of splits on the
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeUpgrade_SplitSurfaceArea
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeUpgrade_SplitSurfaceArea(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeUpgrade_SplitSurfaceArea self) -> ShapeUpgrade_SplitSurfaceArea

        Empty constructor.


        """
        this = _ShapeUpgrade.new_ShapeUpgrade_SplitSurfaceArea(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NbParts(self, *args):
        """
        NbParts(ShapeUpgrade_SplitSurfaceArea self) -> Standard_Integer &

        Set number of split for surfaces

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitSurfaceArea_NbParts(self, *args)


    def Compute(self, *args):
        """
        Compute(ShapeUpgrade_SplitSurfaceArea self, Standard_Boolean const Segment)

        :type Segment: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitSurfaceArea_Compute(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitSurfaceArea_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeUpgrade.ShapeUpgrade_SplitSurfaceArea_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.ShapeUpgrade_SplitSurfaceArea_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeUpgrade.delete_ShapeUpgrade_SplitSurfaceArea
ShapeUpgrade_SplitSurfaceArea_swigregister = _ShapeUpgrade.ShapeUpgrade_SplitSurfaceArea_swigregister
ShapeUpgrade_SplitSurfaceArea_swigregister(ShapeUpgrade_SplitSurfaceArea)

def ShapeUpgrade_SplitSurfaceArea_get_type_name(*args):
    """
    ShapeUpgrade_SplitSurfaceArea_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeUpgrade.ShapeUpgrade_SplitSurfaceArea_get_type_name(*args)

def ShapeUpgrade_SplitSurfaceArea_get_type_descriptor(*args):
    """
    ShapeUpgrade_SplitSurfaceArea_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeUpgrade.ShapeUpgrade_SplitSurfaceArea_get_type_descriptor(*args)

class Handle_ShapeUpgrade_EdgeDivide(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeUpgrade_EdgeDivide self)

        Nullify the handle


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeUpgrade_EdgeDivide self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeUpgrade_EdgeDivide self, ShapeUpgrade_EdgeDivide thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeUpgrade_EdgeDivide self, Handle_ShapeUpgrade_EdgeDivide theHandle) -> Handle_ShapeUpgrade_EdgeDivide
        assign(Handle_ShapeUpgrade_EdgeDivide self, ShapeUpgrade_EdgeDivide thePtr) -> Handle_ShapeUpgrade_EdgeDivide
        assign(Handle_ShapeUpgrade_EdgeDivide self, Handle_ShapeUpgrade_EdgeDivide theHandle) -> Handle_ShapeUpgrade_EdgeDivide

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeUpgrade_EdgeDivide self) -> ShapeUpgrade_EdgeDivide

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeUpgrade_EdgeDivide self) -> ShapeUpgrade_EdgeDivide

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeUpgrade_EdgeDivide self) -> ShapeUpgrade_EdgeDivide

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide___ref__(self, *args)


    def __hash__(self):
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeUpgrade.new_Handle_ShapeUpgrade_EdgeDivide(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_DownCast)
    __swig_destroy__ = _ShapeUpgrade.delete_Handle_ShapeUpgrade_EdgeDivide

    def Clear(self, *args):
        """Clear(Handle_ShapeUpgrade_EdgeDivide self)"""
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_Clear(self, *args)


    def SetFace(self, *args):
        """
        SetFace(Handle_ShapeUpgrade_EdgeDivide self, TopoDS_Face F)

        Sets supporting surface by face

        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_SetFace(self, *args)


    def Compute(self, *args):
        """
        Compute(Handle_ShapeUpgrade_EdgeDivide self, TopoDS_Edge E) -> Standard_Boolean

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_Compute(self, *args)


    def HasCurve2d(self, *args):
        """
        HasCurve2d(Handle_ShapeUpgrade_EdgeDivide self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_HasCurve2d(self, *args)


    def HasCurve3d(self, *args):
        """
        HasCurve3d(Handle_ShapeUpgrade_EdgeDivide self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_HasCurve3d(self, *args)


    def Knots2d(self, *args):
        """
        Knots2d(Handle_ShapeUpgrade_EdgeDivide self) -> Handle_TColStd_HSequenceOfReal

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_Knots2d(self, *args)


    def Knots3d(self, *args):
        """
        Knots3d(Handle_ShapeUpgrade_EdgeDivide self) -> Handle_TColStd_HSequenceOfReal

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_Knots3d(self, *args)


    def SetSplitCurve2dTool(self, *args):
        """
        SetSplitCurve2dTool(Handle_ShapeUpgrade_EdgeDivide self, Handle_ShapeUpgrade_SplitCurve2d splitCurve2dTool)

        Sets the tool for splitting pcurves.

        :type splitCurve2dTool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_SetSplitCurve2dTool(self, *args)


    def SetSplitCurve3dTool(self, *args):
        """
        SetSplitCurve3dTool(Handle_ShapeUpgrade_EdgeDivide self, Handle_ShapeUpgrade_SplitCurve3d splitCurve3dTool)

        Sets the tool for splitting 3D curves.

        :type splitCurve3dTool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_SetSplitCurve3dTool(self, *args)


    def GetSplitCurve2dTool(self, *args):
        """
        GetSplitCurve2dTool(Handle_ShapeUpgrade_EdgeDivide self) -> Handle_ShapeUpgrade_SplitCurve2d

        Returns the tool for splitting pcurves.

        :rtype: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_GetSplitCurve2dTool(self, *args)


    def GetSplitCurve3dTool(self, *args):
        """
        GetSplitCurve3dTool(Handle_ShapeUpgrade_EdgeDivide self) -> Handle_ShapeUpgrade_SplitCurve3d

        Returns the tool for splitting 3D curves.

        :rtype: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_GetSplitCurve3dTool(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeUpgrade_EdgeDivide self) -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_ShapeUpgrade_EdgeDivide self, Handle_ShapeUpgrade_Tool tool)

        Copy all fields from another Root object

        :type tool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_Tool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_Set(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_ShapeUpgrade_EdgeDivide self, Handle_ShapeBuild_ReShape context)

        Sets context

        :type context: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_SetContext(self, *args)


    def Context(self, *args):
        """
        Context(Handle_ShapeUpgrade_EdgeDivide self) -> Handle_ShapeBuild_ReShape

        Returns context

        :rtype: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_Context(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(Handle_ShapeUpgrade_EdgeDivide self, Standard_Real const preci)

        Sets basic precision value

        :type preci: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_SetPrecision(self, *args)


    def Precision(self, *args):
        """
        Precision(Handle_ShapeUpgrade_EdgeDivide self) -> Standard_Real

        Returns basic precision value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_Precision(self, *args)


    def SetMinTolerance(self, *args):
        """
        SetMinTolerance(Handle_ShapeUpgrade_EdgeDivide self, Standard_Real const mintol)

        Sets minimal allowed tolerance

        :type mintol: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_SetMinTolerance(self, *args)


    def MinTolerance(self, *args):
        """
        MinTolerance(Handle_ShapeUpgrade_EdgeDivide self) -> Standard_Real

        Returns minimal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_MinTolerance(self, *args)


    def SetMaxTolerance(self, *args):
        """
        SetMaxTolerance(Handle_ShapeUpgrade_EdgeDivide self, Standard_Real const maxtol)

        Sets maximal allowed tolerance

        :type maxtol: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_SetMaxTolerance(self, *args)


    def MaxTolerance(self, *args):
        """
        MaxTolerance(Handle_ShapeUpgrade_EdgeDivide self) -> Standard_Real

        Returns maximal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_MaxTolerance(self, *args)


    def LimitTolerance(self, *args):
        """
        LimitTolerance(Handle_ShapeUpgrade_EdgeDivide self, Standard_Real const toler) -> Standard_Real

        Returns tolerance limited by [myMinTol,myMaxTol]

        :type toler: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_LimitTolerance(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeUpgrade_EdgeDivide self)

        Memory deallocator for transient classes


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeUpgrade_EdgeDivide self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeUpgrade_EdgeDivide self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeUpgrade_EdgeDivide self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeUpgrade_EdgeDivide self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeUpgrade_EdgeDivide self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeUpgrade_EdgeDivide self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeUpgrade_EdgeDivide self)

        Increments the reference counter of this object


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeUpgrade_EdgeDivide self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_DecrementRefCounter(self, *args)

Handle_ShapeUpgrade_EdgeDivide_swigregister = _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_swigregister
Handle_ShapeUpgrade_EdgeDivide_swigregister(Handle_ShapeUpgrade_EdgeDivide)

def Handle_ShapeUpgrade_EdgeDivide_DownCast(thing):
    return _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_DownCast(thing)
Handle_ShapeUpgrade_EdgeDivide_DownCast = _ShapeUpgrade.Handle_ShapeUpgrade_EdgeDivide_DownCast

class Handle_ShapeUpgrade_FaceDivide(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeUpgrade_FaceDivide self)

        Nullify the handle


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeUpgrade_FaceDivide self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeUpgrade_FaceDivide self, ShapeUpgrade_FaceDivide thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeUpgrade_FaceDivide self, Handle_ShapeUpgrade_FaceDivide theHandle) -> Handle_ShapeUpgrade_FaceDivide
        assign(Handle_ShapeUpgrade_FaceDivide self, ShapeUpgrade_FaceDivide thePtr) -> Handle_ShapeUpgrade_FaceDivide
        assign(Handle_ShapeUpgrade_FaceDivide self, Handle_ShapeUpgrade_FaceDivide theHandle) -> Handle_ShapeUpgrade_FaceDivide

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeUpgrade_FaceDivide self) -> ShapeUpgrade_FaceDivide

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeUpgrade_FaceDivide self) -> ShapeUpgrade_FaceDivide

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeUpgrade_FaceDivide self) -> ShapeUpgrade_FaceDivide

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide___ref__(self, *args)


    def __hash__(self):
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeUpgrade.new_Handle_ShapeUpgrade_FaceDivide(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_DownCast)
    __swig_destroy__ = _ShapeUpgrade.delete_Handle_ShapeUpgrade_FaceDivide

    def Init(self, *args):
        """
        Init(Handle_ShapeUpgrade_FaceDivide self, TopoDS_Face F)

        Initialize by a Face.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_Init(self, *args)


    def SetSurfaceSegmentMode(self, *args):
        """
        SetSurfaceSegmentMode(Handle_ShapeUpgrade_FaceDivide self, Standard_Boolean const Segment)

        Purpose sets mode for trimming (segment) surface by
        wire UV bounds.

        :type Segment: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_SetSurfaceSegmentMode(self, *args)


    def Perform(self, *args):
        """
        Perform(Handle_ShapeUpgrade_FaceDivide self) -> Standard_Boolean

        Performs splitting and computes the resulting shell
        The context is used to keep track of former splittings
        in order to keep sharings. It is updated according to
        modifications made.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_Perform(self, *args)


    def SplitSurface(self, *args):
        """
        SplitSurface(Handle_ShapeUpgrade_FaceDivide self) -> Standard_Boolean

        Performs splitting of surface and computes the shell
        from source face.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_SplitSurface(self, *args)


    def SplitCurves(self, *args):
        """
        SplitCurves(Handle_ShapeUpgrade_FaceDivide self) -> Standard_Boolean

        Performs splitting of curves of all the edges in the
        shape and divides these edges.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_SplitCurves(self, *args)


    def Result(self, *args):
        """
        Result(Handle_ShapeUpgrade_FaceDivide self) -> TopoDS_Shape

        Gives the resulting Shell, or Face, or Null shape if not done.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_Result(self, *args)


    def Status(self, *args):
        """
        Status(Handle_ShapeUpgrade_FaceDivide self, ShapeExtend_Status const status) -> Standard_Boolean

        Queries the status of last call to Perform
        OK   : no splitting was done (or no call to Perform)
        DONE1: some edges were splitted
        DONE2: surface was splitted
        DONE3: surface was modified without splitting
        FAIL1: some fails encountered during splitting wires
        FAIL2: face cannot be splitted

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_Status(self, *args)


    def SetSplitSurfaceTool(self, *args):
        """
        SetSplitSurfaceTool(Handle_ShapeUpgrade_FaceDivide self, Handle_ShapeUpgrade_SplitSurface splitSurfaceTool)

        Sets the tool for splitting surfaces.

        :type splitSurfaceTool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_SetSplitSurfaceTool(self, *args)


    def SetWireDivideTool(self, *args):
        """
        SetWireDivideTool(Handle_ShapeUpgrade_FaceDivide self, Handle_ShapeUpgrade_WireDivide wireDivideTool)

        Sets the tool for dividing edges on Face.

        :type wireDivideTool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_WireDivide

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_SetWireDivideTool(self, *args)


    def GetSplitSurfaceTool(self, *args):
        """
        GetSplitSurfaceTool(Handle_ShapeUpgrade_FaceDivide self) -> Handle_ShapeUpgrade_SplitSurface

        Returns the tool for splitting surfaces.
        This tool must be already initialized.

        :rtype: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_GetSplitSurfaceTool(self, *args)


    def GetWireDivideTool(self, *args):
        """
        GetWireDivideTool(Handle_ShapeUpgrade_FaceDivide self) -> Handle_ShapeUpgrade_WireDivide

        Returns the tool for dividing edges on Face.
        This tool must be already initialized.

        :rtype: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_WireDivide

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_GetWireDivideTool(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeUpgrade_FaceDivide self) -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_ShapeUpgrade_FaceDivide self, Handle_ShapeUpgrade_Tool tool)

        Copy all fields from another Root object

        :type tool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_Tool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_Set(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_ShapeUpgrade_FaceDivide self, Handle_ShapeBuild_ReShape context)

        Sets context

        :type context: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_SetContext(self, *args)


    def Context(self, *args):
        """
        Context(Handle_ShapeUpgrade_FaceDivide self) -> Handle_ShapeBuild_ReShape

        Returns context

        :rtype: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_Context(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(Handle_ShapeUpgrade_FaceDivide self, Standard_Real const preci)

        Sets basic precision value

        :type preci: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_SetPrecision(self, *args)


    def Precision(self, *args):
        """
        Precision(Handle_ShapeUpgrade_FaceDivide self) -> Standard_Real

        Returns basic precision value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_Precision(self, *args)


    def SetMinTolerance(self, *args):
        """
        SetMinTolerance(Handle_ShapeUpgrade_FaceDivide self, Standard_Real const mintol)

        Sets minimal allowed tolerance

        :type mintol: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_SetMinTolerance(self, *args)


    def MinTolerance(self, *args):
        """
        MinTolerance(Handle_ShapeUpgrade_FaceDivide self) -> Standard_Real

        Returns minimal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_MinTolerance(self, *args)


    def SetMaxTolerance(self, *args):
        """
        SetMaxTolerance(Handle_ShapeUpgrade_FaceDivide self, Standard_Real const maxtol)

        Sets maximal allowed tolerance

        :type maxtol: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_SetMaxTolerance(self, *args)


    def MaxTolerance(self, *args):
        """
        MaxTolerance(Handle_ShapeUpgrade_FaceDivide self) -> Standard_Real

        Returns maximal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_MaxTolerance(self, *args)


    def LimitTolerance(self, *args):
        """
        LimitTolerance(Handle_ShapeUpgrade_FaceDivide self, Standard_Real const toler) -> Standard_Real

        Returns tolerance limited by [myMinTol,myMaxTol]

        :type toler: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_LimitTolerance(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeUpgrade_FaceDivide self)

        Memory deallocator for transient classes


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeUpgrade_FaceDivide self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeUpgrade_FaceDivide self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeUpgrade_FaceDivide self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeUpgrade_FaceDivide self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeUpgrade_FaceDivide self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeUpgrade_FaceDivide self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeUpgrade_FaceDivide self)

        Increments the reference counter of this object


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeUpgrade_FaceDivide self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_DecrementRefCounter(self, *args)

Handle_ShapeUpgrade_FaceDivide_swigregister = _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_swigregister
Handle_ShapeUpgrade_FaceDivide_swigregister(Handle_ShapeUpgrade_FaceDivide)

def Handle_ShapeUpgrade_FaceDivide_DownCast(thing):
    return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_DownCast(thing)
Handle_ShapeUpgrade_FaceDivide_DownCast = _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivide_DownCast

class Handle_ShapeUpgrade_RemoveInternalWires(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeUpgrade_RemoveInternalWires self)

        Nullify the handle


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeUpgrade_RemoveInternalWires self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeUpgrade_RemoveInternalWires self, ShapeUpgrade_RemoveInternalWires thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeUpgrade_RemoveInternalWires self, Handle_ShapeUpgrade_RemoveInternalWires theHandle) -> Handle_ShapeUpgrade_RemoveInternalWires
        assign(Handle_ShapeUpgrade_RemoveInternalWires self, ShapeUpgrade_RemoveInternalWires thePtr) -> Handle_ShapeUpgrade_RemoveInternalWires
        assign(Handle_ShapeUpgrade_RemoveInternalWires self, Handle_ShapeUpgrade_RemoveInternalWires theHandle) -> Handle_ShapeUpgrade_RemoveInternalWires

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeUpgrade_RemoveInternalWires self) -> ShapeUpgrade_RemoveInternalWires

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeUpgrade_RemoveInternalWires self) -> ShapeUpgrade_RemoveInternalWires

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeUpgrade_RemoveInternalWires self) -> ShapeUpgrade_RemoveInternalWires

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires___ref__(self, *args)


    def __hash__(self):
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeUpgrade.new_Handle_ShapeUpgrade_RemoveInternalWires(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_DownCast)
    __swig_destroy__ = _ShapeUpgrade.delete_Handle_ShapeUpgrade_RemoveInternalWires

    def Init(self, *args):
        """
        Init(Handle_ShapeUpgrade_RemoveInternalWires self, TopoDS_Shape theShape)

        Initialize by a Shape.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_Init(self, *args)


    def Perform(self, *args):
        """
        Perform(Handle_ShapeUpgrade_RemoveInternalWires self) -> Standard_Boolean
        Perform(Handle_ShapeUpgrade_RemoveInternalWires self, NCollection_Sequence_TopoDS_Shape theSeqShapes) -> Standard_Boolean

        If specified sequence of shape contains -
        1.wires then these wires will be removed if they have area less than allowed min area.
        2.faces than internal wires from these faces will be removed if they have area less than allowed min area.

        :type theSeqShapes: OCC.wrapper.TopTools.TopTools_SequenceOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_Perform(self, *args)


    def GetResult(self, *args):
        """
        GetResult(Handle_ShapeUpgrade_RemoveInternalWires self) -> TopoDS_Shape

        Get result shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_GetResult(self, *args)


    def MinArea(self, *args):
        """
        MinArea(Handle_ShapeUpgrade_RemoveInternalWires self) -> Standard_Real &

        Set min area allowed for holes( all holes having area less than mi area will be removed)

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_MinArea(self, *args)


    def RemoveFaceMode(self, *args):
        """
        RemoveFaceMode(Handle_ShapeUpgrade_RemoveInternalWires self) -> Standard_Boolean &

        Set mode which manage removing faces which have outer wires consisting only from edges
        belonginig to removed internal wires.
        By default it is equal to true.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_RemoveFaceMode(self, *args)


    def RemovedFaces(self, *args):
        """
        Returns sequence of removed faces.

        :rtype: OCC.wrapper.TopTools.TopTools_SequenceOfShape

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_RemovedFaces(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RemovedWires(self, *args):
        """
        Returns sequence of removed faces.

        :rtype: OCC.wrapper.TopTools.TopTools_SequenceOfShape

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_RemovedWires(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Status(self, *args):
        """
        Status(Handle_ShapeUpgrade_RemoveInternalWires self, ShapeExtend_Status const theStatus) -> Standard_Boolean

        Queries status of last call to Perform()
        : OK - nothing was done
        :DONE1 - internal wires were removed
        :DONE2 - small faces were removed.
        :FAIL1 - initial shape is not specified
        :FAIL2 - specified sub-shape is not belonged to inotial shape.

        :type theStatus: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_Status(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeUpgrade_RemoveInternalWires self) -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_ShapeUpgrade_RemoveInternalWires self, Handle_ShapeUpgrade_Tool tool)

        Copy all fields from another Root object

        :type tool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_Tool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_Set(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_ShapeUpgrade_RemoveInternalWires self, Handle_ShapeBuild_ReShape context)

        Sets context

        :type context: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_SetContext(self, *args)


    def Context(self, *args):
        """
        Context(Handle_ShapeUpgrade_RemoveInternalWires self) -> Handle_ShapeBuild_ReShape

        Returns context

        :rtype: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_Context(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(Handle_ShapeUpgrade_RemoveInternalWires self, Standard_Real const preci)

        Sets basic precision value

        :type preci: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_SetPrecision(self, *args)


    def Precision(self, *args):
        """
        Precision(Handle_ShapeUpgrade_RemoveInternalWires self) -> Standard_Real

        Returns basic precision value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_Precision(self, *args)


    def SetMinTolerance(self, *args):
        """
        SetMinTolerance(Handle_ShapeUpgrade_RemoveInternalWires self, Standard_Real const mintol)

        Sets minimal allowed tolerance

        :type mintol: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_SetMinTolerance(self, *args)


    def MinTolerance(self, *args):
        """
        MinTolerance(Handle_ShapeUpgrade_RemoveInternalWires self) -> Standard_Real

        Returns minimal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_MinTolerance(self, *args)


    def SetMaxTolerance(self, *args):
        """
        SetMaxTolerance(Handle_ShapeUpgrade_RemoveInternalWires self, Standard_Real const maxtol)

        Sets maximal allowed tolerance

        :type maxtol: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_SetMaxTolerance(self, *args)


    def MaxTolerance(self, *args):
        """
        MaxTolerance(Handle_ShapeUpgrade_RemoveInternalWires self) -> Standard_Real

        Returns maximal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_MaxTolerance(self, *args)


    def LimitTolerance(self, *args):
        """
        LimitTolerance(Handle_ShapeUpgrade_RemoveInternalWires self, Standard_Real const toler) -> Standard_Real

        Returns tolerance limited by [myMinTol,myMaxTol]

        :type toler: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_LimitTolerance(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeUpgrade_RemoveInternalWires self)

        Memory deallocator for transient classes


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeUpgrade_RemoveInternalWires self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeUpgrade_RemoveInternalWires self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeUpgrade_RemoveInternalWires self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeUpgrade_RemoveInternalWires self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeUpgrade_RemoveInternalWires self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeUpgrade_RemoveInternalWires self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeUpgrade_RemoveInternalWires self)

        Increments the reference counter of this object


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeUpgrade_RemoveInternalWires self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_DecrementRefCounter(self, *args)

Handle_ShapeUpgrade_RemoveInternalWires_swigregister = _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_swigregister
Handle_ShapeUpgrade_RemoveInternalWires_swigregister(Handle_ShapeUpgrade_RemoveInternalWires)

def Handle_ShapeUpgrade_RemoveInternalWires_DownCast(thing):
    return _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_DownCast(thing)
Handle_ShapeUpgrade_RemoveInternalWires_DownCast = _ShapeUpgrade.Handle_ShapeUpgrade_RemoveInternalWires_DownCast

class Handle_ShapeUpgrade_ClosedEdgeDivide(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeUpgrade_ClosedEdgeDivide self)

        Nullify the handle


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeUpgrade_ClosedEdgeDivide self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeUpgrade_ClosedEdgeDivide self, ShapeUpgrade_ClosedEdgeDivide thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeUpgrade_ClosedEdgeDivide self, Handle_ShapeUpgrade_ClosedEdgeDivide theHandle) -> Handle_ShapeUpgrade_ClosedEdgeDivide
        assign(Handle_ShapeUpgrade_ClosedEdgeDivide self, ShapeUpgrade_ClosedEdgeDivide thePtr) -> Handle_ShapeUpgrade_ClosedEdgeDivide
        assign(Handle_ShapeUpgrade_ClosedEdgeDivide self, Handle_ShapeUpgrade_ClosedEdgeDivide theHandle) -> Handle_ShapeUpgrade_ClosedEdgeDivide

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeUpgrade_ClosedEdgeDivide self) -> ShapeUpgrade_ClosedEdgeDivide

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeUpgrade_ClosedEdgeDivide self) -> ShapeUpgrade_ClosedEdgeDivide

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeUpgrade_ClosedEdgeDivide self) -> ShapeUpgrade_ClosedEdgeDivide

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide___ref__(self, *args)


    def __hash__(self):
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeUpgrade.new_Handle_ShapeUpgrade_ClosedEdgeDivide(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_DownCast)
    __swig_destroy__ = _ShapeUpgrade.delete_Handle_ShapeUpgrade_ClosedEdgeDivide

    def Compute(self, *args):
        """
        Compute(Handle_ShapeUpgrade_ClosedEdgeDivide self, TopoDS_Edge anEdge) -> Standard_Boolean

        :type anEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_Compute(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeUpgrade_ClosedEdgeDivide self) -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """Clear(Handle_ShapeUpgrade_ClosedEdgeDivide self)"""
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_Clear(self, *args)


    def SetFace(self, *args):
        """
        SetFace(Handle_ShapeUpgrade_ClosedEdgeDivide self, TopoDS_Face F)

        Sets supporting surface by face

        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_SetFace(self, *args)


    def HasCurve2d(self, *args):
        """
        HasCurve2d(Handle_ShapeUpgrade_ClosedEdgeDivide self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_HasCurve2d(self, *args)


    def HasCurve3d(self, *args):
        """
        HasCurve3d(Handle_ShapeUpgrade_ClosedEdgeDivide self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_HasCurve3d(self, *args)


    def Knots2d(self, *args):
        """
        Knots2d(Handle_ShapeUpgrade_ClosedEdgeDivide self) -> Handle_TColStd_HSequenceOfReal

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_Knots2d(self, *args)


    def Knots3d(self, *args):
        """
        Knots3d(Handle_ShapeUpgrade_ClosedEdgeDivide self) -> Handle_TColStd_HSequenceOfReal

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_Knots3d(self, *args)


    def SetSplitCurve2dTool(self, *args):
        """
        SetSplitCurve2dTool(Handle_ShapeUpgrade_ClosedEdgeDivide self, Handle_ShapeUpgrade_SplitCurve2d splitCurve2dTool)

        Sets the tool for splitting pcurves.

        :type splitCurve2dTool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_SetSplitCurve2dTool(self, *args)


    def SetSplitCurve3dTool(self, *args):
        """
        SetSplitCurve3dTool(Handle_ShapeUpgrade_ClosedEdgeDivide self, Handle_ShapeUpgrade_SplitCurve3d splitCurve3dTool)

        Sets the tool for splitting 3D curves.

        :type splitCurve3dTool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_SetSplitCurve3dTool(self, *args)


    def GetSplitCurve2dTool(self, *args):
        """
        GetSplitCurve2dTool(Handle_ShapeUpgrade_ClosedEdgeDivide self) -> Handle_ShapeUpgrade_SplitCurve2d

        Returns the tool for splitting pcurves.

        :rtype: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_GetSplitCurve2dTool(self, *args)


    def GetSplitCurve3dTool(self, *args):
        """
        GetSplitCurve3dTool(Handle_ShapeUpgrade_ClosedEdgeDivide self) -> Handle_ShapeUpgrade_SplitCurve3d

        Returns the tool for splitting 3D curves.

        :rtype: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_GetSplitCurve3dTool(self, *args)


    def Set(self, *args):
        """
        Set(Handle_ShapeUpgrade_ClosedEdgeDivide self, Handle_ShapeUpgrade_Tool tool)

        Copy all fields from another Root object

        :type tool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_Tool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_Set(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_ShapeUpgrade_ClosedEdgeDivide self, Handle_ShapeBuild_ReShape context)

        Sets context

        :type context: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_SetContext(self, *args)


    def Context(self, *args):
        """
        Context(Handle_ShapeUpgrade_ClosedEdgeDivide self) -> Handle_ShapeBuild_ReShape

        Returns context

        :rtype: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_Context(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(Handle_ShapeUpgrade_ClosedEdgeDivide self, Standard_Real const preci)

        Sets basic precision value

        :type preci: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_SetPrecision(self, *args)


    def Precision(self, *args):
        """
        Precision(Handle_ShapeUpgrade_ClosedEdgeDivide self) -> Standard_Real

        Returns basic precision value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_Precision(self, *args)


    def SetMinTolerance(self, *args):
        """
        SetMinTolerance(Handle_ShapeUpgrade_ClosedEdgeDivide self, Standard_Real const mintol)

        Sets minimal allowed tolerance

        :type mintol: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_SetMinTolerance(self, *args)


    def MinTolerance(self, *args):
        """
        MinTolerance(Handle_ShapeUpgrade_ClosedEdgeDivide self) -> Standard_Real

        Returns minimal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_MinTolerance(self, *args)


    def SetMaxTolerance(self, *args):
        """
        SetMaxTolerance(Handle_ShapeUpgrade_ClosedEdgeDivide self, Standard_Real const maxtol)

        Sets maximal allowed tolerance

        :type maxtol: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_SetMaxTolerance(self, *args)


    def MaxTolerance(self, *args):
        """
        MaxTolerance(Handle_ShapeUpgrade_ClosedEdgeDivide self) -> Standard_Real

        Returns maximal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_MaxTolerance(self, *args)


    def LimitTolerance(self, *args):
        """
        LimitTolerance(Handle_ShapeUpgrade_ClosedEdgeDivide self, Standard_Real const toler) -> Standard_Real

        Returns tolerance limited by [myMinTol,myMaxTol]

        :type toler: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_LimitTolerance(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeUpgrade_ClosedEdgeDivide self)

        Memory deallocator for transient classes


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeUpgrade_ClosedEdgeDivide self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeUpgrade_ClosedEdgeDivide self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeUpgrade_ClosedEdgeDivide self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeUpgrade_ClosedEdgeDivide self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeUpgrade_ClosedEdgeDivide self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeUpgrade_ClosedEdgeDivide self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeUpgrade_ClosedEdgeDivide self)

        Increments the reference counter of this object


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeUpgrade_ClosedEdgeDivide self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_DecrementRefCounter(self, *args)

Handle_ShapeUpgrade_ClosedEdgeDivide_swigregister = _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_swigregister
Handle_ShapeUpgrade_ClosedEdgeDivide_swigregister(Handle_ShapeUpgrade_ClosedEdgeDivide)

def Handle_ShapeUpgrade_ClosedEdgeDivide_DownCast(thing):
    return _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_DownCast(thing)
Handle_ShapeUpgrade_ClosedEdgeDivide_DownCast = _ShapeUpgrade.Handle_ShapeUpgrade_ClosedEdgeDivide_DownCast

class Handle_ShapeUpgrade_FaceDivideArea(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeUpgrade_FaceDivideArea self)

        Nullify the handle


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeUpgrade_FaceDivideArea self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeUpgrade_FaceDivideArea self, ShapeUpgrade_FaceDivideArea thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeUpgrade_FaceDivideArea self, Handle_ShapeUpgrade_FaceDivideArea theHandle) -> Handle_ShapeUpgrade_FaceDivideArea
        assign(Handle_ShapeUpgrade_FaceDivideArea self, ShapeUpgrade_FaceDivideArea thePtr) -> Handle_ShapeUpgrade_FaceDivideArea
        assign(Handle_ShapeUpgrade_FaceDivideArea self, Handle_ShapeUpgrade_FaceDivideArea theHandle) -> Handle_ShapeUpgrade_FaceDivideArea

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeUpgrade_FaceDivideArea self) -> ShapeUpgrade_FaceDivideArea

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeUpgrade_FaceDivideArea self) -> ShapeUpgrade_FaceDivideArea

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeUpgrade_FaceDivideArea self) -> ShapeUpgrade_FaceDivideArea

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea___ref__(self, *args)


    def __hash__(self):
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeUpgrade.new_Handle_ShapeUpgrade_FaceDivideArea(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_DownCast)
    __swig_destroy__ = _ShapeUpgrade.delete_Handle_ShapeUpgrade_FaceDivideArea

    def Perform(self, *args):
        """
        Perform(Handle_ShapeUpgrade_FaceDivideArea self) -> Standard_Boolean

        Performs splitting and computes the resulting shell
        The context is used to keep track of former splittings

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_Perform(self, *args)


    def MaxArea(self, *args):
        """
        MaxArea(Handle_ShapeUpgrade_FaceDivideArea self) -> Standard_Real &

        Set max area allowed for faces

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_MaxArea(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeUpgrade_FaceDivideArea self) -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_ShapeUpgrade_FaceDivideArea self, TopoDS_Face F)

        Initialize by a Face.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_Init(self, *args)


    def SetSurfaceSegmentMode(self, *args):
        """
        SetSurfaceSegmentMode(Handle_ShapeUpgrade_FaceDivideArea self, Standard_Boolean const Segment)

        Purpose sets mode for trimming (segment) surface by
        wire UV bounds.

        :type Segment: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_SetSurfaceSegmentMode(self, *args)


    def SplitSurface(self, *args):
        """
        SplitSurface(Handle_ShapeUpgrade_FaceDivideArea self) -> Standard_Boolean

        Performs splitting of surface and computes the shell
        from source face.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_SplitSurface(self, *args)


    def SplitCurves(self, *args):
        """
        SplitCurves(Handle_ShapeUpgrade_FaceDivideArea self) -> Standard_Boolean

        Performs splitting of curves of all the edges in the
        shape and divides these edges.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_SplitCurves(self, *args)


    def Result(self, *args):
        """
        Result(Handle_ShapeUpgrade_FaceDivideArea self) -> TopoDS_Shape

        Gives the resulting Shell, or Face, or Null shape if not done.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_Result(self, *args)


    def Status(self, *args):
        """
        Status(Handle_ShapeUpgrade_FaceDivideArea self, ShapeExtend_Status const status) -> Standard_Boolean

        Queries the status of last call to Perform
        OK   : no splitting was done (or no call to Perform)
        DONE1: some edges were splitted
        DONE2: surface was splitted
        DONE3: surface was modified without splitting
        FAIL1: some fails encountered during splitting wires
        FAIL2: face cannot be splitted

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_Status(self, *args)


    def SetSplitSurfaceTool(self, *args):
        """
        SetSplitSurfaceTool(Handle_ShapeUpgrade_FaceDivideArea self, Handle_ShapeUpgrade_SplitSurface splitSurfaceTool)

        Sets the tool for splitting surfaces.

        :type splitSurfaceTool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_SetSplitSurfaceTool(self, *args)


    def SetWireDivideTool(self, *args):
        """
        SetWireDivideTool(Handle_ShapeUpgrade_FaceDivideArea self, Handle_ShapeUpgrade_WireDivide wireDivideTool)

        Sets the tool for dividing edges on Face.

        :type wireDivideTool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_WireDivide

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_SetWireDivideTool(self, *args)


    def GetSplitSurfaceTool(self, *args):
        """
        GetSplitSurfaceTool(Handle_ShapeUpgrade_FaceDivideArea self) -> Handle_ShapeUpgrade_SplitSurface

        Returns the tool for splitting surfaces.
        This tool must be already initialized.

        :rtype: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_SplitSurface

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_GetSplitSurfaceTool(self, *args)


    def GetWireDivideTool(self, *args):
        """
        GetWireDivideTool(Handle_ShapeUpgrade_FaceDivideArea self) -> Handle_ShapeUpgrade_WireDivide

        Returns the tool for dividing edges on Face.
        This tool must be already initialized.

        :rtype: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_WireDivide

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_GetWireDivideTool(self, *args)


    def Set(self, *args):
        """
        Set(Handle_ShapeUpgrade_FaceDivideArea self, Handle_ShapeUpgrade_Tool tool)

        Copy all fields from another Root object

        :type tool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_Tool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_Set(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_ShapeUpgrade_FaceDivideArea self, Handle_ShapeBuild_ReShape context)

        Sets context

        :type context: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_SetContext(self, *args)


    def Context(self, *args):
        """
        Context(Handle_ShapeUpgrade_FaceDivideArea self) -> Handle_ShapeBuild_ReShape

        Returns context

        :rtype: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_Context(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(Handle_ShapeUpgrade_FaceDivideArea self, Standard_Real const preci)

        Sets basic precision value

        :type preci: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_SetPrecision(self, *args)


    def Precision(self, *args):
        """
        Precision(Handle_ShapeUpgrade_FaceDivideArea self) -> Standard_Real

        Returns basic precision value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_Precision(self, *args)


    def SetMinTolerance(self, *args):
        """
        SetMinTolerance(Handle_ShapeUpgrade_FaceDivideArea self, Standard_Real const mintol)

        Sets minimal allowed tolerance

        :type mintol: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_SetMinTolerance(self, *args)


    def MinTolerance(self, *args):
        """
        MinTolerance(Handle_ShapeUpgrade_FaceDivideArea self) -> Standard_Real

        Returns minimal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_MinTolerance(self, *args)


    def SetMaxTolerance(self, *args):
        """
        SetMaxTolerance(Handle_ShapeUpgrade_FaceDivideArea self, Standard_Real const maxtol)

        Sets maximal allowed tolerance

        :type maxtol: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_SetMaxTolerance(self, *args)


    def MaxTolerance(self, *args):
        """
        MaxTolerance(Handle_ShapeUpgrade_FaceDivideArea self) -> Standard_Real

        Returns maximal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_MaxTolerance(self, *args)


    def LimitTolerance(self, *args):
        """
        LimitTolerance(Handle_ShapeUpgrade_FaceDivideArea self, Standard_Real const toler) -> Standard_Real

        Returns tolerance limited by [myMinTol,myMaxTol]

        :type toler: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_LimitTolerance(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeUpgrade_FaceDivideArea self)

        Memory deallocator for transient classes


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeUpgrade_FaceDivideArea self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeUpgrade_FaceDivideArea self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeUpgrade_FaceDivideArea self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeUpgrade_FaceDivideArea self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeUpgrade_FaceDivideArea self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeUpgrade_FaceDivideArea self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeUpgrade_FaceDivideArea self)

        Increments the reference counter of this object


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeUpgrade_FaceDivideArea self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_DecrementRefCounter(self, *args)

Handle_ShapeUpgrade_FaceDivideArea_swigregister = _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_swigregister
Handle_ShapeUpgrade_FaceDivideArea_swigregister(Handle_ShapeUpgrade_FaceDivideArea)

def Handle_ShapeUpgrade_FaceDivideArea_DownCast(thing):
    return _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_DownCast(thing)
Handle_ShapeUpgrade_FaceDivideArea_DownCast = _ShapeUpgrade.Handle_ShapeUpgrade_FaceDivideArea_DownCast

class Handle_ShapeUpgrade_FixSmallBezierCurves(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeUpgrade_FixSmallBezierCurves self)

        Nullify the handle


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeUpgrade_FixSmallBezierCurves self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeUpgrade_FixSmallBezierCurves self, ShapeUpgrade_FixSmallBezierCurves thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeUpgrade_FixSmallBezierCurves self, Handle_ShapeUpgrade_FixSmallBezierCurves theHandle) -> Handle_ShapeUpgrade_FixSmallBezierCurves
        assign(Handle_ShapeUpgrade_FixSmallBezierCurves self, ShapeUpgrade_FixSmallBezierCurves thePtr) -> Handle_ShapeUpgrade_FixSmallBezierCurves
        assign(Handle_ShapeUpgrade_FixSmallBezierCurves self, Handle_ShapeUpgrade_FixSmallBezierCurves theHandle) -> Handle_ShapeUpgrade_FixSmallBezierCurves

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeUpgrade_FixSmallBezierCurves self) -> ShapeUpgrade_FixSmallBezierCurves

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeUpgrade_FixSmallBezierCurves self) -> ShapeUpgrade_FixSmallBezierCurves

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeUpgrade_FixSmallBezierCurves self) -> ShapeUpgrade_FixSmallBezierCurves

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves___ref__(self, *args)


    def __hash__(self):
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeUpgrade.new_Handle_ShapeUpgrade_FixSmallBezierCurves(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves_DownCast)
    __swig_destroy__ = _ShapeUpgrade.delete_Handle_ShapeUpgrade_FixSmallBezierCurves

    def Approx(self, *args):
        """
        Approx(Handle_ShapeUpgrade_FixSmallBezierCurves self, Handle_Geom_Curve Curve3d, Handle_Geom2d_Curve Curve2d, Handle_Geom2d_Curve Curve2dR) -> Standard_Boolean

        :type Curve3d: OCC.wrapper.Geom.Handle_Geom_Curve
        :type Curve2d: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Curve2dR: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type First: float
        :type Last: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves_Approx(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeUpgrade_FixSmallBezierCurves self) -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_ShapeUpgrade_FixSmallBezierCurves self, TopoDS_Edge theEdge, TopoDS_Face theFace)

        :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves_Init(self, *args)


    def SetSplitCurve3dTool(self, *args):
        """
        SetSplitCurve3dTool(Handle_ShapeUpgrade_FixSmallBezierCurves self, Handle_ShapeUpgrade_SplitCurve3d splitCurve3dTool)

        Sets the tool for splitting 3D curves.

        :type splitCurve3dTool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves_SetSplitCurve3dTool(self, *args)


    def SetSplitCurve2dTool(self, *args):
        """
        SetSplitCurve2dTool(Handle_ShapeUpgrade_FixSmallBezierCurves self, Handle_ShapeUpgrade_SplitCurve2d splitCurve2dTool)

        Sets the tool for splitting pcurves.

        :type splitCurve2dTool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves_SetSplitCurve2dTool(self, *args)


    def Status(self, *args):
        """
        Status(Handle_ShapeUpgrade_FixSmallBezierCurves self, ShapeExtend_Status const status) -> Standard_Boolean

        Queries the status of last call to Perform
        OK   :
        DONE1:
        DONE2:
        FAIL1:

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves_Status(self, *args)


    def Set(self, *args):
        """
        Set(Handle_ShapeUpgrade_FixSmallBezierCurves self, Handle_ShapeUpgrade_Tool tool)

        Copy all fields from another Root object

        :type tool: OCC.wrapper.ShapeUpgrade.Handle_ShapeUpgrade_Tool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves_Set(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_ShapeUpgrade_FixSmallBezierCurves self, Handle_ShapeBuild_ReShape context)

        Sets context

        :type context: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves_SetContext(self, *args)


    def Context(self, *args):
        """
        Context(Handle_ShapeUpgrade_FixSmallBezierCurves self) -> Handle_ShapeBuild_ReShape

        Returns context

        :rtype: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves_Context(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(Handle_ShapeUpgrade_FixSmallBezierCurves self, Standard_Real const preci)

        Sets basic precision value

        :type preci: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves_SetPrecision(self, *args)


    def Precision(self, *args):
        """
        Precision(Handle_ShapeUpgrade_FixSmallBezierCurves self) -> Standard_Real

        Returns basic precision value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves_Precision(self, *args)


    def SetMinTolerance(self, *args):
        """
        SetMinTolerance(Handle_ShapeUpgrade_FixSmallBezierCurves self, Standard_Real const mintol)

        Sets minimal allowed tolerance

        :type mintol: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves_SetMinTolerance(self, *args)


    def MinTolerance(self, *args):
        """
        MinTolerance(Handle_ShapeUpgrade_FixSmallBezierCurves self) -> Standard_Real

        Returns minimal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves_MinTolerance(self, *args)


    def SetMaxTolerance(self, *args):
        """
        SetMaxTolerance(Handle_ShapeUpgrade_FixSmallBezierCurves self, Standard_Real const maxtol)

        Sets maximal allowed tolerance

        :type maxtol: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves_SetMaxTolerance(self, *args)


    def MaxTolerance(self, *args):
        """
        MaxTolerance(Handle_ShapeUpgrade_FixSmallBezierCurves self) -> Standard_Real

        Returns maximal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves_MaxTolerance(self, *args)


    def LimitTolerance(self, *args):
        """
        LimitTolerance(Handle_ShapeUpgrade_FixSmallBezierCurves self, Standard_Real const toler) -> Standard_Real

        Returns tolerance limited by [myMinTol,myMaxTol]

        :type toler: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves_LimitTolerance(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeUpgrade_FixSmallBezierCurves self)

        Memory deallocator for transient classes


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeUpgrade_FixSmallBezierCurves self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeUpgrade_FixSmallBezierCurves self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeUpgrade_FixSmallBezierCurves self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeUpgrade_FixSmallBezierCurves self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeUpgrade_FixSmallBezierCurves self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeUpgrade_FixSmallBezierCurves self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeUpgrade_FixSmallBezierCurves self)

        Increments the reference counter of this object


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeUpgrade_FixSmallBezierCurves self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves_DecrementRefCounter(self, *args)

Handle_ShapeUpgrade_FixSmallBezierCurves_swigregister = _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves_swigregister
Handle_ShapeUpgrade_FixSmallBezierCurves_swigregister(Handle_ShapeUpgrade_FixSmallBezierCurves)

def Handle_ShapeUpgrade_FixSmallBezierCurves_DownCast(thing):
    return _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves_DownCast(thing)
Handle_ShapeUpgrade_FixSmallBezierCurves_DownCast = _ShapeUpgrade.Handle_ShapeUpgrade_FixSmallBezierCurves_DownCast

class ShapeUpgrade_(object):
    """
    This package provides tools
    for splitting and converting shapes by some criteria. It
    provides modifications of the kind when one topological
    object can be converted or splitted to several ones. In
    particular this package contains high level API classes which perform:
    converting geometry of shapes up to given continuity,
    splitting revolutions by U to segments less than given value,
    converting to beziers,
    splitting closed faces.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def C0BSplineToSequenceOfC1BSplineCurve(*args):
        """
        C0BSplineToSequenceOfC1BSplineCurve(Handle_Geom_BSplineCurve BS, Handle_TColGeom_HSequenceOfBoundedCurve seqBS) -> Standard_Boolean
        C0BSplineToSequenceOfC1BSplineCurve(Handle_Geom2d_BSplineCurve BS, Handle_TColGeom2d_HSequenceOfBoundedCurve seqBS) -> Standard_Boolean

        Converts C0 B-Spline curve into sequence of C1 B-Spline curves.
        This method splits B-Spline at the knots with multiplicities
        equal to degree, i.e. unlike method
        GeomConvert::C0BSplineToArrayOfC1BSplineCurve this one does not
        use any tolerance and therefore does not change the geometry of
        B-Spline.
        Returns True if C0 B-Spline was successfully splitted, else
        returns False (if BS is C1 B-Spline).

        :type BS: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve
        :type seqBS: OCC.wrapper.TColGeom2d.Handle_TColGeom2d_HSequenceOfBoundedCurve
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade__C0BSplineToSequenceOfC1BSplineCurve(*args)

    C0BSplineToSequenceOfC1BSplineCurve = staticmethod(C0BSplineToSequenceOfC1BSplineCurve)

    def __init__(self):
        """
        This package provides tools
        for splitting and converting shapes by some criteria. It
        provides modifications of the kind when one topological
        object can be converted or splitted to several ones. In
        particular this package contains high level API classes which perform:
        converting geometry of shapes up to given continuity,
        splitting revolutions by U to segments less than given value,
        converting to beziers,
        splitting closed faces.
        """
        this = _ShapeUpgrade.new_ShapeUpgrade_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ShapeUpgrade.delete_ShapeUpgrade_
ShapeUpgrade__swigregister = _ShapeUpgrade.ShapeUpgrade__swigregister
ShapeUpgrade__swigregister(ShapeUpgrade_)

def ShapeUpgrade__C0BSplineToSequenceOfC1BSplineCurve(*args):
    """
    C0BSplineToSequenceOfC1BSplineCurve(Handle_Geom_BSplineCurve BS, Handle_TColGeom_HSequenceOfBoundedCurve seqBS) -> Standard_Boolean
    ShapeUpgrade__C0BSplineToSequenceOfC1BSplineCurve(Handle_Geom2d_BSplineCurve BS, Handle_TColGeom2d_HSequenceOfBoundedCurve seqBS) -> Standard_Boolean

    Converts C0 B-Spline curve into sequence of C1 B-Spline curves.
    This method splits B-Spline at the knots with multiplicities
    equal to degree, i.e. unlike method
    GeomConvert::C0BSplineToArrayOfC1BSplineCurve this one does not
    use any tolerance and therefore does not change the geometry of
    B-Spline.
    Returns True if C0 B-Spline was successfully splitted, else
    returns False (if BS is C1 B-Spline).

    :type BS: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve
    :type seqBS: OCC.wrapper.TColGeom2d.Handle_TColGeom2d_HSequenceOfBoundedCurve
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _ShapeUpgrade.ShapeUpgrade__C0BSplineToSequenceOfC1BSplineCurve(*args)

class Handle_ShapeUpgrade_SplitSurfaceArea(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeUpgrade_SplitSurfaceArea self)

        Nullify the handle


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceArea_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeUpgrade_SplitSurfaceArea self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceArea_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeUpgrade_SplitSurfaceArea self, ShapeUpgrade_SplitSurfaceArea thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceArea_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeUpgrade_SplitSurfaceArea self, Handle_ShapeUpgrade_SplitSurfaceArea theHandle) -> Handle_ShapeUpgrade_SplitSurfaceArea
        assign(Handle_ShapeUpgrade_SplitSurfaceArea self, ShapeUpgrade_SplitSurfaceArea thePtr) -> Handle_ShapeUpgrade_SplitSurfaceArea
        assign(Handle_ShapeUpgrade_SplitSurfaceArea self, Handle_ShapeUpgrade_SplitSurfaceArea theHandle) -> Handle_ShapeUpgrade_SplitSurfaceArea

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceArea_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeUpgrade_SplitSurfaceArea self) -> ShapeUpgrade_SplitSurfaceArea

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceArea_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeUpgrade_SplitSurfaceArea self) -> ShapeUpgrade_SplitSurfaceArea

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceArea___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeUpgrade_SplitSurfaceArea self) -> ShapeUpgrade_SplitSurfaceArea

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceArea___ref__(self, *args)


    def __hash__(self):
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceArea___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceArea___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeUpgrade.new_Handle_ShapeUpgrade_SplitSurfaceArea(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceArea_DownCast)
    __swig_destroy__ = _ShapeUpgrade.delete_Handle_ShapeUpgrade_SplitSurfaceArea

    def NbParts(self, *args):
        """
        NbParts(Handle_ShapeUpgrade_SplitSurfaceArea self) -> Standard_Integer &

        Set number of split for surfaces

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceArea_NbParts(self, *args)


    def Compute(self, *args):
        """
        Compute(Handle_ShapeUpgrade_SplitSurfaceArea self, Standard_Boolean const Segment)

        :type Segment: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceArea_Compute(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeUpgrade_SplitSurfaceArea self) -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceArea_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceArea_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceArea_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_ShapeUpgrade_SplitSurfaceArea self, Handle_Geom_Surface S)
        Init(Handle_ShapeUpgrade_SplitSurfaceArea self, Handle_Geom_Surface S, Standard_Real const UFirst, Standard_Real const ULast, Standard_Real const VFirst, Standard_Real const VLast)

        Initializes with single supporting surface with bounding parameters.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type UFirst: float
        :type ULast: float
        :type VFirst: float
        :type VLast: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceArea_Init(self, *args)


    def SetUSplitValues(self, *args):
        """
        SetUSplitValues(Handle_ShapeUpgrade_SplitSurfaceArea self, Handle_TColStd_HSequenceOfReal UValues)

        Sets U parameters where splitting has to be done

        :type UValues: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceArea_SetUSplitValues(self, *args)


    def SetVSplitValues(self, *args):
        """
        SetVSplitValues(Handle_ShapeUpgrade_SplitSurfaceArea self, Handle_TColStd_HSequenceOfReal VValues)

        Sets V parameters where splitting has to be done

        :type VValues: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceArea_SetVSplitValues(self, *args)


    def Build(self, *args):
        """
        Build(Handle_ShapeUpgrade_SplitSurfaceArea self, Standard_Boolean const Segment)

        Performs splitting of the supporting surface.
        If resulting surface is B-Spline and Segment is True,
        the result is composed with segments of the surface bounded
        by the U and V SplitValues (method Geom_BSplineSurface::Segment
        is used).
        If Segment is False, the result is composed with
        Geom_RectangularTrimmedSurface all based on the same complete
        surface.
        Fields myNbResultingRow and myNbResultingCol must be set to
        specify the size of resulting grid of surfaces.

        :type Segment: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceArea_Build(self, *args)


    def Perform(self, *args):
        """
        Perform(Handle_ShapeUpgrade_SplitSurfaceArea self, Standard_Boolean const Segment)

        Performs correction/splitting of the surface.
        First defines splitting values by method Compute(), then calls method Build().

        :type Segment: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceArea_Perform(self, *args)


    def USplitValues(self, *args):
        """
        returns all the U splitting values including the
        First and Last parameters of the input surface

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceArea_USplitValues(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def VSplitValues(self, *args):
        """
        returns all the splitting V values including the
        First and Last parameters of the input surface

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceArea_VSplitValues(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Status(self, *args):
        """
        Status(Handle_ShapeUpgrade_SplitSurfaceArea self, ShapeExtend_Status const status) -> Standard_Boolean

        Returns the status
        OK    - no splitting is needed
        DONE1 - splitting required and gives more than one patch
        DONE2 - splitting is required, but gives only single patch (initial)
        DONE3 - geometric form of the surface or parametrisation is modified

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceArea_Status(self, *args)


    def ResSurfaces(self, *args):
        """
        Returns obtained surfaces after splitting as CompositeSurface

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_CompositeSurface

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceArea_ResSurfaces(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_ShapeUpgrade_SplitSurfaceArea self)

        Memory deallocator for transient classes


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceArea_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeUpgrade_SplitSurfaceArea self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeUpgrade_SplitSurfaceArea self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceArea_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeUpgrade_SplitSurfaceArea self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeUpgrade_SplitSurfaceArea self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceArea_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeUpgrade_SplitSurfaceArea self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceArea_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeUpgrade_SplitSurfaceArea self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceArea_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeUpgrade_SplitSurfaceArea self)

        Increments the reference counter of this object


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceArea_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeUpgrade_SplitSurfaceArea self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceArea_DecrementRefCounter(self, *args)

Handle_ShapeUpgrade_SplitSurfaceArea_swigregister = _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceArea_swigregister
Handle_ShapeUpgrade_SplitSurfaceArea_swigregister(Handle_ShapeUpgrade_SplitSurfaceArea)

def Handle_ShapeUpgrade_SplitSurfaceArea_DownCast(thing):
    return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceArea_DownCast(thing)
Handle_ShapeUpgrade_SplitSurfaceArea_DownCast = _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceArea_DownCast

class Handle_ShapeUpgrade_ConvertCurve3dToBezier(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeUpgrade_ConvertCurve3dToBezier self)

        Nullify the handle


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeUpgrade_ConvertCurve3dToBezier self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeUpgrade_ConvertCurve3dToBezier self, ShapeUpgrade_ConvertCurve3dToBezier thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeUpgrade_ConvertCurve3dToBezier self, Handle_ShapeUpgrade_ConvertCurve3dToBezier theHandle) -> Handle_ShapeUpgrade_ConvertCurve3dToBezier
        assign(Handle_ShapeUpgrade_ConvertCurve3dToBezier self, ShapeUpgrade_ConvertCurve3dToBezier thePtr) -> Handle_ShapeUpgrade_ConvertCurve3dToBezier
        assign(Handle_ShapeUpgrade_ConvertCurve3dToBezier self, Handle_ShapeUpgrade_ConvertCurve3dToBezier theHandle) -> Handle_ShapeUpgrade_ConvertCurve3dToBezier

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeUpgrade_ConvertCurve3dToBezier self) -> ShapeUpgrade_ConvertCurve3dToBezier

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeUpgrade_ConvertCurve3dToBezier self) -> ShapeUpgrade_ConvertCurve3dToBezier

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeUpgrade_ConvertCurve3dToBezier self) -> ShapeUpgrade_ConvertCurve3dToBezier

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier___ref__(self, *args)


    def __hash__(self):
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeUpgrade.new_Handle_ShapeUpgrade_ConvertCurve3dToBezier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier_DownCast)
    __swig_destroy__ = _ShapeUpgrade.delete_Handle_ShapeUpgrade_ConvertCurve3dToBezier

    def SetLineMode(self, *args):
        """
        SetLineMode(Handle_ShapeUpgrade_ConvertCurve3dToBezier self, Standard_Boolean const mode)

        Sets mode for conversion Geom_Line to bezier.

        :type mode: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier_SetLineMode(self, *args)


    def GetLineMode(self, *args):
        """
        GetLineMode(Handle_ShapeUpgrade_ConvertCurve3dToBezier self) -> Standard_Boolean

        Returns the Geom_Line conversion mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier_GetLineMode(self, *args)


    def SetCircleMode(self, *args):
        """
        SetCircleMode(Handle_ShapeUpgrade_ConvertCurve3dToBezier self, Standard_Boolean const mode)

        Sets mode for conversion Geom_Circle to bezier.

        :type mode: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier_SetCircleMode(self, *args)


    def GetCircleMode(self, *args):
        """
        GetCircleMode(Handle_ShapeUpgrade_ConvertCurve3dToBezier self) -> Standard_Boolean

        Returns the Geom_Circle conversion mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier_GetCircleMode(self, *args)


    def SetConicMode(self, *args):
        """
        SetConicMode(Handle_ShapeUpgrade_ConvertCurve3dToBezier self, Standard_Boolean const mode)

        Returns the Geom_Conic conversion mode.

        :type mode: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier_SetConicMode(self, *args)


    def GetConicMode(self, *args):
        """
        GetConicMode(Handle_ShapeUpgrade_ConvertCurve3dToBezier self) -> Standard_Boolean

        Performs converting and computes the resulting shape.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier_GetConicMode(self, *args)


    def Compute(self, *args):
        """
        Compute(Handle_ShapeUpgrade_ConvertCurve3dToBezier self)

        Converts curve into a list of beziers, and stores the
        splitting parameters on original curve.


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier_Compute(self, *args)


    def Build(self, *args):
        """
        Build(Handle_ShapeUpgrade_ConvertCurve3dToBezier self, Standard_Boolean const Segment)

        Splits a list of beziers computed by Compute method according
        the split values and splitting parameters.

        :type Segment: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier_Build(self, *args)


    def SplitParams(self, *args):
        """
        SplitParams(Handle_ShapeUpgrade_ConvertCurve3dToBezier self) -> Handle_TColStd_HSequenceOfReal

        Returns the list of splitted parameters in original curve
        parametrisation.

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier_SplitParams(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeUpgrade_ConvertCurve3dToBezier self) -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_ShapeUpgrade_ConvertCurve3dToBezier self, Handle_Geom_Curve C)
        Init(Handle_ShapeUpgrade_ConvertCurve3dToBezier self, Handle_Geom_Curve C, Standard_Real const First, Standard_Real const Last)

        Initializes with curve with its parameters.

        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type First: float
        :type Last: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier_Init(self, *args)


    def GetCurves(self, *args):
        """
        :rtype: OCC.wrapper.TColGeom.Handle_TColGeom_HArray1OfCurve

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier_GetCurves(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSplitValues(self, *args):
        """
        SetSplitValues(Handle_ShapeUpgrade_ConvertCurve3dToBezier self, Handle_TColStd_HSequenceOfReal SplitValues)

        Sets the parameters where splitting has to be done.

        :type SplitValues: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier_SetSplitValues(self, *args)


    def SplitValues(self, *args):
        """
        returns all the splitting values including the
        First and Last parameters of the input curve
        Merges input split values and new ones into myGlobalKnots

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier_SplitValues(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Perform(self, *args):
        """
        Perform(Handle_ShapeUpgrade_ConvertCurve3dToBezier self, Standard_Boolean const Segment)

        Performs correction/splitting of the curve.
        First defines splitting values by method Compute(), then calls method Build().

        :type Segment: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier_Perform(self, *args)


    def Status(self, *args):
        """
        Status(Handle_ShapeUpgrade_ConvertCurve3dToBezier self, ShapeExtend_Status const status) -> Standard_Boolean

        Returns the status
        OK    - no splitting is needed
        DONE1 - splitting required and gives more than one segment
        DONE2 - splitting is required, but gives only one segment (initial)
        DONE3 - geometric form of the curve or parametrisation is modified

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier_Status(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeUpgrade_ConvertCurve3dToBezier self)

        Memory deallocator for transient classes


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeUpgrade_ConvertCurve3dToBezier self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeUpgrade_ConvertCurve3dToBezier self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeUpgrade_ConvertCurve3dToBezier self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeUpgrade_ConvertCurve3dToBezier self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeUpgrade_ConvertCurve3dToBezier self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeUpgrade_ConvertCurve3dToBezier self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeUpgrade_ConvertCurve3dToBezier self)

        Increments the reference counter of this object


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeUpgrade_ConvertCurve3dToBezier self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier_DecrementRefCounter(self, *args)

Handle_ShapeUpgrade_ConvertCurve3dToBezier_swigregister = _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier_swigregister
Handle_ShapeUpgrade_ConvertCurve3dToBezier_swigregister(Handle_ShapeUpgrade_ConvertCurve3dToBezier)

def Handle_ShapeUpgrade_ConvertCurve3dToBezier_DownCast(thing):
    return _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier_DownCast(thing)
Handle_ShapeUpgrade_ConvertCurve3dToBezier_DownCast = _ShapeUpgrade.Handle_ShapeUpgrade_ConvertCurve3dToBezier_DownCast

class Handle_ShapeUpgrade_SplitCurve2dContinuity(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeUpgrade_SplitCurve2dContinuity self)

        Nullify the handle


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2dContinuity_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeUpgrade_SplitCurve2dContinuity self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2dContinuity_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeUpgrade_SplitCurve2dContinuity self, ShapeUpgrade_SplitCurve2dContinuity thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2dContinuity_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeUpgrade_SplitCurve2dContinuity self, Handle_ShapeUpgrade_SplitCurve2dContinuity theHandle) -> Handle_ShapeUpgrade_SplitCurve2dContinuity
        assign(Handle_ShapeUpgrade_SplitCurve2dContinuity self, ShapeUpgrade_SplitCurve2dContinuity thePtr) -> Handle_ShapeUpgrade_SplitCurve2dContinuity
        assign(Handle_ShapeUpgrade_SplitCurve2dContinuity self, Handle_ShapeUpgrade_SplitCurve2dContinuity theHandle) -> Handle_ShapeUpgrade_SplitCurve2dContinuity

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2dContinuity_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeUpgrade_SplitCurve2dContinuity self) -> ShapeUpgrade_SplitCurve2dContinuity

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2dContinuity_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeUpgrade_SplitCurve2dContinuity self) -> ShapeUpgrade_SplitCurve2dContinuity

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2dContinuity___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeUpgrade_SplitCurve2dContinuity self) -> ShapeUpgrade_SplitCurve2dContinuity

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2dContinuity___ref__(self, *args)


    def __hash__(self):
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2dContinuity___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2dContinuity___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeUpgrade.new_Handle_ShapeUpgrade_SplitCurve2dContinuity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2dContinuity_DownCast)
    __swig_destroy__ = _ShapeUpgrade.delete_Handle_ShapeUpgrade_SplitCurve2dContinuity

    def SetCriterion(self, *args):
        """
        SetCriterion(Handle_ShapeUpgrade_SplitCurve2dContinuity self, GeomAbs_Shape const Criterion)

        Sets criterion for splitting.

        :type Criterion: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2dContinuity_SetCriterion(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(Handle_ShapeUpgrade_SplitCurve2dContinuity self, Standard_Real const Tol)

        Sets tolerance.

        :type Tol: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2dContinuity_SetTolerance(self, *args)


    def Compute(self, *args):
        """
        Compute(Handle_ShapeUpgrade_SplitCurve2dContinuity self)

        Calculates points for correction/splitting of the curve


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2dContinuity_Compute(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeUpgrade_SplitCurve2dContinuity self) -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2dContinuity_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2dContinuity_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2dContinuity_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_ShapeUpgrade_SplitCurve2dContinuity self, Handle_Geom2d_Curve C)
        Init(Handle_ShapeUpgrade_SplitCurve2dContinuity self, Handle_Geom2d_Curve C, Standard_Real const First, Standard_Real const Last)

        Initializes with pcurve with its parameters.

        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type First: float
        :type Last: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2dContinuity_Init(self, *args)


    def Build(self, *args):
        """
        Build(Handle_ShapeUpgrade_SplitCurve2dContinuity self, Standard_Boolean const Segment)

        If Segment is True, the result is composed with
        segments of the curve bounded by the SplitValues.  If
        Segment is False, the result is composed with trimmed
        Curves all based on the same complete curve.

        :type Segment: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2dContinuity_Build(self, *args)


    def GetCurves(self, *args):
        """
        :rtype: OCC.wrapper.TColGeom2d.Handle_TColGeom2d_HArray1OfCurve

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2dContinuity_GetCurves(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSplitValues(self, *args):
        """
        SetSplitValues(Handle_ShapeUpgrade_SplitCurve2dContinuity self, Handle_TColStd_HSequenceOfReal SplitValues)

        Sets the parameters where splitting has to be done.

        :type SplitValues: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2dContinuity_SetSplitValues(self, *args)


    def SplitValues(self, *args):
        """
        returns all the splitting values including the
        First and Last parameters of the input curve
        Merges input split values and new ones into myGlobalKnots

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2dContinuity_SplitValues(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Perform(self, *args):
        """
        Perform(Handle_ShapeUpgrade_SplitCurve2dContinuity self, Standard_Boolean const Segment)

        Performs correction/splitting of the curve.
        First defines splitting values by method Compute(), then calls method Build().

        :type Segment: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2dContinuity_Perform(self, *args)


    def Status(self, *args):
        """
        Status(Handle_ShapeUpgrade_SplitCurve2dContinuity self, ShapeExtend_Status const status) -> Standard_Boolean

        Returns the status
        OK    - no splitting is needed
        DONE1 - splitting required and gives more than one segment
        DONE2 - splitting is required, but gives only one segment (initial)
        DONE3 - geometric form of the curve or parametrisation is modified

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2dContinuity_Status(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeUpgrade_SplitCurve2dContinuity self)

        Memory deallocator for transient classes


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2dContinuity_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeUpgrade_SplitCurve2dContinuity self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeUpgrade_SplitCurve2dContinuity self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2dContinuity_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeUpgrade_SplitCurve2dContinuity self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeUpgrade_SplitCurve2dContinuity self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2dContinuity_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeUpgrade_SplitCurve2dContinuity self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2dContinuity_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeUpgrade_SplitCurve2dContinuity self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2dContinuity_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeUpgrade_SplitCurve2dContinuity self)

        Increments the reference counter of this object


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2dContinuity_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeUpgrade_SplitCurve2dContinuity self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2dContinuity_DecrementRefCounter(self, *args)

Handle_ShapeUpgrade_SplitCurve2dContinuity_swigregister = _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2dContinuity_swigregister
Handle_ShapeUpgrade_SplitCurve2dContinuity_swigregister(Handle_ShapeUpgrade_SplitCurve2dContinuity)

def Handle_ShapeUpgrade_SplitCurve2dContinuity_DownCast(thing):
    return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2dContinuity_DownCast(thing)
Handle_ShapeUpgrade_SplitCurve2dContinuity_DownCast = _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2dContinuity_DownCast

class Handle_ShapeUpgrade_SplitCurve2d(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeUpgrade_SplitCurve2d self)

        Nullify the handle


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeUpgrade_SplitCurve2d self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeUpgrade_SplitCurve2d self, ShapeUpgrade_SplitCurve2d thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeUpgrade_SplitCurve2d self, Handle_ShapeUpgrade_SplitCurve2d theHandle) -> Handle_ShapeUpgrade_SplitCurve2d
        assign(Handle_ShapeUpgrade_SplitCurve2d self, ShapeUpgrade_SplitCurve2d thePtr) -> Handle_ShapeUpgrade_SplitCurve2d
        assign(Handle_ShapeUpgrade_SplitCurve2d self, Handle_ShapeUpgrade_SplitCurve2d theHandle) -> Handle_ShapeUpgrade_SplitCurve2d

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeUpgrade_SplitCurve2d self) -> ShapeUpgrade_SplitCurve2d

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeUpgrade_SplitCurve2d self) -> ShapeUpgrade_SplitCurve2d

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeUpgrade_SplitCurve2d self) -> ShapeUpgrade_SplitCurve2d

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d___ref__(self, *args)


    def __hash__(self):
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeUpgrade.new_Handle_ShapeUpgrade_SplitCurve2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d_DownCast)
    __swig_destroy__ = _ShapeUpgrade.delete_Handle_ShapeUpgrade_SplitCurve2d

    def Init(self, *args):
        """
        Init(Handle_ShapeUpgrade_SplitCurve2d self, Handle_Geom2d_Curve C)
        Init(Handle_ShapeUpgrade_SplitCurve2d self, Handle_Geom2d_Curve C, Standard_Real const First, Standard_Real const Last)

        Initializes with pcurve with its parameters.

        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type First: float
        :type Last: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d_Init(self, *args)


    def Build(self, *args):
        """
        Build(Handle_ShapeUpgrade_SplitCurve2d self, Standard_Boolean const Segment)

        If Segment is True, the result is composed with
        segments of the curve bounded by the SplitValues.  If
        Segment is False, the result is composed with trimmed
        Curves all based on the same complete curve.

        :type Segment: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d_Build(self, *args)


    def GetCurves(self, *args):
        """
        :rtype: OCC.wrapper.TColGeom2d.Handle_TColGeom2d_HArray1OfCurve

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d_GetCurves(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeUpgrade_SplitCurve2d self) -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSplitValues(self, *args):
        """
        SetSplitValues(Handle_ShapeUpgrade_SplitCurve2d self, Handle_TColStd_HSequenceOfReal SplitValues)

        Sets the parameters where splitting has to be done.

        :type SplitValues: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d_SetSplitValues(self, *args)


    def SplitValues(self, *args):
        """
        returns all the splitting values including the
        First and Last parameters of the input curve
        Merges input split values and new ones into myGlobalKnots

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d_SplitValues(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Compute(self, *args):
        """
        Compute(Handle_ShapeUpgrade_SplitCurve2d self)

        Calculates points for correction/splitting of the curve


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d_Compute(self, *args)


    def Perform(self, *args):
        """
        Perform(Handle_ShapeUpgrade_SplitCurve2d self, Standard_Boolean const Segment)

        Performs correction/splitting of the curve.
        First defines splitting values by method Compute(), then calls method Build().

        :type Segment: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d_Perform(self, *args)


    def Status(self, *args):
        """
        Status(Handle_ShapeUpgrade_SplitCurve2d self, ShapeExtend_Status const status) -> Standard_Boolean

        Returns the status
        OK    - no splitting is needed
        DONE1 - splitting required and gives more than one segment
        DONE2 - splitting is required, but gives only one segment (initial)
        DONE3 - geometric form of the curve or parametrisation is modified

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d_Status(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeUpgrade_SplitCurve2d self)

        Memory deallocator for transient classes


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeUpgrade_SplitCurve2d self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeUpgrade_SplitCurve2d self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeUpgrade_SplitCurve2d self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeUpgrade_SplitCurve2d self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeUpgrade_SplitCurve2d self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeUpgrade_SplitCurve2d self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeUpgrade_SplitCurve2d self)

        Increments the reference counter of this object


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeUpgrade_SplitCurve2d self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d_DecrementRefCounter(self, *args)

Handle_ShapeUpgrade_SplitCurve2d_swigregister = _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d_swigregister
Handle_ShapeUpgrade_SplitCurve2d_swigregister(Handle_ShapeUpgrade_SplitCurve2d)

def Handle_ShapeUpgrade_SplitCurve2d_DownCast(thing):
    return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d_DownCast(thing)
Handle_ShapeUpgrade_SplitCurve2d_DownCast = _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve2d_DownCast

class Handle_ShapeUpgrade_SplitSurfaceAngle(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeUpgrade_SplitSurfaceAngle self)

        Nullify the handle


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeUpgrade_SplitSurfaceAngle self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeUpgrade_SplitSurfaceAngle self, ShapeUpgrade_SplitSurfaceAngle thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeUpgrade_SplitSurfaceAngle self, Handle_ShapeUpgrade_SplitSurfaceAngle theHandle) -> Handle_ShapeUpgrade_SplitSurfaceAngle
        assign(Handle_ShapeUpgrade_SplitSurfaceAngle self, ShapeUpgrade_SplitSurfaceAngle thePtr) -> Handle_ShapeUpgrade_SplitSurfaceAngle
        assign(Handle_ShapeUpgrade_SplitSurfaceAngle self, Handle_ShapeUpgrade_SplitSurfaceAngle theHandle) -> Handle_ShapeUpgrade_SplitSurfaceAngle

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeUpgrade_SplitSurfaceAngle self) -> ShapeUpgrade_SplitSurfaceAngle

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeUpgrade_SplitSurfaceAngle self) -> ShapeUpgrade_SplitSurfaceAngle

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeUpgrade_SplitSurfaceAngle self) -> ShapeUpgrade_SplitSurfaceAngle

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle___ref__(self, *args)


    def __hash__(self):
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeUpgrade.new_Handle_ShapeUpgrade_SplitSurfaceAngle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle_DownCast)
    __swig_destroy__ = _ShapeUpgrade.delete_Handle_ShapeUpgrade_SplitSurfaceAngle

    def SetMaxAngle(self, *args):
        """
        SetMaxAngle(Handle_ShapeUpgrade_SplitSurfaceAngle self, Standard_Real const MaxAngle)

        Set maximal angle

        :type MaxAngle: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle_SetMaxAngle(self, *args)


    def MaxAngle(self, *args):
        """
        MaxAngle(Handle_ShapeUpgrade_SplitSurfaceAngle self) -> Standard_Real

        Returns maximal angle

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle_MaxAngle(self, *args)


    def Compute(self, *args):
        """
        Compute(Handle_ShapeUpgrade_SplitSurfaceAngle self, Standard_Boolean const Segment)

        Performs splitting of the supporting surface(s).
        First defines splitting values, then calls inherited method.

        :type Segment: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle_Compute(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeUpgrade_SplitSurfaceAngle self) -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_ShapeUpgrade_SplitSurfaceAngle self, Handle_Geom_Surface S)
        Init(Handle_ShapeUpgrade_SplitSurfaceAngle self, Handle_Geom_Surface S, Standard_Real const UFirst, Standard_Real const ULast, Standard_Real const VFirst, Standard_Real const VLast)

        Initializes with single supporting surface with bounding parameters.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type UFirst: float
        :type ULast: float
        :type VFirst: float
        :type VLast: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle_Init(self, *args)


    def SetUSplitValues(self, *args):
        """
        SetUSplitValues(Handle_ShapeUpgrade_SplitSurfaceAngle self, Handle_TColStd_HSequenceOfReal UValues)

        Sets U parameters where splitting has to be done

        :type UValues: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle_SetUSplitValues(self, *args)


    def SetVSplitValues(self, *args):
        """
        SetVSplitValues(Handle_ShapeUpgrade_SplitSurfaceAngle self, Handle_TColStd_HSequenceOfReal VValues)

        Sets V parameters where splitting has to be done

        :type VValues: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle_SetVSplitValues(self, *args)


    def Build(self, *args):
        """
        Build(Handle_ShapeUpgrade_SplitSurfaceAngle self, Standard_Boolean const Segment)

        Performs splitting of the supporting surface.
        If resulting surface is B-Spline and Segment is True,
        the result is composed with segments of the surface bounded
        by the U and V SplitValues (method Geom_BSplineSurface::Segment
        is used).
        If Segment is False, the result is composed with
        Geom_RectangularTrimmedSurface all based on the same complete
        surface.
        Fields myNbResultingRow and myNbResultingCol must be set to
        specify the size of resulting grid of surfaces.

        :type Segment: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle_Build(self, *args)


    def Perform(self, *args):
        """
        Perform(Handle_ShapeUpgrade_SplitSurfaceAngle self, Standard_Boolean const Segment)

        Performs correction/splitting of the surface.
        First defines splitting values by method Compute(), then calls method Build().

        :type Segment: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle_Perform(self, *args)


    def USplitValues(self, *args):
        """
        returns all the U splitting values including the
        First and Last parameters of the input surface

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle_USplitValues(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def VSplitValues(self, *args):
        """
        returns all the splitting V values including the
        First and Last parameters of the input surface

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle_VSplitValues(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Status(self, *args):
        """
        Status(Handle_ShapeUpgrade_SplitSurfaceAngle self, ShapeExtend_Status const status) -> Standard_Boolean

        Returns the status
        OK    - no splitting is needed
        DONE1 - splitting required and gives more than one patch
        DONE2 - splitting is required, but gives only single patch (initial)
        DONE3 - geometric form of the surface or parametrisation is modified

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle_Status(self, *args)


    def ResSurfaces(self, *args):
        """
        Returns obtained surfaces after splitting as CompositeSurface

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_CompositeSurface

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle_ResSurfaces(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_ShapeUpgrade_SplitSurfaceAngle self)

        Memory deallocator for transient classes


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeUpgrade_SplitSurfaceAngle self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeUpgrade_SplitSurfaceAngle self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeUpgrade_SplitSurfaceAngle self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeUpgrade_SplitSurfaceAngle self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeUpgrade_SplitSurfaceAngle self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeUpgrade_SplitSurfaceAngle self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeUpgrade_SplitSurfaceAngle self)

        Increments the reference counter of this object


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeUpgrade_SplitSurfaceAngle self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle_DecrementRefCounter(self, *args)

Handle_ShapeUpgrade_SplitSurfaceAngle_swigregister = _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle_swigregister
Handle_ShapeUpgrade_SplitSurfaceAngle_swigregister(Handle_ShapeUpgrade_SplitSurfaceAngle)

def Handle_ShapeUpgrade_SplitSurfaceAngle_DownCast(thing):
    return _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle_DownCast(thing)
Handle_ShapeUpgrade_SplitSurfaceAngle_DownCast = _ShapeUpgrade.Handle_ShapeUpgrade_SplitSurfaceAngle_DownCast

class ShapeUpgrade_ShapeConvertToBezier(ShapeUpgrade_ShapeDivide):
    """
    API class for performing conversion of 3D, 2D curves to bezier curves
    and surfaces to bezier based surfaces (
    bezier surface,
    surface of revolution based on bezier curve,
    offset surface based on any previous type).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ShapeUpgrade_ShapeConvertToBezier self) -> ShapeUpgrade_ShapeConvertToBezier
        __init__(ShapeUpgrade_ShapeConvertToBezier self, TopoDS_Shape S) -> ShapeUpgrade_ShapeConvertToBezier

        Initialize by a Shape.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _ShapeUpgrade.new_ShapeUpgrade_ShapeConvertToBezier(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Set2dConversion(self, *args):
        """
        Set2dConversion(ShapeUpgrade_ShapeConvertToBezier self, Standard_Boolean const mode)

        Sets mode for conversion 2D curves to bezier.

        :type mode: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeConvertToBezier_Set2dConversion(self, *args)


    def Get2dConversion(self, *args):
        """
        Get2dConversion(ShapeUpgrade_ShapeConvertToBezier self) -> Standard_Boolean

        Returns the 2D conversion mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeConvertToBezier_Get2dConversion(self, *args)


    def Set3dConversion(self, *args):
        """
        Set3dConversion(ShapeUpgrade_ShapeConvertToBezier self, Standard_Boolean const mode)

        Sets mode for conversion 3d curves to bezier.

        :type mode: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeConvertToBezier_Set3dConversion(self, *args)


    def Get3dConversion(self, *args):
        """
        Get3dConversion(ShapeUpgrade_ShapeConvertToBezier self) -> Standard_Boolean

        Returns the 3D conversion mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeConvertToBezier_Get3dConversion(self, *args)


    def SetSurfaceConversion(self, *args):
        """
        SetSurfaceConversion(ShapeUpgrade_ShapeConvertToBezier self, Standard_Boolean const mode)

        Sets mode for conversion surfaces curves to
        bezier basis.

        :type mode: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeConvertToBezier_SetSurfaceConversion(self, *args)


    def GetSurfaceConversion(self, *args):
        """
        GetSurfaceConversion(ShapeUpgrade_ShapeConvertToBezier self) -> Standard_Boolean

        Returns the surface conversion mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeConvertToBezier_GetSurfaceConversion(self, *args)


    def Set3dLineConversion(self, *args):
        """
        Set3dLineConversion(ShapeUpgrade_ShapeConvertToBezier self, Standard_Boolean const mode)

        Sets mode for conversion Geom_Line to bezier.

        :type mode: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeConvertToBezier_Set3dLineConversion(self, *args)


    def Get3dLineConversion(self, *args):
        """
        Get3dLineConversion(ShapeUpgrade_ShapeConvertToBezier self) -> Standard_Boolean

        Returns the Geom_Line conversion mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeConvertToBezier_Get3dLineConversion(self, *args)


    def Set3dCircleConversion(self, *args):
        """
        Set3dCircleConversion(ShapeUpgrade_ShapeConvertToBezier self, Standard_Boolean const mode)

        Sets mode for conversion Geom_Circle to bezier.

        :type mode: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeConvertToBezier_Set3dCircleConversion(self, *args)


    def Get3dCircleConversion(self, *args):
        """
        Get3dCircleConversion(ShapeUpgrade_ShapeConvertToBezier self) -> Standard_Boolean

        Returns the Geom_Circle conversion mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeConvertToBezier_Get3dCircleConversion(self, *args)


    def Set3dConicConversion(self, *args):
        """
        Set3dConicConversion(ShapeUpgrade_ShapeConvertToBezier self, Standard_Boolean const mode)

        Sets mode for conversion Geom_Conic to bezier.

        :type mode: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeConvertToBezier_Set3dConicConversion(self, *args)


    def Get3dConicConversion(self, *args):
        """
        Get3dConicConversion(ShapeUpgrade_ShapeConvertToBezier self) -> Standard_Boolean

        Returns the Geom_Conic conversion mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeConvertToBezier_Get3dConicConversion(self, *args)


    def SetPlaneMode(self, *args):
        """
        SetPlaneMode(ShapeUpgrade_ShapeConvertToBezier self, Standard_Boolean const mode)

        Sets mode for conversion Geom_Plane to Bezier

        :type mode: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeConvertToBezier_SetPlaneMode(self, *args)


    def GetPlaneMode(self, *args):
        """
        GetPlaneMode(ShapeUpgrade_ShapeConvertToBezier self) -> Standard_Boolean

        Returns the Geom_Pline conversion mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeConvertToBezier_GetPlaneMode(self, *args)


    def SetRevolutionMode(self, *args):
        """
        SetRevolutionMode(ShapeUpgrade_ShapeConvertToBezier self, Standard_Boolean const mode)

        Sets mode for conversion Geom_SurfaceOfRevolution to Bezier

        :type mode: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeConvertToBezier_SetRevolutionMode(self, *args)


    def GetRevolutionMode(self, *args):
        """
        GetRevolutionMode(ShapeUpgrade_ShapeConvertToBezier self) -> Standard_Boolean

        Returns the Geom_SurfaceOfRevolution conversion mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeConvertToBezier_GetRevolutionMode(self, *args)


    def SetExtrusionMode(self, *args):
        """
        SetExtrusionMode(ShapeUpgrade_ShapeConvertToBezier self, Standard_Boolean const mode)

        Sets mode for conversion Geom_SurfaceOfLinearExtrusion to Bezier

        :type mode: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeConvertToBezier_SetExtrusionMode(self, *args)


    def GetExtrusionMode(self, *args):
        """
        GetExtrusionMode(ShapeUpgrade_ShapeConvertToBezier self) -> Standard_Boolean

        Returns the Geom_SurfaceOfLinearExtrusion conversion mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeConvertToBezier_GetExtrusionMode(self, *args)


    def SetBSplineMode(self, *args):
        """
        SetBSplineMode(ShapeUpgrade_ShapeConvertToBezier self, Standard_Boolean const mode)

        Sets mode for conversion Geom_BSplineSurface to Bezier

        :type mode: bool

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeConvertToBezier_SetBSplineMode(self, *args)


    def GetBSplineMode(self, *args):
        """
        GetBSplineMode(ShapeUpgrade_ShapeConvertToBezier self) -> Standard_Boolean

        Returns the Geom_BSplineSurface conversion mode.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeConvertToBezier_GetBSplineMode(self, *args)


    def Perform(self, *args):
        """
        Perform(ShapeUpgrade_ShapeConvertToBezier self, Standard_Boolean const newContext) -> Standard_Boolean

        Performs converting and computes the resulting shape

        :type newContext: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeConvertToBezier_Perform(self, *args)

    __swig_destroy__ = _ShapeUpgrade.delete_ShapeUpgrade_ShapeConvertToBezier
ShapeUpgrade_ShapeConvertToBezier_swigregister = _ShapeUpgrade.ShapeUpgrade_ShapeConvertToBezier_swigregister
ShapeUpgrade_ShapeConvertToBezier_swigregister(ShapeUpgrade_ShapeConvertToBezier)

class Handle_ShapeUpgrade_SplitCurve3d(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeUpgrade_SplitCurve3d self)

        Nullify the handle


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeUpgrade_SplitCurve3d self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeUpgrade_SplitCurve3d self, ShapeUpgrade_SplitCurve3d thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeUpgrade_SplitCurve3d self, Handle_ShapeUpgrade_SplitCurve3d theHandle) -> Handle_ShapeUpgrade_SplitCurve3d
        assign(Handle_ShapeUpgrade_SplitCurve3d self, ShapeUpgrade_SplitCurve3d thePtr) -> Handle_ShapeUpgrade_SplitCurve3d
        assign(Handle_ShapeUpgrade_SplitCurve3d self, Handle_ShapeUpgrade_SplitCurve3d theHandle) -> Handle_ShapeUpgrade_SplitCurve3d

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeUpgrade_SplitCurve3d self) -> ShapeUpgrade_SplitCurve3d

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeUpgrade_SplitCurve3d self) -> ShapeUpgrade_SplitCurve3d

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeUpgrade_SplitCurve3d self) -> ShapeUpgrade_SplitCurve3d

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d___ref__(self, *args)


    def __hash__(self):
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeUpgrade.new_Handle_ShapeUpgrade_SplitCurve3d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d_DownCast)
    __swig_destroy__ = _ShapeUpgrade.delete_Handle_ShapeUpgrade_SplitCurve3d

    def Init(self, *args):
        """
        Init(Handle_ShapeUpgrade_SplitCurve3d self, Handle_Geom_Curve C)
        Init(Handle_ShapeUpgrade_SplitCurve3d self, Handle_Geom_Curve C, Standard_Real const First, Standard_Real const Last)

        Initializes with curve with its parameters.

        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type First: float
        :type Last: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d_Init(self, *args)


    def Build(self, *args):
        """
        Build(Handle_ShapeUpgrade_SplitCurve3d self, Standard_Boolean const Segment)

        If Segment is True, the result is composed with
        segments of the curve bounded by the SplitValues.  If
        Segment is False, the result is composed with trimmed
        Curves all based on the same complete curve.

        :type Segment: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d_Build(self, *args)


    def GetCurves(self, *args):
        """
        :rtype: OCC.wrapper.TColGeom.Handle_TColGeom_HArray1OfCurve

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d_GetCurves(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeUpgrade_SplitCurve3d self) -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetSplitValues(self, *args):
        """
        SetSplitValues(Handle_ShapeUpgrade_SplitCurve3d self, Handle_TColStd_HSequenceOfReal SplitValues)

        Sets the parameters where splitting has to be done.

        :type SplitValues: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d_SetSplitValues(self, *args)


    def SplitValues(self, *args):
        """
        returns all the splitting values including the
        First and Last parameters of the input curve
        Merges input split values and new ones into myGlobalKnots

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfReal

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d_SplitValues(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Compute(self, *args):
        """
        Compute(Handle_ShapeUpgrade_SplitCurve3d self)

        Calculates points for correction/splitting of the curve


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d_Compute(self, *args)


    def Perform(self, *args):
        """
        Perform(Handle_ShapeUpgrade_SplitCurve3d self, Standard_Boolean const Segment)

        Performs correction/splitting of the curve.
        First defines splitting values by method Compute(), then calls method Build().

        :type Segment: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d_Perform(self, *args)


    def Status(self, *args):
        """
        Status(Handle_ShapeUpgrade_SplitCurve3d self, ShapeExtend_Status const status) -> Standard_Boolean

        Returns the status
        OK    - no splitting is needed
        DONE1 - splitting required and gives more than one segment
        DONE2 - splitting is required, but gives only one segment (initial)
        DONE3 - geometric form of the curve or parametrisation is modified

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d_Status(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeUpgrade_SplitCurve3d self)

        Memory deallocator for transient classes


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeUpgrade_SplitCurve3d self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeUpgrade_SplitCurve3d self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeUpgrade_SplitCurve3d self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeUpgrade_SplitCurve3d self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeUpgrade_SplitCurve3d self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeUpgrade_SplitCurve3d self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeUpgrade_SplitCurve3d self)

        Increments the reference counter of this object


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeUpgrade_SplitCurve3d self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d_DecrementRefCounter(self, *args)

Handle_ShapeUpgrade_SplitCurve3d_swigregister = _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d_swigregister
Handle_ShapeUpgrade_SplitCurve3d_swigregister(Handle_ShapeUpgrade_SplitCurve3d)

def Handle_ShapeUpgrade_SplitCurve3d_DownCast(thing):
    return _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d_DownCast(thing)
Handle_ShapeUpgrade_SplitCurve3d_DownCast = _ShapeUpgrade.Handle_ShapeUpgrade_SplitCurve3d_DownCast

class ShapeUpgrade_ShapeDivideClosedEdges(ShapeUpgrade_ShapeDivide):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ShapeUpgrade_ShapeDivideClosedEdges self, TopoDS_Shape S) -> ShapeUpgrade_ShapeDivideClosedEdges

        Initialises tool with shape and default parameter.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _ShapeUpgrade.new_ShapeUpgrade_ShapeDivideClosedEdges(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetNbSplitPoints(self, *args):
        """
        SetNbSplitPoints(ShapeUpgrade_ShapeDivideClosedEdges self, Standard_Integer const num)

        Sets the number of cuts applied to divide closed edges.
        The number of resulting faces will be num+1.

        :type num: int

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeDivideClosedEdges_SetNbSplitPoints(self, *args)

    __swig_destroy__ = _ShapeUpgrade.delete_ShapeUpgrade_ShapeDivideClosedEdges
ShapeUpgrade_ShapeDivideClosedEdges_swigregister = _ShapeUpgrade.ShapeUpgrade_ShapeDivideClosedEdges_swigregister
ShapeUpgrade_ShapeDivideClosedEdges_swigregister(ShapeUpgrade_ShapeDivideClosedEdges)

class ShapeUpgrade_ShapeDivideClosed(ShapeUpgrade_ShapeDivide):
    """
    Divides all closed faces in the shape. Class
    ShapeUpgrade_ClosedFaceDivide is used as divide tool.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ShapeUpgrade_ShapeDivideClosed self, TopoDS_Shape S) -> ShapeUpgrade_ShapeDivideClosed

        Initialises tool with shape and default parameter.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _ShapeUpgrade.new_ShapeUpgrade_ShapeDivideClosed(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetNbSplitPoints(self, *args):
        """
        SetNbSplitPoints(ShapeUpgrade_ShapeDivideClosed self, Standard_Integer const num)

        Sets the number of cuts applied to divide closed faces.
        The number of resulting faces will be num+1.

        :type num: int

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeDivideClosed_SetNbSplitPoints(self, *args)

    __swig_destroy__ = _ShapeUpgrade.delete_ShapeUpgrade_ShapeDivideClosed
ShapeUpgrade_ShapeDivideClosed_swigregister = _ShapeUpgrade.ShapeUpgrade_ShapeDivideClosed_swigregister
ShapeUpgrade_ShapeDivideClosed_swigregister(ShapeUpgrade_ShapeDivideClosed)

class Handle_ShapeUpgrade_UnifySameDomain(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeUpgrade_UnifySameDomain self)

        Nullify the handle


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_UnifySameDomain_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeUpgrade_UnifySameDomain self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_UnifySameDomain_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeUpgrade_UnifySameDomain self, ShapeUpgrade_UnifySameDomain thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_UnifySameDomain_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeUpgrade_UnifySameDomain self, Handle_ShapeUpgrade_UnifySameDomain theHandle) -> Handle_ShapeUpgrade_UnifySameDomain
        assign(Handle_ShapeUpgrade_UnifySameDomain self, ShapeUpgrade_UnifySameDomain thePtr) -> Handle_ShapeUpgrade_UnifySameDomain
        assign(Handle_ShapeUpgrade_UnifySameDomain self, Handle_ShapeUpgrade_UnifySameDomain theHandle) -> Handle_ShapeUpgrade_UnifySameDomain

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_UnifySameDomain_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeUpgrade_UnifySameDomain self) -> ShapeUpgrade_UnifySameDomain

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_UnifySameDomain_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeUpgrade_UnifySameDomain self) -> ShapeUpgrade_UnifySameDomain

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_UnifySameDomain___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeUpgrade_UnifySameDomain self) -> ShapeUpgrade_UnifySameDomain

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_UnifySameDomain___ref__(self, *args)


    def __hash__(self):
        return _ShapeUpgrade.Handle_ShapeUpgrade_UnifySameDomain___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeUpgrade.Handle_ShapeUpgrade_UnifySameDomain___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeUpgrade.new_Handle_ShapeUpgrade_UnifySameDomain(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeUpgrade.Handle_ShapeUpgrade_UnifySameDomain_DownCast)
    __swig_destroy__ = _ShapeUpgrade.delete_Handle_ShapeUpgrade_UnifySameDomain

    def Initialize(self, *args):
        """
        Initialize(Handle_ShapeUpgrade_UnifySameDomain self, TopoDS_Shape aShape, Standard_Boolean const UnifyEdges, Standard_Boolean const UnifyFaces, Standard_Boolean const ConcatBSplines)

        Initializes with a shape and necessary flags.
        It does not perform unification.
        If you intend to nullify the History place holder do it after
        initialization.

        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type UnifyEdges: bool
        :type UnifyFaces: bool
        :type ConcatBSplines: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_UnifySameDomain_Initialize(self, *args)


    def AllowInternalEdges(self, *args):
        """
        AllowInternalEdges(Handle_ShapeUpgrade_UnifySameDomain self, Standard_Boolean const theValue)

        Sets the flag defining whether it is allowed to create
        internal edges inside merged faces in the case of non-manifold
        topology. Without this flag merging through multi connected edge
        is forbidden. Default value is false.

        :type theValue: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_UnifySameDomain_AllowInternalEdges(self, *args)


    def KeepShape(self, *args):
        """
        KeepShape(Handle_ShapeUpgrade_UnifySameDomain self, TopoDS_Shape theShape)

        Sets the shape for avoid merging of the faces/edges.
        This shape can be vertex or edge.
        If the shape is a vertex it forbids merging of connected edges.
        If the shape is a edge it forbids merging of connected faces.
        This method can be called several times to keep several shapes.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_UnifySameDomain_KeepShape(self, *args)


    def KeepShapes(self, *args):
        """
        KeepShapes(Handle_ShapeUpgrade_UnifySameDomain self, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theShapes)

        Sets the map of shapes for avoid merging of the faces/edges.
        It allows passing a ready to use map instead of calling many times
        the method KeepShape.

        :type theShapes: OCC.wrapper.TopTools.TopTools_MapOfShape

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_UnifySameDomain_KeepShapes(self, *args)


    def SetSafeInputMode(self, *args):
        """
        SetSafeInputMode(Handle_ShapeUpgrade_UnifySameDomain self, Standard_Boolean theValue)

        Sets the flag defining the behavior of the algorithm regarding 
        modification of input shape.
        If this flag is equal to True then the input (original) shape can't be
        modified during modification process. Default value is true.

        :type theValue: bool

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_UnifySameDomain_SetSafeInputMode(self, *args)


    def SetLinearTolerance(self, *args):
        """
        SetLinearTolerance(Handle_ShapeUpgrade_UnifySameDomain self, Standard_Real const theValue)

        Sets the linear tolerance. It plays the role of chord error when
        taking decision about merging of shapes. Default value is Precision::Confusion().

        :type theValue: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_UnifySameDomain_SetLinearTolerance(self, *args)


    def SetAngularTolerance(self, *args):
        """
        SetAngularTolerance(Handle_ShapeUpgrade_UnifySameDomain self, Standard_Real const theValue)

        Sets the angular tolerance. If two shapes form a connection angle greater than 
        this value they will not be merged. Default value is Precision::Angular().

        :type theValue: float

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_UnifySameDomain_SetAngularTolerance(self, *args)


    def Build(self, *args):
        """
        Build(Handle_ShapeUpgrade_UnifySameDomain self)

        Performs unification and builds the resulting shape.


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_UnifySameDomain_Build(self, *args)


    def Shape(self, *args):
        """
        Gives the resulting shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_UnifySameDomain_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def History(self, *args):
        """
        Returns the history of the processed shapes.

        :rtype: OCC.wrapper.BRepTools.Handle_BRepTools_History

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_UnifySameDomain_History(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeUpgrade_UnifySameDomain self) -> char const *

        :rtype: const char *

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_UnifySameDomain_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_UnifySameDomain_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeUpgrade.Handle_ShapeUpgrade_UnifySameDomain_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_ShapeUpgrade_UnifySameDomain self)

        Memory deallocator for transient classes


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_UnifySameDomain_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeUpgrade_UnifySameDomain self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeUpgrade_UnifySameDomain self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_UnifySameDomain_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeUpgrade_UnifySameDomain self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeUpgrade_UnifySameDomain self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_UnifySameDomain_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeUpgrade_UnifySameDomain self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_UnifySameDomain_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeUpgrade_UnifySameDomain self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_UnifySameDomain_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeUpgrade_UnifySameDomain self)

        Increments the reference counter of this object


        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_UnifySameDomain_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeUpgrade_UnifySameDomain self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeUpgrade.Handle_ShapeUpgrade_UnifySameDomain_DecrementRefCounter(self, *args)

Handle_ShapeUpgrade_UnifySameDomain_swigregister = _ShapeUpgrade.Handle_ShapeUpgrade_UnifySameDomain_swigregister
Handle_ShapeUpgrade_UnifySameDomain_swigregister(Handle_ShapeUpgrade_UnifySameDomain)

def Handle_ShapeUpgrade_UnifySameDomain_DownCast(thing):
    return _ShapeUpgrade.Handle_ShapeUpgrade_UnifySameDomain_DownCast(thing)
Handle_ShapeUpgrade_UnifySameDomain_DownCast = _ShapeUpgrade.Handle_ShapeUpgrade_UnifySameDomain_DownCast

class ShapeUpgrade_ShapeDivideContinuity(ShapeUpgrade_ShapeDivide):
    """API Tool for converting shapes with C0 geometry into C1 ones"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ShapeUpgrade_ShapeDivideContinuity self) -> ShapeUpgrade_ShapeDivideContinuity
        __init__(ShapeUpgrade_ShapeDivideContinuity self, TopoDS_Shape S) -> ShapeUpgrade_ShapeDivideContinuity

        Initialize by a Shape.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _ShapeUpgrade.new_ShapeUpgrade_ShapeDivideContinuity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetTolerance(self, *args):
        """
        SetTolerance(ShapeUpgrade_ShapeDivideContinuity self, Standard_Real const Tol)

        Sets tolerance.

        :type Tol: float

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeDivideContinuity_SetTolerance(self, *args)


    def SetTolerance2d(self, *args):
        """
        SetTolerance2d(ShapeUpgrade_ShapeDivideContinuity self, Standard_Real const Tol)

        Sets tolerance.

        :type Tol: float

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeDivideContinuity_SetTolerance2d(self, *args)


    def SetBoundaryCriterion(self, *args):
        """
        SetBoundaryCriterion(ShapeUpgrade_ShapeDivideContinuity self, GeomAbs_Shape const Criterion=GeomAbs_C1)

        Defines a criterion of continuity for the boundary (all the
        Wires)

        The possible values are C0, G1, C1, G2, C2, C3, CN The
        default is C1 to respect the Cas.Cade Shape Validity.  G1
        and G2 are not authorized.

        :type Criterion: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeDivideContinuity_SetBoundaryCriterion(self, *args)


    def SetPCurveCriterion(self, *args):
        """
        SetPCurveCriterion(ShapeUpgrade_ShapeDivideContinuity self, GeomAbs_Shape const Criterion=GeomAbs_C1)

        Defines a criterion of continuity for the boundary (all the
        pcurves of Wires)

        The possible values are C0, G1, C1, G2, C2, C3, CN The
        default is C1 to respect the Cas.Cade Shape Validity.  G1
        and G2 are not authorized.

        :type Criterion: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeDivideContinuity_SetPCurveCriterion(self, *args)


    def SetSurfaceCriterion(self, *args):
        """
        SetSurfaceCriterion(ShapeUpgrade_ShapeDivideContinuity self, GeomAbs_Shape const Criterion=GeomAbs_C1)

        Defines a criterion of continuity for the boundary (all the
        Wires)

        The possible values are C0, G1, C1, G2, C2, C3, CN The
        default is C1 to respect the Cas.Cade Shape Validity.  G1
        and G2 are not authorized.

        :type Criterion: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _ShapeUpgrade.ShapeUpgrade_ShapeDivideContinuity_SetSurfaceCriterion(self, *args)

    __swig_destroy__ = _ShapeUpgrade.delete_ShapeUpgrade_ShapeDivideContinuity
ShapeUpgrade_ShapeDivideContinuity_swigregister = _ShapeUpgrade.ShapeUpgrade_ShapeDivideContinuity_swigregister
ShapeUpgrade_ShapeDivideContinuity_swigregister(ShapeUpgrade_ShapeDivideContinuity)




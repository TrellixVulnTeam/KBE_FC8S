# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Intf')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Intf')
    _Intf = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Intf', [dirname(__file__)])
        except ImportError:
            import _Intf
            return _Intf
        try:
            _mod = imp.load_module('_Intf', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Intf = swig_import_helper()
    del swig_import_helper
else:
    import _Intf
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Intf.delete_SwigPyIterator

    def value(self):
        return _Intf.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Intf.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Intf.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Intf.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Intf.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Intf.SwigPyIterator_copy(self)

    def next(self):
        return _Intf.SwigPyIterator_next(self)

    def __next__(self):
        return _Intf.SwigPyIterator___next__(self)

    def previous(self):
        return _Intf.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Intf.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Intf.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Intf.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Intf.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Intf.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Intf.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Intf.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _Intf.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Intf.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_Intf.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _Intf.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Intf.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Intf.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _Intf.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _Intf.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _Intf.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Intf.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_Intf.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _Intf.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Intf.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Intf.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _Intf.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _Intf.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _Intf.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _Intf.ptr_to_number(item)
ptr_to_number = _Intf.ptr_to_number

def HashCode(*args):
    return _Intf.HashCode(*args)
HashCode = _Intf.HashCode

def ptr_equal(a, b):
    return _Intf.ptr_equal(a, b)
ptr_equal = _Intf.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
Intf_EXTERNAL = _Intf.Intf_EXTERNAL
Intf_FACE = _Intf.Intf_FACE
Intf_EDGE = _Intf.Intf_EDGE
Intf_VERTEX = _Intf.Intf_VERTEX
class Intf_TangentZone(object):
    """
    Describes   a  zone  of  tangence  between  polygons  or
    polyhedra as a sequence of points of intersection.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def NumberOfPoints(self, *args):
        """
        NumberOfPoints(Intf_TangentZone self) -> Standard_Integer

        Returns number of SectionPoint in this TangentZone.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Intf.Intf_TangentZone_NumberOfPoints(self, *args)


    def GetPoint(self, *args):
        """
        Gives   the   SectionPoint   of  address  <Index>  in  the
        TangentZone.

        :type Index: int
        :rtype: OCC.wrapper.Intf.Intf_SectionPoint

        """
        res = _Intf.Intf_TangentZone_GetPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsEqual(self, *args):
        """
        IsEqual(Intf_TangentZone self, Intf_TangentZone Other) -> Standard_Boolean

        Compares two TangentZones.

        :type Other: OCC.wrapper.Intf.Intf_TangentZone
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intf.Intf_TangentZone_IsEqual(self, *args)


    def __eq__(self, *args):
        """
        __eq__(Intf_TangentZone self, Intf_TangentZone Other) -> Standard_Boolean

        :type Other: OCC.wrapper.Intf.Intf_TangentZone
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intf.Intf_TangentZone___eq__(self, *args)


    def Contains(self, *args):
        """
        Contains(Intf_TangentZone self, Intf_SectionPoint ThePI) -> Standard_Boolean

        Checks if <ThePI> is in TangentZone.

        :type ThePI: OCC.wrapper.Intf.Intf_SectionPoint
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intf.Intf_TangentZone_Contains(self, *args)


    def ParamOnFirst(self, *args):
        """
        ParamOnFirst(Intf_TangentZone self)

        Gives  the parameter range of the  TangentZone on the first
        argument of the Interference. (Usable only for polygon)

        :type paraMin: float
        :type paraMax: float

        """
        return _Intf.Intf_TangentZone_ParamOnFirst(self, *args)


    def ParamOnSecond(self, *args):
        """
        ParamOnSecond(Intf_TangentZone self)

        Gives the parameter range of the  TangentZone on the second
        argument of the Interference. (Usable only for polygon)

        :type paraMin: float
        :type paraMax: float

        """
        return _Intf.Intf_TangentZone_ParamOnSecond(self, *args)


    def InfoFirst(self, *args):
        """
        InfoFirst(Intf_TangentZone self)

        Gives information  about  the    first argument   of   the
        Interference. (Usable only for polygon)

        :type segMin: int
        :type paraMin: float
        :type segMax: int
        :type paraMax: float

        """
        return _Intf.Intf_TangentZone_InfoFirst(self, *args)


    def InfoSecond(self, *args):
        """
        InfoSecond(Intf_TangentZone self)

        Gives   informations  about  the  second   argument of  the
        Interference. (Usable only for polygon)

        :type segMin: int
        :type paraMin: float
        :type segMax: int
        :type paraMax: float

        """
        return _Intf.Intf_TangentZone_InfoSecond(self, *args)


    def RangeContains(self, *args):
        """
        RangeContains(Intf_TangentZone self, Intf_SectionPoint ThePI) -> Standard_Boolean

        Returns True if  <ThePI>  is in the parameter  range of the
        TangentZone.

        :type ThePI: OCC.wrapper.Intf.Intf_SectionPoint
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intf.Intf_TangentZone_RangeContains(self, *args)


    def HasCommonRange(self, *args):
        """
        HasCommonRange(Intf_TangentZone self, Intf_TangentZone Other) -> Standard_Boolean

        Returns True if the TangentZone  <Other> has  a common part
        with <me>.

        :type Other: OCC.wrapper.Intf.Intf_TangentZone
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intf.Intf_TangentZone_HasCommonRange(self, *args)


    def __init__(self, *args):
        """
        __init__(Intf_TangentZone self) -> Intf_TangentZone
        __init__(Intf_TangentZone self, Intf_TangentZone Other) -> Intf_TangentZone

        Copies a Tangent zone.

        :type Other: OCC.wrapper.Intf.Intf_TangentZone

        """
        this = _Intf.new_Intf_TangentZone(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Append(self, *args):
        """
        Append(Intf_TangentZone self, Intf_SectionPoint Pi)
        Append(Intf_TangentZone self, Intf_TangentZone Tzi)

        Adds the TangentZone <Tzi> to <me>.

        :type Tzi: OCC.wrapper.Intf.Intf_TangentZone

        """
        return _Intf.Intf_TangentZone_Append(self, *args)


    def Insert(self, *args):
        """
        Insert(Intf_TangentZone self, Intf_SectionPoint Pi) -> Standard_Boolean

        Inserts a SectionPoint in the TangentZone.

        :type Pi: OCC.wrapper.Intf.Intf_SectionPoint
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intf.Intf_TangentZone_Insert(self, *args)


    def PolygonInsert(self, *args):
        """
        PolygonInsert(Intf_TangentZone self, Intf_SectionPoint Pi)

        Inserts a point in the polygonal TangentZone.

        :type Pi: OCC.wrapper.Intf.Intf_SectionPoint

        """
        return _Intf.Intf_TangentZone_PolygonInsert(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(Intf_TangentZone self, Standard_Integer const Index, Intf_SectionPoint Pi)

        Inserts a SectionPoint before <Index> in the TangentZone.

        :type Index: int
        :type Pi: OCC.wrapper.Intf.Intf_SectionPoint

        """
        return _Intf.Intf_TangentZone_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(Intf_TangentZone self, Standard_Integer const Index, Intf_SectionPoint Pi)

        Inserts a SectionPoint after <Index> in the TangentZone.

        :type Index: int
        :type Pi: OCC.wrapper.Intf.Intf_SectionPoint

        """
        return _Intf.Intf_TangentZone_InsertAfter(self, *args)


    def Dump(self, *args):
        """
        Dump(Intf_TangentZone self, Standard_Integer const Indent)

        :type Indent: int

        """
        return _Intf.Intf_TangentZone_Dump(self, *args)

    __swig_destroy__ = _Intf.delete_Intf_TangentZone
Intf_TangentZone_swigregister = _Intf.Intf_TangentZone_swigregister
Intf_TangentZone_swigregister(Intf_TangentZone)

class Intf_SectionPoint(object):
    """
    Describes an intersection  point between  polygons  and
    polyedra.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Pnt(self, *args):
        """
        Returns the location of the SectionPoint.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Intf.Intf_SectionPoint_Pnt(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ParamOnFirst(self, *args):
        """
        ParamOnFirst(Intf_SectionPoint self) -> Standard_Real

        Returns the cumulated  Parameter of the SectionPoint on the
        first element.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Intf.Intf_SectionPoint_ParamOnFirst(self, *args)


    def ParamOnSecond(self, *args):
        """
        ParamOnSecond(Intf_SectionPoint self) -> Standard_Real

        Returns the cumulated Parameter of the section point on the
        second element.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Intf.Intf_SectionPoint_ParamOnSecond(self, *args)


    def TypeOnFirst(self, *args):
        """
        TypeOnFirst(Intf_SectionPoint self) -> Intf_PIType

        Returns the type of the section point on the first element.

        :rtype: OCC.wrapper.Intf.Intf_PIType

        """
        return _Intf.Intf_SectionPoint_TypeOnFirst(self, *args)


    def TypeOnSecond(self, *args):
        """
        TypeOnSecond(Intf_SectionPoint self) -> Intf_PIType

        Returns  the  type  of the  section  point  on  the  second
        element.

        :rtype: OCC.wrapper.Intf.Intf_PIType

        """
        return _Intf.Intf_SectionPoint_TypeOnSecond(self, *args)


    def InfoFirst(self, *args):
        """
        InfoFirst(Intf_SectionPoint self)
        InfoFirst(Intf_SectionPoint self)

        Gives the   datas  about   the    first  argument of    the
        Interference.

        :type Dim: OCC.wrapper.Intf.Intf_PIType
        :type Addr: int
        :type Param: float

        """
        return _Intf.Intf_SectionPoint_InfoFirst(self, *args)


    def InfoSecond(self, *args):
        """
        InfoSecond(Intf_SectionPoint self)
        InfoSecond(Intf_SectionPoint self)

        Gives the   datas  about   the    second  argument of    the
        Interference.

        :type Dim: OCC.wrapper.Intf.Intf_PIType
        :type Addr: int
        :type Param: float

        """
        return _Intf.Intf_SectionPoint_InfoSecond(self, *args)


    def Incidence(self, *args):
        """
        Incidence(Intf_SectionPoint self) -> Standard_Real

        Gives the incidence at  this  section point. The  incidence
        between the two triangles is given by the cosine.  The best
        incidence is 0. (PI/2).  The worst is 1. (null angle).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Intf.Intf_SectionPoint_Incidence(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(Intf_SectionPoint self, Intf_SectionPoint Other) -> Standard_Boolean

        Returns True if the two SectionPoint have the  same logical
        informations.

        :type Other: OCC.wrapper.Intf.Intf_SectionPoint
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intf.Intf_SectionPoint_IsEqual(self, *args)


    def __eq__(self, *args):
        """
        __eq__(Intf_SectionPoint self, Intf_SectionPoint Other) -> Standard_Boolean

        :type Other: OCC.wrapper.Intf.Intf_SectionPoint
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intf.Intf_SectionPoint___eq__(self, *args)


    def IsOnSameEdge(self, *args):
        """
        IsOnSameEdge(Intf_SectionPoint self, Intf_SectionPoint Other) -> Standard_Boolean

        Returns True if the two SectionPoints are  on the  same edge
        of the first or the second element.

        :type Other: OCC.wrapper.Intf.Intf_SectionPoint
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intf.Intf_SectionPoint_IsOnSameEdge(self, *args)


    def __init__(self, *args):
        """
        __init__(Intf_SectionPoint self) -> Intf_SectionPoint
        __init__(Intf_SectionPoint self, gp_Pnt Where, Intf_PIType const DimeO, Standard_Integer const AddrO1, Standard_Integer const AddrO2, Standard_Real const ParamO, Intf_PIType const DimeT, Standard_Integer const AddrT1, Standard_Integer const AddrT2, Standard_Real const ParamT, Standard_Real const Incid) -> Intf_SectionPoint
        __init__(Intf_SectionPoint self, gp_Pnt2d Where, Intf_PIType const DimeO, Standard_Integer const AddrO1, Standard_Real const ParamO, Intf_PIType const DimeT, Standard_Integer const AddrT1, Standard_Real const ParamT, Standard_Real const Incid) -> Intf_SectionPoint

        Builds  a  SectionPoint 2d   with the respective dimensions
        (vertex or  edge)  of  the concerned arguments   and  their
        addresses in the Topological structure.

        :type Where: OCC.wrapper.gp.gp_Pnt2d
        :type DimeO: OCC.wrapper.Intf.Intf_PIType
        :type AddrO1: int
        :type ParamO: float
        :type DimeT: OCC.wrapper.Intf.Intf_PIType
        :type AddrT1: int
        :type ParamT: float
        :type Incid: float

        """
        this = _Intf.new_Intf_SectionPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Merge(self, *args):
        """
        Merge(Intf_SectionPoint self, Intf_SectionPoint Other)

        Merges two SectionPoints.

        :type Other: OCC.wrapper.Intf.Intf_SectionPoint

        """
        return _Intf.Intf_SectionPoint_Merge(self, *args)


    def Dump(self, *args):
        """
        Dump(Intf_SectionPoint self, Standard_Integer const Indent)

        :type Indent: int

        """
        return _Intf.Intf_SectionPoint_Dump(self, *args)

    __swig_destroy__ = _Intf.delete_Intf_SectionPoint
Intf_SectionPoint_swigregister = _Intf.Intf_SectionPoint_swigregister
Intf_SectionPoint_swigregister(Intf_SectionPoint)

class Intf_SectionLine(object):
    """
    Describe    a  polyline  of   intersection  between two
    polyhedra as a sequence of points of intersection.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def NumberOfPoints(self, *args):
        """
        NumberOfPoints(Intf_SectionLine self) -> Standard_Integer

        Returns number of points in this SectionLine.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Intf.Intf_SectionLine_NumberOfPoints(self, *args)


    def GetPoint(self, *args):
        """
        Gives the point of intersection of  address <Index>  in the
        SectionLine.

        :type Index: int
        :rtype: OCC.wrapper.Intf.Intf_SectionPoint

        """
        res = _Intf.Intf_SectionLine_GetPoint(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsClosed(self, *args):
        """
        IsClosed(Intf_SectionLine self) -> Standard_Boolean

        Returns True if the SectionLine is closed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intf.Intf_SectionLine_IsClosed(self, *args)


    def Contains(self, *args):
        """
        Contains(Intf_SectionLine self, Intf_SectionPoint ThePI) -> Standard_Boolean

        Returns True if ThePI is in the SectionLine <me>.

        :type ThePI: OCC.wrapper.Intf.Intf_SectionPoint
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intf.Intf_SectionLine_Contains(self, *args)


    def IsEnd(self, *args):
        """
        IsEnd(Intf_SectionLine self, Intf_SectionPoint ThePI) -> Standard_Integer

        Checks if <ThePI>  is an end of  the SectionLine. Returns 1
        for the beginning, 2 for the end, otherwise 0.

        :type ThePI: OCC.wrapper.Intf.Intf_SectionPoint
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Intf.Intf_SectionLine_IsEnd(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(Intf_SectionLine self, Intf_SectionLine Other) -> Standard_Boolean

        Compares two SectionLines.

        :type Other: OCC.wrapper.Intf.Intf_SectionLine
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intf.Intf_SectionLine_IsEqual(self, *args)


    def __eq__(self, *args):
        """
        __eq__(Intf_SectionLine self, Intf_SectionLine Other) -> Standard_Boolean

        :type Other: OCC.wrapper.Intf.Intf_SectionLine
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intf.Intf_SectionLine___eq__(self, *args)


    def __init__(self, *args):
        """
        __init__(Intf_SectionLine self) -> Intf_SectionLine
        __init__(Intf_SectionLine self, Intf_SectionLine Other) -> Intf_SectionLine

        Copies a SectionLine.

        :type Other: OCC.wrapper.Intf.Intf_SectionLine

        """
        this = _Intf.new_Intf_SectionLine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Append(self, *args):
        """
        Append(Intf_SectionLine self, Intf_SectionPoint Pi)
        Append(Intf_SectionLine self, Intf_SectionLine LS)

        Concatenates   the SectionLine  <LS>  at  the  end  of  the
        SectionLine <me>.

        :type LS: OCC.wrapper.Intf.Intf_SectionLine

        """
        return _Intf.Intf_SectionLine_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(Intf_SectionLine self, Intf_SectionPoint Pi)
        Prepend(Intf_SectionLine self, Intf_SectionLine LS)

        Concatenates a SectionLine  <LS>  at the  beginning  of the
        SectionLine <me>.

        :type LS: OCC.wrapper.Intf.Intf_SectionLine

        """
        return _Intf.Intf_SectionLine_Prepend(self, *args)


    def Reverse(self, *args):
        """
        Reverse(Intf_SectionLine self)

        Reverses the order of the elements of the SectionLine.


        """
        return _Intf.Intf_SectionLine_Reverse(self, *args)


    def Close(self, *args):
        """
        Close(Intf_SectionLine self)

        Closes the SectionLine.


        """
        return _Intf.Intf_SectionLine_Close(self, *args)


    def Dump(self, *args):
        """
        Dump(Intf_SectionLine self, Standard_Integer const Indent)

        :type Indent: int

        """
        return _Intf.Intf_SectionLine_Dump(self, *args)

    __swig_destroy__ = _Intf.delete_Intf_SectionLine
Intf_SectionLine_swigregister = _Intf.Intf_SectionLine_swigregister
Intf_SectionLine_swigregister(Intf_SectionLine)

class Intf_(object):
    """
    Interference computation  between polygons, lines  and
    polyhedra with only  triangular  facets. These objects
    are polygonal  representations of complex   curves and
    triangulated representations of complex surfaces.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def PlaneEquation(*args):
        """
        PlaneEquation(gp_Pnt P1, gp_Pnt P2, gp_Pnt P3, gp_XYZ NormalVector)

        Computes   the  interference between   two polygons in  2d.
        Result : points of intersections and zones of tangence.
        Computes the interference  between a polygon or  a straight
        line and a polyhedron.   Points of intersection  and zones
        of tangence.
        Give the plane equation of the triangle <P1> <P2> <P3>.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :type P3: OCC.wrapper.gp.gp_Pnt
        :type NormalVector: OCC.wrapper.gp.gp_XYZ
        :type PolarDistance: float

        """
        return _Intf.Intf__PlaneEquation(*args)

    PlaneEquation = staticmethod(PlaneEquation)

    def Contain(*args):
        """
        Contain(gp_Pnt P1, gp_Pnt P2, gp_Pnt P3, gp_Pnt ThePnt) -> Standard_Boolean

        Compute if the triangle <P1> <P2> <P3> contain <ThePnt>.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :type P3: OCC.wrapper.gp.gp_Pnt
        :type ThePnt: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intf.Intf__Contain(*args)

    Contain = staticmethod(Contain)

    def __init__(self):
        """
        Interference computation  between polygons, lines  and
        polyhedra with only  triangular  facets. These objects
        are polygonal  representations of complex   curves and
        triangulated representations of complex surfaces.
        """
        this = _Intf.new_Intf_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Intf.delete_Intf_
Intf__swigregister = _Intf.Intf__swigregister
Intf__swigregister(Intf_)

def Intf__PlaneEquation(*args):
    """
    Intf__PlaneEquation(gp_Pnt P1, gp_Pnt P2, gp_Pnt P3, gp_XYZ NormalVector)

    Computes   the  interference between   two polygons in  2d.
    Result : points of intersections and zones of tangence.
    Computes the interference  between a polygon or  a straight
    line and a polyhedron.   Points of intersection  and zones
    of tangence.
    Give the plane equation of the triangle <P1> <P2> <P3>.

    :type P1: OCC.wrapper.gp.gp_Pnt
    :type P2: OCC.wrapper.gp.gp_Pnt
    :type P3: OCC.wrapper.gp.gp_Pnt
    :type NormalVector: OCC.wrapper.gp.gp_XYZ
    :type PolarDistance: float

    """
    return _Intf.Intf__PlaneEquation(*args)

def Intf__Contain(*args):
    """
    Intf__Contain(gp_Pnt P1, gp_Pnt P2, gp_Pnt P3, gp_Pnt ThePnt) -> Standard_Boolean

    Compute if the triangle <P1> <P2> <P3> contain <ThePnt>.

    :type P1: OCC.wrapper.gp.gp_Pnt
    :type P2: OCC.wrapper.gp.gp_Pnt
    :type P3: OCC.wrapper.gp.gp_Pnt
    :type ThePnt: OCC.wrapper.gp.gp_Pnt
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Intf.Intf__Contain(*args)

class Intf_Interference(object):
    """
    Describes the   Interference  computation    result
    between polygon2d or polygon3d or polyhedron
    (as  three sequences   of  points  of  intersection,
    polylines of intersection and zones de tangence).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def NbSectionPoints(self, *args):
        """
        NbSectionPoints(Intf_Interference self) -> Standard_Integer

        Gives the number   of  points of  intersection  in the
        interference.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Intf.Intf_Interference_NbSectionPoints(self, *args)


    def PntValue(self, *args):
        """
        Gives the point of  intersection of address  Index in
        the interference.

        :type Index: int
        :rtype: OCC.wrapper.Intf.Intf_SectionPoint

        """
        res = _Intf.Intf_Interference_PntValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbSectionLines(self, *args):
        """
        NbSectionLines(Intf_Interference self) -> Standard_Integer

        Gives the number  of polylines of  intersection in the
        interference.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Intf.Intf_Interference_NbSectionLines(self, *args)


    def LineValue(self, *args):
        """
        Gives the polyline of intersection at address <Index> in
        the interference.

        :type Index: int
        :rtype: OCC.wrapper.Intf.Intf_SectionLine

        """
        res = _Intf.Intf_Interference_LineValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbTangentZones(self, *args):
        """
        NbTangentZones(Intf_Interference self) -> Standard_Integer

        Gives the number of zones of tangence in the interference.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Intf.Intf_Interference_NbTangentZones(self, *args)


    def ZoneValue(self, *args):
        """
        Gives  the zone of  tangence at address   Index in the
        interference.

        :type Index: int
        :rtype: OCC.wrapper.Intf.Intf_TangentZone

        """
        res = _Intf.Intf_Interference_ZoneValue(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetTolerance(self, *args):
        """
        GetTolerance(Intf_Interference self) -> Standard_Real

        Gives the tolerance used for the calculation.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Intf.Intf_Interference_GetTolerance(self, *args)


    def Contains(self, *args):
        """
        Contains(Intf_Interference self, Intf_SectionPoint ThePnt) -> Standard_Boolean

        Tests if the polylines of  intersection or the zones of
        tangence contain the point of intersection <ThePnt>.

        :type ThePnt: OCC.wrapper.Intf.Intf_SectionPoint
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intf.Intf_Interference_Contains(self, *args)


    def Insert(self, *args):
        """
        Insert(Intf_Interference self, Intf_TangentZone TheZone) -> Standard_Boolean
        Insert(Intf_Interference self, Intf_SectionPoint pdeb, Intf_SectionPoint pfin)

        Insert a new segment of intersection in the current  list of
        polylines of intersection of the interference.

        :type pdeb: OCC.wrapper.Intf.Intf_SectionPoint
        :type pfin: OCC.wrapper.Intf.Intf_SectionPoint

        """
        return _Intf.Intf_Interference_Insert(self, *args)


    def Dump(self, *args):
        """Dump(Intf_Interference self)"""
        return _Intf.Intf_Interference_Dump(self, *args)

Intf_Interference_swigregister = _Intf.Intf_Interference_swigregister
Intf_Interference_swigregister(Intf_Interference)

class NCollection_Sequence_Intf_TangentZone(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Intf_TangentZone self) -> NCollection_Sequence< Intf_TangentZone >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _Intf.NCollection_Sequence_Intf_TangentZone_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Intf_TangentZone self) -> NCollection_Sequence< Intf_TangentZone >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _Intf.NCollection_Sequence_Intf_TangentZone_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Intf_TangentZone self) -> NCollection_Sequence< Intf_TangentZone >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _Intf.NCollection_Sequence_Intf_TangentZone_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Intf_TangentZone self) -> NCollection_Sequence< Intf_TangentZone >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _Intf.NCollection_Sequence_Intf_TangentZone_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _Intf.new_NCollection_Sequence_Intf_TangentZone(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Intf_TangentZone self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Intf.NCollection_Sequence_Intf_TangentZone_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Intf_TangentZone self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Intf.NCollection_Sequence_Intf_TangentZone_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Intf_TangentZone self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Intf.NCollection_Sequence_Intf_TangentZone_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Intf_TangentZone self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Intf.NCollection_Sequence_Intf_TangentZone_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Intf_TangentZone self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intf.NCollection_Sequence_Intf_TangentZone_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Intf_TangentZone self)

        Reverse sequence


        """
        return _Intf.NCollection_Sequence_Intf_TangentZone_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Intf_TangentZone self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _Intf.NCollection_Sequence_Intf_TangentZone_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Intf.NCollection_Sequence_Intf_TangentZone_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Intf_TangentZone self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Intf.NCollection_Sequence_Intf_TangentZone_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Intf_TangentZone self, NCollection_Sequence_Intf_TangentZone theOther) -> NCollection_Sequence_Intf_TangentZone

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Intf.NCollection_Sequence_Intf_TangentZone_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Intf_TangentZone self, NCollection_Sequence_Intf_TangentZone theOther) -> NCollection_Sequence_Intf_TangentZone

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Intf.NCollection_Sequence_Intf_TangentZone_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Intf_TangentZone self, NCollection_Sequence< Intf_TangentZone >::Iterator & thePosition)
        Remove(NCollection_Sequence_Intf_TangentZone self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Intf_TangentZone self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _Intf.NCollection_Sequence_Intf_TangentZone_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Intf_TangentZone self, Intf_TangentZone theItem)
        Append(NCollection_Sequence_Intf_TangentZone self, NCollection_Sequence_Intf_TangentZone theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Intf.NCollection_Sequence_Intf_TangentZone_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Intf_TangentZone self, Intf_TangentZone theItem)
        Prepend(NCollection_Sequence_Intf_TangentZone self, NCollection_Sequence_Intf_TangentZone theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Intf.NCollection_Sequence_Intf_TangentZone_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Intf_TangentZone self, Standard_Integer const theIndex, Intf_TangentZone theItem)
        InsertBefore(NCollection_Sequence_Intf_TangentZone self, Standard_Integer const theIndex, NCollection_Sequence_Intf_TangentZone theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Intf.NCollection_Sequence_Intf_TangentZone_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Intf_TangentZone self, NCollection_Sequence< Intf_TangentZone >::Iterator & thePosition, Intf_TangentZone theItem)
        InsertAfter(NCollection_Sequence_Intf_TangentZone self, Standard_Integer const theIndex, NCollection_Sequence_Intf_TangentZone theSeq)
        InsertAfter(NCollection_Sequence_Intf_TangentZone self, Standard_Integer const theIndex, Intf_TangentZone theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Intf.NCollection_Sequence_Intf_TangentZone_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Intf_TangentZone self, Standard_Integer const theIndex, NCollection_Sequence_Intf_TangentZone theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Intf.NCollection_Sequence_Intf_TangentZone_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _Intf.NCollection_Sequence_Intf_TangentZone_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Intf_TangentZone self) -> Intf_TangentZone

        First item access

        :rtype: TheItemType &

        """
        return _Intf.NCollection_Sequence_Intf_TangentZone_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _Intf.NCollection_Sequence_Intf_TangentZone_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Intf_TangentZone self) -> Intf_TangentZone

        Last item access

        :rtype: TheItemType &

        """
        return _Intf.NCollection_Sequence_Intf_TangentZone_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Intf.NCollection_Sequence_Intf_TangentZone_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Intf_TangentZone self, Standard_Integer const theIndex) -> Intf_TangentZone

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Intf.NCollection_Sequence_Intf_TangentZone_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Intf.NCollection_Sequence_Intf_TangentZone___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Intf_TangentZone self, Standard_Integer const theIndex, Intf_TangentZone theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Intf.NCollection_Sequence_Intf_TangentZone_SetValue(self, *args)


    def __iter__(self):
        return _Intf.NCollection_Sequence_Intf_TangentZone___iter__(self)
    __swig_destroy__ = _Intf.delete_NCollection_Sequence_Intf_TangentZone
NCollection_Sequence_Intf_TangentZone_swigregister = _Intf.NCollection_Sequence_Intf_TangentZone_swigregister
NCollection_Sequence_Intf_TangentZone_swigregister(NCollection_Sequence_Intf_TangentZone)

def NCollection_Sequence_Intf_TangentZone_delNode(*args):
    """
    NCollection_Sequence_Intf_TangentZone_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _Intf.NCollection_Sequence_Intf_TangentZone_delNode(*args)

class NCollection_Sequence_Intf_TangentZone_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Intf.new_NCollection_Sequence_Intf_TangentZone_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Intf.delete_NCollection_Sequence_Intf_TangentZone_IteratorHelper

    def __next__(self):
        return _Intf.NCollection_Sequence_Intf_TangentZone_IteratorHelper___next__(self)
NCollection_Sequence_Intf_TangentZone_IteratorHelper_swigregister = _Intf.NCollection_Sequence_Intf_TangentZone_IteratorHelper_swigregister
NCollection_Sequence_Intf_TangentZone_IteratorHelper_swigregister(NCollection_Sequence_Intf_TangentZone_IteratorHelper)


try:
	Intf_SeqOfTangentZone = NCollection_Sequence_Intf_TangentZone
except NameError:
	pass # does not exist, probably ignored

class NCollection_Sequence_Intf_SectionPoint(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Intf_SectionPoint self) -> NCollection_Sequence< Intf_SectionPoint >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _Intf.NCollection_Sequence_Intf_SectionPoint_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Intf_SectionPoint self) -> NCollection_Sequence< Intf_SectionPoint >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _Intf.NCollection_Sequence_Intf_SectionPoint_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Intf_SectionPoint self) -> NCollection_Sequence< Intf_SectionPoint >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _Intf.NCollection_Sequence_Intf_SectionPoint_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Intf_SectionPoint self) -> NCollection_Sequence< Intf_SectionPoint >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _Intf.NCollection_Sequence_Intf_SectionPoint_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _Intf.new_NCollection_Sequence_Intf_SectionPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Intf_SectionPoint self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Intf.NCollection_Sequence_Intf_SectionPoint_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Intf_SectionPoint self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Intf.NCollection_Sequence_Intf_SectionPoint_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Intf_SectionPoint self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Intf.NCollection_Sequence_Intf_SectionPoint_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Intf_SectionPoint self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Intf.NCollection_Sequence_Intf_SectionPoint_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Intf_SectionPoint self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intf.NCollection_Sequence_Intf_SectionPoint_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Intf_SectionPoint self)

        Reverse sequence


        """
        return _Intf.NCollection_Sequence_Intf_SectionPoint_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Intf_SectionPoint self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _Intf.NCollection_Sequence_Intf_SectionPoint_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Intf.NCollection_Sequence_Intf_SectionPoint_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Intf_SectionPoint self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Intf.NCollection_Sequence_Intf_SectionPoint_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Intf_SectionPoint self, NCollection_Sequence_Intf_SectionPoint theOther) -> NCollection_Sequence_Intf_SectionPoint

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Intf.NCollection_Sequence_Intf_SectionPoint_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Intf_SectionPoint self, NCollection_Sequence_Intf_SectionPoint theOther) -> NCollection_Sequence_Intf_SectionPoint

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Intf.NCollection_Sequence_Intf_SectionPoint_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Intf_SectionPoint self, NCollection_Sequence< Intf_SectionPoint >::Iterator & thePosition)
        Remove(NCollection_Sequence_Intf_SectionPoint self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Intf_SectionPoint self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _Intf.NCollection_Sequence_Intf_SectionPoint_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Intf_SectionPoint self, Intf_SectionPoint theItem)
        Append(NCollection_Sequence_Intf_SectionPoint self, NCollection_Sequence_Intf_SectionPoint theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Intf.NCollection_Sequence_Intf_SectionPoint_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Intf_SectionPoint self, Intf_SectionPoint theItem)
        Prepend(NCollection_Sequence_Intf_SectionPoint self, NCollection_Sequence_Intf_SectionPoint theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Intf.NCollection_Sequence_Intf_SectionPoint_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Intf_SectionPoint self, Standard_Integer const theIndex, Intf_SectionPoint theItem)
        InsertBefore(NCollection_Sequence_Intf_SectionPoint self, Standard_Integer const theIndex, NCollection_Sequence_Intf_SectionPoint theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Intf.NCollection_Sequence_Intf_SectionPoint_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Intf_SectionPoint self, NCollection_Sequence< Intf_SectionPoint >::Iterator & thePosition, Intf_SectionPoint theItem)
        InsertAfter(NCollection_Sequence_Intf_SectionPoint self, Standard_Integer const theIndex, NCollection_Sequence_Intf_SectionPoint theSeq)
        InsertAfter(NCollection_Sequence_Intf_SectionPoint self, Standard_Integer const theIndex, Intf_SectionPoint theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Intf.NCollection_Sequence_Intf_SectionPoint_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Intf_SectionPoint self, Standard_Integer const theIndex, NCollection_Sequence_Intf_SectionPoint theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Intf.NCollection_Sequence_Intf_SectionPoint_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _Intf.NCollection_Sequence_Intf_SectionPoint_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Intf_SectionPoint self) -> Intf_SectionPoint

        First item access

        :rtype: TheItemType &

        """
        return _Intf.NCollection_Sequence_Intf_SectionPoint_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _Intf.NCollection_Sequence_Intf_SectionPoint_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Intf_SectionPoint self) -> Intf_SectionPoint

        Last item access

        :rtype: TheItemType &

        """
        return _Intf.NCollection_Sequence_Intf_SectionPoint_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Intf.NCollection_Sequence_Intf_SectionPoint_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Intf_SectionPoint self, Standard_Integer const theIndex) -> Intf_SectionPoint

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Intf.NCollection_Sequence_Intf_SectionPoint_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Intf.NCollection_Sequence_Intf_SectionPoint___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Intf_SectionPoint self, Standard_Integer const theIndex, Intf_SectionPoint theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Intf.NCollection_Sequence_Intf_SectionPoint_SetValue(self, *args)


    def __iter__(self):
        return _Intf.NCollection_Sequence_Intf_SectionPoint___iter__(self)
    __swig_destroy__ = _Intf.delete_NCollection_Sequence_Intf_SectionPoint
NCollection_Sequence_Intf_SectionPoint_swigregister = _Intf.NCollection_Sequence_Intf_SectionPoint_swigregister
NCollection_Sequence_Intf_SectionPoint_swigregister(NCollection_Sequence_Intf_SectionPoint)

def NCollection_Sequence_Intf_SectionPoint_delNode(*args):
    """
    NCollection_Sequence_Intf_SectionPoint_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _Intf.NCollection_Sequence_Intf_SectionPoint_delNode(*args)

class NCollection_Sequence_Intf_SectionPoint_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Intf.new_NCollection_Sequence_Intf_SectionPoint_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Intf.delete_NCollection_Sequence_Intf_SectionPoint_IteratorHelper

    def __next__(self):
        return _Intf.NCollection_Sequence_Intf_SectionPoint_IteratorHelper___next__(self)
NCollection_Sequence_Intf_SectionPoint_IteratorHelper_swigregister = _Intf.NCollection_Sequence_Intf_SectionPoint_IteratorHelper_swigregister
NCollection_Sequence_Intf_SectionPoint_IteratorHelper_swigregister(NCollection_Sequence_Intf_SectionPoint_IteratorHelper)


try:
	Intf_SeqOfSectionPoint = NCollection_Sequence_Intf_SectionPoint
except NameError:
	pass # does not exist, probably ignored

class NCollection_Sequence_Intf_SectionLine(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Intf_SectionLine self) -> NCollection_Sequence< Intf_SectionLine >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _Intf.NCollection_Sequence_Intf_SectionLine_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Intf_SectionLine self) -> NCollection_Sequence< Intf_SectionLine >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _Intf.NCollection_Sequence_Intf_SectionLine_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Intf_SectionLine self) -> NCollection_Sequence< Intf_SectionLine >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _Intf.NCollection_Sequence_Intf_SectionLine_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Intf_SectionLine self) -> NCollection_Sequence< Intf_SectionLine >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _Intf.NCollection_Sequence_Intf_SectionLine_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _Intf.new_NCollection_Sequence_Intf_SectionLine(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Intf_SectionLine self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Intf.NCollection_Sequence_Intf_SectionLine_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Intf_SectionLine self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Intf.NCollection_Sequence_Intf_SectionLine_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Intf_SectionLine self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Intf.NCollection_Sequence_Intf_SectionLine_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Intf_SectionLine self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Intf.NCollection_Sequence_Intf_SectionLine_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Intf_SectionLine self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intf.NCollection_Sequence_Intf_SectionLine_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Intf_SectionLine self)

        Reverse sequence


        """
        return _Intf.NCollection_Sequence_Intf_SectionLine_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Intf_SectionLine self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _Intf.NCollection_Sequence_Intf_SectionLine_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Intf.NCollection_Sequence_Intf_SectionLine_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Intf_SectionLine self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Intf.NCollection_Sequence_Intf_SectionLine_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Intf_SectionLine self, NCollection_Sequence_Intf_SectionLine theOther) -> NCollection_Sequence_Intf_SectionLine

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Intf.NCollection_Sequence_Intf_SectionLine_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Intf_SectionLine self, NCollection_Sequence_Intf_SectionLine theOther) -> NCollection_Sequence_Intf_SectionLine

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Intf.NCollection_Sequence_Intf_SectionLine_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Intf_SectionLine self, NCollection_Sequence< Intf_SectionLine >::Iterator & thePosition)
        Remove(NCollection_Sequence_Intf_SectionLine self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Intf_SectionLine self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _Intf.NCollection_Sequence_Intf_SectionLine_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Intf_SectionLine self, Intf_SectionLine theItem)
        Append(NCollection_Sequence_Intf_SectionLine self, NCollection_Sequence_Intf_SectionLine theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Intf.NCollection_Sequence_Intf_SectionLine_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Intf_SectionLine self, Intf_SectionLine theItem)
        Prepend(NCollection_Sequence_Intf_SectionLine self, NCollection_Sequence_Intf_SectionLine theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Intf.NCollection_Sequence_Intf_SectionLine_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Intf_SectionLine self, Standard_Integer const theIndex, Intf_SectionLine theItem)
        InsertBefore(NCollection_Sequence_Intf_SectionLine self, Standard_Integer const theIndex, NCollection_Sequence_Intf_SectionLine theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Intf.NCollection_Sequence_Intf_SectionLine_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Intf_SectionLine self, NCollection_Sequence< Intf_SectionLine >::Iterator & thePosition, Intf_SectionLine theItem)
        InsertAfter(NCollection_Sequence_Intf_SectionLine self, Standard_Integer const theIndex, NCollection_Sequence_Intf_SectionLine theSeq)
        InsertAfter(NCollection_Sequence_Intf_SectionLine self, Standard_Integer const theIndex, Intf_SectionLine theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Intf.NCollection_Sequence_Intf_SectionLine_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Intf_SectionLine self, Standard_Integer const theIndex, NCollection_Sequence_Intf_SectionLine theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _Intf.NCollection_Sequence_Intf_SectionLine_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _Intf.NCollection_Sequence_Intf_SectionLine_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Intf_SectionLine self) -> Intf_SectionLine

        First item access

        :rtype: TheItemType &

        """
        return _Intf.NCollection_Sequence_Intf_SectionLine_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _Intf.NCollection_Sequence_Intf_SectionLine_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Intf_SectionLine self) -> Intf_SectionLine

        Last item access

        :rtype: TheItemType &

        """
        return _Intf.NCollection_Sequence_Intf_SectionLine_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Intf.NCollection_Sequence_Intf_SectionLine_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Intf_SectionLine self, Standard_Integer const theIndex) -> Intf_SectionLine

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Intf.NCollection_Sequence_Intf_SectionLine_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Intf.NCollection_Sequence_Intf_SectionLine___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Intf_SectionLine self, Standard_Integer const theIndex, Intf_SectionLine theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Intf.NCollection_Sequence_Intf_SectionLine_SetValue(self, *args)


    def __iter__(self):
        return _Intf.NCollection_Sequence_Intf_SectionLine___iter__(self)
    __swig_destroy__ = _Intf.delete_NCollection_Sequence_Intf_SectionLine
NCollection_Sequence_Intf_SectionLine_swigregister = _Intf.NCollection_Sequence_Intf_SectionLine_swigregister
NCollection_Sequence_Intf_SectionLine_swigregister(NCollection_Sequence_Intf_SectionLine)

def NCollection_Sequence_Intf_SectionLine_delNode(*args):
    """
    NCollection_Sequence_Intf_SectionLine_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _Intf.NCollection_Sequence_Intf_SectionLine_delNode(*args)

class NCollection_Sequence_Intf_SectionLine_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Intf.new_NCollection_Sequence_Intf_SectionLine_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Intf.delete_NCollection_Sequence_Intf_SectionLine_IteratorHelper

    def __next__(self):
        return _Intf.NCollection_Sequence_Intf_SectionLine_IteratorHelper___next__(self)
NCollection_Sequence_Intf_SectionLine_IteratorHelper_swigregister = _Intf.NCollection_Sequence_Intf_SectionLine_IteratorHelper_swigregister
NCollection_Sequence_Intf_SectionLine_IteratorHelper_swigregister(NCollection_Sequence_Intf_SectionLine_IteratorHelper)


try:
	Intf_SeqOfSectionLine = NCollection_Sequence_Intf_SectionLine
except NameError:
	pass # does not exist, probably ignored

class Intf_Tool(object):
    """
    Provides services to create box for infinites
    lines in a given contexte.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Intf_Tool self) -> Intf_Tool

        Provides services to create box for infinites
        lines in a given contexte.
        """
        this = _Intf.new_Intf_Tool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Lin2dBox(self, *args):
        """
        Lin2dBox(Intf_Tool self, gp_Lin2d theLin2d, Bnd_Box2d bounding, Bnd_Box2d boxLin)

        :type theLin2d: OCC.wrapper.gp.gp_Lin2d
        :type bounding: OCC.wrapper.Bnd.Bnd_Box2d
        :type boxLin: OCC.wrapper.Bnd.Bnd_Box2d

        """
        return _Intf.Intf_Tool_Lin2dBox(self, *args)


    def Hypr2dBox(self, *args):
        """
        Hypr2dBox(Intf_Tool self, gp_Hypr2d theHypr2d, Bnd_Box2d bounding, Bnd_Box2d boxHypr)

        :type theHypr2d: OCC.wrapper.gp.gp_Hypr2d
        :type bounding: OCC.wrapper.Bnd.Bnd_Box2d
        :type boxHypr: OCC.wrapper.Bnd.Bnd_Box2d

        """
        return _Intf.Intf_Tool_Hypr2dBox(self, *args)


    def Parab2dBox(self, *args):
        """
        Parab2dBox(Intf_Tool self, gp_Parab2d theParab2d, Bnd_Box2d bounding, Bnd_Box2d boxHypr)

        :type theParab2d: OCC.wrapper.gp.gp_Parab2d
        :type bounding: OCC.wrapper.Bnd.Bnd_Box2d
        :type boxHypr: OCC.wrapper.Bnd.Bnd_Box2d

        """
        return _Intf.Intf_Tool_Parab2dBox(self, *args)


    def LinBox(self, *args):
        """
        LinBox(Intf_Tool self, gp_Lin theLin, Bnd_Box bounding, Bnd_Box boxLin)

        :type theLin: OCC.wrapper.gp.gp_Lin
        :type bounding: OCC.wrapper.Bnd.Bnd_Box
        :type boxLin: OCC.wrapper.Bnd.Bnd_Box

        """
        return _Intf.Intf_Tool_LinBox(self, *args)


    def HyprBox(self, *args):
        """
        HyprBox(Intf_Tool self, gp_Hypr theHypr, Bnd_Box bounding, Bnd_Box boxHypr)

        :type theHypr: OCC.wrapper.gp.gp_Hypr
        :type bounding: OCC.wrapper.Bnd.Bnd_Box
        :type boxHypr: OCC.wrapper.Bnd.Bnd_Box

        """
        return _Intf.Intf_Tool_HyprBox(self, *args)


    def ParabBox(self, *args):
        """
        ParabBox(Intf_Tool self, gp_Parab theParab, Bnd_Box bounding, Bnd_Box boxHypr)

        :type theParab: OCC.wrapper.gp.gp_Parab
        :type bounding: OCC.wrapper.Bnd.Bnd_Box
        :type boxHypr: OCC.wrapper.Bnd.Bnd_Box

        """
        return _Intf.Intf_Tool_ParabBox(self, *args)


    def NbSegments(self, *args):
        """
        NbSegments(Intf_Tool self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Intf.Intf_Tool_NbSegments(self, *args)


    def BeginParam(self, *args):
        """
        BeginParam(Intf_Tool self, Standard_Integer const SegmentNum) -> Standard_Real

        :type SegmentNum: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Intf.Intf_Tool_BeginParam(self, *args)


    def EndParam(self, *args):
        """
        EndParam(Intf_Tool self, Standard_Integer const SegmentNum) -> Standard_Real

        :type SegmentNum: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Intf.Intf_Tool_EndParam(self, *args)

    __swig_destroy__ = _Intf.delete_Intf_Tool
Intf_Tool_swigregister = _Intf.Intf_Tool_swigregister
Intf_Tool_swigregister(Intf_Tool)

class NCollection_Array1_gp_Lin(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_gp_Lin self) -> NCollection_Array1< gp_Lin >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _Intf.NCollection_Array1_gp_Lin_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_gp_Lin self) -> NCollection_Array1< gp_Lin >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _Intf.NCollection_Array1_gp_Lin_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_gp_Lin self) -> NCollection_Array1< gp_Lin >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _Intf.NCollection_Array1_gp_Lin_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_gp_Lin self) -> NCollection_Array1< gp_Lin >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _Intf.NCollection_Array1_gp_Lin_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _Intf.new_NCollection_Array1_gp_Lin(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_gp_Lin self, gp_Lin theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _Intf.NCollection_Array1_gp_Lin_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_gp_Lin self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Intf.NCollection_Array1_gp_Lin_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_gp_Lin self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Intf.NCollection_Array1_gp_Lin_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_gp_Lin self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intf.NCollection_Array1_gp_Lin_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_gp_Lin self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Intf.NCollection_Array1_gp_Lin_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_gp_Lin self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Intf.NCollection_Array1_gp_Lin_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_gp_Lin self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intf.NCollection_Array1_gp_Lin_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_gp_Lin self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intf.NCollection_Array1_gp_Lin_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_gp_Lin self, NCollection_Array1_gp_Lin theOther) -> NCollection_Array1_gp_Lin

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Intf.NCollection_Array1_gp_Lin_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_gp_Lin self, NCollection_Array1_gp_Lin theOther) -> NCollection_Array1_gp_Lin

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Intf.NCollection_Array1_gp_Lin_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_gp_Lin self, NCollection_Array1_gp_Lin theOther) -> NCollection_Array1_gp_Lin
        assign(NCollection_Array1_gp_Lin self, NCollection_Array1_gp_Lin theOther) -> NCollection_Array1_gp_Lin

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Intf.NCollection_Array1_gp_Lin_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _Intf.NCollection_Array1_gp_Lin_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_gp_Lin self) -> gp_Lin

        @return first element

        :rtype: TheItemType &

        """
        return _Intf.NCollection_Array1_gp_Lin_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _Intf.NCollection_Array1_gp_Lin_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_gp_Lin self) -> gp_Lin

        @return last element

        :rtype: TheItemType &

        """
        return _Intf.NCollection_Array1_gp_Lin_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Intf.NCollection_Array1_gp_Lin_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_gp_Lin self, Standard_Integer const theIndex) -> gp_Lin

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Intf.NCollection_Array1_gp_Lin_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Intf.NCollection_Array1_gp_Lin___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Intf.NCollection_Array1_gp_Lin_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_gp_Lin self, Standard_Integer const theIndex, gp_Lin theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Intf.NCollection_Array1_gp_Lin_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_gp_Lin self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _Intf.NCollection_Array1_gp_Lin_Resize(self, *args)

    __swig_destroy__ = _Intf.delete_NCollection_Array1_gp_Lin
NCollection_Array1_gp_Lin_swigregister = _Intf.NCollection_Array1_gp_Lin_swigregister
NCollection_Array1_gp_Lin_swigregister(NCollection_Array1_gp_Lin)


try:
	Intf_Array1OfLin = NCollection_Array1_gp_Lin
except NameError:
	pass # does not exist, probably ignored

class Intf_InterferencePolygon2d(Intf_Interference):
    """
    Computes the  interference between two  polygons or
    the    self intersection of    a  polygon  in  two
    dimensions.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Intf_InterferencePolygon2d self) -> Intf_InterferencePolygon2d
        __init__(Intf_InterferencePolygon2d self, Intf_Polygon2d Obje1, Intf_Polygon2d Obje2) -> Intf_InterferencePolygon2d
        __init__(Intf_InterferencePolygon2d self, Intf_Polygon2d Obje) -> Intf_InterferencePolygon2d

        Constructs and computes the auto interference of a Polygon.

        :type Obje: OCC.wrapper.Intf.Intf_Polygon2d

        """
        this = _Intf.new_Intf_InterferencePolygon2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(Intf_InterferencePolygon2d self, Intf_Polygon2d Obje1, Intf_Polygon2d Obje2)
        Perform(Intf_InterferencePolygon2d self, Intf_Polygon2d Obje)

        Computes the self interference of a Polygon.

        :type Obje: OCC.wrapper.Intf.Intf_Polygon2d

        """
        return _Intf.Intf_InterferencePolygon2d_Perform(self, *args)


    def Pnt2dValue(self, *args):
        """
        Pnt2dValue(Intf_InterferencePolygon2d self, Standard_Integer const Index) -> gp_Pnt2d

        Gives the  geometrical 2d point   of the  intersection
        point at address <Index> in the interference.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Intf.Intf_InterferencePolygon2d_Pnt2dValue(self, *args)

    __swig_destroy__ = _Intf.delete_Intf_InterferencePolygon2d
Intf_InterferencePolygon2d_swigregister = _Intf.Intf_InterferencePolygon2d_swigregister
Intf_InterferencePolygon2d_swigregister(Intf_InterferencePolygon2d)

class Intf_Polygon2d(object):
    """
    Describes the necessary polygon information to compute
    the interferences.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Bounding(self, *args):
        """
        Returns the bounding box of the polygon.

        :rtype: OCC.wrapper.Bnd.Bnd_Box2d

        """
        res = _Intf.Intf_Polygon2d_Bounding(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Closed(self, *args):
        """
        Closed(Intf_Polygon2d self) -> Standard_Boolean

        Returns True if the polyline is closed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Intf.Intf_Polygon2d_Closed(self, *args)


    def DeflectionOverEstimation(self, *args):
        """
        DeflectionOverEstimation(Intf_Polygon2d self) -> Standard_Real

        Returns the tolerance of the polygon.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Intf.Intf_Polygon2d_DeflectionOverEstimation(self, *args)


    def NbSegments(self, *args):
        """
        NbSegments(Intf_Polygon2d self) -> Standard_Integer

        Returns the number of Segments in the polyline.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Intf.Intf_Polygon2d_NbSegments(self, *args)


    def Segment(self, *args):
        """
        Segment(Intf_Polygon2d self, Standard_Integer const theIndex, gp_Pnt2d theBegin, gp_Pnt2d theEnd)

        Returns the points of the segment <Index> in the Polygon.

        :type theIndex: int
        :type theBegin: OCC.wrapper.gp.gp_Pnt2d
        :type theEnd: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Intf.Intf_Polygon2d_Segment(self, *args)

    __swig_destroy__ = _Intf.delete_Intf_Polygon2d
Intf_Polygon2d_swigregister = _Intf.Intf_Polygon2d_swigregister
Intf_Polygon2d_swigregister(Intf_Polygon2d)




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_CDM')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_CDM')
    _CDM = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_CDM', [dirname(__file__)])
        except ImportError:
            import _CDM
            return _CDM
        try:
            _mod = imp.load_module('_CDM', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _CDM = swig_import_helper()
    del swig_import_helper
else:
    import _CDM
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _CDM.delete_SwigPyIterator

    def value(self):
        return _CDM.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _CDM.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _CDM.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _CDM.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _CDM.SwigPyIterator_equal(self, x)

    def copy(self):
        return _CDM.SwigPyIterator_copy(self)

    def next(self):
        return _CDM.SwigPyIterator_next(self)

    def __next__(self):
        return _CDM.SwigPyIterator___next__(self)

    def previous(self):
        return _CDM.SwigPyIterator_previous(self)

    def advance(self, n):
        return _CDM.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _CDM.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _CDM.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _CDM.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _CDM.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _CDM.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _CDM.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _CDM.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _CDM.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_CDM.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _CDM.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _CDM.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _CDM.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _CDM.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _CDM.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _CDM.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _CDM.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_CDM.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _CDM.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _CDM.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _CDM.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _CDM.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _CDM.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _CDM.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _CDM.ptr_to_number(item)
ptr_to_number = _CDM.ptr_to_number

def HashCode(*args):
    return _CDM.HashCode(*args)
HashCode = _CDM.HashCode

def ptr_equal(a, b):
    return _CDM.ptr_equal(a, b)
ptr_equal = _CDM.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Resource
else:
    import Resource
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
CDM_CCS_OK = _CDM.CDM_CCS_OK
CDM_CCS_NotOpen = _CDM.CDM_CCS_NotOpen
CDM_CCS_UnstoredReferenced = _CDM.CDM_CCS_UnstoredReferenced
CDM_CCS_ModifiedReferenced = _CDM.CDM_CCS_ModifiedReferenced
CDM_CCS_ReferenceRejection = _CDM.CDM_CCS_ReferenceRejection
class CDM_Application(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_CDM_Application
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_CDM_Application(self) 
            return h


    def Resources(self, *args):
        """
        Resources(CDM_Application self) -> Handle_Resource_Manager

        The manager returned by  this virtual  method will be
        used to search for Format.Retrieval  resource items.

        :rtype: OCC.wrapper.Resource.Handle_Resource_Manager

        """
        return _CDM.CDM_Application_Resources(self, *args)


    def MessageDriver(self, *args):
        """
        MessageDriver(CDM_Application self) -> Handle_Message_Messenger

        Returns default messenger;

        :rtype: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _CDM.CDM_Application_MessageDriver(self, *args)


    def BeginOfUpdate(self, *args):
        """
        BeginOfUpdate(CDM_Application self, Handle_CDM_Document aDocument)

        this method is called before the update of a document.
        By default, writes in MessageDriver().

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _CDM.CDM_Application_BeginOfUpdate(self, *args)


    def EndOfUpdate(self, *args):
        """
        EndOfUpdate(CDM_Application self, Handle_CDM_Document aDocument, Standard_Boolean const theStatus, TCollection_ExtendedString ErrorString)

        this method is called affter the update of a document.
        By default, writes in MessageDriver().

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :type theStatus: bool
        :type ErrorString: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.CDM_Application_EndOfUpdate(self, *args)


    def Write(self, *args):
        """
        Write(CDM_Application self, Standard_ExtString const aString)

        writes the string in the application MessagerDriver.

        :type aString: OCC.wrapper.Standard.Standard_ExtString

        """
        return _CDM.CDM_Application_Write(self, *args)


    def Name(self, *args):
        """
        Name(CDM_Application self) -> TCollection_ExtendedString

        Returns the application name.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.CDM_Application_Name(self, *args)


    def Version(self, *args):
        """
        Version(CDM_Application self) -> TCollection_AsciiString

        Returns the application version.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _CDM.CDM_Application_Version(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _CDM.CDM_Application_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _CDM.CDM_Application_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _CDM.CDM_Application_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _CDM.delete_CDM_Application
CDM_Application_swigregister = _CDM.CDM_Application_swigregister
CDM_Application_swigregister(CDM_Application)

def CDM_Application_get_type_name(*args):
    """
    CDM_Application_get_type_name() -> char const *

    :rtype: const char *

    """
    return _CDM.CDM_Application_get_type_name(*args)

def CDM_Application_get_type_descriptor(*args):
    """
    CDM_Application_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _CDM.CDM_Application_get_type_descriptor(*args)

class CDM_ReferenceIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(CDM_ReferenceIterator self, Handle_CDM_Document aDocument) -> CDM_ReferenceIterator

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document

        """
        this = _CDM.new_CDM_ReferenceIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def More(self, *args):
        """
        More(CDM_ReferenceIterator self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.CDM_ReferenceIterator_More(self, *args)


    def Next(self, *args):
        """Next(CDM_ReferenceIterator self)"""
        return _CDM.CDM_ReferenceIterator_Next(self, *args)


    def Document(self, *args):
        """
        Document(CDM_ReferenceIterator self) -> Handle_CDM_Document

        :rtype: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _CDM.CDM_ReferenceIterator_Document(self, *args)


    def ReferenceIdentifier(self, *args):
        """
        ReferenceIdentifier(CDM_ReferenceIterator self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDM.CDM_ReferenceIterator_ReferenceIdentifier(self, *args)


    def DocumentVersion(self, *args):
        """
        DocumentVersion(CDM_ReferenceIterator self) -> Standard_Integer

        returns the Document Version in the reference.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDM.CDM_ReferenceIterator_DocumentVersion(self, *args)

    __swig_destroy__ = _CDM.delete_CDM_ReferenceIterator
CDM_ReferenceIterator_swigregister = _CDM.CDM_ReferenceIterator_swigregister
CDM_ReferenceIterator_swigregister(CDM_ReferenceIterator)

class CDM_Document(Standard.Standard_Transient):
    """
    An applicative document is an instance of a class inheriting CDM_Document.
    These documents have the following properties:
    - they can have references to other documents.
    - the modifications of a document are propagated to the referencing
    documents.
    - a  document can be   stored in different formats, with  or
    without a persistent model.
    - the drivers  for  storing  and retrieving documents  are
    plugged in when necessary.
    - a  document has a modification counter. This counter is
    incremented when the document is  modified.  When a document
    is stored,  the current  counter  value is memorized as the
    last storage  version of the   document.  A document  is
    considered to be  modified   when the  counter value  is
    different from the storage version.  Once  the document is
    saved  the storage  version  and the  counter  value are
    identical.  The document  is  now  not considered  to  be
    modified.
    - a reference is a link between two documents. A reference has two
    components: the "From Document" and the "To Document". When
    a reference is created, an identifier of the reference is generated.
    This identifier is unique in the scope of the From Document and
    is conserved during storage and retrieval. This means that the
    referenced document will be always accessible through this
    identifier.
    - a reference memorizes the counter value of the To Document when
    the reference is created. The From Document is considered to
    be up to date relative to the To Document when the
    reference counter value is equal to the To Document counter value.
    -  retrieval of a document  having references does not imply
    the retrieving of the referenced documents.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_CDM_Document
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_CDM_Document(self) 
            return h


    def StorageFormat(self, *args):
        """
        StorageFormat(CDM_Document self) -> TCollection_ExtendedString

        The Storage Format is the key which is used to determine in the
        application resources the storage driver plugin, the file
        extension and other data used to store the document.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.CDM_Document_StorageFormat(self, *args)


    def Extensions(self, *args):
        """
        Extensions(CDM_Document self, NCollection_Sequence_TCollection_ExtendedString Extensions)

        by default empties the extensions.

        :type Extensions: OCC.wrapper.TColStd.TColStd_SequenceOfExtendedString

        """
        return _CDM.CDM_Document_Extensions(self, *args)


    def GetAlternativeDocument(self, *args):
        """
        GetAlternativeDocument(CDM_Document self, TCollection_ExtendedString aFormat, Handle_CDM_Document anAlternativeDocument) -> Standard_Boolean

        This method can be redefined to extract another document in
        a different format. For example, to extract a Shape
        from an applicative document.

        :type aFormat: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type anAlternativeDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.CDM_Document_GetAlternativeDocument(self, *args)


    def RemoveReference(self, *args):
        """
        RemoveReference(CDM_Document self, Standard_Integer const aReferenceIdentifier)

        Removes the reference between the From Document and the
        To Document identified by a reference identifier.

        :type aReferenceIdentifier: int

        """
        return _CDM.CDM_Document_RemoveReference(self, *args)


    def RemoveAllReferences(self, *args):
        """
        RemoveAllReferences(CDM_Document self)

        Removes all references having this document for From Document.


        """
        return _CDM.CDM_Document_RemoveAllReferences(self, *args)


    def Document(self, *args):
        """
        Document(CDM_Document self, Standard_Integer const aReferenceIdentifier) -> Handle_CDM_Document

        Returns the To Document  of the reference identified by
        aReferenceIdentifier. If the ToDocument is stored and
        has not yet been retrieved, this method will retrieve it.

        :type aReferenceIdentifier: int
        :rtype: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _CDM.CDM_Document_Document(self, *args)


    def IsInSession(self, *args):
        """
        IsInSession(CDM_Document self, Standard_Integer const aReferenceIdentifier) -> Standard_Boolean

        returns True if   the  To Document of the  reference
        identified by aReferenceIdentifier is in session,  False
        if it corresponds to a not yet retrieved document.

        :type aReferenceIdentifier: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.CDM_Document_IsInSession(self, *args)


    def Name(self, *args):
        """
        Name(CDM_Document self, Standard_Integer const aReferenceIdentifier) -> TCollection_ExtendedString

        returns the name of the metadata of the To Document of
        the reference identified by aReferenceIdentifier.

        :type aReferenceIdentifier: int
        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.CDM_Document_Name(self, *args)


    def UpdateFromDocuments(self, *args):
        """
        UpdateFromDocuments(CDM_Document self, Standard_Address const aModifContext)

        call  virtual  method   Update  on  all   referencing
        documents.   This method keeps  the list  of the --
        documents  to process.It may  be the starting of an
        update -- cycle. If  not,  the reentrant calls made by
        Update  method (without argument)  will append the
        referencing documents to the list and call the Update method
        (with arguments). Only the first call to UpdateFromDocuments
        generate call to Update().

        :type aModifContext: OCC.wrapper.Standard.Standard_Address

        """
        return _CDM.CDM_Document_UpdateFromDocuments(self, *args)


    def ToReferencesNumber(self, *args):
        """
        ToReferencesNumber(CDM_Document self) -> Standard_Integer

        returns the number of references having this document as
        From Document.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDM.CDM_Document_ToReferencesNumber(self, *args)


    def FromReferencesNumber(self, *args):
        """
        FromReferencesNumber(CDM_Document self) -> Standard_Integer

        returns the number of references having this document as
        To Document.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDM.CDM_Document_FromReferencesNumber(self, *args)


    def ShallowReferences(self, *args):
        """
        ShallowReferences(CDM_Document self, Handle_CDM_Document aDocument) -> Standard_Boolean

        returns True is this document references aDocument;

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.CDM_Document_ShallowReferences(self, *args)


    def DeepReferences(self, *args):
        """
        DeepReferences(CDM_Document self, Handle_CDM_Document aDocument) -> Standard_Boolean

        returns True is this document references aDocument;

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.CDM_Document_DeepReferences(self, *args)


    def CopyReference(self, *args):
        """
        CopyReference(CDM_Document self, Handle_CDM_Document aFromDocument, Standard_Integer const aReferenceIdentifier) -> Standard_Integer

        Copies a  reference  to  this document.   This  method
        avoid retrieval of referenced document.  The arguments
        are  the  original  document  and a  valid  reference
        identifier Returns the  local identifier.

        :type aFromDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :type aReferenceIdentifier: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDM.CDM_Document_CopyReference(self, *args)


    def IsReadOnly(self, *args):
        """
        IsReadOnly(CDM_Document self) -> Standard_Boolean
        IsReadOnly(CDM_Document self, Standard_Integer const aReferenceIdentifier) -> Standard_Boolean

        indicates that the referenced document cannot be modified,

        :type aReferenceIdentifier: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.CDM_Document_IsReadOnly(self, *args)


    def SetIsReadOnly(self, *args):
        """SetIsReadOnly(CDM_Document self)"""
        return _CDM.CDM_Document_SetIsReadOnly(self, *args)


    def UnsetIsReadOnly(self, *args):
        """UnsetIsReadOnly(CDM_Document self)"""
        return _CDM.CDM_Document_UnsetIsReadOnly(self, *args)


    def Modify(self, *args):
        """
        Modify(CDM_Document self)

        Indicates that this document has been modified.
        This method increments the modification counter.


        """
        return _CDM.CDM_Document_Modify(self, *args)


    def Modifications(self, *args):
        """
        Modifications(CDM_Document self) -> Standard_Integer

        returns the current modification counter.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDM.CDM_Document_Modifications(self, *args)


    def UnModify(self, *args):
        """UnModify(CDM_Document self)"""
        return _CDM.CDM_Document_UnModify(self, *args)


    def IsUpToDate(self, *args):
        """
        IsUpToDate(CDM_Document self, Standard_Integer const aReferenceIdentifier) -> Standard_Boolean

        returns true if the modification counter found in the given
        reference is equal to the actual modification counter of
        the To Document. This method is able to deal with a reference
        to a not retrieved document.

        :type aReferenceIdentifier: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.CDM_Document_IsUpToDate(self, *args)


    def SetIsUpToDate(self, *args):
        """
        SetIsUpToDate(CDM_Document self, Standard_Integer const aReferenceIdentifier)

        Resets the modification counter in the given reference
        to the actual modification counter of its To Document.
        This method should be called after the application has updated
        this document.

        :type aReferenceIdentifier: int

        """
        return _CDM.CDM_Document_SetIsUpToDate(self, *args)


    def SetComment(self, *args):
        """
        SetComment(CDM_Document self, TCollection_ExtendedString aComment)

        associates a comment with this document.

        :type aComment: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.CDM_Document_SetComment(self, *args)


    def AddComment(self, *args):
        """
        AddComment(CDM_Document self, TCollection_ExtendedString aComment)

        appends a comment into comments of this document.

        :type aComment: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.CDM_Document_AddComment(self, *args)


    def SetComments(self, *args):
        """
        SetComments(CDM_Document self, NCollection_Sequence_TCollection_ExtendedString aComments)

        associates a comments with this document.

        :type aComments: OCC.wrapper.TColStd.TColStd_SequenceOfExtendedString

        """
        return _CDM.CDM_Document_SetComments(self, *args)


    def Comments(self, *args):
        """
        Comments(CDM_Document self, NCollection_Sequence_TCollection_ExtendedString aComments)

        returns the associated comments through <aComments>.
        Returns empty sequence if no comments are associated.

        :type aComments: OCC.wrapper.TColStd.TColStd_SequenceOfExtendedString

        """
        return _CDM.CDM_Document_Comments(self, *args)


    def Comment(self, *args):
        """
        Comment(CDM_Document self) -> Standard_ExtString

        returns the first of associated comments. By defaut
        the comment is an empty string.

        :rtype: OCC.wrapper.Standard.Standard_ExtString

        """
        return _CDM.CDM_Document_Comment(self, *args)


    def Presentation(self, *args):
        """
        Presentation(CDM_Document self) -> Standard_ExtString

        Returns an alphanumeric string identifying this document
        in a unique manner in the current process. The presentation
        may change when the document is stored.
        Tries to get the 'FileFormat`.Presentation resource
        This item is used to give a default presentation
        to the document.

        :rtype: OCC.wrapper.Standard.Standard_ExtString

        """
        return _CDM.CDM_Document_Presentation(self, *args)


    def FindFromPresentation(*args):
        """
        FindFromPresentation(TCollection_ExtendedString aPresentation) -> Handle_CDM_Document

        returns the document having the given alphanumeric presentation.

        :type aPresentation: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _CDM.CDM_Document_FindFromPresentation(*args)

    FindFromPresentation = staticmethod(FindFromPresentation)

    def FindPresentation(*args):
        """
        FindPresentation(TCollection_ExtendedString aPresentation) -> Standard_Boolean

        indicates whether a document having the given presentation
        does exist.

        :type aPresentation: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.CDM_Document_FindPresentation(*args)

    FindPresentation = staticmethod(FindPresentation)

    def IsStored(self, *args):
        """
        IsStored(CDM_Document self, Standard_Integer const aReferenceIdentifier) -> Standard_Boolean
        IsStored(CDM_Document self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.CDM_Document_IsStored(self, *args)


    def StorageVersion(self, *args):
        """
        StorageVersion(CDM_Document self) -> Standard_Integer

        returns  the value of  the modification counter at the
        time of storage. By default returns 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDM.CDM_Document_StorageVersion(self, *args)


    def SetMetaData(self, *args):
        """
        SetMetaData(CDM_Document self, Handle_CDM_MetaData aMetaData)

        associates database  information to  a document which
        has been stored.  The name of the  document is now the
        name which has beenused to store the data.

        :type aMetaData: OCC.wrapper.CDM.Handle_CDM_MetaData

        """
        return _CDM.CDM_Document_SetMetaData(self, *args)


    def UnsetIsStored(self, *args):
        """UnsetIsStored(CDM_Document self)"""
        return _CDM.CDM_Document_UnsetIsStored(self, *args)


    def MetaData(self, *args):
        """
        MetaData(CDM_Document self) -> Handle_CDM_MetaData

        :rtype: OCC.wrapper.CDM.Handle_CDM_MetaData

        """
        return _CDM.CDM_Document_MetaData(self, *args)


    def Folder(self, *args):
        """
        Folder(CDM_Document self) -> TCollection_ExtendedString

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.CDM_Document_Folder(self, *args)


    def SetRequestedFolder(self, *args):
        """
        SetRequestedFolder(CDM_Document self, TCollection_ExtendedString aFolder)

        defines the folder in which the object should be stored.

        :type aFolder: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.CDM_Document_SetRequestedFolder(self, *args)


    def RequestedFolder(self, *args):
        """
        RequestedFolder(CDM_Document self) -> TCollection_ExtendedString

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.CDM_Document_RequestedFolder(self, *args)


    def HasRequestedFolder(self, *args):
        """
        HasRequestedFolder(CDM_Document self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.CDM_Document_HasRequestedFolder(self, *args)


    def SetRequestedName(self, *args):
        """
        SetRequestedName(CDM_Document self, TCollection_ExtendedString aName)

        defines the name under which the object should be stored.

        :type aName: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.CDM_Document_SetRequestedName(self, *args)


    def RequestedName(self, *args):
        """
        RequestedName(CDM_Document self) -> TCollection_ExtendedString

        determines  under  which the document  is  going to be
        store.  By default the name of the document wil be --
        used.  If the document has  no name  its presentation
        will be used.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.CDM_Document_RequestedName(self, *args)


    def SetRequestedPreviousVersion(self, *args):
        """
        SetRequestedPreviousVersion(CDM_Document self, TCollection_ExtendedString aPreviousVersion)

        :type aPreviousVersion: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.CDM_Document_SetRequestedPreviousVersion(self, *args)


    def UnsetRequestedPreviousVersion(self, *args):
        """UnsetRequestedPreviousVersion(CDM_Document self)"""
        return _CDM.CDM_Document_UnsetRequestedPreviousVersion(self, *args)


    def HasRequestedPreviousVersion(self, *args):
        """
        HasRequestedPreviousVersion(CDM_Document self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.CDM_Document_HasRequestedPreviousVersion(self, *args)


    def RequestedPreviousVersion(self, *args):
        """
        RequestedPreviousVersion(CDM_Document self) -> TCollection_ExtendedString

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.CDM_Document_RequestedPreviousVersion(self, *args)


    def SetRequestedComment(self, *args):
        """
        SetRequestedComment(CDM_Document self, TCollection_ExtendedString aComment)

        defines the Comment with  which the object should be stored.

        :type aComment: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.CDM_Document_SetRequestedComment(self, *args)


    def RequestedComment(self, *args):
        """
        RequestedComment(CDM_Document self) -> TCollection_ExtendedString

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.CDM_Document_RequestedComment(self, *args)


    def LoadResources(self, *args):
        """
        LoadResources(CDM_Document self)

        read (or rereads) the following resource.


        """
        return _CDM.CDM_Document_LoadResources(self, *args)


    def FindFileExtension(self, *args):
        """
        FindFileExtension(CDM_Document self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.CDM_Document_FindFileExtension(self, *args)


    def FileExtension(self, *args):
        """
        FileExtension(CDM_Document self) -> TCollection_ExtendedString

        gets the Desktop.Domain.Application.`FileFormat`.FileExtension resource.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.CDM_Document_FileExtension(self, *args)


    def FindDescription(self, *args):
        """
        FindDescription(CDM_Document self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.CDM_Document_FindDescription(self, *args)


    def Description(self, *args):
        """
        Description(CDM_Document self) -> TCollection_ExtendedString

        gets the `FileFormat`.Description resource.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.CDM_Document_Description(self, *args)


    def IsModified(self, *args):
        """
        IsModified(CDM_Document self) -> Standard_Boolean

        returns  true  if the   version is greater  than   the
        storage version

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.CDM_Document_IsModified(self, *args)


    def Print(self, *args):
        """
        Print(CDM_Document self, Standard_OStream & anOStream) -> Standard_OStream &

        :type anOStream: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _CDM.CDM_Document_Print(self, *args)


    def Open(self, *args):
        """
        Open(CDM_Document self, Handle_CDM_Application anApplication)

        :type anApplication: OCC.wrapper.CDM.Handle_CDM_Application

        """
        return _CDM.CDM_Document_Open(self, *args)


    def CanClose(self, *args):
        """
        CanClose(CDM_Document self) -> CDM_CanCloseStatus

        :rtype: OCC.wrapper.CDM.CDM_CanCloseStatus

        """
        return _CDM.CDM_Document_CanClose(self, *args)


    def Close(self, *args):
        """Close(CDM_Document self)"""
        return _CDM.CDM_Document_Close(self, *args)


    def Application(self, *args):
        """
        :rtype: OCC.wrapper.CDM.Handle_CDM_Application

        """
        res = _CDM.CDM_Document_Application(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CanCloseReference(self, *args):
        """
        CanCloseReference(CDM_Document self, Handle_CDM_Document aDocument, Standard_Integer const aReferenceIdentifier) -> Standard_Boolean

        A  referenced  document  may  indicate   through  this
        virtual  method that it does  not allow the closing of
        aDocument  which  it references through  the reference
        aReferenceIdentifier. By default returns Standard_True;;

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :type aReferenceIdentifier: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.CDM_Document_CanCloseReference(self, *args)


    def CloseReference(self, *args):
        """
        CloseReference(CDM_Document self, Handle_CDM_Document aDocument, Standard_Integer const aReferenceIdentifier)

        A referenced document may update its internal
        data structure when {aDocument} which it references
        through the reference {aReferenceIdentifier} is being closed.
        By default this method does nothing.

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :type aReferenceIdentifier: int

        """
        return _CDM.CDM_Document_CloseReference(self, *args)


    def IsOpened(self, *args):
        """
        IsOpened(CDM_Document self) -> Standard_Boolean
        IsOpened(CDM_Document self, Standard_Integer const aReferenceIdentifier) -> Standard_Boolean

        returns true if  the   document corresponding to  the
        given   reference has    been retrieved  and  opened.
        Otherwise returns false. This method does not retrieve
        the referenced document

        :type aReferenceIdentifier: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.CDM_Document_IsOpened(self, *args)


    def CreateReference(self, *args):
        """
        CreateReference(CDM_Document self, Handle_CDM_Document anOtherDocument) -> Standard_Integer
        CreateReference(CDM_Document self, Handle_CDM_MetaData aMetaData, Standard_Integer const aReferenceIdentifier, Handle_CDM_Application anApplication, Standard_Integer const aToDocumentVersion, Standard_Boolean const UseStorageConfiguration)
        CreateReference(CDM_Document self, Handle_CDM_MetaData aMetaData, Handle_CDM_Application anApplication, Standard_Integer const aDocumentVersion, Standard_Boolean const UseStorageConfiguration) -> Standard_Integer

        :type aMetaData: OCC.wrapper.CDM.Handle_CDM_MetaData
        :type anApplication: OCC.wrapper.CDM.Handle_CDM_Application
        :type aDocumentVersion: int
        :type UseStorageConfiguration: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDM.CDM_Document_CreateReference(self, *args)


    def ReferenceCounter(self, *args):
        """
        ReferenceCounter(CDM_Document self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDM.CDM_Document_ReferenceCounter(self, *args)


    def Update(self, *args):
        """
        Update(CDM_Document self, Handle_CDM_Document aToDocument, Standard_Integer const aReferenceIdentifier, Standard_Address const aModifContext)
        Update(CDM_Document self, TCollection_ExtendedString ErrorString) -> Standard_Boolean
        Update(CDM_Document self)

        the following method should be used instead:

        Update(me:mutable; ErrorString: out ExtendedString from TCollection)
        returns Boolean from Standard


        """
        return _CDM.CDM_Document_Update(self, *args)


    def Reference(self, *args):
        """
        Reference(CDM_Document self, Standard_Integer const aReferenceIdentifier) -> Handle_CDM_Reference

        :type aReferenceIdentifier: int
        :rtype: OCC.wrapper.CDM.Handle_CDM_Reference

        """
        return _CDM.CDM_Document_Reference(self, *args)


    def SetModifications(self, *args):
        """
        SetModifications(CDM_Document self, Standard_Integer const Modifications)

        :type Modifications: int

        """
        return _CDM.CDM_Document_SetModifications(self, *args)


    def SetReferenceCounter(self, *args):
        """
        SetReferenceCounter(CDM_Document self, Standard_Integer const aReferenceCounter)

        :type aReferenceCounter: int

        """
        return _CDM.CDM_Document_SetReferenceCounter(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _CDM.CDM_Document_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _CDM.CDM_Document_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _CDM.CDM_Document_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


CDM_Document_swigregister = _CDM.CDM_Document_swigregister
CDM_Document_swigregister(CDM_Document)

def CDM_Document_FindFromPresentation(*args):
    """
    CDM_Document_FindFromPresentation(TCollection_ExtendedString aPresentation) -> Handle_CDM_Document

    returns the document having the given alphanumeric presentation.

    :type aPresentation: OCC.wrapper.TCollection.TCollection_ExtendedString
    :rtype: OCC.wrapper.CDM.Handle_CDM_Document

    """
    return _CDM.CDM_Document_FindFromPresentation(*args)

def CDM_Document_FindPresentation(*args):
    """
    CDM_Document_FindPresentation(TCollection_ExtendedString aPresentation) -> Standard_Boolean

    indicates whether a document having the given presentation
    does exist.

    :type aPresentation: OCC.wrapper.TCollection.TCollection_ExtendedString
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _CDM.CDM_Document_FindPresentation(*args)

def CDM_Document_get_type_name(*args):
    """
    CDM_Document_get_type_name() -> char const *

    :rtype: const char *

    """
    return _CDM.CDM_Document_get_type_name(*args)

def CDM_Document_get_type_descriptor(*args):
    """
    CDM_Document_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _CDM.CDM_Document_get_type_descriptor(*args)

class Handle_CDM_Document(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_CDM_Document self)

        Nullify the handle


        """
        return _CDM.Handle_CDM_Document_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_CDM_Document self) -> bool

        Check for being null

        :rtype: bool

        """
        return _CDM.Handle_CDM_Document_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_CDM_Document self, CDM_Document thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _CDM.Handle_CDM_Document_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_CDM_Document self, Handle_CDM_Document theHandle) -> Handle_CDM_Document
        assign(Handle_CDM_Document self, CDM_Document thePtr) -> Handle_CDM_Document
        assign(Handle_CDM_Document self, Handle_CDM_Document theHandle) -> Handle_CDM_Document

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _CDM.Handle_CDM_Document_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_CDM_Document self) -> CDM_Document

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _CDM.Handle_CDM_Document_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_CDM_Document self) -> CDM_Document

        Member access operator (note non-const)

        :rtype: T *

        """
        return _CDM.Handle_CDM_Document___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_CDM_Document self) -> CDM_Document

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _CDM.Handle_CDM_Document___ref__(self, *args)


    def __hash__(self):
        return _CDM.Handle_CDM_Document___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _CDM.Handle_CDM_Document___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _CDM.new_Handle_CDM_Document(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_CDM.Handle_CDM_Document_DownCast)
    __swig_destroy__ = _CDM.delete_Handle_CDM_Document

    def Update(self, *args):
        """
        Update(Handle_CDM_Document self, Handle_CDM_Document aToDocument, Standard_Integer const aReferenceIdentifier, Standard_Address const aModifContext)
        Update(Handle_CDM_Document self, TCollection_ExtendedString ErrorString) -> Standard_Boolean
        Update(Handle_CDM_Document self)

        the following method should be used instead:

        Update(me:mutable; ErrorString: out ExtendedString from TCollection)
        returns Boolean from Standard


        """
        return _CDM.Handle_CDM_Document_Update(self, *args)


    def StorageFormat(self, *args):
        """
        StorageFormat(Handle_CDM_Document self) -> TCollection_ExtendedString

        The Storage Format is the key which is used to determine in the
        application resources the storage driver plugin, the file
        extension and other data used to store the document.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.Handle_CDM_Document_StorageFormat(self, *args)


    def Extensions(self, *args):
        """
        Extensions(Handle_CDM_Document self, NCollection_Sequence_TCollection_ExtendedString Extensions)

        by default empties the extensions.

        :type Extensions: OCC.wrapper.TColStd.TColStd_SequenceOfExtendedString

        """
        return _CDM.Handle_CDM_Document_Extensions(self, *args)


    def GetAlternativeDocument(self, *args):
        """
        GetAlternativeDocument(Handle_CDM_Document self, TCollection_ExtendedString aFormat, Handle_CDM_Document anAlternativeDocument) -> Standard_Boolean

        This method can be redefined to extract another document in
        a different format. For example, to extract a Shape
        from an applicative document.

        :type aFormat: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type anAlternativeDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.Handle_CDM_Document_GetAlternativeDocument(self, *args)


    def CreateReference(self, *args):
        """
        CreateReference(Handle_CDM_Document self, Handle_CDM_Document anOtherDocument) -> Standard_Integer
        CreateReference(Handle_CDM_Document self, Handle_CDM_MetaData aMetaData, Standard_Integer const aReferenceIdentifier, Handle_CDM_Application anApplication, Standard_Integer const aToDocumentVersion, Standard_Boolean const UseStorageConfiguration)
        CreateReference(Handle_CDM_Document self, Handle_CDM_MetaData aMetaData, Handle_CDM_Application anApplication, Standard_Integer const aDocumentVersion, Standard_Boolean const UseStorageConfiguration) -> Standard_Integer

        :type aMetaData: OCC.wrapper.CDM.Handle_CDM_MetaData
        :type anApplication: OCC.wrapper.CDM.Handle_CDM_Application
        :type aDocumentVersion: int
        :type UseStorageConfiguration: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDM.Handle_CDM_Document_CreateReference(self, *args)


    def RemoveReference(self, *args):
        """
        RemoveReference(Handle_CDM_Document self, Standard_Integer const aReferenceIdentifier)

        Removes the reference between the From Document and the
        To Document identified by a reference identifier.

        :type aReferenceIdentifier: int

        """
        return _CDM.Handle_CDM_Document_RemoveReference(self, *args)


    def RemoveAllReferences(self, *args):
        """
        RemoveAllReferences(Handle_CDM_Document self)

        Removes all references having this document for From Document.


        """
        return _CDM.Handle_CDM_Document_RemoveAllReferences(self, *args)


    def Document(self, *args):
        """
        Document(Handle_CDM_Document self, Standard_Integer const aReferenceIdentifier) -> Handle_CDM_Document

        Returns the To Document  of the reference identified by
        aReferenceIdentifier. If the ToDocument is stored and
        has not yet been retrieved, this method will retrieve it.

        :type aReferenceIdentifier: int
        :rtype: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _CDM.Handle_CDM_Document_Document(self, *args)


    def IsInSession(self, *args):
        """
        IsInSession(Handle_CDM_Document self, Standard_Integer const aReferenceIdentifier) -> Standard_Boolean

        returns True if   the  To Document of the  reference
        identified by aReferenceIdentifier is in session,  False
        if it corresponds to a not yet retrieved document.

        :type aReferenceIdentifier: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.Handle_CDM_Document_IsInSession(self, *args)


    def IsStored(self, *args):
        """
        IsStored(Handle_CDM_Document self, Standard_Integer const aReferenceIdentifier) -> Standard_Boolean
        IsStored(Handle_CDM_Document self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.Handle_CDM_Document_IsStored(self, *args)


    def Name(self, *args):
        """
        Name(Handle_CDM_Document self, Standard_Integer const aReferenceIdentifier) -> TCollection_ExtendedString

        returns the name of the metadata of the To Document of
        the reference identified by aReferenceIdentifier.

        :type aReferenceIdentifier: int
        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.Handle_CDM_Document_Name(self, *args)


    def UpdateFromDocuments(self, *args):
        """
        UpdateFromDocuments(Handle_CDM_Document self, Standard_Address const aModifContext)

        call  virtual  method   Update  on  all   referencing
        documents.   This method keeps  the list  of the --
        documents  to process.It may  be the starting of an
        update -- cycle. If  not,  the reentrant calls made by
        Update  method (without argument)  will append the
        referencing documents to the list and call the Update method
        (with arguments). Only the first call to UpdateFromDocuments
        generate call to Update().

        :type aModifContext: OCC.wrapper.Standard.Standard_Address

        """
        return _CDM.Handle_CDM_Document_UpdateFromDocuments(self, *args)


    def ToReferencesNumber(self, *args):
        """
        ToReferencesNumber(Handle_CDM_Document self) -> Standard_Integer

        returns the number of references having this document as
        From Document.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDM.Handle_CDM_Document_ToReferencesNumber(self, *args)


    def FromReferencesNumber(self, *args):
        """
        FromReferencesNumber(Handle_CDM_Document self) -> Standard_Integer

        returns the number of references having this document as
        To Document.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDM.Handle_CDM_Document_FromReferencesNumber(self, *args)


    def ShallowReferences(self, *args):
        """
        ShallowReferences(Handle_CDM_Document self, Handle_CDM_Document aDocument) -> Standard_Boolean

        returns True is this document references aDocument;

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.Handle_CDM_Document_ShallowReferences(self, *args)


    def DeepReferences(self, *args):
        """
        DeepReferences(Handle_CDM_Document self, Handle_CDM_Document aDocument) -> Standard_Boolean

        returns True is this document references aDocument;

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.Handle_CDM_Document_DeepReferences(self, *args)


    def CopyReference(self, *args):
        """
        CopyReference(Handle_CDM_Document self, Handle_CDM_Document aFromDocument, Standard_Integer const aReferenceIdentifier) -> Standard_Integer

        Copies a  reference  to  this document.   This  method
        avoid retrieval of referenced document.  The arguments
        are  the  original  document  and a  valid  reference
        identifier Returns the  local identifier.

        :type aFromDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :type aReferenceIdentifier: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDM.Handle_CDM_Document_CopyReference(self, *args)


    def IsReadOnly(self, *args):
        """
        IsReadOnly(Handle_CDM_Document self) -> Standard_Boolean
        IsReadOnly(Handle_CDM_Document self, Standard_Integer const aReferenceIdentifier) -> Standard_Boolean

        indicates that the referenced document cannot be modified,

        :type aReferenceIdentifier: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.Handle_CDM_Document_IsReadOnly(self, *args)


    def SetIsReadOnly(self, *args):
        """SetIsReadOnly(Handle_CDM_Document self)"""
        return _CDM.Handle_CDM_Document_SetIsReadOnly(self, *args)


    def UnsetIsReadOnly(self, *args):
        """UnsetIsReadOnly(Handle_CDM_Document self)"""
        return _CDM.Handle_CDM_Document_UnsetIsReadOnly(self, *args)


    def Modify(self, *args):
        """
        Modify(Handle_CDM_Document self)

        Indicates that this document has been modified.
        This method increments the modification counter.


        """
        return _CDM.Handle_CDM_Document_Modify(self, *args)


    def Modifications(self, *args):
        """
        Modifications(Handle_CDM_Document self) -> Standard_Integer

        returns the current modification counter.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDM.Handle_CDM_Document_Modifications(self, *args)


    def UnModify(self, *args):
        """UnModify(Handle_CDM_Document self)"""
        return _CDM.Handle_CDM_Document_UnModify(self, *args)


    def IsUpToDate(self, *args):
        """
        IsUpToDate(Handle_CDM_Document self, Standard_Integer const aReferenceIdentifier) -> Standard_Boolean

        returns true if the modification counter found in the given
        reference is equal to the actual modification counter of
        the To Document. This method is able to deal with a reference
        to a not retrieved document.

        :type aReferenceIdentifier: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.Handle_CDM_Document_IsUpToDate(self, *args)


    def SetIsUpToDate(self, *args):
        """
        SetIsUpToDate(Handle_CDM_Document self, Standard_Integer const aReferenceIdentifier)

        Resets the modification counter in the given reference
        to the actual modification counter of its To Document.
        This method should be called after the application has updated
        this document.

        :type aReferenceIdentifier: int

        """
        return _CDM.Handle_CDM_Document_SetIsUpToDate(self, *args)


    def SetComment(self, *args):
        """
        SetComment(Handle_CDM_Document self, TCollection_ExtendedString aComment)

        associates a comment with this document.

        :type aComment: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.Handle_CDM_Document_SetComment(self, *args)


    def AddComment(self, *args):
        """
        AddComment(Handle_CDM_Document self, TCollection_ExtendedString aComment)

        appends a comment into comments of this document.

        :type aComment: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.Handle_CDM_Document_AddComment(self, *args)


    def SetComments(self, *args):
        """
        SetComments(Handle_CDM_Document self, NCollection_Sequence_TCollection_ExtendedString aComments)

        associates a comments with this document.

        :type aComments: OCC.wrapper.TColStd.TColStd_SequenceOfExtendedString

        """
        return _CDM.Handle_CDM_Document_SetComments(self, *args)


    def Comments(self, *args):
        """
        Comments(Handle_CDM_Document self, NCollection_Sequence_TCollection_ExtendedString aComments)

        returns the associated comments through <aComments>.
        Returns empty sequence if no comments are associated.

        :type aComments: OCC.wrapper.TColStd.TColStd_SequenceOfExtendedString

        """
        return _CDM.Handle_CDM_Document_Comments(self, *args)


    def Comment(self, *args):
        """
        Comment(Handle_CDM_Document self) -> Standard_ExtString

        returns the first of associated comments. By defaut
        the comment is an empty string.

        :rtype: OCC.wrapper.Standard.Standard_ExtString

        """
        return _CDM.Handle_CDM_Document_Comment(self, *args)


    def Presentation(self, *args):
        """
        Presentation(Handle_CDM_Document self) -> Standard_ExtString

        Returns an alphanumeric string identifying this document
        in a unique manner in the current process. The presentation
        may change when the document is stored.
        Tries to get the 'FileFormat`.Presentation resource
        This item is used to give a default presentation
        to the document.

        :rtype: OCC.wrapper.Standard.Standard_ExtString

        """
        return _CDM.Handle_CDM_Document_Presentation(self, *args)


    def FindFromPresentation(self, *args):
        """
        FindFromPresentation(Handle_CDM_Document self, TCollection_ExtendedString aPresentation) -> Handle_CDM_Document

        returns the document having the given alphanumeric presentation.

        :type aPresentation: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _CDM.Handle_CDM_Document_FindFromPresentation(self, *args)


    def FindPresentation(self, *args):
        """
        FindPresentation(Handle_CDM_Document self, TCollection_ExtendedString aPresentation) -> Standard_Boolean

        indicates whether a document having the given presentation
        does exist.

        :type aPresentation: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.Handle_CDM_Document_FindPresentation(self, *args)


    def StorageVersion(self, *args):
        """
        StorageVersion(Handle_CDM_Document self) -> Standard_Integer

        returns  the value of  the modification counter at the
        time of storage. By default returns 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDM.Handle_CDM_Document_StorageVersion(self, *args)


    def SetMetaData(self, *args):
        """
        SetMetaData(Handle_CDM_Document self, Handle_CDM_MetaData aMetaData)

        associates database  information to  a document which
        has been stored.  The name of the  document is now the
        name which has beenused to store the data.

        :type aMetaData: OCC.wrapper.CDM.Handle_CDM_MetaData

        """
        return _CDM.Handle_CDM_Document_SetMetaData(self, *args)


    def UnsetIsStored(self, *args):
        """UnsetIsStored(Handle_CDM_Document self)"""
        return _CDM.Handle_CDM_Document_UnsetIsStored(self, *args)


    def MetaData(self, *args):
        """
        MetaData(Handle_CDM_Document self) -> Handle_CDM_MetaData

        :rtype: OCC.wrapper.CDM.Handle_CDM_MetaData

        """
        return _CDM.Handle_CDM_Document_MetaData(self, *args)


    def Folder(self, *args):
        """
        Folder(Handle_CDM_Document self) -> TCollection_ExtendedString

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.Handle_CDM_Document_Folder(self, *args)


    def SetRequestedFolder(self, *args):
        """
        SetRequestedFolder(Handle_CDM_Document self, TCollection_ExtendedString aFolder)

        defines the folder in which the object should be stored.

        :type aFolder: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.Handle_CDM_Document_SetRequestedFolder(self, *args)


    def RequestedFolder(self, *args):
        """
        RequestedFolder(Handle_CDM_Document self) -> TCollection_ExtendedString

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.Handle_CDM_Document_RequestedFolder(self, *args)


    def HasRequestedFolder(self, *args):
        """
        HasRequestedFolder(Handle_CDM_Document self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.Handle_CDM_Document_HasRequestedFolder(self, *args)


    def SetRequestedName(self, *args):
        """
        SetRequestedName(Handle_CDM_Document self, TCollection_ExtendedString aName)

        defines the name under which the object should be stored.

        :type aName: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.Handle_CDM_Document_SetRequestedName(self, *args)


    def RequestedName(self, *args):
        """
        RequestedName(Handle_CDM_Document self) -> TCollection_ExtendedString

        determines  under  which the document  is  going to be
        store.  By default the name of the document wil be --
        used.  If the document has  no name  its presentation
        will be used.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.Handle_CDM_Document_RequestedName(self, *args)


    def SetRequestedPreviousVersion(self, *args):
        """
        SetRequestedPreviousVersion(Handle_CDM_Document self, TCollection_ExtendedString aPreviousVersion)

        :type aPreviousVersion: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.Handle_CDM_Document_SetRequestedPreviousVersion(self, *args)


    def UnsetRequestedPreviousVersion(self, *args):
        """UnsetRequestedPreviousVersion(Handle_CDM_Document self)"""
        return _CDM.Handle_CDM_Document_UnsetRequestedPreviousVersion(self, *args)


    def HasRequestedPreviousVersion(self, *args):
        """
        HasRequestedPreviousVersion(Handle_CDM_Document self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.Handle_CDM_Document_HasRequestedPreviousVersion(self, *args)


    def RequestedPreviousVersion(self, *args):
        """
        RequestedPreviousVersion(Handle_CDM_Document self) -> TCollection_ExtendedString

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.Handle_CDM_Document_RequestedPreviousVersion(self, *args)


    def SetRequestedComment(self, *args):
        """
        SetRequestedComment(Handle_CDM_Document self, TCollection_ExtendedString aComment)

        defines the Comment with  which the object should be stored.

        :type aComment: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.Handle_CDM_Document_SetRequestedComment(self, *args)


    def RequestedComment(self, *args):
        """
        RequestedComment(Handle_CDM_Document self) -> TCollection_ExtendedString

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.Handle_CDM_Document_RequestedComment(self, *args)


    def LoadResources(self, *args):
        """
        LoadResources(Handle_CDM_Document self)

        read (or rereads) the following resource.


        """
        return _CDM.Handle_CDM_Document_LoadResources(self, *args)


    def FindFileExtension(self, *args):
        """
        FindFileExtension(Handle_CDM_Document self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.Handle_CDM_Document_FindFileExtension(self, *args)


    def FileExtension(self, *args):
        """
        FileExtension(Handle_CDM_Document self) -> TCollection_ExtendedString

        gets the Desktop.Domain.Application.`FileFormat`.FileExtension resource.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.Handle_CDM_Document_FileExtension(self, *args)


    def FindDescription(self, *args):
        """
        FindDescription(Handle_CDM_Document self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.Handle_CDM_Document_FindDescription(self, *args)


    def Description(self, *args):
        """
        Description(Handle_CDM_Document self) -> TCollection_ExtendedString

        gets the `FileFormat`.Description resource.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.Handle_CDM_Document_Description(self, *args)


    def IsModified(self, *args):
        """
        IsModified(Handle_CDM_Document self) -> Standard_Boolean

        returns  true  if the   version is greater  than   the
        storage version

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.Handle_CDM_Document_IsModified(self, *args)


    def Print(self, *args):
        """
        Print(Handle_CDM_Document self, Standard_OStream & anOStream) -> Standard_OStream &

        :type anOStream: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _CDM.Handle_CDM_Document_Print(self, *args)


    def IsOpened(self, *args):
        """
        IsOpened(Handle_CDM_Document self) -> Standard_Boolean
        IsOpened(Handle_CDM_Document self, Standard_Integer const aReferenceIdentifier) -> Standard_Boolean

        returns true if  the   document corresponding to  the
        given   reference has    been retrieved  and  opened.
        Otherwise returns false. This method does not retrieve
        the referenced document

        :type aReferenceIdentifier: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.Handle_CDM_Document_IsOpened(self, *args)


    def Open(self, *args):
        """
        Open(Handle_CDM_Document self, Handle_CDM_Application anApplication)

        :type anApplication: OCC.wrapper.CDM.Handle_CDM_Application

        """
        return _CDM.Handle_CDM_Document_Open(self, *args)


    def CanClose(self, *args):
        """
        CanClose(Handle_CDM_Document self) -> CDM_CanCloseStatus

        :rtype: OCC.wrapper.CDM.CDM_CanCloseStatus

        """
        return _CDM.Handle_CDM_Document_CanClose(self, *args)


    def Close(self, *args):
        """Close(Handle_CDM_Document self)"""
        return _CDM.Handle_CDM_Document_Close(self, *args)


    def Application(self, *args):
        """
        :rtype: OCC.wrapper.CDM.Handle_CDM_Application

        """
        res = _CDM.Handle_CDM_Document_Application(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CanCloseReference(self, *args):
        """
        CanCloseReference(Handle_CDM_Document self, Handle_CDM_Document aDocument, Standard_Integer const aReferenceIdentifier) -> Standard_Boolean

        A  referenced  document  may  indicate   through  this
        virtual  method that it does  not allow the closing of
        aDocument  which  it references through  the reference
        aReferenceIdentifier. By default returns Standard_True;;

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :type aReferenceIdentifier: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.Handle_CDM_Document_CanCloseReference(self, *args)


    def CloseReference(self, *args):
        """
        CloseReference(Handle_CDM_Document self, Handle_CDM_Document aDocument, Standard_Integer const aReferenceIdentifier)

        A referenced document may update its internal
        data structure when {aDocument} which it references
        through the reference {aReferenceIdentifier} is being closed.
        By default this method does nothing.

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :type aReferenceIdentifier: int

        """
        return _CDM.Handle_CDM_Document_CloseReference(self, *args)


    def ReferenceCounter(self, *args):
        """
        ReferenceCounter(Handle_CDM_Document self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDM.Handle_CDM_Document_ReferenceCounter(self, *args)


    def Reference(self, *args):
        """
        Reference(Handle_CDM_Document self, Standard_Integer const aReferenceIdentifier) -> Handle_CDM_Reference

        :type aReferenceIdentifier: int
        :rtype: OCC.wrapper.CDM.Handle_CDM_Reference

        """
        return _CDM.Handle_CDM_Document_Reference(self, *args)


    def SetModifications(self, *args):
        """
        SetModifications(Handle_CDM_Document self, Standard_Integer const Modifications)

        :type Modifications: int

        """
        return _CDM.Handle_CDM_Document_SetModifications(self, *args)


    def SetReferenceCounter(self, *args):
        """
        SetReferenceCounter(Handle_CDM_Document self, Standard_Integer const aReferenceCounter)

        :type aReferenceCounter: int

        """
        return _CDM.Handle_CDM_Document_SetReferenceCounter(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_CDM_Document self) -> char const *

        :rtype: const char *

        """
        return _CDM.Handle_CDM_Document_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _CDM.Handle_CDM_Document_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _CDM.Handle_CDM_Document_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_CDM_Document self)

        Memory deallocator for transient classes


        """
        return _CDM.Handle_CDM_Document_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_CDM_Document self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_CDM_Document self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.Handle_CDM_Document_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_CDM_Document self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_CDM_Document self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.Handle_CDM_Document_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_CDM_Document self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _CDM.Handle_CDM_Document_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_CDM_Document self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDM.Handle_CDM_Document_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_CDM_Document self)

        Increments the reference counter of this object


        """
        return _CDM.Handle_CDM_Document_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_CDM_Document self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDM.Handle_CDM_Document_DecrementRefCounter(self, *args)

Handle_CDM_Document_swigregister = _CDM.Handle_CDM_Document_swigregister
Handle_CDM_Document_swigregister(Handle_CDM_Document)

def Handle_CDM_Document_DownCast(thing):
    return _CDM.Handle_CDM_Document_DownCast(thing)
Handle_CDM_Document_DownCast = _CDM.Handle_CDM_Document_DownCast

class CDM_Reference(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_CDM_Reference
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_CDM_Reference(self) 
            return h


    def FromDocument(self, *args):
        """
        FromDocument(CDM_Reference self) -> Handle_CDM_Document

        :rtype: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _CDM.CDM_Reference_FromDocument(self, *args)


    def ToDocument(self, *args):
        """
        ToDocument(CDM_Reference self) -> Handle_CDM_Document

        :rtype: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _CDM.CDM_Reference_ToDocument(self, *args)


    def ReferenceIdentifier(self, *args):
        """
        ReferenceIdentifier(CDM_Reference self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDM.CDM_Reference_ReferenceIdentifier(self, *args)


    def DocumentVersion(self, *args):
        """
        DocumentVersion(CDM_Reference self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDM.CDM_Reference_DocumentVersion(self, *args)


    def IsReadOnly(self, *args):
        """
        IsReadOnly(CDM_Reference self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.CDM_Reference_IsReadOnly(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _CDM.CDM_Reference_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _CDM.CDM_Reference_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _CDM.CDM_Reference_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _CDM.delete_CDM_Reference
CDM_Reference_swigregister = _CDM.CDM_Reference_swigregister
CDM_Reference_swigregister(CDM_Reference)

def CDM_Reference_get_type_name(*args):
    """
    CDM_Reference_get_type_name() -> char const *

    :rtype: const char *

    """
    return _CDM.CDM_Reference_get_type_name(*args)

def CDM_Reference_get_type_descriptor(*args):
    """
    CDM_Reference_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _CDM.CDM_Reference_get_type_descriptor(*args)

class CDM_MetaData(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_CDM_MetaData
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_CDM_MetaData(self) 
            return h


    def LookUp(*args):
        """
        LookUp(TCollection_ExtendedString aFolder, TCollection_ExtendedString aName, TCollection_ExtendedString aPath, TCollection_ExtendedString aFileName, Standard_Boolean const ReadOnly) -> Handle_CDM_MetaData
        LookUp(TCollection_ExtendedString aFolder, TCollection_ExtendedString aName, TCollection_ExtendedString aPath, TCollection_ExtendedString aVersion, TCollection_ExtendedString aFileName, Standard_Boolean const ReadOnly) -> Handle_CDM_MetaData

        :type aFolder: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aPath: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aVersion: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aFileName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type ReadOnly: bool
        :rtype: OCC.wrapper.CDM.Handle_CDM_MetaData

        """
        return _CDM.CDM_MetaData_LookUp(*args)

    LookUp = staticmethod(LookUp)

    def IsRetrieved(self, *args):
        """
        IsRetrieved(CDM_MetaData self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.CDM_MetaData_IsRetrieved(self, *args)


    def Document(self, *args):
        """
        Document(CDM_MetaData self) -> Handle_CDM_Document

        :rtype: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _CDM.CDM_MetaData_Document(self, *args)


    def Folder(self, *args):
        """
        Folder(CDM_MetaData self) -> TCollection_ExtendedString

        returns the folder in which the meta-data has to be created
        or has to be found.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.CDM_MetaData_Folder(self, *args)


    def Name(self, *args):
        """
        Name(CDM_MetaData self) -> TCollection_ExtendedString

        returns the name under which the meta-data has to be created
        or has to be found.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.CDM_MetaData_Name(self, *args)


    def Version(self, *args):
        """
        Version(CDM_MetaData self) -> TCollection_ExtendedString

        returns the version under which the meta-data has to be found.
        Warning: raises NoSuchObject from Standard if no Version has been defined

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.CDM_MetaData_Version(self, *args)


    def HasVersion(self, *args):
        """
        HasVersion(CDM_MetaData self) -> Standard_Boolean

        indicates that the version has to be taken into account when
        searching the corresponding meta-data.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.CDM_MetaData_HasVersion(self, *args)


    def FileName(self, *args):
        """
        FileName(CDM_MetaData self) -> TCollection_ExtendedString

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.CDM_MetaData_FileName(self, *args)


    def Print(self, *args):
        """
        Print(CDM_MetaData self, Standard_OStream & anOStream) -> Standard_OStream &

        :type anOStream: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _CDM.CDM_MetaData_Print(self, *args)


    def Path(self, *args):
        """
        Path(CDM_MetaData self) -> TCollection_ExtendedString

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.CDM_MetaData_Path(self, *args)


    def UnsetDocument(self, *args):
        """UnsetDocument(CDM_MetaData self)"""
        return _CDM.CDM_MetaData_UnsetDocument(self, *args)


    def IsReadOnly(self, *args):
        """
        IsReadOnly(CDM_MetaData self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.CDM_MetaData_IsReadOnly(self, *args)


    def SetIsReadOnly(self, *args):
        """SetIsReadOnly(CDM_MetaData self)"""
        return _CDM.CDM_MetaData_SetIsReadOnly(self, *args)


    def UnsetIsReadOnly(self, *args):
        """UnsetIsReadOnly(CDM_MetaData self)"""
        return _CDM.CDM_MetaData_UnsetIsReadOnly(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _CDM.CDM_MetaData_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _CDM.CDM_MetaData_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _CDM.CDM_MetaData_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _CDM.delete_CDM_MetaData
CDM_MetaData_swigregister = _CDM.CDM_MetaData_swigregister
CDM_MetaData_swigregister(CDM_MetaData)

def CDM_MetaData_LookUp(*args):
    """
    LookUp(TCollection_ExtendedString aFolder, TCollection_ExtendedString aName, TCollection_ExtendedString aPath, TCollection_ExtendedString aFileName, Standard_Boolean const ReadOnly) -> Handle_CDM_MetaData
    CDM_MetaData_LookUp(TCollection_ExtendedString aFolder, TCollection_ExtendedString aName, TCollection_ExtendedString aPath, TCollection_ExtendedString aVersion, TCollection_ExtendedString aFileName, Standard_Boolean const ReadOnly) -> Handle_CDM_MetaData

    :type aFolder: OCC.wrapper.TCollection.TCollection_ExtendedString
    :type aName: OCC.wrapper.TCollection.TCollection_ExtendedString
    :type aPath: OCC.wrapper.TCollection.TCollection_ExtendedString
    :type aVersion: OCC.wrapper.TCollection.TCollection_ExtendedString
    :type aFileName: OCC.wrapper.TCollection.TCollection_ExtendedString
    :type ReadOnly: bool
    :rtype: OCC.wrapper.CDM.Handle_CDM_MetaData

    """
    return _CDM.CDM_MetaData_LookUp(*args)

def CDM_MetaData_get_type_name(*args):
    """
    CDM_MetaData_get_type_name() -> char const *

    :rtype: const char *

    """
    return _CDM.CDM_MetaData_get_type_name(*args)

def CDM_MetaData_get_type_descriptor(*args):
    """
    CDM_MetaData_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _CDM.CDM_MetaData_get_type_descriptor(*args)

class NCollection_DefaultHasher_Handle_CDM_Document(object):
    """
    Purpose:     The  DefaultHasher  is a  Hasher  that is used by
    default in NCollection maps. 
    To compute the  hash code of the key  is used the
    global function HashCode.
    To compare two keys is used  the  global function 
    IsEqual.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def HashCode(*args):
        """
        HashCode(Handle_CDM_Document theKey, Standard_Integer const Upper) -> Standard_Integer

        :type theKey: const TheKeyType &
        :type Upper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDM.NCollection_DefaultHasher_Handle_CDM_Document_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args):
        """
        IsEqual(Handle_CDM_Document theKey1, Handle_CDM_Document theKey2) -> Standard_Boolean

        :type theKey1: const TheKeyType &
        :type theKey2: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.NCollection_DefaultHasher_Handle_CDM_Document_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    def __init__(self):
        """
        Purpose:     The  DefaultHasher  is a  Hasher  that is used by
        default in NCollection maps. 
        To compute the  hash code of the key  is used the
        global function HashCode.
        To compare two keys is used  the  global function 
        IsEqual.
        """
        this = _CDM.new_NCollection_DefaultHasher_Handle_CDM_Document()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _CDM.delete_NCollection_DefaultHasher_Handle_CDM_Document
NCollection_DefaultHasher_Handle_CDM_Document_swigregister = _CDM.NCollection_DefaultHasher_Handle_CDM_Document_swigregister
NCollection_DefaultHasher_Handle_CDM_Document_swigregister(NCollection_DefaultHasher_Handle_CDM_Document)

def NCollection_DefaultHasher_Handle_CDM_Document_HashCode(*args):
    """
    NCollection_DefaultHasher_Handle_CDM_Document_HashCode(Handle_CDM_Document theKey, Standard_Integer const Upper) -> Standard_Integer

    :type theKey: const TheKeyType &
    :type Upper: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _CDM.NCollection_DefaultHasher_Handle_CDM_Document_HashCode(*args)

def NCollection_DefaultHasher_Handle_CDM_Document_IsEqual(*args):
    """
    NCollection_DefaultHasher_Handle_CDM_Document_IsEqual(Handle_CDM_Document theKey1, Handle_CDM_Document theKey2) -> Standard_Boolean

    :type theKey1: const TheKeyType &
    :type theKey2: const TheKeyType &
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _CDM.NCollection_DefaultHasher_Handle_CDM_Document_IsEqual(*args)


try:
	CDM_DocumentHasher = NCollection_DefaultHasher_Handle_CDM_Document
except NameError:
	pass # does not exist, probably ignored

class NCollection_List_Handle_CDM_Reference(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_Handle_CDM_Reference self) -> NCollection_List< opencascade::handle< CDM_Reference > >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _CDM.NCollection_List_Handle_CDM_Reference_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_Handle_CDM_Reference self) -> NCollection_List< opencascade::handle< CDM_Reference > >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _CDM.NCollection_List_Handle_CDM_Reference_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_Handle_CDM_Reference self) -> NCollection_List< opencascade::handle< CDM_Reference > >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _CDM.NCollection_List_Handle_CDM_Reference_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_Handle_CDM_Reference self) -> NCollection_List< opencascade::handle< CDM_Reference > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _CDM.NCollection_List_Handle_CDM_Reference_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _CDM.new_NCollection_List_Handle_CDM_Reference(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_Handle_CDM_Reference self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDM.NCollection_List_Handle_CDM_Reference_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_Handle_CDM_Reference self, NCollection_List_Handle_CDM_Reference theOther) -> NCollection_List_Handle_CDM_Reference

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _CDM.NCollection_List_Handle_CDM_Reference_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_Handle_CDM_Reference self, NCollection_List_Handle_CDM_Reference theOther) -> NCollection_List_Handle_CDM_Reference

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _CDM.NCollection_List_Handle_CDM_Reference_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_Handle_CDM_Reference self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _CDM.NCollection_List_Handle_CDM_Reference_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _CDM.NCollection_List_Handle_CDM_Reference_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _CDM.NCollection_List_Handle_CDM_Reference_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_Handle_CDM_Reference self, Handle_CDM_Reference theItem) -> Handle_CDM_Reference
        Append(NCollection_List_Handle_CDM_Reference self, Handle_CDM_Reference theItem, NCollection_List< opencascade::handle< CDM_Reference > >::Iterator & theIter)
        Append(NCollection_List_Handle_CDM_Reference self, NCollection_List_Handle_CDM_Reference theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _CDM.NCollection_List_Handle_CDM_Reference_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_Handle_CDM_Reference self, Handle_CDM_Reference theItem) -> Handle_CDM_Reference
        Prepend(NCollection_List_Handle_CDM_Reference self, NCollection_List_Handle_CDM_Reference theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _CDM.NCollection_List_Handle_CDM_Reference_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_Handle_CDM_Reference self)

        RemoveFirst item


        """
        return _CDM.NCollection_List_Handle_CDM_Reference_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_Handle_CDM_Reference self, NCollection_List< opencascade::handle< CDM_Reference > >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _CDM.NCollection_List_Handle_CDM_Reference_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_Handle_CDM_Reference self, Handle_CDM_Reference theItem, NCollection_List< opencascade::handle< CDM_Reference > >::Iterator & theIter) -> Handle_CDM_Reference
        InsertBefore(NCollection_List_Handle_CDM_Reference self, NCollection_List_Handle_CDM_Reference theOther, NCollection_List< opencascade::handle< CDM_Reference > >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _CDM.NCollection_List_Handle_CDM_Reference_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_Handle_CDM_Reference self, Handle_CDM_Reference theItem, NCollection_List< opencascade::handle< CDM_Reference > >::Iterator & theIter) -> Handle_CDM_Reference
        InsertAfter(NCollection_List_Handle_CDM_Reference self, NCollection_List_Handle_CDM_Reference theOther, NCollection_List< opencascade::handle< CDM_Reference > >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _CDM.NCollection_List_Handle_CDM_Reference_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_Handle_CDM_Reference self)

        Reverse the list


        """
        return _CDM.NCollection_List_Handle_CDM_Reference_Reverse(self, *args)


    def __iter__(self):
        return _CDM.NCollection_List_Handle_CDM_Reference___iter__(self)
    __swig_destroy__ = _CDM.delete_NCollection_List_Handle_CDM_Reference
NCollection_List_Handle_CDM_Reference_swigregister = _CDM.NCollection_List_Handle_CDM_Reference_swigregister
NCollection_List_Handle_CDM_Reference_swigregister(NCollection_List_Handle_CDM_Reference)

class NCollection_List_Handle_CDM_Reference_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _CDM.new_NCollection_List_Handle_CDM_Reference_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _CDM.delete_NCollection_List_Handle_CDM_Reference_IteratorHelper

    def __next__(self):
        return _CDM.NCollection_List_Handle_CDM_Reference_IteratorHelper___next__(self)
NCollection_List_Handle_CDM_Reference_IteratorHelper_swigregister = _CDM.NCollection_List_Handle_CDM_Reference_IteratorHelper_swigregister
NCollection_List_Handle_CDM_Reference_IteratorHelper_swigregister(NCollection_List_Handle_CDM_Reference_IteratorHelper)


try:
	CDM_ListOfReferences = NCollection_List_Handle_CDM_Reference
except NameError:
	pass # does not exist, probably ignored

class NCollection_List_Handle_CDM_Document(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_Handle_CDM_Document self) -> NCollection_List< opencascade::handle< CDM_Document > >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _CDM.NCollection_List_Handle_CDM_Document_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_Handle_CDM_Document self) -> NCollection_List< opencascade::handle< CDM_Document > >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _CDM.NCollection_List_Handle_CDM_Document_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_Handle_CDM_Document self) -> NCollection_List< opencascade::handle< CDM_Document > >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _CDM.NCollection_List_Handle_CDM_Document_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_Handle_CDM_Document self) -> NCollection_List< opencascade::handle< CDM_Document > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _CDM.NCollection_List_Handle_CDM_Document_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _CDM.new_NCollection_List_Handle_CDM_Document(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_Handle_CDM_Document self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDM.NCollection_List_Handle_CDM_Document_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_Handle_CDM_Document self, NCollection_List_Handle_CDM_Document theOther) -> NCollection_List_Handle_CDM_Document

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _CDM.NCollection_List_Handle_CDM_Document_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_Handle_CDM_Document self, NCollection_List_Handle_CDM_Document theOther) -> NCollection_List_Handle_CDM_Document

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _CDM.NCollection_List_Handle_CDM_Document_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_Handle_CDM_Document self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _CDM.NCollection_List_Handle_CDM_Document_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _CDM.NCollection_List_Handle_CDM_Document_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _CDM.NCollection_List_Handle_CDM_Document_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_Handle_CDM_Document self, Handle_CDM_Document theItem) -> Handle_CDM_Document
        Append(NCollection_List_Handle_CDM_Document self, Handle_CDM_Document theItem, NCollection_List< opencascade::handle< CDM_Document > >::Iterator & theIter)
        Append(NCollection_List_Handle_CDM_Document self, NCollection_List_Handle_CDM_Document theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _CDM.NCollection_List_Handle_CDM_Document_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_Handle_CDM_Document self, Handle_CDM_Document theItem) -> Handle_CDM_Document
        Prepend(NCollection_List_Handle_CDM_Document self, NCollection_List_Handle_CDM_Document theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _CDM.NCollection_List_Handle_CDM_Document_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_Handle_CDM_Document self)

        RemoveFirst item


        """
        return _CDM.NCollection_List_Handle_CDM_Document_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_Handle_CDM_Document self, NCollection_List< opencascade::handle< CDM_Document > >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _CDM.NCollection_List_Handle_CDM_Document_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_Handle_CDM_Document self, Handle_CDM_Document theItem, NCollection_List< opencascade::handle< CDM_Document > >::Iterator & theIter) -> Handle_CDM_Document
        InsertBefore(NCollection_List_Handle_CDM_Document self, NCollection_List_Handle_CDM_Document theOther, NCollection_List< opencascade::handle< CDM_Document > >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _CDM.NCollection_List_Handle_CDM_Document_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_Handle_CDM_Document self, Handle_CDM_Document theItem, NCollection_List< opencascade::handle< CDM_Document > >::Iterator & theIter) -> Handle_CDM_Document
        InsertAfter(NCollection_List_Handle_CDM_Document self, NCollection_List_Handle_CDM_Document theOther, NCollection_List< opencascade::handle< CDM_Document > >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _CDM.NCollection_List_Handle_CDM_Document_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_Handle_CDM_Document self)

        Reverse the list


        """
        return _CDM.NCollection_List_Handle_CDM_Document_Reverse(self, *args)


    def __iter__(self):
        return _CDM.NCollection_List_Handle_CDM_Document___iter__(self)
    __swig_destroy__ = _CDM.delete_NCollection_List_Handle_CDM_Document
NCollection_List_Handle_CDM_Document_swigregister = _CDM.NCollection_List_Handle_CDM_Document_swigregister
NCollection_List_Handle_CDM_Document_swigregister(NCollection_List_Handle_CDM_Document)

class NCollection_List_Handle_CDM_Document_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _CDM.new_NCollection_List_Handle_CDM_Document_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _CDM.delete_NCollection_List_Handle_CDM_Document_IteratorHelper

    def __next__(self):
        return _CDM.NCollection_List_Handle_CDM_Document_IteratorHelper___next__(self)
NCollection_List_Handle_CDM_Document_IteratorHelper_swigregister = _CDM.NCollection_List_Handle_CDM_Document_IteratorHelper_swigregister
NCollection_List_Handle_CDM_Document_IteratorHelper_swigregister(NCollection_List_Handle_CDM_Document_IteratorHelper)


try:
	CDM_ListOfDocument = NCollection_List_Handle_CDM_Document
except NameError:
	pass # does not exist, probably ignored

class Handle_CDM_Application(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_CDM_Application self)

        Nullify the handle


        """
        return _CDM.Handle_CDM_Application_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_CDM_Application self) -> bool

        Check for being null

        :rtype: bool

        """
        return _CDM.Handle_CDM_Application_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_CDM_Application self, CDM_Application thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _CDM.Handle_CDM_Application_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_CDM_Application self, Handle_CDM_Application theHandle) -> Handle_CDM_Application
        assign(Handle_CDM_Application self, CDM_Application thePtr) -> Handle_CDM_Application
        assign(Handle_CDM_Application self, Handle_CDM_Application theHandle) -> Handle_CDM_Application

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _CDM.Handle_CDM_Application_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_CDM_Application self) -> CDM_Application

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _CDM.Handle_CDM_Application_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_CDM_Application self) -> CDM_Application

        Member access operator (note non-const)

        :rtype: T *

        """
        return _CDM.Handle_CDM_Application___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_CDM_Application self) -> CDM_Application

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _CDM.Handle_CDM_Application___ref__(self, *args)


    def __hash__(self):
        return _CDM.Handle_CDM_Application___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _CDM.Handle_CDM_Application___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _CDM.new_Handle_CDM_Application(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_CDM.Handle_CDM_Application_DownCast)
    __swig_destroy__ = _CDM.delete_Handle_CDM_Application

    def Resources(self, *args):
        """
        Resources(Handle_CDM_Application self) -> Handle_Resource_Manager

        The manager returned by  this virtual  method will be
        used to search for Format.Retrieval  resource items.

        :rtype: OCC.wrapper.Resource.Handle_Resource_Manager

        """
        return _CDM.Handle_CDM_Application_Resources(self, *args)


    def MessageDriver(self, *args):
        """
        MessageDriver(Handle_CDM_Application self) -> Handle_Message_Messenger

        Returns default messenger;

        :rtype: OCC.wrapper.Message.Handle_Message_Messenger

        """
        return _CDM.Handle_CDM_Application_MessageDriver(self, *args)


    def BeginOfUpdate(self, *args):
        """
        BeginOfUpdate(Handle_CDM_Application self, Handle_CDM_Document aDocument)

        this method is called before the update of a document.
        By default, writes in MessageDriver().

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _CDM.Handle_CDM_Application_BeginOfUpdate(self, *args)


    def EndOfUpdate(self, *args):
        """
        EndOfUpdate(Handle_CDM_Application self, Handle_CDM_Document aDocument, Standard_Boolean const theStatus, TCollection_ExtendedString ErrorString)

        this method is called affter the update of a document.
        By default, writes in MessageDriver().

        :type aDocument: OCC.wrapper.CDM.Handle_CDM_Document
        :type theStatus: bool
        :type ErrorString: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.Handle_CDM_Application_EndOfUpdate(self, *args)


    def Write(self, *args):
        """
        Write(Handle_CDM_Application self, Standard_ExtString const aString)

        writes the string in the application MessagerDriver.

        :type aString: OCC.wrapper.Standard.Standard_ExtString

        """
        return _CDM.Handle_CDM_Application_Write(self, *args)


    def Name(self, *args):
        """
        Name(Handle_CDM_Application self) -> TCollection_ExtendedString

        Returns the application name.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.Handle_CDM_Application_Name(self, *args)


    def Version(self, *args):
        """
        Version(Handle_CDM_Application self) -> TCollection_AsciiString

        Returns the application version.

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _CDM.Handle_CDM_Application_Version(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_CDM_Application self) -> char const *

        :rtype: const char *

        """
        return _CDM.Handle_CDM_Application_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _CDM.Handle_CDM_Application_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _CDM.Handle_CDM_Application_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_CDM_Application self)

        Memory deallocator for transient classes


        """
        return _CDM.Handle_CDM_Application_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_CDM_Application self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_CDM_Application self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.Handle_CDM_Application_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_CDM_Application self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_CDM_Application self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.Handle_CDM_Application_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_CDM_Application self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _CDM.Handle_CDM_Application_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_CDM_Application self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDM.Handle_CDM_Application_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_CDM_Application self)

        Increments the reference counter of this object


        """
        return _CDM.Handle_CDM_Application_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_CDM_Application self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDM.Handle_CDM_Application_DecrementRefCounter(self, *args)

Handle_CDM_Application_swigregister = _CDM.Handle_CDM_Application_swigregister
Handle_CDM_Application_swigregister(Handle_CDM_Application)

def Handle_CDM_Application_DownCast(thing):
    return _CDM.Handle_CDM_Application_DownCast(thing)
Handle_CDM_Application_DownCast = _CDM.Handle_CDM_Application_DownCast

class NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString self) -> NCollection_DataMap< TCollection_ExtendedString,opencascade::handle< CDM_Document >,TCollection_ExtendedString >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString self) -> NCollection_DataMap< TCollection_ExtendedString,opencascade::handle< CDM_Document >,TCollection_ExtendedString >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString self) -> NCollection_DataMap< TCollection_ExtendedString,opencascade::handle< CDM_Document >,TCollection_ExtendedString >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString self) -> NCollection_DataMap< TCollection_ExtendedString,opencascade::handle< CDM_Document >,TCollection_ExtendedString >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _CDM.new_NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString self, NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString self, NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString theOther) -> NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString self, NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString theOther) -> NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString self, TCollection_ExtendedString theKey, Handle_CDM_Document theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString self, TCollection_ExtendedString theKey, Handle_CDM_Document theItem) -> Handle_CDM_Document

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> Handle_CDM_Document

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> Handle_CDM_Document

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> Handle_CDM_Document

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString_Size(self, *args)


    def __iter__(self):
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString___iter__(self)
    __swig_destroy__ = _CDM.delete_NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString
NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString_swigregister = _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString_swigregister
NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString_swigregister(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString)

class NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _CDM.new_NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _CDM.delete_NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString_IteratorHelper

    def __next__(self):
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString_IteratorHelper___next__(self)
NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString_IteratorHelper_swigregister = _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString_IteratorHelper_swigregister
NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString_IteratorHelper_swigregister(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString_IteratorHelper)


try:
	CDM_PresentationDirectory = NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_Document_TCollection_ExtendedString
except NameError:
	pass # does not exist, probably ignored

class Handle_CDM_Reference(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_CDM_Reference self)

        Nullify the handle


        """
        return _CDM.Handle_CDM_Reference_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_CDM_Reference self) -> bool

        Check for being null

        :rtype: bool

        """
        return _CDM.Handle_CDM_Reference_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_CDM_Reference self, CDM_Reference thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _CDM.Handle_CDM_Reference_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_CDM_Reference self, Handle_CDM_Reference theHandle) -> Handle_CDM_Reference
        assign(Handle_CDM_Reference self, CDM_Reference thePtr) -> Handle_CDM_Reference
        assign(Handle_CDM_Reference self, Handle_CDM_Reference theHandle) -> Handle_CDM_Reference

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _CDM.Handle_CDM_Reference_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_CDM_Reference self) -> CDM_Reference

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _CDM.Handle_CDM_Reference_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_CDM_Reference self) -> CDM_Reference

        Member access operator (note non-const)

        :rtype: T *

        """
        return _CDM.Handle_CDM_Reference___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_CDM_Reference self) -> CDM_Reference

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _CDM.Handle_CDM_Reference___ref__(self, *args)


    def __hash__(self):
        return _CDM.Handle_CDM_Reference___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _CDM.Handle_CDM_Reference___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _CDM.new_Handle_CDM_Reference(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_CDM.Handle_CDM_Reference_DownCast)
    __swig_destroy__ = _CDM.delete_Handle_CDM_Reference

    def FromDocument(self, *args):
        """
        FromDocument(Handle_CDM_Reference self) -> Handle_CDM_Document

        :rtype: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _CDM.Handle_CDM_Reference_FromDocument(self, *args)


    def ToDocument(self, *args):
        """
        ToDocument(Handle_CDM_Reference self) -> Handle_CDM_Document

        :rtype: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _CDM.Handle_CDM_Reference_ToDocument(self, *args)


    def ReferenceIdentifier(self, *args):
        """
        ReferenceIdentifier(Handle_CDM_Reference self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDM.Handle_CDM_Reference_ReferenceIdentifier(self, *args)


    def DocumentVersion(self, *args):
        """
        DocumentVersion(Handle_CDM_Reference self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDM.Handle_CDM_Reference_DocumentVersion(self, *args)


    def IsReadOnly(self, *args):
        """
        IsReadOnly(Handle_CDM_Reference self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.Handle_CDM_Reference_IsReadOnly(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_CDM_Reference self) -> char const *

        :rtype: const char *

        """
        return _CDM.Handle_CDM_Reference_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _CDM.Handle_CDM_Reference_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _CDM.Handle_CDM_Reference_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_CDM_Reference self)

        Memory deallocator for transient classes


        """
        return _CDM.Handle_CDM_Reference_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_CDM_Reference self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_CDM_Reference self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.Handle_CDM_Reference_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_CDM_Reference self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_CDM_Reference self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.Handle_CDM_Reference_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_CDM_Reference self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _CDM.Handle_CDM_Reference_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_CDM_Reference self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDM.Handle_CDM_Reference_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_CDM_Reference self)

        Increments the reference counter of this object


        """
        return _CDM.Handle_CDM_Reference_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_CDM_Reference self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDM.Handle_CDM_Reference_DecrementRefCounter(self, *args)

Handle_CDM_Reference_swigregister = _CDM.Handle_CDM_Reference_swigregister
Handle_CDM_Reference_swigregister(Handle_CDM_Reference)

def Handle_CDM_Reference_DownCast(thing):
    return _CDM.Handle_CDM_Reference_DownCast(thing)
Handle_CDM_Reference_DownCast = _CDM.Handle_CDM_Reference_DownCast

class Handle_CDM_MetaData(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_CDM_MetaData self)

        Nullify the handle


        """
        return _CDM.Handle_CDM_MetaData_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_CDM_MetaData self) -> bool

        Check for being null

        :rtype: bool

        """
        return _CDM.Handle_CDM_MetaData_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_CDM_MetaData self, CDM_MetaData thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _CDM.Handle_CDM_MetaData_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_CDM_MetaData self, Handle_CDM_MetaData theHandle) -> Handle_CDM_MetaData
        assign(Handle_CDM_MetaData self, CDM_MetaData thePtr) -> Handle_CDM_MetaData
        assign(Handle_CDM_MetaData self, Handle_CDM_MetaData theHandle) -> Handle_CDM_MetaData

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _CDM.Handle_CDM_MetaData_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_CDM_MetaData self) -> CDM_MetaData

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _CDM.Handle_CDM_MetaData_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_CDM_MetaData self) -> CDM_MetaData

        Member access operator (note non-const)

        :rtype: T *

        """
        return _CDM.Handle_CDM_MetaData___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_CDM_MetaData self) -> CDM_MetaData

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _CDM.Handle_CDM_MetaData___ref__(self, *args)


    def __hash__(self):
        return _CDM.Handle_CDM_MetaData___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _CDM.Handle_CDM_MetaData___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _CDM.new_Handle_CDM_MetaData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_CDM.Handle_CDM_MetaData_DownCast)
    __swig_destroy__ = _CDM.delete_Handle_CDM_MetaData

    def LookUp(self, *args):
        """
        LookUp(Handle_CDM_MetaData self, TCollection_ExtendedString aFolder, TCollection_ExtendedString aName, TCollection_ExtendedString aPath, TCollection_ExtendedString aFileName, Standard_Boolean const ReadOnly) -> Handle_CDM_MetaData
        LookUp(Handle_CDM_MetaData self, TCollection_ExtendedString aFolder, TCollection_ExtendedString aName, TCollection_ExtendedString aPath, TCollection_ExtendedString aVersion, TCollection_ExtendedString aFileName, Standard_Boolean const ReadOnly) -> Handle_CDM_MetaData

        :type aFolder: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aPath: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aVersion: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type aFileName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type ReadOnly: bool
        :rtype: OCC.wrapper.CDM.Handle_CDM_MetaData

        """
        return _CDM.Handle_CDM_MetaData_LookUp(self, *args)


    def IsRetrieved(self, *args):
        """
        IsRetrieved(Handle_CDM_MetaData self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.Handle_CDM_MetaData_IsRetrieved(self, *args)


    def Document(self, *args):
        """
        Document(Handle_CDM_MetaData self) -> Handle_CDM_Document

        :rtype: OCC.wrapper.CDM.Handle_CDM_Document

        """
        return _CDM.Handle_CDM_MetaData_Document(self, *args)


    def Folder(self, *args):
        """
        Folder(Handle_CDM_MetaData self) -> TCollection_ExtendedString

        returns the folder in which the meta-data has to be created
        or has to be found.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.Handle_CDM_MetaData_Folder(self, *args)


    def Name(self, *args):
        """
        Name(Handle_CDM_MetaData self) -> TCollection_ExtendedString

        returns the name under which the meta-data has to be created
        or has to be found.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.Handle_CDM_MetaData_Name(self, *args)


    def Version(self, *args):
        """
        Version(Handle_CDM_MetaData self) -> TCollection_ExtendedString

        returns the version under which the meta-data has to be found.
        Warning: raises NoSuchObject from Standard if no Version has been defined

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.Handle_CDM_MetaData_Version(self, *args)


    def HasVersion(self, *args):
        """
        HasVersion(Handle_CDM_MetaData self) -> Standard_Boolean

        indicates that the version has to be taken into account when
        searching the corresponding meta-data.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.Handle_CDM_MetaData_HasVersion(self, *args)


    def FileName(self, *args):
        """
        FileName(Handle_CDM_MetaData self) -> TCollection_ExtendedString

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.Handle_CDM_MetaData_FileName(self, *args)


    def Print(self, *args):
        """
        Print(Handle_CDM_MetaData self, Standard_OStream & anOStream) -> Standard_OStream &

        :type anOStream: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _CDM.Handle_CDM_MetaData_Print(self, *args)


    def Path(self, *args):
        """
        Path(Handle_CDM_MetaData self) -> TCollection_ExtendedString

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _CDM.Handle_CDM_MetaData_Path(self, *args)


    def UnsetDocument(self, *args):
        """UnsetDocument(Handle_CDM_MetaData self)"""
        return _CDM.Handle_CDM_MetaData_UnsetDocument(self, *args)


    def IsReadOnly(self, *args):
        """
        IsReadOnly(Handle_CDM_MetaData self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.Handle_CDM_MetaData_IsReadOnly(self, *args)


    def SetIsReadOnly(self, *args):
        """SetIsReadOnly(Handle_CDM_MetaData self)"""
        return _CDM.Handle_CDM_MetaData_SetIsReadOnly(self, *args)


    def UnsetIsReadOnly(self, *args):
        """UnsetIsReadOnly(Handle_CDM_MetaData self)"""
        return _CDM.Handle_CDM_MetaData_UnsetIsReadOnly(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_CDM_MetaData self) -> char const *

        :rtype: const char *

        """
        return _CDM.Handle_CDM_MetaData_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _CDM.Handle_CDM_MetaData_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _CDM.Handle_CDM_MetaData_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_CDM_MetaData self)

        Memory deallocator for transient classes


        """
        return _CDM.Handle_CDM_MetaData_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_CDM_MetaData self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_CDM_MetaData self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.Handle_CDM_MetaData_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_CDM_MetaData self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_CDM_MetaData self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.Handle_CDM_MetaData_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_CDM_MetaData self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _CDM.Handle_CDM_MetaData_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_CDM_MetaData self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDM.Handle_CDM_MetaData_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_CDM_MetaData self)

        Increments the reference counter of this object


        """
        return _CDM.Handle_CDM_MetaData_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_CDM_MetaData self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDM.Handle_CDM_MetaData_DecrementRefCounter(self, *args)

Handle_CDM_MetaData_swigregister = _CDM.Handle_CDM_MetaData_swigregister
Handle_CDM_MetaData_swigregister(Handle_CDM_MetaData)

def Handle_CDM_MetaData_DownCast(thing):
    return _CDM.Handle_CDM_MetaData_DownCast(thing)
Handle_CDM_MetaData_DownCast = _CDM.Handle_CDM_MetaData_DownCast

class NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     Single hashed Map. This  Map is used  to store and
    retrieve keys in linear time.

    The ::Iterator class can be  used to explore  the
    content of the map. It is not  wise to iterate and
    modify a map in parallel.

    To compute  the hashcode of  the key the  function
    ::HashCode must be defined in the global namespace

    To compare two keys the function ::IsEqual must be
    defined in the global namespace.

    The performance of  a Map is conditionned  by  its
    number of buckets that  should be kept greater  to
    the number   of keys.  This  map has  an automatic
    management of the number of buckets. It is resized
    when  the number of Keys  becomes greater than the
    number of buckets.

    If you have a fair  idea of the number of  objects
    you  can save on automatic   resizing by giving  a
    number of buckets  at creation or using the ReSize
    method. This should be  consider only for  crucial
    optimisation issues.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def cbegin(self, *args):
        """
        cbegin(NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher self) -> NCollection_Map< opencascade::handle< CDM_Document >,CDM_DocumentHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _CDM.NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher self) -> NCollection_Map< opencascade::handle< CDM_Document >,CDM_DocumentHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _CDM.NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Single hashed Map. This  Map is used  to store and
        retrieve keys in linear time.

        The ::Iterator class can be  used to explore  the
        content of the map. It is not  wise to iterate and
        modify a map in parallel.

        To compute  the hashcode of  the key the  function
        ::HashCode must be defined in the global namespace

        To compare two keys the function ::IsEqual must be
        defined in the global namespace.

        The performance of  a Map is conditionned  by  its
        number of buckets that  should be kept greater  to
        the number   of keys.  This  map has  an automatic
        management of the number of buckets. It is resized
        when  the number of Keys  becomes greater than the
        number of buckets.

        If you have a fair  idea of the number of  objects
        you  can save on automatic   resizing by giving  a
        number of buckets  at creation or using the ReSize
        method. This should be  consider only for  crucial
        optimisation issues.
        """
        this = _CDM.new_NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher self, NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_Map

        """
        return _CDM.NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher self, NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher theOther) -> NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher

        Assign.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _CDM.NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher self, NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher theOther) -> NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher

        Assign operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _CDM.NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _CDM.NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher self, Handle_CDM_Document K) -> Standard_Boolean

        Add

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher_Add(self, *args)


    def Added(self, *args):
        """
        Added: add a new key if not yet in the map, and return 
        reference to either newly added or previously existing object

        :type K: const TheKeyType &
        :rtype: const TheKeyType &

        """
        res = _CDM.NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher_Added(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Remove(self, *args):
        """
        Remove(NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher self, Handle_CDM_Document K) -> Standard_Boolean

        Remove

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher_Remove(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _CDM.NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDM.NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher_Size(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher self, NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher theOther) -> Standard_Boolean

        @return true if two maps contains exactly the same keys

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher_IsEqual(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher self, Handle_CDM_Document K) -> Standard_Boolean
        Contains(NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher self, NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher theOther) -> Standard_Boolean

        @return true if this map contains ALL keys of another map.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher_Contains(self, *args)


    def Union(self, *args):
        """
        Union(NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher self, NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher theLeft, NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher theRight)

        Sets this Map to be the result of union (aka addition, fuse, merge, boolean OR) operation between two given Maps
        The new Map contains the values that are contained either in the first map or in the second map or in both.
        All previous content of this Map is cleared.
        This map (result of the boolean operation) can also be passed as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _CDM.NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher_Union(self, *args)


    def Unite(self, *args):
        """
        Unite(NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher self, NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher theOther) -> Standard_Boolean

        Apply to this Map the boolean operation union (aka addition, fuse, merge, boolean OR) with another (given) Map.
        The result contains the values that were previously contained in this map or contained in the given (operand) map.
        This algorithm is similar to method Union().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher_Unite(self, *args)


    def HasIntersection(self, *args):
        """
        HasIntersection(NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher self, NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher theMap) -> Standard_Boolean

        Returns true if this and theMap have common elements.

        :type theMap: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher_HasIntersection(self, *args)


    def Intersection(self, *args):
        """
        Intersection(NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher self, NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher theLeft, NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher theRight)

        Sets this Map to be the result of intersection (aka multiplication, common, boolean AND) operation between two given Maps.
        The new Map contains only the values that are contained in both map operands.
        All previous content of this Map is cleared.
        This same map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _CDM.NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher_Intersection(self, *args)


    def Intersect(self, *args):
        """
        Intersect(NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher self, NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher theOther) -> Standard_Boolean

        Apply to this Map the intersection operation (aka multiplication, common, boolean AND) with another (given) Map.
        The result contains only the values that are contained in both this and the given maps.
        This algorithm is similar to method Intersection().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher_Intersect(self, *args)


    def Subtraction(self, *args):
        """
        Subtraction(NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher self, NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher theLeft, NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher theRight)

        Sets this Map to be the result of subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation between two given Maps.
        The new Map contains only the values that are contained in the first map operands and not contained in the second one.
        All previous content of this Map is cleared.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _CDM.NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher_Subtraction(self, *args)


    def Subtract(self, *args):
        """
        Subtract(NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher self, NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher theOther) -> Standard_Boolean

        Apply to this Map the subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation with another (given) Map.
        The result contains only the values that were previously contained in this map and not contained in this map.
        This algorithm is similar to method Subtract() with two operands.
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher_Subtract(self, *args)


    def Difference(self, *args):
        """
        Difference(NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher self, NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher theLeft, NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher theRight)

        Sets this Map to be the result of symmetric difference (aka exclusive disjunction, boolean XOR) operation between two given Maps.
        The new Map contains the values that are contained only in the first or the second operand maps but not in both.
        All previous content of this Map is cleared. This map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _CDM.NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher_Difference(self, *args)


    def Differ(self, *args):
        """
        Differ(NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher self, NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher theOther) -> Standard_Boolean

        Apply to this Map the symmetric difference (aka exclusive disjunction, boolean XOR) operation with another (given) Map.
        The result contains the values that are contained only in this or the operand map, but not in both.
        This algorithm is similar to method Difference().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher_Differ(self, *args)


    def __iter__(self):
        return _CDM.NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher___iter__(self)
    __swig_destroy__ = _CDM.delete_NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher
NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher_swigregister = _CDM.NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher_swigregister
NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher_swigregister(NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher)

class NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _CDM.new_NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _CDM.delete_NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher_IteratorHelper

    def __next__(self):
        return _CDM.NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher_IteratorHelper___next__(self)
NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher_IteratorHelper_swigregister = _CDM.NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher_IteratorHelper_swigregister
NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher_IteratorHelper_swigregister(NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher_IteratorHelper)


try:
	CDM_MapOfDocument = NCollection_Map_Handle_CDM_Document_CDM_DocumentHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString self) -> NCollection_DataMap< TCollection_ExtendedString,opencascade::handle< CDM_MetaData >,TCollection_ExtendedString >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString self) -> NCollection_DataMap< TCollection_ExtendedString,opencascade::handle< CDM_MetaData >,TCollection_ExtendedString >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString self) -> NCollection_DataMap< TCollection_ExtendedString,opencascade::handle< CDM_MetaData >,TCollection_ExtendedString >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString self) -> NCollection_DataMap< TCollection_ExtendedString,opencascade::handle< CDM_MetaData >,TCollection_ExtendedString >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _CDM.new_NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString self, NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString self, NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString theOther) -> NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString self, NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString theOther) -> NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString self, TCollection_ExtendedString theKey, Handle_CDM_MetaData theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString self, TCollection_ExtendedString theKey, Handle_CDM_MetaData theItem) -> Handle_CDM_MetaData

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> Handle_CDM_MetaData

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> Handle_CDM_MetaData

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> Handle_CDM_MetaData

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString_Size(self, *args)


    def __iter__(self):
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString___iter__(self)
    __swig_destroy__ = _CDM.delete_NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString
NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString_swigregister = _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString_swigregister
NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString_swigregister(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString)

class NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _CDM.new_NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _CDM.delete_NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString_IteratorHelper

    def __next__(self):
        return _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString_IteratorHelper___next__(self)
NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString_IteratorHelper_swigregister = _CDM.NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString_IteratorHelper_swigregister
NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString_IteratorHelper_swigregister(NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString_IteratorHelper)


try:
	CDM_MetaDataLookUpTable = NCollection_DataMap_TCollection_ExtendedString_Handle_CDM_MetaData_TCollection_ExtendedString
except NameError:
	pass # does not exist, probably ignored




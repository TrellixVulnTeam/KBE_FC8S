# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Poly')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Poly')
    _Poly = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Poly', [dirname(__file__)])
        except ImportError:
            import _Poly
            return _Poly
        try:
            _mod = imp.load_module('_Poly', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Poly = swig_import_helper()
    del swig_import_helper
else:
    import _Poly
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Poly.delete_SwigPyIterator

    def value(self):
        return _Poly.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Poly.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Poly.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Poly.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Poly.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Poly.SwigPyIterator_copy(self)

    def next(self):
        return _Poly.SwigPyIterator_next(self)

    def __next__(self):
        return _Poly.SwigPyIterator___next__(self)

    def previous(self):
        return _Poly.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Poly.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Poly.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Poly.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Poly.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Poly.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Poly.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Poly.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _Poly.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Poly.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_Poly.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _Poly.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Poly.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Poly.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _Poly.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _Poly.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _Poly.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Poly.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_Poly.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _Poly.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Poly.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Poly.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _Poly.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _Poly.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _Poly.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _Poly.ptr_to_number(item)
ptr_to_number = _Poly.ptr_to_number

def HashCode(*args):
    return _Poly.HashCode(*args)
HashCode = _Poly.HashCode

def ptr_equal(a, b):
    return _Poly.ptr_equal(a, b)
ptr_equal = _Poly.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TShort
else:
    import TShort
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
class Poly_Polygon3D(Standard.Standard_Transient):
    """
    This class Provides a polygon in 3D space. It is generally an approximate representation of a curve.
    A Polygon3D is defined by a table of nodes. Each node is
    a 3D point. If the polygon is closed, the point of closure is
    repeated at the end of the table of nodes.
    If the polygon is an approximate representation of a curve,
    you can associate with each of its nodes the value of the
    parameter of the corresponding point on the curve.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Poly_Polygon3D
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Poly_Polygon3D(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Poly_Polygon3D self, NCollection_Array1_gp_Pnt Nodes) -> Poly_Polygon3D
        __init__(Poly_Polygon3D self, NCollection_Array1_gp_Pnt Nodes, NCollection_Array1_Standard_Real Parameters) -> Poly_Polygon3D

        Constructs a 3D polygon defined by
        the table of points, Nodes, and the parallel table of
        parameters, Parameters, where each value of the table
        Parameters is the parameter of the corresponding point
        on the curve approximated by the constructed polygon.
        Warning
        Both the Nodes and Parameters tables must have the
        same bounds. This property is not checked at construction time.

        :type Nodes: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Parameters: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        this = _Poly.new_Poly_Polygon3D(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Copy(self, *args):
        """
        Copy(Poly_Polygon3D self) -> Handle_Poly_Polygon3D

        Creates a copy of current polygon

        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon3D

        """
        return _Poly.Poly_Polygon3D_Copy(self, *args)


    def Deflection(self, *args):
        """
        Deflection(Poly_Polygon3D self) -> Standard_Real
        Deflection(Poly_Polygon3D self, Standard_Real const D)

        Sets the deflection of this polygon to D. See more on deflection in Poly_Polygon2D

        :type D: float

        """
        return _Poly.Poly_Polygon3D_Deflection(self, *args)


    def NbNodes(self, *args):
        """
        NbNodes(Poly_Polygon3D self) -> Standard_Integer

        Returns the number of nodes in this polygon.
        Note: If the polygon is closed, the point of closure is
        repeated at the end of its table of nodes. Thus, on a closed
        triangle the function NbNodes returns 4.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Poly_Polygon3D_NbNodes(self, *args)


    def Nodes(self, *args):
        """
        Returns the table of nodes for this polygon.

        :rtype: OCC.wrapper.TColgp.TColgp_Array1OfPnt

        """
        res = _Poly.Poly_Polygon3D_Nodes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasParameters(self, *args):
        """
        HasParameters(Poly_Polygon3D self) -> Standard_Boolean

        Returns the table of the parameters associated with each node in this polygon.
        HasParameters function checks if   parameters are associated with the nodes of this polygon.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Poly_Polygon3D_HasParameters(self, *args)


    def Parameters(self, *args):
        """
        Returns true if parameters are associated with the nodes
        in this polygon.

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _Poly.Poly_Polygon3D_Parameters(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeParameters(self, *args):
        """
        ChangeParameters(Poly_Polygon3D self) -> NCollection_Array1_Standard_Real

        Returns the table of the parameters associated with each node in this polygon.
        ChangeParameters function returnes the  array as shared. Therefore if the table is selected by
        reference you can, by simply modifying it, directly modify
        the data structure of this polygon.

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Poly.Poly_Polygon3D_ChangeParameters(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Poly.Poly_Polygon3D_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Poly.Poly_Polygon3D_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Poly.Poly_Polygon3D_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Poly.delete_Poly_Polygon3D
Poly_Polygon3D_swigregister = _Poly.Poly_Polygon3D_swigregister
Poly_Polygon3D_swigregister(Poly_Polygon3D)

def Poly_Polygon3D_get_type_name(*args):
    """
    Poly_Polygon3D_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Poly.Poly_Polygon3D_get_type_name(*args)

def Poly_Polygon3D_get_type_descriptor(*args):
    """
    Poly_Polygon3D_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Poly.Poly_Polygon3D_get_type_descriptor(*args)

class Poly_MakeLoops(object):
    """
    Make loops from a set of connected links. A link is represented by 
    a pair of integer indices of nodes.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    LF_None = _Poly.Poly_MakeLoops_LF_None
    LF_Fwd = _Poly.Poly_MakeLoops_LF_Fwd
    LF_Rev = _Poly.Poly_MakeLoops_LF_Rev
    LF_Both = _Poly.Poly_MakeLoops_LF_Both
    LF_Reversed = _Poly.Poly_MakeLoops_LF_Reversed
    RC_LoopsDone = _Poly.Poly_MakeLoops_RC_LoopsDone
    RC_HangingLinks = _Poly.Poly_MakeLoops_RC_HangingLinks
    RC_Failure = _Poly.Poly_MakeLoops_RC_Failure

    def Reset(self, *args):
        """
        Reset(Poly_MakeLoops self, Poly_MakeLoops::Helper const * theHelper, Handle_NCollection_BaseAllocator theAlloc=0)

        It is to reset the algorithm to the initial state.

        :type theHelper: OCC.wrapper.Poly.Helper
        :type theAlloc: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Poly.Poly_MakeLoops_Reset(self, *args)


    def AddLink(self, *args):
        """
        AddLink(Poly_MakeLoops self, Poly_MakeLoops::Link const & theLink)

        Adds a link to the set. theOrient defines which orientations of the link
        are allowed.

        :type theLink: Link

        """
        return _Poly.Poly_MakeLoops_AddLink(self, *args)


    def ReplaceLink(self, *args):
        """
        ReplaceLink(Poly_MakeLoops self, Poly_MakeLoops::Link const & theLink, Poly_MakeLoops::Link const & theNewLink)

        Replace one link with another (e.g. to change order of nodes)

        :type theLink: Link
        :type theNewLink: Link

        """
        return _Poly.Poly_MakeLoops_ReplaceLink(self, *args)


    def SetLinkOrientation(self, *args):
        """
        SetLinkOrientation(Poly_MakeLoops self, Poly_MakeLoops::Link const & theLink, Poly_MakeLoops::LinkFlag const theOrient) -> Poly_MakeLoops::LinkFlag

        Set a new value of orientation of a link already added earlier.
        It can be used with LF_None to exclude the link from consideration.
        Returns the old value of orienation.

        :type theLink: Link
        :type theOrient: LinkFlag
        :rtype: LinkFlag

        """
        return _Poly.Poly_MakeLoops_SetLinkOrientation(self, *args)


    def FindLink(self, *args):
        """
        FindLink(Poly_MakeLoops self, Poly_MakeLoops::Link const & theLink) -> Poly_MakeLoops::Link

        Find the link stored in algo by value

        :type theLink: Link
        :rtype: Link

        """
        return _Poly.Poly_MakeLoops_FindLink(self, *args)


    def Perform(self, *args):
        """
        Perform(Poly_MakeLoops self) -> Standard_Integer

        Does the work. Returns the collection of result codes

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Poly_MakeLoops_Perform(self, *args)


    def GetNbLoops(self, *args):
        """
        GetNbLoops(Poly_MakeLoops self) -> Standard_Integer

        Returns the number of loops in the result

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Poly_MakeLoops_GetNbLoops(self, *args)


    def GetLoop(self, *args):
        """
        Returns the loop of the given index

        :type theIndex: int
        :rtype: Loop

        """
        res = _Poly.Poly_MakeLoops_GetLoop(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetNbHanging(self, *args):
        """
        GetNbHanging(Poly_MakeLoops self) -> Standard_Integer

        Returns the number of detected hanging chains

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Poly_MakeLoops_GetNbHanging(self, *args)


    def GetHangingLinks(self, *args):
        """
        GetHangingLinks(Poly_MakeLoops self, Poly_MakeLoops::ListOfLink & theLinks)

        Fills in the list of hanging links

        :type theLinks: ListOfLink

        """
        return _Poly.Poly_MakeLoops_GetHangingLinks(self, *args)

    __swig_destroy__ = _Poly.delete_Poly_MakeLoops
Poly_MakeLoops_swigregister = _Poly.Poly_MakeLoops_swigregister
Poly_MakeLoops_swigregister(Poly_MakeLoops)

class Poly_CoherentTriangulation(Standard.Standard_Transient):
    """
    Triangulation structure that allows to:
    <ul>
    <li>Store the connectivity of each triangle with up to 3 neighbouring ones and with the corresponding 3rd nodes on them,</li>
    <li>Store the connectivity of each node with all triangles that share this node</li>
    <li>Add nodes and triangles to the structure,</li>
    <li>Find all triangles sharing a single or a couple of nodes</li>
    <li>Remove triangles from structure</li>
    <li>Optionally create Links between pairs of nodes according to the current triangulation.</li>
    <li>Convert from/to Poly_Triangulation structure.</li>
    </ul>

    This class is useful for algorithms that need to analyse and/or edit a triangulated mesh -- for example for mesh refining.
    The connectivity model follows the idea that all Triangles in a mesh should have coherent orientation like on a surface of a solid body.
    Connections between more than 2 triangles are not suppoorted.

    @section Poly_CoherentTriangulation Architecture
    The data types used in this structure are:
    <ul>
    <li><b>Poly_CoherentNode</b>: Inherits go_XYZ therefore provides the full public API of gp_XYZ.
    Contains references to all incident triangles. You can add new nodes but you cannot remove existing ones.
    However each node that has no referenced triangle is considered as "free" (use the method IsFreeNode() to check this).
    Free nodes are not available to further processing, particularly they are not exported in Poly_Triangulation.
    </li>
    <li><b>Poly_CoherentTriangle</b>: Main data type. Refers three Nodes, three connected Triangles, three opposite (connected) Nodes and three Links.
    If there is boundary then 1, 2 or 3 references to Triangles/connected Nodes/Links are assigned to NULL (for pointers) or -1 (for integer node index).

    You can find a triangle by one node using its triangle iterator or by
    two nodes - creating a temporary Poly_CoherentLink and calling the method FindTriangle().

    Triangles can be removed but they are never deleted from the containing array. Removed triangles have all nodes equal to -1.
    You can use the method IsEmpty() to check that.
    </li>
    <li><b>Poly_CoherentLink</b>: Auxiliary data type. Normally the array of Links is empty, because for many algorithms it is sufficient to define only Triangles.
    You can explicitly create the Links at least once, calling the method ComputeLinks(). Each Link is oriented couple of Poly_CoherentNode (directed to the ascending Node index).
    It refers two connected triangulated Nodes - on the left and on the right,
    therefore a Poly_CoherentLink instance refers the full set of nodes that constitute a couple of connected Triangles.
    A boundary Link has either the first (left) or the second (right) connected node index equal to -1.

    When the array of Links is created, all subsequent calls to AddTriangle and RemoveTriangle try to preserve the connectivity Triangle-Link in addition to the connectivity Triangle-Triangle.
    Particularly, new Links are created by method AddTriangle() and existing ones are removed by method RemoveTriangle(), in each case whenever necessary.

    Similarly to Poly_CoherentTriangle, a Link can be removed but not destroyed separately from others.
    Removed Link can be recogniosed using the method IsEmpty(). To destroy all Links, call the method ClearLinks(),
    this method also nullifies Link references in all Triangles.
    </li>
    All objects (except for free Nodes and empty Triangles and Links) can be visited by the corresponding Iterator.
    Direct access is provided only for Nodes (needed to resolve Node indexed commonly used as reference).
    Triangles and Links can be retrieved by their index only internally, the public API provides only references or pointers to C++ objects.
    If you need a direct access to Triangles and Links, you can subclass Poly_CoherentTriangulation and use the protected API for your needs.

    Memory management: All data objects are stored in NCollection_Vector containers that prove to be efficient for the performance.
    In addition references to triangles are stored in ring lists, with an instance of such list per Poly_CoherentNode.
    These lists are allocated in a memory allocator that is provided in the constructor of Poly_CoherentTriangulation.
    By default the standard OCCT allocator (aka NCollection_BaseAllocator) is used.
    But if you need to increase the performance you can use NCollection_IncAllocator instead.
    </ul>
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Poly_CoherentTriangulation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Poly_CoherentTriangulation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Poly_CoherentTriangulation self, Handle_NCollection_BaseAllocator theAlloc=0) -> Poly_CoherentTriangulation
        __init__(Poly_CoherentTriangulation self, Handle_Poly_Triangulation theTriangulation, Handle_NCollection_BaseAllocator theAlloc=0) -> Poly_CoherentTriangulation

        Constructor. It does not create Links, you should call ComputeLinks
        following this constructor if you need these links.

        :type theTriangulation: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :type theAlloc: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _Poly.new_Poly_CoherentTriangulation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def GetTriangulation(self, *args):
        """
        GetTriangulation(Poly_CoherentTriangulation self) -> Handle_Poly_Triangulation

        Create an instance of Poly_Triangulation from this object.

        :rtype: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        return _Poly.Poly_CoherentTriangulation_GetTriangulation(self, *args)


    def RemoveDegenerated(self, *args):
        """
        RemoveDegenerated(Poly_CoherentTriangulation self, Standard_Real const theTol, NCollection_List< Poly_CoherentTriangulation::TwoIntegers > * pLstRemovedNode=0) -> Standard_Boolean

        Find and remove degenerated triangles in Triangulation.
        @param theTol
        Tolerance for the degeneration case. If any two nodes of a triangle have
        the distance less than this tolerance, this triangle is considered
        degenerated and therefore removed by this method.
        @param pLstRemovedNode
        Optional parameter. If defined, then it will receive the list of arrays
        where the first number is the index of removed node and the seond -
        the index of remaining node to which the mesh was reconnected.

        :type theTol: float
        :type pLstRemovedNode: OCC.wrapper.Poly.NCollection_List_Poly_CoherentTriangulation::TwoIntegers
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Poly_CoherentTriangulation_RemoveDegenerated(self, *args)


    def GetFreeNodes(self, *args):
        """
        GetFreeNodes(Poly_CoherentTriangulation self, NCollection_List_Standard_Integer lstNodes) -> Standard_Boolean

        Create a list of free nodes. These nodes may appear as a result of any
        custom mesh decimation or RemoveDegenerated() call. This analysis is
        necessary if you support additional data structures based on the
        triangulation (e.g., edges on the surface boundary).
        @param lstNodes
        <tt>[out]</tt> List that receives the indices of free nodes.

        :type lstNodes: OCC.wrapper.Poly.NCollection_List_Standard_Integer
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Poly_CoherentTriangulation_GetFreeNodes(self, *args)


    def MaxNode(self, *args):
        """
        MaxNode(Poly_CoherentTriangulation self) -> Standard_Integer

        Query the index of the last node in the triangulation

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Poly_CoherentTriangulation_MaxNode(self, *args)


    def MaxTriangle(self, *args):
        """
        MaxTriangle(Poly_CoherentTriangulation self) -> Standard_Integer

        Query the index of the last triangle in the triangulation

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Poly_CoherentTriangulation_MaxTriangle(self, *args)


    def SetDeflection(self, *args):
        """
        SetDeflection(Poly_CoherentTriangulation self, Standard_Real const theDefl)

        Set the Deflection value as the parameter of the given triangulation.

        :type theDefl: float

        """
        return _Poly.Poly_CoherentTriangulation_SetDeflection(self, *args)


    def Deflection(self, *args):
        """
        Deflection(Poly_CoherentTriangulation self) -> Standard_Real

        Query the Deflection parameter (default value 0. -- if never initialized)

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Poly.Poly_CoherentTriangulation_Deflection(self, *args)


    def SetNode(self, *args):
        """
        SetNode(Poly_CoherentTriangulation self, gp_XYZ thePnt, Standard_Integer const iN=-1) -> Standard_Integer

        Initialize a node
        @param thePoint
        3D Coordinates of the node.
        @param iN
        Index of the node. If negative (default), the node is added to the
        end of the current array of nodes.
        @return
        Index of the added node.

        :type thePnt: OCC.wrapper.gp.gp_XYZ
        :type iN: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Poly_CoherentTriangulation_SetNode(self, *args)


    def Node(self, *args):
        """
        Get the node at the given index 'i'.

        :type i: int
        :rtype: OCC.wrapper.Poly.Poly_CoherentNode

        """
        res = _Poly.Poly_CoherentTriangulation_Node(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeNode(self, *args):
        """
        ChangeNode(Poly_CoherentTriangulation self, Standard_Integer const i) -> Poly_CoherentNode

        Get the node at the given index 'i'.

        :type i: int
        :rtype: OCC.wrapper.Poly.Poly_CoherentNode

        """
        return _Poly.Poly_CoherentTriangulation_ChangeNode(self, *args)


    def NNodes(self, *args):
        """
        NNodes(Poly_CoherentTriangulation self) -> Standard_Integer

        Query the total number of active nodes (i.e. nodes used by 1 or more
        triangles)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Poly_CoherentTriangulation_NNodes(self, *args)


    def Triangle(self, *args):
        """
        Get the triangle at the given index 'i'.

        :type i: int
        :rtype: OCC.wrapper.Poly.Poly_CoherentTriangle

        """
        res = _Poly.Poly_CoherentTriangulation_Triangle(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NTriangles(self, *args):
        """
        NTriangles(Poly_CoherentTriangulation self) -> Standard_Integer

        Query the total number of active triangles (i.e. triangles that refer
        nodes, non-empty ones)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Poly_CoherentTriangulation_NTriangles(self, *args)


    def NLinks(self, *args):
        """
        NLinks(Poly_CoherentTriangulation self) -> Standard_Integer

        Query the total number of active Links.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Poly_CoherentTriangulation_NLinks(self, *args)


    def RemoveTriangle(self, *args):
        """
        RemoveTriangle(Poly_CoherentTriangulation self, Poly_CoherentTriangle theTr) -> Standard_Boolean

        Removal of a single triangle from the triangulation.

        :type theTr: OCC.wrapper.Poly.Poly_CoherentTriangle
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Poly_CoherentTriangulation_RemoveTriangle(self, *args)


    def RemoveLink(self, *args):
        """
        RemoveLink(Poly_CoherentTriangulation self, Poly_CoherentLink theLink)

        Removal of a single link from the triangulation.

        :type theLink: OCC.wrapper.Poly.Poly_CoherentLink

        """
        return _Poly.Poly_CoherentTriangulation_RemoveLink(self, *args)


    def AddTriangle(self, *args):
        """
        AddTriangle(Poly_CoherentTriangulation self, Standard_Integer const iNode0, Standard_Integer const iNode1, Standard_Integer const iNode2) -> Poly_CoherentTriangle

        Add a triangle to the triangulation.
        @return
        Pointer to the added triangle instance or NULL if an error occurred.

        :type iNode0: int
        :type iNode1: int
        :type iNode2: int
        :rtype: OCC.wrapper.Poly.Poly_CoherentTriangle

        """
        return _Poly.Poly_CoherentTriangulation_AddTriangle(self, *args)


    def ReplaceNodes(self, *args):
        """
        ReplaceNodes(Poly_CoherentTriangulation self, Poly_CoherentTriangle theTriangle, Standard_Integer const iNode0, Standard_Integer const iNode1, Standard_Integer const iNode2) -> Standard_Boolean

        Replace nodes in the given triangle.
        @return
        True if operation succeeded.

        :type theTriangle: OCC.wrapper.Poly.Poly_CoherentTriangle
        :type iNode0: int
        :type iNode1: int
        :type iNode2: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Poly_CoherentTriangulation_ReplaceNodes(self, *args)


    def AddLink(self, *args):
        """
        AddLink(Poly_CoherentTriangulation self, Poly_CoherentTriangle theTri, Standard_Integer const theConn) -> Poly_CoherentLink

        Add a single link to triangulation, based on a triangle and its side index.
        This method does not check for coincidence with already present links.
        @param theTri
        Triangle that contains the link to be added.
        @param theConn
        Index of the side (i.e., 0, 1 0r 2) defining the added link.

        :type theTri: OCC.wrapper.Poly.Poly_CoherentTriangle
        :type theConn: int
        :rtype: OCC.wrapper.Poly.Poly_CoherentLink

        """
        return _Poly.Poly_CoherentTriangulation_AddLink(self, *args)


    def FindTriangle(self, *args):
        """
        FindTriangle(Poly_CoherentTriangulation self, Poly_CoherentLink theLink, Poly_CoherentTriangle const ** pTri) -> Standard_Boolean

        Find one or two triangles that share the given couple of nodes.
        @param theLink
        Link (in fact, just a couple of nodes) on which the triangle is
        searched.
        @param pTri
        <tt>[out]</tt> Array of two pointers to triangle. pTri[0] stores the
        triangle to the left of the link, while pTri[1] stores the one to the
        right of the link.
        @return
        True if at least one triangle is found and output as pTri.

        :type theLink: OCC.wrapper.Poly.Poly_CoherentLink
        :type pTri: const Poly_CoherentTriangle *[2]
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Poly_CoherentTriangulation_FindTriangle(self, *args)


    def ComputeLinks(self, *args):
        """
        ComputeLinks(Poly_CoherentTriangulation self) -> Standard_Integer

        (Re)Calculate all links in this Triangulation.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Poly_CoherentTriangulation_ComputeLinks(self, *args)


    def ClearLinks(self, *args):
        """
        ClearLinks(Poly_CoherentTriangulation self)

        Clear all Links data from the Triangulation data.


        """
        return _Poly.Poly_CoherentTriangulation_ClearLinks(self, *args)


    def Allocator(self, *args):
        """
        Query the allocator of elements, this allocator can be used for other
        objects 

        :rtype: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        res = _Poly.Poly_CoherentTriangulation_Allocator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clone(self, *args):
        """
        Clone(Poly_CoherentTriangulation self, Handle_NCollection_BaseAllocator theAlloc) -> Handle_Poly_CoherentTriangulation

        Create a copy of this Triangulation, using the given allocator.

        :type theAlloc: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator
        :rtype: OCC.wrapper.Poly.Handle_Poly_CoherentTriangulation

        """
        return _Poly.Poly_CoherentTriangulation_Clone(self, *args)


    def Dump(self, *args):
        """
        Dump(Poly_CoherentTriangulation self, Standard_OStream & arg2)

        Debugging output.

        :type : OCC.wrapper.Standard.Standard_OStream

        """
        return _Poly.Poly_CoherentTriangulation_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Poly.Poly_CoherentTriangulation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Poly.Poly_CoherentTriangulation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Poly.Poly_CoherentTriangulation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Poly.delete_Poly_CoherentTriangulation
Poly_CoherentTriangulation_swigregister = _Poly.Poly_CoherentTriangulation_swigregister
Poly_CoherentTriangulation_swigregister(Poly_CoherentTriangulation)

def Poly_CoherentTriangulation_get_type_name(*args):
    """
    Poly_CoherentTriangulation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Poly.Poly_CoherentTriangulation_get_type_name(*args)

def Poly_CoherentTriangulation_get_type_descriptor(*args):
    """
    Poly_CoherentTriangulation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Poly.Poly_CoherentTriangulation_get_type_descriptor(*args)

class Poly_PolygonOnTriangulation(Standard.Standard_Transient):
    """
    This class provides a polygon in 3D space, based on the triangulation
    of a surface. It may be the approximate representation of a
    curve on the surface, or more generally the shape.
    A PolygonOnTriangulation is defined by a table of
    nodes. Each node is an index in the table of nodes specific
    to a triangulation, and represents a point on the surface. If
    the polygon is closed, the index of the point of closure is
    repeated at the end of the table of nodes.
    If the polygon is an approximate representation of a curve
    on a surface, you can associate with each of its nodes the
    value of the parameter of the corresponding point on the
    curve.represents a 3d Polygon
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Poly_PolygonOnTriangulation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Poly_PolygonOnTriangulation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Poly_PolygonOnTriangulation self, NCollection_Array1_Standard_Integer Nodes) -> Poly_PolygonOnTriangulation
        __init__(Poly_PolygonOnTriangulation self, NCollection_Array1_Standard_Integer Nodes, NCollection_Array1_Standard_Real Parameters) -> Poly_PolygonOnTriangulation

        Constructs a 3D polygon on the triangulation of a shape, defined by:
        -   the table of nodes, Nodes, and the table of parameters, <Parameters>.
        where:
        -   a node value is an index in the table of nodes specific
        to an existing triangulation of a shape
        -   and a parameter value is the value of the parameter of
        the corresponding point on the curve approximated by
        the constructed polygon.
        Warning
        The tables Nodes and Parameters must be the same size.
        This property is not checked at construction time.

        :type Nodes: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type Parameters: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        this = _Poly.new_Poly_PolygonOnTriangulation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Copy(self, *args):
        """
        Copy(Poly_PolygonOnTriangulation self) -> Handle_Poly_PolygonOnTriangulation

        Creates a copy of current polygon

        :rtype: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation

        """
        return _Poly.Poly_PolygonOnTriangulation_Copy(self, *args)


    def Deflection(self, *args):
        """
        Deflection(Poly_PolygonOnTriangulation self) -> Standard_Real
        Deflection(Poly_PolygonOnTriangulation self, Standard_Real const D)

        Sets the deflection of this polygon to D.
        See more on deflection in Poly_Polygones2D.

        :type D: float

        """
        return _Poly.Poly_PolygonOnTriangulation_Deflection(self, *args)


    def NbNodes(self, *args):
        """
        NbNodes(Poly_PolygonOnTriangulation self) -> Standard_Integer

        Returns the number of nodes for this polygon.
        Note: If the polygon is closed, the point of closure is
        repeated at the end of its table of nodes. Thus, on a closed
        triangle, the function NbNodes returns 4.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Poly_PolygonOnTriangulation_NbNodes(self, *args)


    def Nodes(self, *args):
        """
        Returns the table of nodes for this polygon. A node value
        is an index in the table of nodes specific to an existing
        triangulation of a shape.

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        res = _Poly.Poly_PolygonOnTriangulation_Nodes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasParameters(self, *args):
        """
        HasParameters(Poly_PolygonOnTriangulation self) -> Standard_Boolean

        Returns true if parameters are associated with the nodes in this polygon.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Poly_PolygonOnTriangulation_HasParameters(self, *args)


    def Parameters(self, *args):
        """
        Parameters(Poly_PolygonOnTriangulation self) -> Handle_TColStd_HArray1OfReal

        Returns the table of the parameters associated with each node in this polygon.
        Warning
        Use the function HasParameters to check if parameters
        are associated with the nodes in this polygon.

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _Poly.Poly_PolygonOnTriangulation_Parameters(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Poly.Poly_PolygonOnTriangulation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Poly.Poly_PolygonOnTriangulation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Poly.Poly_PolygonOnTriangulation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Poly.delete_Poly_PolygonOnTriangulation
Poly_PolygonOnTriangulation_swigregister = _Poly.Poly_PolygonOnTriangulation_swigregister
Poly_PolygonOnTriangulation_swigregister(Poly_PolygonOnTriangulation)

def Poly_PolygonOnTriangulation_get_type_name(*args):
    """
    Poly_PolygonOnTriangulation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Poly.Poly_PolygonOnTriangulation_get_type_name(*args)

def Poly_PolygonOnTriangulation_get_type_descriptor(*args):
    """
    Poly_PolygonOnTriangulation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Poly.Poly_PolygonOnTriangulation_get_type_descriptor(*args)

class Poly_Triangle(object):
    """
    Describes a component triangle of a triangulation
    (Poly_Triangulation object).
    A Triangle is defined by a triplet of nodes. Each node is an
    index in the table of nodes specific to an existing
    triangulation of a shape, and represents a point on the surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Poly_Triangle self) -> Poly_Triangle
        __init__(Poly_Triangle self, Standard_Integer const N1, Standard_Integer const N2, Standard_Integer const N3) -> Poly_Triangle

        Constructs a triangle and sets its three indices
        to N1, N2 and N3 respectively, where these node values
        are indices in the table of nodes specific to an existing
        triangulation of a shape.

        :type N1: int
        :type N2: int
        :type N3: int

        """
        this = _Poly.new_Poly_Triangle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Set(self, *args):
        """
        Set(Poly_Triangle self, Standard_Integer const N1, Standard_Integer const N2, Standard_Integer const N3)
        Set(Poly_Triangle self, Standard_Integer const Index, Standard_Integer const Node)

        Sets the value of  the Indexth node of this triangle to Node.
        Raises OutOfRange if Index is not in 1,2,3

        :type Index: int
        :type Node: int

        """
        return _Poly.Poly_Triangle_Set(self, *args)


    def Get(self, *args):
        """
        Get(Poly_Triangle self)

        Returns the node indices of this triangle in N1, N2 and N3.

        :type N1: int
        :type N2: int
        :type N3: int

        """
        return _Poly.Poly_Triangle_Get(self, *args)


    def Value(self, *args):
        """
        Value(Poly_Triangle self, Standard_Integer const Index) -> Standard_Integer

        Get the node of given Index.
        Raises OutOfRange from Standard if Index is not in 1,2,3

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Poly_Triangle_Value(self, *args)


    def ChangeValue(self, *args):
        """
        ChangeValue(Poly_Triangle self, Standard_Integer const Index) -> Standard_Integer &

        Get the node of given Index.
        Raises OutOfRange if Index is not in 1,2,3

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Poly_Triangle_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        __call__(Poly_Triangle self, Standard_Integer const Index) -> Standard_Integer
        __call__(Poly_Triangle self, Standard_Integer const Index) -> Standard_Integer &

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Poly_Triangle___call__(self, *args)

    __swig_destroy__ = _Poly.delete_Poly_Triangle
Poly_Triangle_swigregister = _Poly.Poly_Triangle_swigregister
Poly_Triangle_swigregister(Poly_Triangle)

class Poly_CoherentNode(gp.gp_XYZ):
    """
    Node of coherent triangulation. Contains:
    <ul>
    <li>Coordinates of a 3D point defining the node location</li>
    <li>2D point coordinates</li>
    <li>List of triangles that use this Node</li>
    <li>Integer index, normally the index of the node in the original
    triangulation</li>
    </ul>
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Poly_CoherentNode self) -> Poly_CoherentNode
        __init__(Poly_CoherentNode self, gp_XYZ thePnt) -> Poly_CoherentNode

        Constructor.

        :type thePnt: OCC.wrapper.gp.gp_XYZ

        """
        this = _Poly.new_Poly_CoherentNode(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetUV(self, *args):
        """
        SetUV(Poly_CoherentNode self, Standard_Real const theU, Standard_Real const theV)

        Set the UV coordinates of the Node.

        :type theU: float
        :type theV: float

        """
        return _Poly.Poly_CoherentNode_SetUV(self, *args)


    def GetU(self, *args):
        """
        GetU(Poly_CoherentNode self) -> Standard_Real

        Get U coordinate of the Node.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Poly.Poly_CoherentNode_GetU(self, *args)


    def GetV(self, *args):
        """
        GetV(Poly_CoherentNode self) -> Standard_Real

        Get V coordinate of the Node.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Poly.Poly_CoherentNode_GetV(self, *args)


    def SetNormal(self, *args):
        """
        SetNormal(Poly_CoherentNode self, gp_XYZ theVector)

        Define the normal vector in the Node.

        :type theVector: OCC.wrapper.gp.gp_XYZ

        """
        return _Poly.Poly_CoherentNode_SetNormal(self, *args)


    def HasNormal(self, *args):
        """
        HasNormal(Poly_CoherentNode self) -> Standard_Boolean

        Query if the Node contains a normal vector.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Poly_CoherentNode_HasNormal(self, *args)


    def GetNormal(self, *args):
        """
        GetNormal(Poly_CoherentNode self) -> gp_XYZ

        Get the stored normal in the node.

        :rtype: OCC.wrapper.gp.gp_XYZ

        """
        return _Poly.Poly_CoherentNode_GetNormal(self, *args)


    def SetIndex(self, *args):
        """
        SetIndex(Poly_CoherentNode self, Standard_Integer const theIndex)

        Set the value of node Index.

        :type theIndex: int

        """
        return _Poly.Poly_CoherentNode_SetIndex(self, *args)


    def GetIndex(self, *args):
        """
        GetIndex(Poly_CoherentNode self) -> Standard_Integer

        Get the value of node Index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Poly_CoherentNode_GetIndex(self, *args)


    def IsFreeNode(self, *args):
        """
        IsFreeNode(Poly_CoherentNode self) -> Standard_Boolean

        Check if this is a free node, i.e., a node without a single
        incident triangle.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Poly_CoherentNode_IsFreeNode(self, *args)


    def Clear(self, *args):
        """
        Clear(Poly_CoherentNode self, Handle_NCollection_BaseAllocator arg2)

        Reset the Node to void.

        :type : OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Poly.Poly_CoherentNode_Clear(self, *args)


    def AddTriangle(self, *args):
        """
        AddTriangle(Poly_CoherentNode self, Poly_CoherentTriangle theTri, Handle_NCollection_BaseAllocator theA)

        Connect a triangle to this Node.

        :type theTri: OCC.wrapper.Poly.Poly_CoherentTriangle
        :type theA: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Poly.Poly_CoherentNode_AddTriangle(self, *args)


    def RemoveTriangle(self, *args):
        """
        RemoveTriangle(Poly_CoherentNode self, Poly_CoherentTriangle theTri, Handle_NCollection_BaseAllocator theA) -> Standard_Boolean

        Disconnect a triangle from this Node.

        :type theTri: OCC.wrapper.Poly.Poly_CoherentTriangle
        :type theA: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Poly_CoherentNode_RemoveTriangle(self, *args)


    def TriangleIterator(self, *args):
        """
        TriangleIterator(Poly_CoherentNode self) -> Poly_CoherentTriPtr::Iterator

        Create an iterator of incident triangles.

        :rtype: OCC.wrapper.Poly.Iterator

        """
        return _Poly.Poly_CoherentNode_TriangleIterator(self, *args)


    def Dump(self, *args):
        """
        Dump(Poly_CoherentNode self, Standard_OStream & theStream)

        :type theStream: OCC.wrapper.Standard.Standard_OStream

        """
        return _Poly.Poly_CoherentNode_Dump(self, *args)

    __swig_destroy__ = _Poly.delete_Poly_CoherentNode
Poly_CoherentNode_swigregister = _Poly.Poly_CoherentNode_swigregister
Poly_CoherentNode_swigregister(Poly_CoherentNode)

class Handle_Poly_CoherentTriangulation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Poly_CoherentTriangulation self)

        Nullify the handle


        """
        return _Poly.Handle_Poly_CoherentTriangulation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Poly_CoherentTriangulation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Poly.Handle_Poly_CoherentTriangulation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Poly_CoherentTriangulation self, Poly_CoherentTriangulation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Poly.Handle_Poly_CoherentTriangulation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Poly_CoherentTriangulation self, Handle_Poly_CoherentTriangulation theHandle) -> Handle_Poly_CoherentTriangulation
        assign(Handle_Poly_CoherentTriangulation self, Poly_CoherentTriangulation thePtr) -> Handle_Poly_CoherentTriangulation
        assign(Handle_Poly_CoherentTriangulation self, Handle_Poly_CoherentTriangulation theHandle) -> Handle_Poly_CoherentTriangulation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Poly.Handle_Poly_CoherentTriangulation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Poly_CoherentTriangulation self) -> Poly_CoherentTriangulation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Poly.Handle_Poly_CoherentTriangulation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Poly_CoherentTriangulation self) -> Poly_CoherentTriangulation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Poly.Handle_Poly_CoherentTriangulation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Poly_CoherentTriangulation self) -> Poly_CoherentTriangulation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Poly.Handle_Poly_CoherentTriangulation___ref__(self, *args)


    def __hash__(self):
        return _Poly.Handle_Poly_CoherentTriangulation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Poly.Handle_Poly_CoherentTriangulation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Poly.new_Handle_Poly_CoherentTriangulation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Poly.Handle_Poly_CoherentTriangulation_DownCast)
    __swig_destroy__ = _Poly.delete_Handle_Poly_CoherentTriangulation

    def GetTriangulation(self, *args):
        """
        GetTriangulation(Handle_Poly_CoherentTriangulation self) -> Handle_Poly_Triangulation

        Create an instance of Poly_Triangulation from this object.

        :rtype: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        return _Poly.Handle_Poly_CoherentTriangulation_GetTriangulation(self, *args)


    def RemoveDegenerated(self, *args):
        """
        RemoveDegenerated(Handle_Poly_CoherentTriangulation self, Standard_Real const theTol, NCollection_List< Poly_CoherentTriangulation::TwoIntegers > * pLstRemovedNode=0) -> Standard_Boolean

        Find and remove degenerated triangles in Triangulation.
        @param theTol
        Tolerance for the degeneration case. If any two nodes of a triangle have
        the distance less than this tolerance, this triangle is considered
        degenerated and therefore removed by this method.
        @param pLstRemovedNode
        Optional parameter. If defined, then it will receive the list of arrays
        where the first number is the index of removed node and the seond -
        the index of remaining node to which the mesh was reconnected.

        :type theTol: float
        :type pLstRemovedNode: OCC.wrapper.Poly.NCollection_List_Poly_CoherentTriangulation::TwoIntegers
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Handle_Poly_CoherentTriangulation_RemoveDegenerated(self, *args)


    def GetFreeNodes(self, *args):
        """
        GetFreeNodes(Handle_Poly_CoherentTriangulation self, NCollection_List_Standard_Integer lstNodes) -> Standard_Boolean

        Create a list of free nodes. These nodes may appear as a result of any
        custom mesh decimation or RemoveDegenerated() call. This analysis is
        necessary if you support additional data structures based on the
        triangulation (e.g., edges on the surface boundary).
        @param lstNodes
        <tt>[out]</tt> List that receives the indices of free nodes.

        :type lstNodes: OCC.wrapper.Poly.NCollection_List_Standard_Integer
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Handle_Poly_CoherentTriangulation_GetFreeNodes(self, *args)


    def MaxNode(self, *args):
        """
        MaxNode(Handle_Poly_CoherentTriangulation self) -> Standard_Integer

        Query the index of the last node in the triangulation

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Handle_Poly_CoherentTriangulation_MaxNode(self, *args)


    def MaxTriangle(self, *args):
        """
        MaxTriangle(Handle_Poly_CoherentTriangulation self) -> Standard_Integer

        Query the index of the last triangle in the triangulation

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Handle_Poly_CoherentTriangulation_MaxTriangle(self, *args)


    def SetDeflection(self, *args):
        """
        SetDeflection(Handle_Poly_CoherentTriangulation self, Standard_Real const theDefl)

        Set the Deflection value as the parameter of the given triangulation.

        :type theDefl: float

        """
        return _Poly.Handle_Poly_CoherentTriangulation_SetDeflection(self, *args)


    def Deflection(self, *args):
        """
        Deflection(Handle_Poly_CoherentTriangulation self) -> Standard_Real

        Query the Deflection parameter (default value 0. -- if never initialized)

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Poly.Handle_Poly_CoherentTriangulation_Deflection(self, *args)


    def SetNode(self, *args):
        """
        SetNode(Handle_Poly_CoherentTriangulation self, gp_XYZ thePnt, Standard_Integer const iN=-1) -> Standard_Integer

        Initialize a node
        @param thePoint
        3D Coordinates of the node.
        @param iN
        Index of the node. If negative (default), the node is added to the
        end of the current array of nodes.
        @return
        Index of the added node.

        :type thePnt: OCC.wrapper.gp.gp_XYZ
        :type iN: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Handle_Poly_CoherentTriangulation_SetNode(self, *args)


    def Node(self, *args):
        """
        Get the node at the given index 'i'.

        :type i: int
        :rtype: OCC.wrapper.Poly.Poly_CoherentNode

        """
        res = _Poly.Handle_Poly_CoherentTriangulation_Node(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeNode(self, *args):
        """
        ChangeNode(Handle_Poly_CoherentTriangulation self, Standard_Integer const i) -> Poly_CoherentNode

        Get the node at the given index 'i'.

        :type i: int
        :rtype: OCC.wrapper.Poly.Poly_CoherentNode

        """
        return _Poly.Handle_Poly_CoherentTriangulation_ChangeNode(self, *args)


    def NNodes(self, *args):
        """
        NNodes(Handle_Poly_CoherentTriangulation self) -> Standard_Integer

        Query the total number of active nodes (i.e. nodes used by 1 or more
        triangles)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Handle_Poly_CoherentTriangulation_NNodes(self, *args)


    def Triangle(self, *args):
        """
        Get the triangle at the given index 'i'.

        :type i: int
        :rtype: OCC.wrapper.Poly.Poly_CoherentTriangle

        """
        res = _Poly.Handle_Poly_CoherentTriangulation_Triangle(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NTriangles(self, *args):
        """
        NTriangles(Handle_Poly_CoherentTriangulation self) -> Standard_Integer

        Query the total number of active triangles (i.e. triangles that refer
        nodes, non-empty ones)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Handle_Poly_CoherentTriangulation_NTriangles(self, *args)


    def NLinks(self, *args):
        """
        NLinks(Handle_Poly_CoherentTriangulation self) -> Standard_Integer

        Query the total number of active Links.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Handle_Poly_CoherentTriangulation_NLinks(self, *args)


    def RemoveTriangle(self, *args):
        """
        RemoveTriangle(Handle_Poly_CoherentTriangulation self, Poly_CoherentTriangle theTr) -> Standard_Boolean

        Removal of a single triangle from the triangulation.

        :type theTr: OCC.wrapper.Poly.Poly_CoherentTriangle
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Handle_Poly_CoherentTriangulation_RemoveTriangle(self, *args)


    def RemoveLink(self, *args):
        """
        RemoveLink(Handle_Poly_CoherentTriangulation self, Poly_CoherentLink theLink)

        Removal of a single link from the triangulation.

        :type theLink: OCC.wrapper.Poly.Poly_CoherentLink

        """
        return _Poly.Handle_Poly_CoherentTriangulation_RemoveLink(self, *args)


    def AddTriangle(self, *args):
        """
        AddTriangle(Handle_Poly_CoherentTriangulation self, Standard_Integer const iNode0, Standard_Integer const iNode1, Standard_Integer const iNode2) -> Poly_CoherentTriangle

        Add a triangle to the triangulation.
        @return
        Pointer to the added triangle instance or NULL if an error occurred.

        :type iNode0: int
        :type iNode1: int
        :type iNode2: int
        :rtype: OCC.wrapper.Poly.Poly_CoherentTriangle

        """
        return _Poly.Handle_Poly_CoherentTriangulation_AddTriangle(self, *args)


    def ReplaceNodes(self, *args):
        """
        ReplaceNodes(Handle_Poly_CoherentTriangulation self, Poly_CoherentTriangle theTriangle, Standard_Integer const iNode0, Standard_Integer const iNode1, Standard_Integer const iNode2) -> Standard_Boolean

        Replace nodes in the given triangle.
        @return
        True if operation succeeded.

        :type theTriangle: OCC.wrapper.Poly.Poly_CoherentTriangle
        :type iNode0: int
        :type iNode1: int
        :type iNode2: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Handle_Poly_CoherentTriangulation_ReplaceNodes(self, *args)


    def AddLink(self, *args):
        """
        AddLink(Handle_Poly_CoherentTriangulation self, Poly_CoherentTriangle theTri, Standard_Integer const theConn) -> Poly_CoherentLink

        Add a single link to triangulation, based on a triangle and its side index.
        This method does not check for coincidence with already present links.
        @param theTri
        Triangle that contains the link to be added.
        @param theConn
        Index of the side (i.e., 0, 1 0r 2) defining the added link.

        :type theTri: OCC.wrapper.Poly.Poly_CoherentTriangle
        :type theConn: int
        :rtype: OCC.wrapper.Poly.Poly_CoherentLink

        """
        return _Poly.Handle_Poly_CoherentTriangulation_AddLink(self, *args)


    def FindTriangle(self, *args):
        """
        FindTriangle(Handle_Poly_CoherentTriangulation self, Poly_CoherentLink theLink, Poly_CoherentTriangle const ** pTri) -> Standard_Boolean

        Find one or two triangles that share the given couple of nodes.
        @param theLink
        Link (in fact, just a couple of nodes) on which the triangle is
        searched.
        @param pTri
        <tt>[out]</tt> Array of two pointers to triangle. pTri[0] stores the
        triangle to the left of the link, while pTri[1] stores the one to the
        right of the link.
        @return
        True if at least one triangle is found and output as pTri.

        :type theLink: OCC.wrapper.Poly.Poly_CoherentLink
        :type pTri: const Poly_CoherentTriangle *[2]
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Handle_Poly_CoherentTriangulation_FindTriangle(self, *args)


    def ComputeLinks(self, *args):
        """
        ComputeLinks(Handle_Poly_CoherentTriangulation self) -> Standard_Integer

        (Re)Calculate all links in this Triangulation.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Handle_Poly_CoherentTriangulation_ComputeLinks(self, *args)


    def ClearLinks(self, *args):
        """
        ClearLinks(Handle_Poly_CoherentTriangulation self)

        Clear all Links data from the Triangulation data.


        """
        return _Poly.Handle_Poly_CoherentTriangulation_ClearLinks(self, *args)


    def Allocator(self, *args):
        """
        Query the allocator of elements, this allocator can be used for other
        objects 

        :rtype: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        res = _Poly.Handle_Poly_CoherentTriangulation_Allocator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clone(self, *args):
        """
        Clone(Handle_Poly_CoherentTriangulation self, Handle_NCollection_BaseAllocator theAlloc) -> Handle_Poly_CoherentTriangulation

        Create a copy of this Triangulation, using the given allocator.

        :type theAlloc: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator
        :rtype: OCC.wrapper.Poly.Handle_Poly_CoherentTriangulation

        """
        return _Poly.Handle_Poly_CoherentTriangulation_Clone(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_Poly_CoherentTriangulation self, Standard_OStream & arg2)

        Debugging output.

        :type : OCC.wrapper.Standard.Standard_OStream

        """
        return _Poly.Handle_Poly_CoherentTriangulation_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Poly_CoherentTriangulation self) -> char const *

        :rtype: const char *

        """
        return _Poly.Handle_Poly_CoherentTriangulation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Poly.Handle_Poly_CoherentTriangulation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Poly.Handle_Poly_CoherentTriangulation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Poly_CoherentTriangulation self)

        Memory deallocator for transient classes


        """
        return _Poly.Handle_Poly_CoherentTriangulation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Poly_CoherentTriangulation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Poly_CoherentTriangulation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Handle_Poly_CoherentTriangulation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Poly_CoherentTriangulation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Poly_CoherentTriangulation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Handle_Poly_CoherentTriangulation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Poly_CoherentTriangulation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Poly.Handle_Poly_CoherentTriangulation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Poly_CoherentTriangulation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Handle_Poly_CoherentTriangulation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Poly_CoherentTriangulation self)

        Increments the reference counter of this object


        """
        return _Poly.Handle_Poly_CoherentTriangulation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Poly_CoherentTriangulation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Handle_Poly_CoherentTriangulation_DecrementRefCounter(self, *args)

Handle_Poly_CoherentTriangulation_swigregister = _Poly.Handle_Poly_CoherentTriangulation_swigregister
Handle_Poly_CoherentTriangulation_swigregister(Handle_Poly_CoherentTriangulation)

def Handle_Poly_CoherentTriangulation_DownCast(thing):
    return _Poly.Handle_Poly_CoherentTriangulation_DownCast(thing)
Handle_Poly_CoherentTriangulation_DownCast = _Poly.Handle_Poly_CoherentTriangulation_DownCast

class Handle_Poly_Polygon3D(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Poly_Polygon3D self)

        Nullify the handle


        """
        return _Poly.Handle_Poly_Polygon3D_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Poly_Polygon3D self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Poly.Handle_Poly_Polygon3D_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Poly_Polygon3D self, Poly_Polygon3D thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Poly.Handle_Poly_Polygon3D_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Poly_Polygon3D self, Handle_Poly_Polygon3D theHandle) -> Handle_Poly_Polygon3D
        assign(Handle_Poly_Polygon3D self, Poly_Polygon3D thePtr) -> Handle_Poly_Polygon3D
        assign(Handle_Poly_Polygon3D self, Handle_Poly_Polygon3D theHandle) -> Handle_Poly_Polygon3D

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Poly.Handle_Poly_Polygon3D_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Poly_Polygon3D self) -> Poly_Polygon3D

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Poly.Handle_Poly_Polygon3D_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Poly_Polygon3D self) -> Poly_Polygon3D

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Poly.Handle_Poly_Polygon3D___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Poly_Polygon3D self) -> Poly_Polygon3D

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Poly.Handle_Poly_Polygon3D___ref__(self, *args)


    def __hash__(self):
        return _Poly.Handle_Poly_Polygon3D___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Poly.Handle_Poly_Polygon3D___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Poly.new_Handle_Poly_Polygon3D(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Poly.Handle_Poly_Polygon3D_DownCast)
    __swig_destroy__ = _Poly.delete_Handle_Poly_Polygon3D

    def Copy(self, *args):
        """
        Copy(Handle_Poly_Polygon3D self) -> Handle_Poly_Polygon3D

        Creates a copy of current polygon

        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon3D

        """
        return _Poly.Handle_Poly_Polygon3D_Copy(self, *args)


    def Deflection(self, *args):
        """
        Deflection(Handle_Poly_Polygon3D self) -> Standard_Real
        Deflection(Handle_Poly_Polygon3D self, Standard_Real const D)

        Sets the deflection of this polygon to D. See more on deflection in Poly_Polygon2D

        :type D: float

        """
        return _Poly.Handle_Poly_Polygon3D_Deflection(self, *args)


    def NbNodes(self, *args):
        """
        NbNodes(Handle_Poly_Polygon3D self) -> Standard_Integer

        Returns the number of nodes in this polygon.
        Note: If the polygon is closed, the point of closure is
        repeated at the end of its table of nodes. Thus, on a closed
        triangle the function NbNodes returns 4.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Handle_Poly_Polygon3D_NbNodes(self, *args)


    def Nodes(self, *args):
        """
        Returns the table of nodes for this polygon.

        :rtype: OCC.wrapper.TColgp.TColgp_Array1OfPnt

        """
        res = _Poly.Handle_Poly_Polygon3D_Nodes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasParameters(self, *args):
        """
        HasParameters(Handle_Poly_Polygon3D self) -> Standard_Boolean

        Returns the table of the parameters associated with each node in this polygon.
        HasParameters function checks if   parameters are associated with the nodes of this polygon.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Handle_Poly_Polygon3D_HasParameters(self, *args)


    def Parameters(self, *args):
        """
        Returns true if parameters are associated with the nodes
        in this polygon.

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _Poly.Handle_Poly_Polygon3D_Parameters(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeParameters(self, *args):
        """
        ChangeParameters(Handle_Poly_Polygon3D self) -> NCollection_Array1_Standard_Real

        Returns the table of the parameters associated with each node in this polygon.
        ChangeParameters function returnes the  array as shared. Therefore if the table is selected by
        reference you can, by simply modifying it, directly modify
        the data structure of this polygon.

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Poly.Handle_Poly_Polygon3D_ChangeParameters(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Poly_Polygon3D self) -> char const *

        :rtype: const char *

        """
        return _Poly.Handle_Poly_Polygon3D_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Poly.Handle_Poly_Polygon3D_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Poly.Handle_Poly_Polygon3D_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Poly_Polygon3D self)

        Memory deallocator for transient classes


        """
        return _Poly.Handle_Poly_Polygon3D_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Poly_Polygon3D self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Poly_Polygon3D self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Handle_Poly_Polygon3D_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Poly_Polygon3D self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Poly_Polygon3D self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Handle_Poly_Polygon3D_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Poly_Polygon3D self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Poly.Handle_Poly_Polygon3D_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Poly_Polygon3D self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Handle_Poly_Polygon3D_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Poly_Polygon3D self)

        Increments the reference counter of this object


        """
        return _Poly.Handle_Poly_Polygon3D_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Poly_Polygon3D self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Handle_Poly_Polygon3D_DecrementRefCounter(self, *args)

Handle_Poly_Polygon3D_swigregister = _Poly.Handle_Poly_Polygon3D_swigregister
Handle_Poly_Polygon3D_swigregister(Handle_Poly_Polygon3D)

def Handle_Poly_Polygon3D_DownCast(thing):
    return _Poly.Handle_Poly_Polygon3D_DownCast(thing)
Handle_Poly_Polygon3D_DownCast = _Poly.Handle_Poly_Polygon3D_DownCast

class Poly_CoherentTriPtr(object):
    """
    Implementation of both list node for Poly_CoherentTriangle type and
    round double-linked list of these nodes. 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def GetTriangle(self, *args):
        """
        Query the stored pointer to Triangle.

        :rtype: OCC.wrapper.Poly.Poly_CoherentTriangle

        """
        res = _Poly.Poly_CoherentTriPtr_GetTriangle(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetTriangle(self, *args):
        """
        SetTriangle(Poly_CoherentTriPtr self, Poly_CoherentTriangle pTri)

        Initialize this instance with a pointer to triangle.

        :type pTri: OCC.wrapper.Poly.Poly_CoherentTriangle

        """
        return _Poly.Poly_CoherentTriPtr_SetTriangle(self, *args)


    def Next(self, *args):
        """
        Next(Poly_CoherentTriPtr self) -> Poly_CoherentTriPtr

        Query the next pointer in the list.

        :rtype: OCC.wrapper.Poly.Poly_CoherentTriPtr

        """
        return _Poly.Poly_CoherentTriPtr_Next(self, *args)


    def Previous(self, *args):
        """
        Previous(Poly_CoherentTriPtr self) -> Poly_CoherentTriPtr

        Query the previous pointer in the list.

        :rtype: OCC.wrapper.Poly.Poly_CoherentTriPtr

        """
        return _Poly.Poly_CoherentTriPtr_Previous(self, *args)


    def Append(self, *args):
        """
        Append(Poly_CoherentTriPtr self, Poly_CoherentTriangle pTri, Handle_NCollection_BaseAllocator theA)

        Append a pointer to triangle into the list after the current instance.
        @param pTri
        Triangle that is to be included in the list after this one.
        @param theA
        Allocator where the new pointer instance is created.

        :type pTri: OCC.wrapper.Poly.Poly_CoherentTriangle
        :type theA: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Poly.Poly_CoherentTriPtr_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(Poly_CoherentTriPtr self, Poly_CoherentTriangle pTri, Handle_NCollection_BaseAllocator theA)

        Prepend a pointer to triangle into the list before the current instance.
        @param pTri
        Triangle that is to be included in the list before this one.
        @param theA
        Allocator where the new pointer instance is created.

        :type pTri: OCC.wrapper.Poly.Poly_CoherentTriangle
        :type theA: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Poly.Poly_CoherentTriPtr_Prepend(self, *args)


    def Remove(*args):
        """
        Remove(Poly_CoherentTriPtr thePtr, Handle_NCollection_BaseAllocator theA)

        Remove a pointer to triangle from its list.
        @param thePtr
        This class instance that should be removed from its list.
        @param theA
        Allocator where the current pointer instance was created.

        :type thePtr: OCC.wrapper.Poly.Poly_CoherentTriPtr
        :type theA: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Poly.Poly_CoherentTriPtr_Remove(*args)

    Remove = staticmethod(Remove)

    def RemoveList(*args):
        """
        RemoveList(Poly_CoherentTriPtr thePtr, Handle_NCollection_BaseAllocator arg2)

        Remove the list containing the given pointer to triangle.

        :type thePtr: OCC.wrapper.Poly.Poly_CoherentTriPtr
        :type : OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Poly.Poly_CoherentTriPtr_RemoveList(*args)

    RemoveList = staticmethod(RemoveList)
Poly_CoherentTriPtr_swigregister = _Poly.Poly_CoherentTriPtr_swigregister
Poly_CoherentTriPtr_swigregister(Poly_CoherentTriPtr)

def Poly_CoherentTriPtr_Remove(*args):
    """
    Poly_CoherentTriPtr_Remove(Poly_CoherentTriPtr thePtr, Handle_NCollection_BaseAllocator theA)

    Remove a pointer to triangle from its list.
    @param thePtr
    This class instance that should be removed from its list.
    @param theA
    Allocator where the current pointer instance was created.

    :type thePtr: OCC.wrapper.Poly.Poly_CoherentTriPtr
    :type theA: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _Poly.Poly_CoherentTriPtr_Remove(*args)

def Poly_CoherentTriPtr_RemoveList(*args):
    """
    Poly_CoherentTriPtr_RemoveList(Poly_CoherentTriPtr thePtr, Handle_NCollection_BaseAllocator arg3)

    Remove the list containing the given pointer to triangle.

    :type thePtr: OCC.wrapper.Poly.Poly_CoherentTriPtr
    :type : OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _Poly.Poly_CoherentTriPtr_RemoveList(*args)

class Poly_MakeLoops2D(Poly_MakeLoops):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Poly_MakeLoops2D self, Standard_Boolean const theLeftWay, Poly_MakeLoops2D::Helper const * theHelper, Handle_NCollection_BaseAllocator theAlloc) -> Poly_MakeLoops2D

        Constructor. If helper is NULL then the algorithm will
        probably return a wrong result

        :type theLeftWay: bool
        :type theHelper: OCC.wrapper.Poly.Helper
        :type theAlloc: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _Poly.new_Poly_MakeLoops2D(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Poly.delete_Poly_MakeLoops2D
Poly_MakeLoops2D_swigregister = _Poly.Poly_MakeLoops2D_swigregister
Poly_MakeLoops2D_swigregister(Poly_MakeLoops2D)

class Poly_Polygon2D(Standard.Standard_Transient):
    """
    Provides a polygon in 2D space (for example, in the
    parametric space of a surface). It is generally an
    approximate representation of a curve.
    A Polygon2D is defined by a table of nodes. Each node is
    a 2D point. If the polygon is closed, the point of closure is
    repeated at the end of the table of nodes.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Poly_Polygon2D
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Poly_Polygon2D(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Poly_Polygon2D self, NCollection_Array1_gp_Pnt2d Nodes) -> Poly_Polygon2D

        Constructs a 2D polygon defined by the table of points, <Nodes>.

        :type Nodes: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d

        """
        this = _Poly.new_Poly_Polygon2D(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Deflection(self, *args):
        """
        Deflection(Poly_Polygon2D self) -> Standard_Real
        Deflection(Poly_Polygon2D self, Standard_Real const D)

        Sets the deflection of this polygon to D

        :type D: float

        """
        return _Poly.Poly_Polygon2D_Deflection(self, *args)


    def NbNodes(self, *args):
        """
        NbNodes(Poly_Polygon2D self) -> Standard_Integer

        Returns the number of nodes in this polygon.
        Note: If the polygon is closed, the point of closure is
        repeated at the end of its table of nodes. Thus, on a closed
        triangle, the function NbNodes returns 4.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Poly_Polygon2D_NbNodes(self, *args)


    def Nodes(self, *args):
        """
        Returns the table of nodes for this polygon.

        :rtype: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d

        """
        res = _Poly.Poly_Polygon2D_Nodes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Poly.Poly_Polygon2D_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Poly.Poly_Polygon2D_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Poly.Poly_Polygon2D_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Poly.delete_Poly_Polygon2D
Poly_Polygon2D_swigregister = _Poly.Poly_Polygon2D_swigregister
Poly_Polygon2D_swigregister(Poly_Polygon2D)

def Poly_Polygon2D_get_type_name(*args):
    """
    Poly_Polygon2D_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Poly.Poly_Polygon2D_get_type_name(*args)

def Poly_Polygon2D_get_type_descriptor(*args):
    """
    Poly_Polygon2D_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Poly.Poly_Polygon2D_get_type_descriptor(*args)

class Poly_MakeLoops3D(Poly_MakeLoops):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Poly_MakeLoops3D self, Poly_MakeLoops3D::Helper const * theHelper, Handle_NCollection_BaseAllocator theAlloc) -> Poly_MakeLoops3D

        Constructor. If helper is NULL then the algorithm will
        probably return a wrong result

        :type theHelper: OCC.wrapper.Poly.Helper
        :type theAlloc: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        this = _Poly.new_Poly_MakeLoops3D(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Poly.delete_Poly_MakeLoops3D
Poly_MakeLoops3D_swigregister = _Poly.Poly_MakeLoops3D_swigregister
Poly_MakeLoops3D_swigregister(Poly_MakeLoops3D)

class Poly_Triangulation(Standard.Standard_Transient):
    """
    Provides a triangulation for a surface, a set of surfaces, or
    more generally a shape.
    A triangulation consists of an approximate representation
    of the actual shape, using a collection of points and
    triangles. The points are located on the surface. The
    edges of the triangles connect adjacent points with a
    straight line that approximates the true curve on the surface.
    A triangulation comprises:
    -   A table of 3D nodes (3D points on the surface).
    -   A table of triangles. Each triangle (Poly_Triangle
    object) comprises a triplet of indices in the table of 3D
    nodes specific to the triangulation.
    -   A table of 2D nodes (2D points), parallel to the table of
    3D nodes. This table is optional. If it exists, the
    coordinates of a 2D point are the (u, v) parameters
    of the corresponding 3D point on the surface
    approximated by the triangulation.
    -   A deflection (optional), which maximizes the distance
    from a point on the surface to the corresponding point
    on its approximate triangulation.
    In many cases, algorithms do not need to work with the
    exact representation of a surface. A triangular
    representation induces simpler and more robust adjusting,
    faster performances, and the results are as good.
    This is a Transient class.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Poly_Triangulation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Poly_Triangulation(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Poly.Poly_Triangulation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Poly.Poly_Triangulation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Poly.Poly_Triangulation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Copy(self, *args):
        """
        Copy(Poly_Triangulation self) -> Handle_Poly_Triangulation

        Creates full copy of current triangulation

        :rtype: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        return _Poly.Poly_Triangulation_Copy(self, *args)


    def __init__(self, *args):
        """
        __init__(Poly_Triangulation self, Standard_Integer const nbNodes, Standard_Integer const nbTriangles, Standard_Boolean const UVNodes) -> Poly_Triangulation
        __init__(Poly_Triangulation self, NCollection_Array1_gp_Pnt Nodes, NCollection_Array1_Poly_Triangle Triangles) -> Poly_Triangulation
        __init__(Poly_Triangulation self, NCollection_Array1_gp_Pnt Nodes, NCollection_Array1_gp_Pnt2d UVNodes, NCollection_Array1_Poly_Triangle Triangles) -> Poly_Triangulation
        __init__(Poly_Triangulation self, Handle_Poly_Triangulation theTriangulation) -> Poly_Triangulation

        Copy constructor for triangulation.

        :type theTriangulation: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        this = _Poly.new_Poly_Triangulation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Deflection(self, *args):
        """
        Deflection(Poly_Triangulation self) -> Standard_Real
        Deflection(Poly_Triangulation self, Standard_Real const theDeflection)

        Sets the deflection of this triangulation to theDeflection.
        See more on deflection in Polygon2D

        :type theDeflection: float

        """
        return _Poly.Poly_Triangulation_Deflection(self, *args)


    def RemoveUVNodes(self, *args):
        """
        RemoveUVNodes(Poly_Triangulation self)

        Deallocates the UV nodes.


        """
        return _Poly.Poly_Triangulation_RemoveUVNodes(self, *args)


    def NbNodes(self, *args):
        """
        NbNodes(Poly_Triangulation self) -> Standard_Integer

        Returns the number of nodes for this triangulation.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Poly_Triangulation_NbNodes(self, *args)


    def NbTriangles(self, *args):
        """
        NbTriangles(Poly_Triangulation self) -> Standard_Integer

        Returns the number of triangles for this triangulation.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Poly_Triangulation_NbTriangles(self, *args)


    def HasUVNodes(self, *args):
        """
        HasUVNodes(Poly_Triangulation self) -> Standard_Boolean

        Returns Standard_True if 2D nodes are associated with 3D nodes for this triangulation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Poly_Triangulation_HasUVNodes(self, *args)


    def Nodes(self, *args):
        """
        Returns the table of 3D nodes (3D points) for this triangulation.

        :rtype: OCC.wrapper.TColgp.TColgp_Array1OfPnt

        """
        res = _Poly.Poly_Triangulation_Nodes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeNodes(self, *args):
        """
        ChangeNodes(Poly_Triangulation self) -> NCollection_Array1_gp_Pnt

        Returns the table of 3D nodes (3D points) for this triangulation.
        The returned array is
        shared. Therefore if the table is selected by reference, you
        can, by simply modifying it, directly modify the data
        structure of this triangulation.

        :rtype: OCC.wrapper.TColgp.TColgp_Array1OfPnt

        """
        return _Poly.Poly_Triangulation_ChangeNodes(self, *args)


    def Node(self, *args):
        """
        Returns node at the given index.
        Raises Standard_OutOfRange exception if theIndex is less than 1 or greater than NbNodes.

        :type theIndex: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Poly.Poly_Triangulation_Node(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeNode(self, *args):
        """
        ChangeNode(Poly_Triangulation self, Standard_Integer const theIndex) -> gp_Pnt

        Give access to the node at the given index.
        Raises Standard_OutOfRange exception if theIndex is less than 1 or greater than NbNodes.

        :type theIndex: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Poly.Poly_Triangulation_ChangeNode(self, *args)


    def UVNodes(self, *args):
        """
        Returns the table of 2D nodes (2D points) associated with
        each 3D node of this triangulation.
        The function HasUVNodes  checks if 2D nodes
        are associated with the 3D nodes of this triangulation.
        Const reference on the 2d nodes values.

        :rtype: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d

        """
        res = _Poly.Poly_Triangulation_UVNodes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeUVNodes(self, *args):
        """
        ChangeUVNodes(Poly_Triangulation self) -> NCollection_Array1_gp_Pnt2d

        Returns the table of 2D nodes (2D points) associated with
        each 3D node of this triangulation.
        Function ChangeUVNodes shares  the returned array.
        Therefore if the table is selected by reference,
        you can, by simply modifying it, directly modify the data
        structure of this triangulation.

        :rtype: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d

        """
        return _Poly.Poly_Triangulation_ChangeUVNodes(self, *args)


    def UVNode(self, *args):
        """
        Returns UVNode at the given index.
        Raises Standard_OutOfRange exception if theIndex is less than 1 or greater than NbNodes.

        :type theIndex: int
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _Poly.Poly_Triangulation_UVNode(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeUVNode(self, *args):
        """
        ChangeUVNode(Poly_Triangulation self, Standard_Integer const theIndex) -> gp_Pnt2d

        Give access to the UVNode at the given index.
        Raises Standard_OutOfRange exception if theIndex is less than 1 or greater than NbNodes.

        :type theIndex: int
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Poly.Poly_Triangulation_ChangeUVNode(self, *args)


    def Triangles(self, *args):
        """
        Returns the table of triangles for this triangulation.

        :rtype: OCC.wrapper.Poly.Poly_Array1OfTriangle

        """
        res = _Poly.Poly_Triangulation_Triangles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeTriangles(self, *args):
        """
        ChangeTriangles(Poly_Triangulation self) -> NCollection_Array1_Poly_Triangle

        Returns the table of triangles for this triangulation.
        Function ChangeUVNodes shares  the returned array.
        Therefore if the table is selected by reference,
        you can, by simply modifying it, directly modify the data
        structure of this triangulation.

        :rtype: OCC.wrapper.Poly.Poly_Array1OfTriangle

        """
        return _Poly.Poly_Triangulation_ChangeTriangles(self, *args)


    def Triangle(self, *args):
        """
        Returns triangle at the given index.
        Raises Standard_OutOfRange exception if theIndex is less than 1 or greater than NbTriangles.

        :type theIndex: int
        :rtype: OCC.wrapper.Poly.Poly_Triangle

        """
        res = _Poly.Poly_Triangulation_Triangle(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeTriangle(self, *args):
        """
        ChangeTriangle(Poly_Triangulation self, Standard_Integer const theIndex) -> Poly_Triangle

        Give access to the triangle at the given index.
        Raises Standard_OutOfRange exception if theIndex is less than 1 or greater than NbTriangles.

        :type theIndex: int
        :rtype: OCC.wrapper.Poly.Poly_Triangle

        """
        return _Poly.Poly_Triangulation_ChangeTriangle(self, *args)


    def SetNormals(self, *args):
        """
        SetNormals(Poly_Triangulation self, Handle_TShort_HArray1OfShortReal theNormals)

        Sets the table of node normals.
        raises exception if length of theNormals != 3*NbNodes

        :type theNormals: OCC.wrapper.TShort.Handle_TShort_HArray1OfShortReal

        """
        return _Poly.Poly_Triangulation_SetNormals(self, *args)


    def Normals(self, *args):
        """
        Returns the table of node normals.

        :rtype: OCC.wrapper.TShort.TShort_Array1OfShortReal

        """
        res = _Poly.Poly_Triangulation_Normals(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeNormals(self, *args):
        """
        ChangeNormals(Poly_Triangulation self) -> NCollection_Array1_Standard_ShortReal

        Gives access to the table of node normals.

        :rtype: OCC.wrapper.TShort.TShort_Array1OfShortReal

        """
        return _Poly.Poly_Triangulation_ChangeNormals(self, *args)


    def HasNormals(self, *args):
        """
        HasNormals(Poly_Triangulation self) -> Standard_Boolean

        Returns Standard_True if nodal normals are defined.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Poly_Triangulation_HasNormals(self, *args)


    def Normal(self, *args):
        """
        Normal(Poly_Triangulation self, Standard_Integer const theIndex) -> gp_Dir

        @return normal at the given index.
        Raises Standard_OutOfRange exception.

        :type theIndex: int
        :rtype: OCC.wrapper.gp.gp_Dir

        """
        return _Poly.Poly_Triangulation_Normal(self, *args)


    def SetNormal(self, *args):
        """
        SetNormal(Poly_Triangulation self, Standard_Integer const theIndex, gp_Dir theNormal)

        Changes normal at the given index.
        Raises Standard_OutOfRange exception.

        :type theIndex: int
        :type theNormal: OCC.wrapper.gp.gp_Dir

        """
        return _Poly.Poly_Triangulation_SetNormal(self, *args)

    __swig_destroy__ = _Poly.delete_Poly_Triangulation
Poly_Triangulation_swigregister = _Poly.Poly_Triangulation_swigregister
Poly_Triangulation_swigregister(Poly_Triangulation)

def Poly_Triangulation_get_type_name(*args):
    """
    Poly_Triangulation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Poly.Poly_Triangulation_get_type_name(*args)

def Poly_Triangulation_get_type_descriptor(*args):
    """
    Poly_Triangulation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Poly.Poly_Triangulation_get_type_descriptor(*args)

class Poly_HArray1OfTriangle(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Poly_HArray1OfTriangle
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Poly_HArray1OfTriangle(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Poly_HArray1OfTriangle self, Standard_Integer const theLower, Standard_Integer const theUpper) -> Poly_HArray1OfTriangle
        __init__(Poly_HArray1OfTriangle self, Standard_Integer const theLower, Standard_Integer const theUpper, Poly_Triangle theValue) -> Poly_HArray1OfTriangle
        __init__(Poly_HArray1OfTriangle self, NCollection_Array1_Poly_Triangle theOther) -> Poly_HArray1OfTriangle

        :type theOther: OCC.wrapper.Poly.Poly_Array1OfTriangle

        """
        this = _Poly.new_Poly_HArray1OfTriangle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Poly_Array1OfTriangle

        """
        res = _Poly.Poly_HArray1OfTriangle_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Poly_HArray1OfTriangle self) -> NCollection_Array1_Poly_Triangle

        :rtype: OCC.wrapper.Poly.Poly_Array1OfTriangle

        """
        return _Poly.Poly_HArray1OfTriangle_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Poly.Poly_HArray1OfTriangle_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Poly.Poly_HArray1OfTriangle_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Poly.Poly_HArray1OfTriangle_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Poly.delete_Poly_HArray1OfTriangle
Poly_HArray1OfTriangle_swigregister = _Poly.Poly_HArray1OfTriangle_swigregister
Poly_HArray1OfTriangle_swigregister(Poly_HArray1OfTriangle)

def Poly_HArray1OfTriangle_get_type_name(*args):
    """
    Poly_HArray1OfTriangle_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Poly.Poly_HArray1OfTriangle_get_type_name(*args)

def Poly_HArray1OfTriangle_get_type_descriptor(*args):
    """
    Poly_HArray1OfTriangle_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Poly.Poly_HArray1OfTriangle_get_type_descriptor(*args)

class Handle_Poly_PolygonOnTriangulation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Poly_PolygonOnTriangulation self)

        Nullify the handle


        """
        return _Poly.Handle_Poly_PolygonOnTriangulation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Poly_PolygonOnTriangulation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Poly.Handle_Poly_PolygonOnTriangulation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Poly_PolygonOnTriangulation self, Poly_PolygonOnTriangulation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Poly.Handle_Poly_PolygonOnTriangulation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Poly_PolygonOnTriangulation self, Handle_Poly_PolygonOnTriangulation theHandle) -> Handle_Poly_PolygonOnTriangulation
        assign(Handle_Poly_PolygonOnTriangulation self, Poly_PolygonOnTriangulation thePtr) -> Handle_Poly_PolygonOnTriangulation
        assign(Handle_Poly_PolygonOnTriangulation self, Handle_Poly_PolygonOnTriangulation theHandle) -> Handle_Poly_PolygonOnTriangulation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Poly.Handle_Poly_PolygonOnTriangulation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Poly_PolygonOnTriangulation self) -> Poly_PolygonOnTriangulation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Poly.Handle_Poly_PolygonOnTriangulation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Poly_PolygonOnTriangulation self) -> Poly_PolygonOnTriangulation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Poly.Handle_Poly_PolygonOnTriangulation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Poly_PolygonOnTriangulation self) -> Poly_PolygonOnTriangulation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Poly.Handle_Poly_PolygonOnTriangulation___ref__(self, *args)


    def __hash__(self):
        return _Poly.Handle_Poly_PolygonOnTriangulation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Poly.Handle_Poly_PolygonOnTriangulation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Poly.new_Handle_Poly_PolygonOnTriangulation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Poly.Handle_Poly_PolygonOnTriangulation_DownCast)
    __swig_destroy__ = _Poly.delete_Handle_Poly_PolygonOnTriangulation

    def Copy(self, *args):
        """
        Copy(Handle_Poly_PolygonOnTriangulation self) -> Handle_Poly_PolygonOnTriangulation

        Creates a copy of current polygon

        :rtype: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation

        """
        return _Poly.Handle_Poly_PolygonOnTriangulation_Copy(self, *args)


    def Deflection(self, *args):
        """
        Deflection(Handle_Poly_PolygonOnTriangulation self) -> Standard_Real
        Deflection(Handle_Poly_PolygonOnTriangulation self, Standard_Real const D)

        Sets the deflection of this polygon to D.
        See more on deflection in Poly_Polygones2D.

        :type D: float

        """
        return _Poly.Handle_Poly_PolygonOnTriangulation_Deflection(self, *args)


    def NbNodes(self, *args):
        """
        NbNodes(Handle_Poly_PolygonOnTriangulation self) -> Standard_Integer

        Returns the number of nodes for this polygon.
        Note: If the polygon is closed, the point of closure is
        repeated at the end of its table of nodes. Thus, on a closed
        triangle, the function NbNodes returns 4.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Handle_Poly_PolygonOnTriangulation_NbNodes(self, *args)


    def Nodes(self, *args):
        """
        Returns the table of nodes for this polygon. A node value
        is an index in the table of nodes specific to an existing
        triangulation of a shape.

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        res = _Poly.Handle_Poly_PolygonOnTriangulation_Nodes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasParameters(self, *args):
        """
        HasParameters(Handle_Poly_PolygonOnTriangulation self) -> Standard_Boolean

        Returns true if parameters are associated with the nodes in this polygon.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Handle_Poly_PolygonOnTriangulation_HasParameters(self, *args)


    def Parameters(self, *args):
        """
        Parameters(Handle_Poly_PolygonOnTriangulation self) -> Handle_TColStd_HArray1OfReal

        Returns the table of the parameters associated with each node in this polygon.
        Warning
        Use the function HasParameters to check if parameters
        are associated with the nodes in this polygon.

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _Poly.Handle_Poly_PolygonOnTriangulation_Parameters(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Poly_PolygonOnTriangulation self) -> char const *

        :rtype: const char *

        """
        return _Poly.Handle_Poly_PolygonOnTriangulation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Poly.Handle_Poly_PolygonOnTriangulation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Poly.Handle_Poly_PolygonOnTriangulation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Poly_PolygonOnTriangulation self)

        Memory deallocator for transient classes


        """
        return _Poly.Handle_Poly_PolygonOnTriangulation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Poly_PolygonOnTriangulation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Poly_PolygonOnTriangulation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Handle_Poly_PolygonOnTriangulation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Poly_PolygonOnTriangulation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Poly_PolygonOnTriangulation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Handle_Poly_PolygonOnTriangulation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Poly_PolygonOnTriangulation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Poly.Handle_Poly_PolygonOnTriangulation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Poly_PolygonOnTriangulation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Handle_Poly_PolygonOnTriangulation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Poly_PolygonOnTriangulation self)

        Increments the reference counter of this object


        """
        return _Poly.Handle_Poly_PolygonOnTriangulation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Poly_PolygonOnTriangulation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Handle_Poly_PolygonOnTriangulation_DecrementRefCounter(self, *args)

Handle_Poly_PolygonOnTriangulation_swigregister = _Poly.Handle_Poly_PolygonOnTriangulation_swigregister
Handle_Poly_PolygonOnTriangulation_swigregister(Handle_Poly_PolygonOnTriangulation)

def Handle_Poly_PolygonOnTriangulation_DownCast(thing):
    return _Poly.Handle_Poly_PolygonOnTriangulation_DownCast(thing)
Handle_Poly_PolygonOnTriangulation_DownCast = _Poly.Handle_Poly_PolygonOnTriangulation_DownCast

class NCollection_List_Handle_Poly_Triangulation(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_Handle_Poly_Triangulation self) -> NCollection_List< opencascade::handle< Poly_Triangulation > >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _Poly.NCollection_List_Handle_Poly_Triangulation_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_Handle_Poly_Triangulation self) -> NCollection_List< opencascade::handle< Poly_Triangulation > >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _Poly.NCollection_List_Handle_Poly_Triangulation_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_Handle_Poly_Triangulation self) -> NCollection_List< opencascade::handle< Poly_Triangulation > >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _Poly.NCollection_List_Handle_Poly_Triangulation_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_Handle_Poly_Triangulation self) -> NCollection_List< opencascade::handle< Poly_Triangulation > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _Poly.NCollection_List_Handle_Poly_Triangulation_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _Poly.new_NCollection_List_Handle_Poly_Triangulation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_Handle_Poly_Triangulation self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.NCollection_List_Handle_Poly_Triangulation_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_Handle_Poly_Triangulation self, NCollection_List_Handle_Poly_Triangulation theOther) -> NCollection_List_Handle_Poly_Triangulation

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _Poly.NCollection_List_Handle_Poly_Triangulation_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_Handle_Poly_Triangulation self, NCollection_List_Handle_Poly_Triangulation theOther) -> NCollection_List_Handle_Poly_Triangulation

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _Poly.NCollection_List_Handle_Poly_Triangulation_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_Handle_Poly_Triangulation self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _Poly.NCollection_List_Handle_Poly_Triangulation_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _Poly.NCollection_List_Handle_Poly_Triangulation_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _Poly.NCollection_List_Handle_Poly_Triangulation_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_Handle_Poly_Triangulation self, Handle_Poly_Triangulation theItem) -> Handle_Poly_Triangulation
        Append(NCollection_List_Handle_Poly_Triangulation self, Handle_Poly_Triangulation theItem, NCollection_List< opencascade::handle< Poly_Triangulation > >::Iterator & theIter)
        Append(NCollection_List_Handle_Poly_Triangulation self, NCollection_List_Handle_Poly_Triangulation theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _Poly.NCollection_List_Handle_Poly_Triangulation_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_Handle_Poly_Triangulation self, Handle_Poly_Triangulation theItem) -> Handle_Poly_Triangulation
        Prepend(NCollection_List_Handle_Poly_Triangulation self, NCollection_List_Handle_Poly_Triangulation theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _Poly.NCollection_List_Handle_Poly_Triangulation_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_Handle_Poly_Triangulation self)

        RemoveFirst item


        """
        return _Poly.NCollection_List_Handle_Poly_Triangulation_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_Handle_Poly_Triangulation self, NCollection_List< opencascade::handle< Poly_Triangulation > >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _Poly.NCollection_List_Handle_Poly_Triangulation_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_Handle_Poly_Triangulation self, Handle_Poly_Triangulation theItem, NCollection_List< opencascade::handle< Poly_Triangulation > >::Iterator & theIter) -> Handle_Poly_Triangulation
        InsertBefore(NCollection_List_Handle_Poly_Triangulation self, NCollection_List_Handle_Poly_Triangulation theOther, NCollection_List< opencascade::handle< Poly_Triangulation > >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _Poly.NCollection_List_Handle_Poly_Triangulation_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_Handle_Poly_Triangulation self, Handle_Poly_Triangulation theItem, NCollection_List< opencascade::handle< Poly_Triangulation > >::Iterator & theIter) -> Handle_Poly_Triangulation
        InsertAfter(NCollection_List_Handle_Poly_Triangulation self, NCollection_List_Handle_Poly_Triangulation theOther, NCollection_List< opencascade::handle< Poly_Triangulation > >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _Poly.NCollection_List_Handle_Poly_Triangulation_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_Handle_Poly_Triangulation self)

        Reverse the list


        """
        return _Poly.NCollection_List_Handle_Poly_Triangulation_Reverse(self, *args)


    def __iter__(self):
        return _Poly.NCollection_List_Handle_Poly_Triangulation___iter__(self)
    __swig_destroy__ = _Poly.delete_NCollection_List_Handle_Poly_Triangulation
NCollection_List_Handle_Poly_Triangulation_swigregister = _Poly.NCollection_List_Handle_Poly_Triangulation_swigregister
NCollection_List_Handle_Poly_Triangulation_swigregister(NCollection_List_Handle_Poly_Triangulation)

class NCollection_List_Handle_Poly_Triangulation_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Poly.new_NCollection_List_Handle_Poly_Triangulation_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Poly.delete_NCollection_List_Handle_Poly_Triangulation_IteratorHelper

    def __next__(self):
        return _Poly.NCollection_List_Handle_Poly_Triangulation_IteratorHelper___next__(self)
NCollection_List_Handle_Poly_Triangulation_IteratorHelper_swigregister = _Poly.NCollection_List_Handle_Poly_Triangulation_IteratorHelper_swigregister
NCollection_List_Handle_Poly_Triangulation_IteratorHelper_swigregister(NCollection_List_Handle_Poly_Triangulation_IteratorHelper)


try:
	Poly_ListOfTriangulation = NCollection_List_Handle_Poly_Triangulation
except NameError:
	pass # does not exist, probably ignored

class Handle_Poly_Polygon2D(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Poly_Polygon2D self)

        Nullify the handle


        """
        return _Poly.Handle_Poly_Polygon2D_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Poly_Polygon2D self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Poly.Handle_Poly_Polygon2D_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Poly_Polygon2D self, Poly_Polygon2D thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Poly.Handle_Poly_Polygon2D_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Poly_Polygon2D self, Handle_Poly_Polygon2D theHandle) -> Handle_Poly_Polygon2D
        assign(Handle_Poly_Polygon2D self, Poly_Polygon2D thePtr) -> Handle_Poly_Polygon2D
        assign(Handle_Poly_Polygon2D self, Handle_Poly_Polygon2D theHandle) -> Handle_Poly_Polygon2D

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Poly.Handle_Poly_Polygon2D_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Poly_Polygon2D self) -> Poly_Polygon2D

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Poly.Handle_Poly_Polygon2D_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Poly_Polygon2D self) -> Poly_Polygon2D

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Poly.Handle_Poly_Polygon2D___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Poly_Polygon2D self) -> Poly_Polygon2D

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Poly.Handle_Poly_Polygon2D___ref__(self, *args)


    def __hash__(self):
        return _Poly.Handle_Poly_Polygon2D___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Poly.Handle_Poly_Polygon2D___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Poly.new_Handle_Poly_Polygon2D(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Poly.Handle_Poly_Polygon2D_DownCast)
    __swig_destroy__ = _Poly.delete_Handle_Poly_Polygon2D

    def Deflection(self, *args):
        """
        Deflection(Handle_Poly_Polygon2D self) -> Standard_Real
        Deflection(Handle_Poly_Polygon2D self, Standard_Real const D)

        Sets the deflection of this polygon to D

        :type D: float

        """
        return _Poly.Handle_Poly_Polygon2D_Deflection(self, *args)


    def NbNodes(self, *args):
        """
        NbNodes(Handle_Poly_Polygon2D self) -> Standard_Integer

        Returns the number of nodes in this polygon.
        Note: If the polygon is closed, the point of closure is
        repeated at the end of its table of nodes. Thus, on a closed
        triangle, the function NbNodes returns 4.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Handle_Poly_Polygon2D_NbNodes(self, *args)


    def Nodes(self, *args):
        """
        Returns the table of nodes for this polygon.

        :rtype: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d

        """
        res = _Poly.Handle_Poly_Polygon2D_Nodes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_Poly_Polygon2D self) -> char const *

        :rtype: const char *

        """
        return _Poly.Handle_Poly_Polygon2D_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Poly.Handle_Poly_Polygon2D_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Poly.Handle_Poly_Polygon2D_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Poly_Polygon2D self)

        Memory deallocator for transient classes


        """
        return _Poly.Handle_Poly_Polygon2D_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Poly_Polygon2D self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Poly_Polygon2D self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Handle_Poly_Polygon2D_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Poly_Polygon2D self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Poly_Polygon2D self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Handle_Poly_Polygon2D_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Poly_Polygon2D self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Poly.Handle_Poly_Polygon2D_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Poly_Polygon2D self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Handle_Poly_Polygon2D_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Poly_Polygon2D self)

        Increments the reference counter of this object


        """
        return _Poly.Handle_Poly_Polygon2D_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Poly_Polygon2D self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Handle_Poly_Polygon2D_DecrementRefCounter(self, *args)

Handle_Poly_Polygon2D_swigregister = _Poly.Handle_Poly_Polygon2D_swigregister
Handle_Poly_Polygon2D_swigregister(Handle_Poly_Polygon2D)

def Handle_Poly_Polygon2D_DownCast(thing):
    return _Poly.Handle_Poly_Polygon2D_DownCast(thing)
Handle_Poly_Polygon2D_DownCast = _Poly.Handle_Poly_Polygon2D_DownCast

class NCollection_Array1_Poly_Triangle(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Poly_Triangle self) -> NCollection_Array1< Poly_Triangle >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _Poly.NCollection_Array1_Poly_Triangle_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Poly_Triangle self) -> NCollection_Array1< Poly_Triangle >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _Poly.NCollection_Array1_Poly_Triangle_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Poly_Triangle self) -> NCollection_Array1< Poly_Triangle >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _Poly.NCollection_Array1_Poly_Triangle_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Poly_Triangle self) -> NCollection_Array1< Poly_Triangle >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _Poly.NCollection_Array1_Poly_Triangle_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _Poly.new_NCollection_Array1_Poly_Triangle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Poly_Triangle self, Poly_Triangle theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _Poly.NCollection_Array1_Poly_Triangle_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Poly_Triangle self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.NCollection_Array1_Poly_Triangle_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Poly_Triangle self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.NCollection_Array1_Poly_Triangle_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Poly_Triangle self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.NCollection_Array1_Poly_Triangle_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Poly_Triangle self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.NCollection_Array1_Poly_Triangle_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Poly_Triangle self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.NCollection_Array1_Poly_Triangle_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Poly_Triangle self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.NCollection_Array1_Poly_Triangle_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Poly_Triangle self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.NCollection_Array1_Poly_Triangle_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Poly_Triangle self, NCollection_Array1_Poly_Triangle theOther) -> NCollection_Array1_Poly_Triangle

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Poly.NCollection_Array1_Poly_Triangle_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Poly_Triangle self, NCollection_Array1_Poly_Triangle theOther) -> NCollection_Array1_Poly_Triangle

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Poly.NCollection_Array1_Poly_Triangle_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Poly_Triangle self, NCollection_Array1_Poly_Triangle theOther) -> NCollection_Array1_Poly_Triangle
        assign(NCollection_Array1_Poly_Triangle self, NCollection_Array1_Poly_Triangle theOther) -> NCollection_Array1_Poly_Triangle

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _Poly.NCollection_Array1_Poly_Triangle_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _Poly.NCollection_Array1_Poly_Triangle_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Poly_Triangle self) -> Poly_Triangle

        @return first element

        :rtype: TheItemType &

        """
        return _Poly.NCollection_Array1_Poly_Triangle_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _Poly.NCollection_Array1_Poly_Triangle_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Poly_Triangle self) -> Poly_Triangle

        @return last element

        :rtype: TheItemType &

        """
        return _Poly.NCollection_Array1_Poly_Triangle_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Poly.NCollection_Array1_Poly_Triangle_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Poly_Triangle self, Standard_Integer const theIndex) -> Poly_Triangle

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _Poly.NCollection_Array1_Poly_Triangle_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Poly.NCollection_Array1_Poly_Triangle___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _Poly.NCollection_Array1_Poly_Triangle_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Poly_Triangle self, Standard_Integer const theIndex, Poly_Triangle theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _Poly.NCollection_Array1_Poly_Triangle_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Poly_Triangle self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _Poly.NCollection_Array1_Poly_Triangle_Resize(self, *args)

    __swig_destroy__ = _Poly.delete_NCollection_Array1_Poly_Triangle
NCollection_Array1_Poly_Triangle_swigregister = _Poly.NCollection_Array1_Poly_Triangle_swigregister
NCollection_Array1_Poly_Triangle_swigregister(NCollection_Array1_Poly_Triangle)


try:
	Poly_Array1OfTriangle = NCollection_Array1_Poly_Triangle
except NameError:
	pass # does not exist, probably ignored

class NCollection_List_Poly_MakeLoops_Link_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _Poly.new_NCollection_List_Poly_MakeLoops_Link_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Poly.delete_NCollection_List_Poly_MakeLoops_Link_IteratorHelper

    def __next__(self):
        return _Poly.NCollection_List_Poly_MakeLoops_Link_IteratorHelper___next__(self)
NCollection_List_Poly_MakeLoops_Link_IteratorHelper_swigregister = _Poly.NCollection_List_Poly_MakeLoops_Link_IteratorHelper_swigregister
NCollection_List_Poly_MakeLoops_Link_IteratorHelper_swigregister(NCollection_List_Poly_MakeLoops_Link_IteratorHelper)


try:
	ListOfLink = NCollection_List_Poly_MakeLoops_Link
except NameError:
	pass # does not exist, probably ignored

class Poly_CoherentTriangle(object):
    """
    Data class used in Poly_CoherentTriangultion.
    Implements a triangle with references to its neighbours.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Poly_CoherentTriangle self) -> Poly_CoherentTriangle
        __init__(Poly_CoherentTriangle self, Standard_Integer const iNode0, Standard_Integer const iNode1, Standard_Integer const iNode2) -> Poly_CoherentTriangle

        Constructor.

        :type iNode0: int
        :type iNode1: int
        :type iNode2: int

        """
        this = _Poly.new_Poly_CoherentTriangle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Node(self, *args):
        """
        Node(Poly_CoherentTriangle self, Standard_Integer const ind) -> Standard_Integer

        Query the node index in the position given by the parameter 'ind'

        :type ind: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Poly_CoherentTriangle_Node(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Poly_CoherentTriangle self) -> Standard_Boolean

        Query if this is a valid triangle.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Poly_CoherentTriangle_IsEmpty(self, *args)


    def SetConnection(self, *args):
        """
        SetConnection(Poly_CoherentTriangle self, Standard_Integer const iConn, Poly_CoherentTriangle theTr) -> Standard_Boolean
        SetConnection(Poly_CoherentTriangle self, Poly_CoherentTriangle theTri) -> Standard_Boolean

        Create connection with another triangle theTri.
        This method creates both connections: in this triangle and in theTri.
        This method is slower than the previous one, because it makes analysis
        what sides of both triangles are connected.
        @param theTri
        Triangle that is connected.
        @return
        True if successful, False if the connection is rejected
        due to improper topology.

        :type theTri: OCC.wrapper.Poly.Poly_CoherentTriangle
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Poly_CoherentTriangle_SetConnection(self, *args)


    def RemoveConnection(self, *args):
        """
        RemoveConnection(Poly_CoherentTriangle self, Standard_Integer const iConn)
        RemoveConnection(Poly_CoherentTriangle self, Poly_CoherentTriangle theTri) -> Standard_Boolean

        Remove the connection with the given Triangle.
        @return
        True if successfuol or False if the connection has not been found.

        :type theTri: OCC.wrapper.Poly.Poly_CoherentTriangle
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Poly_CoherentTriangle_RemoveConnection(self, *args)


    def NConnections(self, *args):
        """
        NConnections(Poly_CoherentTriangle self) -> Standard_Integer

        Query the number of connected triangles.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Poly_CoherentTriangle_NConnections(self, *args)


    def GetConnectedNode(self, *args):
        """
        GetConnectedNode(Poly_CoherentTriangle self, Standard_Integer const iConn) -> Standard_Integer

        Query the connected node on the given side.
        Returns -1 if there is no connection on the specified side.

        :type iConn: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Poly_CoherentTriangle_GetConnectedNode(self, *args)


    def GetConnectedTri(self, *args):
        """
        GetConnectedTri(Poly_CoherentTriangle self, Standard_Integer const iConn) -> Poly_CoherentTriangle

        Query the connected triangle on the given side.
        Returns NULL if there is no connection on the specified side.

        :type iConn: int
        :rtype: OCC.wrapper.Poly.Poly_CoherentTriangle

        """
        return _Poly.Poly_CoherentTriangle_GetConnectedTri(self, *args)


    def GetLink(self, *args):
        """
        GetLink(Poly_CoherentTriangle self, Standard_Integer const iLink) -> Poly_CoherentLink

        Query the Link associate with the given side of the Triangle.
        May return NULL if there are no links in the triangulation.

        :type iLink: int
        :rtype: OCC.wrapper.Poly.Poly_CoherentLink

        """
        return _Poly.Poly_CoherentTriangle_GetLink(self, *args)


    def FindConnection(self, *args):
        """
        FindConnection(Poly_CoherentTriangle self, Poly_CoherentTriangle arg2) -> Standard_Integer

        Retuns the index of the connection with the given triangle, or -1 if not
        found.

        :type : OCC.wrapper.Poly.Poly_CoherentTriangle
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Poly_CoherentTriangle_FindConnection(self, *args)

    __swig_destroy__ = _Poly.delete_Poly_CoherentTriangle
Poly_CoherentTriangle_swigregister = _Poly.Poly_CoherentTriangle_swigregister
Poly_CoherentTriangle_swigregister(Poly_CoherentTriangle)

class Handle_Poly_Triangulation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Poly_Triangulation self)

        Nullify the handle


        """
        return _Poly.Handle_Poly_Triangulation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Poly_Triangulation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Poly.Handle_Poly_Triangulation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Poly_Triangulation self, Poly_Triangulation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Poly.Handle_Poly_Triangulation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Poly_Triangulation self, Handle_Poly_Triangulation theHandle) -> Handle_Poly_Triangulation
        assign(Handle_Poly_Triangulation self, Poly_Triangulation thePtr) -> Handle_Poly_Triangulation
        assign(Handle_Poly_Triangulation self, Handle_Poly_Triangulation theHandle) -> Handle_Poly_Triangulation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Poly.Handle_Poly_Triangulation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Poly_Triangulation self) -> Poly_Triangulation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Poly.Handle_Poly_Triangulation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Poly_Triangulation self) -> Poly_Triangulation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Poly.Handle_Poly_Triangulation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Poly_Triangulation self) -> Poly_Triangulation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Poly.Handle_Poly_Triangulation___ref__(self, *args)


    def __hash__(self):
        return _Poly.Handle_Poly_Triangulation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Poly.Handle_Poly_Triangulation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Poly.new_Handle_Poly_Triangulation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Poly.Handle_Poly_Triangulation_DownCast)
    __swig_destroy__ = _Poly.delete_Handle_Poly_Triangulation

    def get_type_name(self, *args):
        """
        get_type_name(Handle_Poly_Triangulation self) -> char const *

        :rtype: const char *

        """
        return _Poly.Handle_Poly_Triangulation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Poly.Handle_Poly_Triangulation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Poly.Handle_Poly_Triangulation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Copy(self, *args):
        """
        Copy(Handle_Poly_Triangulation self) -> Handle_Poly_Triangulation

        Creates full copy of current triangulation

        :rtype: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        return _Poly.Handle_Poly_Triangulation_Copy(self, *args)


    def Deflection(self, *args):
        """
        Deflection(Handle_Poly_Triangulation self) -> Standard_Real
        Deflection(Handle_Poly_Triangulation self, Standard_Real const theDeflection)

        Sets the deflection of this triangulation to theDeflection.
        See more on deflection in Polygon2D

        :type theDeflection: float

        """
        return _Poly.Handle_Poly_Triangulation_Deflection(self, *args)


    def RemoveUVNodes(self, *args):
        """
        RemoveUVNodes(Handle_Poly_Triangulation self)

        Deallocates the UV nodes.


        """
        return _Poly.Handle_Poly_Triangulation_RemoveUVNodes(self, *args)


    def NbNodes(self, *args):
        """
        NbNodes(Handle_Poly_Triangulation self) -> Standard_Integer

        Returns the number of nodes for this triangulation.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Handle_Poly_Triangulation_NbNodes(self, *args)


    def NbTriangles(self, *args):
        """
        NbTriangles(Handle_Poly_Triangulation self) -> Standard_Integer

        Returns the number of triangles for this triangulation.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Handle_Poly_Triangulation_NbTriangles(self, *args)


    def HasUVNodes(self, *args):
        """
        HasUVNodes(Handle_Poly_Triangulation self) -> Standard_Boolean

        Returns Standard_True if 2D nodes are associated with 3D nodes for this triangulation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Handle_Poly_Triangulation_HasUVNodes(self, *args)


    def Nodes(self, *args):
        """
        Returns the table of 3D nodes (3D points) for this triangulation.

        :rtype: OCC.wrapper.TColgp.TColgp_Array1OfPnt

        """
        res = _Poly.Handle_Poly_Triangulation_Nodes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeNodes(self, *args):
        """
        ChangeNodes(Handle_Poly_Triangulation self) -> NCollection_Array1_gp_Pnt

        Returns the table of 3D nodes (3D points) for this triangulation.
        The returned array is
        shared. Therefore if the table is selected by reference, you
        can, by simply modifying it, directly modify the data
        structure of this triangulation.

        :rtype: OCC.wrapper.TColgp.TColgp_Array1OfPnt

        """
        return _Poly.Handle_Poly_Triangulation_ChangeNodes(self, *args)


    def Node(self, *args):
        """
        Returns node at the given index.
        Raises Standard_OutOfRange exception if theIndex is less than 1 or greater than NbNodes.

        :type theIndex: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _Poly.Handle_Poly_Triangulation_Node(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeNode(self, *args):
        """
        ChangeNode(Handle_Poly_Triangulation self, Standard_Integer const theIndex) -> gp_Pnt

        Give access to the node at the given index.
        Raises Standard_OutOfRange exception if theIndex is less than 1 or greater than NbNodes.

        :type theIndex: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _Poly.Handle_Poly_Triangulation_ChangeNode(self, *args)


    def UVNodes(self, *args):
        """
        Returns the table of 2D nodes (2D points) associated with
        each 3D node of this triangulation.
        The function HasUVNodes  checks if 2D nodes
        are associated with the 3D nodes of this triangulation.
        Const reference on the 2d nodes values.

        :rtype: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d

        """
        res = _Poly.Handle_Poly_Triangulation_UVNodes(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeUVNodes(self, *args):
        """
        ChangeUVNodes(Handle_Poly_Triangulation self) -> NCollection_Array1_gp_Pnt2d

        Returns the table of 2D nodes (2D points) associated with
        each 3D node of this triangulation.
        Function ChangeUVNodes shares  the returned array.
        Therefore if the table is selected by reference,
        you can, by simply modifying it, directly modify the data
        structure of this triangulation.

        :rtype: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d

        """
        return _Poly.Handle_Poly_Triangulation_ChangeUVNodes(self, *args)


    def UVNode(self, *args):
        """
        Returns UVNode at the given index.
        Raises Standard_OutOfRange exception if theIndex is less than 1 or greater than NbNodes.

        :type theIndex: int
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        res = _Poly.Handle_Poly_Triangulation_UVNode(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeUVNode(self, *args):
        """
        ChangeUVNode(Handle_Poly_Triangulation self, Standard_Integer const theIndex) -> gp_Pnt2d

        Give access to the UVNode at the given index.
        Raises Standard_OutOfRange exception if theIndex is less than 1 or greater than NbNodes.

        :type theIndex: int
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Poly.Handle_Poly_Triangulation_ChangeUVNode(self, *args)


    def Triangles(self, *args):
        """
        Returns the table of triangles for this triangulation.

        :rtype: OCC.wrapper.Poly.Poly_Array1OfTriangle

        """
        res = _Poly.Handle_Poly_Triangulation_Triangles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeTriangles(self, *args):
        """
        ChangeTriangles(Handle_Poly_Triangulation self) -> NCollection_Array1_Poly_Triangle

        Returns the table of triangles for this triangulation.
        Function ChangeUVNodes shares  the returned array.
        Therefore if the table is selected by reference,
        you can, by simply modifying it, directly modify the data
        structure of this triangulation.

        :rtype: OCC.wrapper.Poly.Poly_Array1OfTriangle

        """
        return _Poly.Handle_Poly_Triangulation_ChangeTriangles(self, *args)


    def Triangle(self, *args):
        """
        Returns triangle at the given index.
        Raises Standard_OutOfRange exception if theIndex is less than 1 or greater than NbTriangles.

        :type theIndex: int
        :rtype: OCC.wrapper.Poly.Poly_Triangle

        """
        res = _Poly.Handle_Poly_Triangulation_Triangle(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeTriangle(self, *args):
        """
        ChangeTriangle(Handle_Poly_Triangulation self, Standard_Integer const theIndex) -> Poly_Triangle

        Give access to the triangle at the given index.
        Raises Standard_OutOfRange exception if theIndex is less than 1 or greater than NbTriangles.

        :type theIndex: int
        :rtype: OCC.wrapper.Poly.Poly_Triangle

        """
        return _Poly.Handle_Poly_Triangulation_ChangeTriangle(self, *args)


    def SetNormals(self, *args):
        """
        SetNormals(Handle_Poly_Triangulation self, Handle_TShort_HArray1OfShortReal theNormals)

        Sets the table of node normals.
        raises exception if length of theNormals != 3*NbNodes

        :type theNormals: OCC.wrapper.TShort.Handle_TShort_HArray1OfShortReal

        """
        return _Poly.Handle_Poly_Triangulation_SetNormals(self, *args)


    def Normals(self, *args):
        """
        Returns the table of node normals.

        :rtype: OCC.wrapper.TShort.TShort_Array1OfShortReal

        """
        res = _Poly.Handle_Poly_Triangulation_Normals(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeNormals(self, *args):
        """
        ChangeNormals(Handle_Poly_Triangulation self) -> NCollection_Array1_Standard_ShortReal

        Gives access to the table of node normals.

        :rtype: OCC.wrapper.TShort.TShort_Array1OfShortReal

        """
        return _Poly.Handle_Poly_Triangulation_ChangeNormals(self, *args)


    def HasNormals(self, *args):
        """
        HasNormals(Handle_Poly_Triangulation self) -> Standard_Boolean

        Returns Standard_True if nodal normals are defined.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Handle_Poly_Triangulation_HasNormals(self, *args)


    def Normal(self, *args):
        """
        Normal(Handle_Poly_Triangulation self, Standard_Integer const theIndex) -> gp_Dir

        @return normal at the given index.
        Raises Standard_OutOfRange exception.

        :type theIndex: int
        :rtype: OCC.wrapper.gp.gp_Dir

        """
        return _Poly.Handle_Poly_Triangulation_Normal(self, *args)


    def SetNormal(self, *args):
        """
        SetNormal(Handle_Poly_Triangulation self, Standard_Integer const theIndex, gp_Dir theNormal)

        Changes normal at the given index.
        Raises Standard_OutOfRange exception.

        :type theIndex: int
        :type theNormal: OCC.wrapper.gp.gp_Dir

        """
        return _Poly.Handle_Poly_Triangulation_SetNormal(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Poly_Triangulation self)

        Memory deallocator for transient classes


        """
        return _Poly.Handle_Poly_Triangulation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Poly_Triangulation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Poly_Triangulation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Handle_Poly_Triangulation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Poly_Triangulation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Poly_Triangulation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Handle_Poly_Triangulation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Poly_Triangulation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Poly.Handle_Poly_Triangulation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Poly_Triangulation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Handle_Poly_Triangulation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Poly_Triangulation self)

        Increments the reference counter of this object


        """
        return _Poly.Handle_Poly_Triangulation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Poly_Triangulation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Handle_Poly_Triangulation_DecrementRefCounter(self, *args)

Handle_Poly_Triangulation_swigregister = _Poly.Handle_Poly_Triangulation_swigregister
Handle_Poly_Triangulation_swigregister(Handle_Poly_Triangulation)

def Handle_Poly_Triangulation_DownCast(thing):
    return _Poly.Handle_Poly_Triangulation_DownCast(thing)
Handle_Poly_Triangulation_DownCast = _Poly.Handle_Poly_Triangulation_DownCast

class Handle_Poly_HArray1OfTriangle(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Poly_HArray1OfTriangle self)

        Nullify the handle


        """
        return _Poly.Handle_Poly_HArray1OfTriangle_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Poly_HArray1OfTriangle self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Poly.Handle_Poly_HArray1OfTriangle_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Poly_HArray1OfTriangle self, Poly_HArray1OfTriangle thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Poly.Handle_Poly_HArray1OfTriangle_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Poly_HArray1OfTriangle self, Handle_Poly_HArray1OfTriangle theHandle) -> Handle_Poly_HArray1OfTriangle
        assign(Handle_Poly_HArray1OfTriangle self, Poly_HArray1OfTriangle thePtr) -> Handle_Poly_HArray1OfTriangle
        assign(Handle_Poly_HArray1OfTriangle self, Handle_Poly_HArray1OfTriangle theHandle) -> Handle_Poly_HArray1OfTriangle

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Poly.Handle_Poly_HArray1OfTriangle_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Poly_HArray1OfTriangle self) -> Poly_HArray1OfTriangle

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Poly.Handle_Poly_HArray1OfTriangle_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Poly_HArray1OfTriangle self) -> Poly_HArray1OfTriangle

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Poly.Handle_Poly_HArray1OfTriangle___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Poly_HArray1OfTriangle self) -> Poly_HArray1OfTriangle

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Poly.Handle_Poly_HArray1OfTriangle___ref__(self, *args)


    def __hash__(self):
        return _Poly.Handle_Poly_HArray1OfTriangle___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Poly.Handle_Poly_HArray1OfTriangle___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Poly.new_Handle_Poly_HArray1OfTriangle(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Poly.Handle_Poly_HArray1OfTriangle_DownCast)
    __swig_destroy__ = _Poly.delete_Handle_Poly_HArray1OfTriangle

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.Poly.Poly_Array1OfTriangle

        """
        res = _Poly.Handle_Poly_HArray1OfTriangle_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_Poly_HArray1OfTriangle self) -> NCollection_Array1_Poly_Triangle

        :rtype: OCC.wrapper.Poly.Poly_Array1OfTriangle

        """
        return _Poly.Handle_Poly_HArray1OfTriangle_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Poly_HArray1OfTriangle self) -> char const *

        :rtype: const char *

        """
        return _Poly.Handle_Poly_HArray1OfTriangle_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Poly.Handle_Poly_HArray1OfTriangle_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Poly.Handle_Poly_HArray1OfTriangle_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Poly_HArray1OfTriangle self)

        Memory deallocator for transient classes


        """
        return _Poly.Handle_Poly_HArray1OfTriangle_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Poly_HArray1OfTriangle self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Poly_HArray1OfTriangle self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Handle_Poly_HArray1OfTriangle_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Poly_HArray1OfTriangle self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Poly_HArray1OfTriangle self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Handle_Poly_HArray1OfTriangle_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Poly_HArray1OfTriangle self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Poly.Handle_Poly_HArray1OfTriangle_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Poly_HArray1OfTriangle self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Handle_Poly_HArray1OfTriangle_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Poly_HArray1OfTriangle self)

        Increments the reference counter of this object


        """
        return _Poly.Handle_Poly_HArray1OfTriangle_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Poly_HArray1OfTriangle self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Handle_Poly_HArray1OfTriangle_DecrementRefCounter(self, *args)

Handle_Poly_HArray1OfTriangle_swigregister = _Poly.Handle_Poly_HArray1OfTriangle_swigregister
Handle_Poly_HArray1OfTriangle_swigregister(Handle_Poly_HArray1OfTriangle)

def Handle_Poly_HArray1OfTriangle_DownCast(thing):
    return _Poly.Handle_Poly_HArray1OfTriangle_DownCast(thing)
Handle_Poly_HArray1OfTriangle_DownCast = _Poly.Handle_Poly_HArray1OfTriangle_DownCast

class Poly_Connect(object):
    """
    Provides an algorithm to explore, inside a triangulation, the
    adjacency data for a node or a triangle.
    Adjacency data for a node consists of triangles which
    contain the node.
    Adjacency data for a triangle consists of:
    -   the 3 adjacent triangles which share an edge of the triangle,
    -   and the 3 nodes which are the other nodes of these adjacent triangles.
    Example
    Inside a triangulation, a triangle T
    has nodes n1, n2 and n3.
    It has adjacent triangles AT1, AT2 and AT3 where:
    - AT1 shares the nodes n2 and n3,
    - AT2 shares the nodes n3 and n1,
    - AT3 shares the nodes n1 and n2.
    It has adjacent nodes an1, an2 and an3 where:
    - an1 is the third node of AT1,
    - an2 is the third node of AT2,
    - an3 is the third node of AT3.
    So triangle AT1 is composed of nodes n2, n3 and an1.
    There are two ways of using this algorithm.
    -   From a given node you can look for one triangle that
    passes through the node, then look for the triangles
    adjacent to this triangle, then the adjacent nodes. You
    can thus explore the triangulation step by step (functions
    Triangle, Triangles and Nodes).
    -   From a given node you can look for all the triangles
    that pass through the node (iteration method, using the
    functions Initialize, More, Next and Value).
    A Connect object can be seen as a tool which analyzes a
    triangulation and translates it into a series of triangles. By
    doing this, it provides an interface with other tools and
    applications working on basic triangles, and which do not
    work directly with a Poly_Triangulation.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Poly_Connect self) -> Poly_Connect
        __init__(Poly_Connect self, Handle_Poly_Triangulation theTriangulation) -> Poly_Connect

        Constructs an algorithm to explore the adjacency data of
        nodes or triangles for the triangulation T.

        :type theTriangulation: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        this = _Poly.new_Poly_Connect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Load(self, *args):
        """
        Load(Poly_Connect self, Handle_Poly_Triangulation theTriangulation)

        Initialize the algorithm to explore the adjacency data of
        nodes or triangles for the triangulation theTriangulation.

        :type theTriangulation: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        return _Poly.Poly_Connect_Load(self, *args)


    def Triangulation(self, *args):
        """
        Returns the triangulation analyzed by this tool.

        :rtype: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        res = _Poly.Poly_Connect_Triangulation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Triangle(self, *args):
        """
        Triangle(Poly_Connect self, Standard_Integer const N) -> Standard_Integer

        Returns the index of a triangle containing the node at
        index N in the nodes table specific to the triangulation analyzed by this tool

        :type N: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Poly_Connect_Triangle(self, *args)


    def Triangles(self, *args):
        """
        Triangles(Poly_Connect self, Standard_Integer const T)

        Returns in t1, t2 and t3, the indices of the 3 triangles
        adjacent to the triangle at index T in the triangles table
        specific to the triangulation analyzed by this tool.
        Warning
        Null indices are returned when there are fewer than 3
        adjacent triangles.

        :type T: int
        :type t1: int
        :type t2: int
        :type t3: int

        """
        return _Poly.Poly_Connect_Triangles(self, *args)


    def Nodes(self, *args):
        """
        Nodes(Poly_Connect self, Standard_Integer const T)

        Returns, in n1, n2 and n3, the indices of the 3 nodes
        adjacent to the triangle referenced at index T in the
        triangles table specific to the triangulation analyzed by this tool.
        Warning
        Null indices are returned when there are fewer than 3 adjacent nodes.

        :type T: int
        :type n1: int
        :type n2: int
        :type n3: int

        """
        return _Poly.Poly_Connect_Nodes(self, *args)


    def Initialize(self, *args):
        """
        Initialize(Poly_Connect self, Standard_Integer const N)

        Initializes an iterator to search for all the triangles
        containing the node referenced at index N in the nodes
        table, for the triangulation analyzed by this tool.
        The iterator is managed by the following functions:
        -   More, which checks if there are still elements in the iterator
        -   Next, which positions the iterator on the next element
        -   Value, which returns the current element.
        The use of such an iterator provides direct access to the
        triangles around a particular node, i.e. it avoids iterating on
        all the component triangles of a triangulation.
        Example
        Poly_Connect C(Tr);
        for
        (C.Initialize(n1);C.More();C.Next())
        {
        t = C.Value();
        }

        :type N: int

        """
        return _Poly.Poly_Connect_Initialize(self, *args)


    def More(self, *args):
        """
        More(Poly_Connect self) -> Standard_Boolean

        Returns true if there is another element in the iterator
        defined with the function Initialize (i.e. if there is another
        triangle containing the given node).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Poly_Connect_More(self, *args)


    def Next(self, *args):
        """
        Next(Poly_Connect self)

        Advances the iterator defined with the function Initialize to
        access the next triangle.
        Note: There is no action if the iterator is empty (i.e. if the
        function More returns false).-


        """
        return _Poly.Poly_Connect_Next(self, *args)


    def Value(self, *args):
        """
        Value(Poly_Connect self) -> Standard_Integer

        Returns the index of the current triangle to which the
        iterator, defined with the function Initialize, points. This is
        an index in the triangles table specific to the triangulation
        analyzed by this tool

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Poly_Connect_Value(self, *args)

    __swig_destroy__ = _Poly.delete_Poly_Connect
Poly_Connect_swigregister = _Poly.Poly_Connect_swigregister
Poly_Connect_swigregister(Poly_Connect)

class Poly_(object):
    """
    This  package  provides  classes  and services  to
    handle :

    * 3D triangular polyhedrons.

    * 3D polygons.

    * 2D polygon.

    * Tools to dump, save and restore those objects.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Catenate(*args):
        """
        Catenate(NCollection_List_Handle_Poly_Triangulation lstTri) -> Handle_Poly_Triangulation

        Computes and  stores  the    link from   nodes  to
        triangles     and from triangles to   neighbouring
        triangles.
        This tool is obsolete, replaced by Poly_CoherentTriangulation
        Algorithm to make minimal loops in a graph
        Join several triangulations to one new triangulation object.
        The new triangulation is just a mechanical sum of input
        triangulations, without node sharing. UV coordinates are
        dropped in the result.

        :type lstTri: OCC.wrapper.Poly.Poly_ListOfTriangulation
        :rtype: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        return _Poly.Poly__Catenate(*args)

    Catenate = staticmethod(Catenate)

    def Write(*args):
        """
        Write(Handle_Poly_Triangulation T, Standard_OStream & OS, Standard_Boolean const Compact)
        Write(Handle_Poly_Polygon3D P, Standard_OStream & OS, Standard_Boolean const Compact)
        Write(Handle_Poly_Polygon2D P, Standard_OStream & OS, Standard_Boolean const Compact)

        Writes the  content  of the 2D polygon  <P> on the
        stream <OS>. If <Compact> is true this is a "save"
        format  intended  to  be read back   with the Read
        method. If compact is False  it is a "Dump" format
        intended to be informative.

        :type P: OCC.wrapper.Poly.Handle_Poly_Polygon2D
        :type OS: OCC.wrapper.Standard.Standard_OStream
        :type Compact: bool

        """
        return _Poly.Poly__Write(*args)

    Write = staticmethod(Write)

    def Dump(*args):
        """
        Dump(Handle_Poly_Triangulation T, Standard_OStream & OS)
        Dump(Handle_Poly_Polygon3D P, Standard_OStream & OS)
        Dump(Handle_Poly_Polygon2D P, Standard_OStream & OS)

        Dumps  the  2D  polygon.  This   is a call to  the
        previous method with Comapct set to False.

        :type P: OCC.wrapper.Poly.Handle_Poly_Polygon2D
        :type OS: OCC.wrapper.Standard.Standard_OStream

        """
        return _Poly.Poly__Dump(*args)

    Dump = staticmethod(Dump)

    def ReadTriangulation(*args):
        """
        ReadTriangulation(Standard_IStream & IS) -> Handle_Poly_Triangulation

        Reads a triangulation from the stream <IS>.

        :type IS: OCC.wrapper.Standard.Standard_IStream
        :rtype: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        return _Poly.Poly__ReadTriangulation(*args)

    ReadTriangulation = staticmethod(ReadTriangulation)

    def ReadPolygon3D(*args):
        """
        ReadPolygon3D(Standard_IStream & IS) -> Handle_Poly_Polygon3D

        Reads a 3d polygon from the stream <IS>.

        :type IS: OCC.wrapper.Standard.Standard_IStream
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon3D

        """
        return _Poly.Poly__ReadPolygon3D(*args)

    ReadPolygon3D = staticmethod(ReadPolygon3D)

    def ReadPolygon2D(*args):
        """
        ReadPolygon2D(Standard_IStream & IS) -> Handle_Poly_Polygon2D

        Reads a 2D polygon from the stream <IS>.

        :type IS: OCC.wrapper.Standard.Standard_IStream
        :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon2D

        """
        return _Poly.Poly__ReadPolygon2D(*args)

    ReadPolygon2D = staticmethod(ReadPolygon2D)

    def ComputeNormals(*args):
        """
        ComputeNormals(Handle_Poly_Triangulation Tri)

        Compute node normals for face triangulation
        as mean normal of surrounding triangles

        :type Tri: OCC.wrapper.Poly.Handle_Poly_Triangulation

        """
        return _Poly.Poly__ComputeNormals(*args)

    ComputeNormals = staticmethod(ComputeNormals)

    def PointOnTriangle(*args):
        """
        PointOnTriangle(gp_XY P1, gp_XY P2, gp_XY P3, gp_XY P, gp_XY UV) -> Standard_Real

        Computes parameters of the point P on triangle
        defined by points P1, P2, and P3, in 2d.
        The parameters U and V are defined so that
        P = P1 + U * (P2 - P1) + V * (P3 - P1),
        with U >= 0, V >= 0, U + V <= 1.
        If P is located outside of triangle, or triangle
        is degenerated, the returned parameters correspond
        to closest point, and returned value is square of
        the distance from original point to triangle (0 if
        point is inside).

        :type P1: OCC.wrapper.gp.gp_XY
        :type P2: OCC.wrapper.gp.gp_XY
        :type P3: OCC.wrapper.gp.gp_XY
        :type P: OCC.wrapper.gp.gp_XY
        :type UV: OCC.wrapper.gp.gp_XY
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Poly.Poly__PointOnTriangle(*args)

    PointOnTriangle = staticmethod(PointOnTriangle)

    def __init__(self):
        """
        This  package  provides  classes  and services  to
        handle :

        * 3D triangular polyhedrons.

        * 3D polygons.

        * 2D polygon.

        * Tools to dump, save and restore those objects.
        """
        this = _Poly.new_Poly_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Poly.delete_Poly_
Poly__swigregister = _Poly.Poly__swigregister
Poly__swigregister(Poly_)

def Poly__Catenate(*args):
    """
    Poly__Catenate(NCollection_List_Handle_Poly_Triangulation lstTri) -> Handle_Poly_Triangulation

    Computes and  stores  the    link from   nodes  to
    triangles     and from triangles to   neighbouring
    triangles.
    This tool is obsolete, replaced by Poly_CoherentTriangulation
    Algorithm to make minimal loops in a graph
    Join several triangulations to one new triangulation object.
    The new triangulation is just a mechanical sum of input
    triangulations, without node sharing. UV coordinates are
    dropped in the result.

    :type lstTri: OCC.wrapper.Poly.Poly_ListOfTriangulation
    :rtype: OCC.wrapper.Poly.Handle_Poly_Triangulation

    """
    return _Poly.Poly__Catenate(*args)

def Poly__Write(*args):
    """
    Write(Handle_Poly_Triangulation T, Standard_OStream & OS, Standard_Boolean const Compact)
    Write(Handle_Poly_Polygon3D P, Standard_OStream & OS, Standard_Boolean const Compact)
    Poly__Write(Handle_Poly_Polygon2D P, Standard_OStream & OS, Standard_Boolean const Compact)

    Writes the  content  of the 2D polygon  <P> on the
    stream <OS>. If <Compact> is true this is a "save"
    format  intended  to  be read back   with the Read
    method. If compact is False  it is a "Dump" format
    intended to be informative.

    :type P: OCC.wrapper.Poly.Handle_Poly_Polygon2D
    :type OS: OCC.wrapper.Standard.Standard_OStream
    :type Compact: bool

    """
    return _Poly.Poly__Write(*args)

def Poly__Dump(*args):
    """
    Dump(Handle_Poly_Triangulation T, Standard_OStream & OS)
    Dump(Handle_Poly_Polygon3D P, Standard_OStream & OS)
    Poly__Dump(Handle_Poly_Polygon2D P, Standard_OStream & OS)

    Dumps  the  2D  polygon.  This   is a call to  the
    previous method with Comapct set to False.

    :type P: OCC.wrapper.Poly.Handle_Poly_Polygon2D
    :type OS: OCC.wrapper.Standard.Standard_OStream

    """
    return _Poly.Poly__Dump(*args)

def Poly__ReadTriangulation(*args):
    """
    Poly__ReadTriangulation(Standard_IStream & IS) -> Handle_Poly_Triangulation

    Reads a triangulation from the stream <IS>.

    :type IS: OCC.wrapper.Standard.Standard_IStream
    :rtype: OCC.wrapper.Poly.Handle_Poly_Triangulation

    """
    return _Poly.Poly__ReadTriangulation(*args)

def Poly__ReadPolygon3D(*args):
    """
    Poly__ReadPolygon3D(Standard_IStream & IS) -> Handle_Poly_Polygon3D

    Reads a 3d polygon from the stream <IS>.

    :type IS: OCC.wrapper.Standard.Standard_IStream
    :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon3D

    """
    return _Poly.Poly__ReadPolygon3D(*args)

def Poly__ReadPolygon2D(*args):
    """
    Poly__ReadPolygon2D(Standard_IStream & IS) -> Handle_Poly_Polygon2D

    Reads a 2D polygon from the stream <IS>.

    :type IS: OCC.wrapper.Standard.Standard_IStream
    :rtype: OCC.wrapper.Poly.Handle_Poly_Polygon2D

    """
    return _Poly.Poly__ReadPolygon2D(*args)

def Poly__ComputeNormals(*args):
    """
    Poly__ComputeNormals(Handle_Poly_Triangulation Tri)

    Compute node normals for face triangulation
    as mean normal of surrounding triangles

    :type Tri: OCC.wrapper.Poly.Handle_Poly_Triangulation

    """
    return _Poly.Poly__ComputeNormals(*args)

def Poly__PointOnTriangle(*args):
    """
    Poly__PointOnTriangle(gp_XY P1, gp_XY P2, gp_XY P3, gp_XY P, gp_XY UV) -> Standard_Real

    Computes parameters of the point P on triangle
    defined by points P1, P2, and P3, in 2d.
    The parameters U and V are defined so that
    P = P1 + U * (P2 - P1) + V * (P3 - P1),
    with U >= 0, V >= 0, U + V <= 1.
    If P is located outside of triangle, or triangle
    is degenerated, the returned parameters correspond
    to closest point, and returned value is square of
    the distance from original point to triangle (0 if
    point is inside).

    :type P1: OCC.wrapper.gp.gp_XY
    :type P2: OCC.wrapper.gp.gp_XY
    :type P3: OCC.wrapper.gp.gp_XY
    :type P: OCC.wrapper.gp.gp_XY
    :type UV: OCC.wrapper.gp.gp_XY
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Poly.Poly__PointOnTriangle(*args)

class Poly_CoherentLink(object):
    """
    Link between two mesh nodes that is created by existing triangle(s).
    Keeps reference to the opposite node of each incident triangle.
    The referred node with index "0" is always on the left side of the link,
    the one with the index "1" is always on the right side.
    It is possible to find both incident triangles using the method
    Poly_CoherentTriangulation::FindTriangle().
    <p>
    Any Link can store an arbitrary pointer that is called Attribute.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Poly_CoherentLink self) -> Poly_CoherentLink
        __init__(Poly_CoherentLink self, Standard_Integer const iNode0, Standard_Integer const iNode1) -> Poly_CoherentLink
        __init__(Poly_CoherentLink self, Poly_CoherentTriangle theTri, Standard_Integer iSide) -> Poly_CoherentLink

        Constructor, takes a triangle and a side. A link is created always such
        that myNode[0] < myNode[1]. Unlike the previous constructor, this one
        assigns the 'opposite node' fields. This constructor is used when a
        link is inserted into a Poly_CoherentTriangulation structure.  
        @param theTri
        Triangle containing the link that is created
        @param iSide
        Can be 0, 1 or 2. Index of the node

        :type theTri: OCC.wrapper.Poly.Poly_CoherentTriangle
        :type iSide: int

        """
        this = _Poly.new_Poly_CoherentLink(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Node(self, *args):
        """
        Node(Poly_CoherentLink self, Standard_Integer const ind) -> Standard_Integer

        Return the node index in the current triangulation.
        @param ind
        0 or 1 making distinction of the two nodes that constitute the Link.
        Node(0) always returns a smaller number than Node(1).

        :type ind: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Poly_CoherentLink_Node(self, *args)


    def OppositeNode(self, *args):
        """
        OppositeNode(Poly_CoherentLink self, Standard_Integer const ind) -> Standard_Integer

        Return the opposite node (belonging to the left or right incident triangle)
        index in the current triangulation.
        @param ind
        0 or 1 making distinction of the two involved triangles: 0 on the left,
        1 on the right side of the Link.

        :type ind: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Poly.Poly_CoherentLink_OppositeNode(self, *args)


    def GetAttribute(self, *args):
        """
        GetAttribute(Poly_CoherentLink self) -> Standard_Address

        Query the attribute of the Link.

        :rtype: OCC.wrapper.Standard.Standard_Address

        """
        return _Poly.Poly_CoherentLink_GetAttribute(self, *args)


    def SetAttribute(self, *args):
        """
        SetAttribute(Poly_CoherentLink self, Standard_Address const theAtt)

        Set the attribute of the Link.

        :type theAtt: OCC.wrapper.Standard.Standard_Address

        """
        return _Poly.Poly_CoherentLink_SetAttribute(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Poly_CoherentLink self) -> Standard_Boolean

        Query the status of the link - if it is an invalid one.
        An invalid link has Node members equal to -1.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Poly.Poly_CoherentLink_IsEmpty(self, *args)


    def Nullify(self, *args):
        """
        Nullify(Poly_CoherentLink self)

        Invalidate this Link.


        """
        return _Poly.Poly_CoherentLink_Nullify(self, *args)

    __swig_destroy__ = _Poly.delete_Poly_CoherentLink
Poly_CoherentLink_swigregister = _Poly.Poly_CoherentLink_swigregister
Poly_CoherentLink_swigregister(Poly_CoherentLink)




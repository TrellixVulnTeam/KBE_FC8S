# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Adaptor2d')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Adaptor2d')
    _Adaptor2d = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Adaptor2d', [dirname(__file__)])
        except ImportError:
            import _Adaptor2d
            return _Adaptor2d
        try:
            _mod = imp.load_module('_Adaptor2d', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Adaptor2d = swig_import_helper()
    del swig_import_helper
else:
    import _Adaptor2d
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Adaptor2d.delete_SwigPyIterator

    def value(self):
        return _Adaptor2d.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Adaptor2d.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Adaptor2d.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Adaptor2d.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Adaptor2d.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Adaptor2d.SwigPyIterator_copy(self)

    def next(self):
        return _Adaptor2d.SwigPyIterator_next(self)

    def __next__(self):
        return _Adaptor2d.SwigPyIterator___next__(self)

    def previous(self):
        return _Adaptor2d.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Adaptor2d.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Adaptor2d.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Adaptor2d.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Adaptor2d.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Adaptor2d.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Adaptor2d.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Adaptor2d.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _Adaptor2d.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Adaptor2d.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_Adaptor2d.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _Adaptor2d.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Adaptor2d.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Adaptor2d.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _Adaptor2d.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _Adaptor2d.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _Adaptor2d.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Adaptor2d.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_Adaptor2d.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _Adaptor2d.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Adaptor2d.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Adaptor2d.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _Adaptor2d.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _Adaptor2d.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _Adaptor2d.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _Adaptor2d.ptr_to_number(item)
ptr_to_number = _Adaptor2d.ptr_to_number

def HashCode(*args):
    return _Adaptor2d.HashCode(*args)
HashCode = _Adaptor2d.HashCode

def ptr_equal(a, b):
    return _Adaptor2d.ptr_equal(a, b)
ptr_equal = _Adaptor2d.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
class Adaptor2d_HCurve2d(Standard.Standard_Transient):
    """
    Root class for 2D curves manipulated by handles, on
    which geometric algorithms work.
    An adapted curve is an interface between the
    services provided by a curve, and those required of
    the curve by algorithms, which use it.
    A derived specific class is provided:
    Geom2dAdaptor_HCurve for a curve from the Geom2d package.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Adaptor2d_HCurve2d
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Adaptor2d_HCurve2d(self) 
            return h


    def Curve2d(self, *args):
        """
        Returns a reference to the Curve2d inside the HCurve2d.

        :rtype: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d

        """
        res = _Adaptor2d.Adaptor2d_HCurve2d_Curve2d(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FirstParameter(self, *args):
        """
        FirstParameter(Adaptor2d_HCurve2d self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Adaptor2d.Adaptor2d_HCurve2d_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Adaptor2d_HCurve2d self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Adaptor2d.Adaptor2d_HCurve2d_LastParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Adaptor2d_HCurve2d self) -> GeomAbs_Shape

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Adaptor2d.Adaptor2d_HCurve2d_Continuity(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Adaptor2d_HCurve2d self, GeomAbs_Shape const S) -> Standard_Integer

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Adaptor2d_HCurve2d_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Adaptor2d_HCurve2d self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Adaptor2d.Adaptor2d_HCurve2d_Intervals(self, *args)


    def Trim(self, *args):
        """
        Trim(Adaptor2d_HCurve2d self, Standard_Real const First, Standard_Real const Last, Standard_Real const Tol) -> Handle_Adaptor2d_HCurve2d

        If <First> >= <Last>

        :type First: float
        :type Last: float
        :type Tol: float
        :rtype: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        return _Adaptor2d.Adaptor2d_HCurve2d_Trim(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Adaptor2d_HCurve2d self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Adaptor2d.Adaptor2d_HCurve2d_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Adaptor2d_HCurve2d self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Adaptor2d.Adaptor2d_HCurve2d_IsPeriodic(self, *args)


    def Period(self, *args):
        """
        Period(Adaptor2d_HCurve2d self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Adaptor2d.Adaptor2d_HCurve2d_Period(self, *args)


    def Value(self, *args):
        """
        Value(Adaptor2d_HCurve2d self, Standard_Real const U) -> gp_Pnt2d

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Adaptor2d.Adaptor2d_HCurve2d_Value(self, *args)


    def D0(self, *args):
        """
        D0(Adaptor2d_HCurve2d self, Standard_Real const U, gp_Pnt2d P)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Adaptor2d.Adaptor2d_HCurve2d_D0(self, *args)


    def D1(self, *args):
        """
        D1(Adaptor2d_HCurve2d self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V: OCC.wrapper.gp.gp_Vec2d

        """
        return _Adaptor2d.Adaptor2d_HCurve2d_D1(self, *args)


    def D2(self, *args):
        """
        D2(Adaptor2d_HCurve2d self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Adaptor2d.Adaptor2d_HCurve2d_D2(self, *args)


    def D3(self, *args):
        """
        D3(Adaptor2d_HCurve2d self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Adaptor2d.Adaptor2d_HCurve2d_D3(self, *args)


    def DN(self, *args):
        """
        DN(Adaptor2d_HCurve2d self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Adaptor2d.Adaptor2d_HCurve2d_DN(self, *args)


    def Resolution(self, *args):
        """
        Resolution(Adaptor2d_HCurve2d self, Standard_Real const R3d) -> Standard_Real

        :type R3d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Adaptor2d.Adaptor2d_HCurve2d_Resolution(self, *args)


    def GetType(self, *args):
        """
        GetType(Adaptor2d_HCurve2d self) -> GeomAbs_CurveType

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

        """
        return _Adaptor2d.Adaptor2d_HCurve2d_GetType(self, *args)


    def Line(self, *args):
        """
        Line(Adaptor2d_HCurve2d self) -> gp_Lin2d

        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _Adaptor2d.Adaptor2d_HCurve2d_Line(self, *args)


    def Circle(self, *args):
        """
        Circle(Adaptor2d_HCurve2d self) -> gp_Circ2d

        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _Adaptor2d.Adaptor2d_HCurve2d_Circle(self, *args)


    def Ellipse(self, *args):
        """
        Ellipse(Adaptor2d_HCurve2d self) -> gp_Elips2d

        :rtype: OCC.wrapper.gp.gp_Elips2d

        """
        return _Adaptor2d.Adaptor2d_HCurve2d_Ellipse(self, *args)


    def Hyperbola(self, *args):
        """
        Hyperbola(Adaptor2d_HCurve2d self) -> gp_Hypr2d

        :rtype: OCC.wrapper.gp.gp_Hypr2d

        """
        return _Adaptor2d.Adaptor2d_HCurve2d_Hyperbola(self, *args)


    def Parabola(self, *args):
        """
        Parabola(Adaptor2d_HCurve2d self) -> gp_Parab2d

        :rtype: OCC.wrapper.gp.gp_Parab2d

        """
        return _Adaptor2d.Adaptor2d_HCurve2d_Parabola(self, *args)


    def Degree(self, *args):
        """
        Degree(Adaptor2d_HCurve2d self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Adaptor2d_HCurve2d_Degree(self, *args)


    def IsRational(self, *args):
        """
        IsRational(Adaptor2d_HCurve2d self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Adaptor2d.Adaptor2d_HCurve2d_IsRational(self, *args)


    def NbPoles(self, *args):
        """
        NbPoles(Adaptor2d_HCurve2d self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Adaptor2d_HCurve2d_NbPoles(self, *args)


    def NbKnots(self, *args):
        """
        NbKnots(Adaptor2d_HCurve2d self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Adaptor2d_HCurve2d_NbKnots(self, *args)


    def Bezier(self, *args):
        """
        Bezier(Adaptor2d_HCurve2d self) -> Handle_Geom2d_BezierCurve

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BezierCurve

        """
        return _Adaptor2d.Adaptor2d_HCurve2d_Bezier(self, *args)


    def BSpline(self, *args):
        """
        BSpline(Adaptor2d_HCurve2d self) -> Handle_Geom2d_BSplineCurve

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

        """
        return _Adaptor2d.Adaptor2d_HCurve2d_BSpline(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Adaptor2d.Adaptor2d_HCurve2d_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Adaptor2d.Adaptor2d_HCurve2d_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Adaptor2d.Adaptor2d_HCurve2d_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Adaptor2d.delete_Adaptor2d_HCurve2d
Adaptor2d_HCurve2d_swigregister = _Adaptor2d.Adaptor2d_HCurve2d_swigregister
Adaptor2d_HCurve2d_swigregister(Adaptor2d_HCurve2d)

def Adaptor2d_HCurve2d_get_type_name(*args):
    """
    Adaptor2d_HCurve2d_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Adaptor2d.Adaptor2d_HCurve2d_get_type_name(*args)

def Adaptor2d_HCurve2d_get_type_descriptor(*args):
    """
    Adaptor2d_HCurve2d_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Adaptor2d.Adaptor2d_HCurve2d_get_type_descriptor(*args)

class Adaptor2d_HLine2d(Adaptor2d_HCurve2d):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Adaptor2d_HLine2d
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Adaptor2d_HLine2d(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Adaptor2d_HLine2d self) -> Adaptor2d_HLine2d
        __init__(Adaptor2d_HLine2d self, Adaptor2d_Line2d C) -> Adaptor2d_HLine2d

        Creates a GenHCurve2d from a Curve

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Line2d

        """
        this = _Adaptor2d.new_Adaptor2d_HLine2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Set(self, *args):
        """
        Set(Adaptor2d_HLine2d self, Adaptor2d_Line2d C)

        Sets the field of the GenHCurve2d.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Line2d

        """
        return _Adaptor2d.Adaptor2d_HLine2d_Set(self, *args)


    def Curve2d(self, *args):
        """
        Returns the curve used to create the GenHCurve2d.
        This is redefined from HCurve2d, cannot be inline.

        :rtype: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d

        """
        res = _Adaptor2d.Adaptor2d_HLine2d_Curve2d(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeCurve2d(self, *args):
        """
        ChangeCurve2d(Adaptor2d_HLine2d self) -> Adaptor2d_Line2d

        Returns the curve used to create the GenHCurve.

        :rtype: OCC.wrapper.Adaptor2d.Adaptor2d_Line2d

        """
        return _Adaptor2d.Adaptor2d_HLine2d_ChangeCurve2d(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Adaptor2d.Adaptor2d_HLine2d_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Adaptor2d.Adaptor2d_HLine2d_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Adaptor2d.Adaptor2d_HLine2d_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Adaptor2d.delete_Adaptor2d_HLine2d
Adaptor2d_HLine2d_swigregister = _Adaptor2d.Adaptor2d_HLine2d_swigregister
Adaptor2d_HLine2d_swigregister(Adaptor2d_HLine2d)

def Adaptor2d_HLine2d_get_type_name(*args):
    """
    Adaptor2d_HLine2d_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Adaptor2d.Adaptor2d_HLine2d_get_type_name(*args)

def Adaptor2d_HLine2d_get_type_descriptor(*args):
    """
    Adaptor2d_HLine2d_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Adaptor2d.Adaptor2d_HLine2d_get_type_descriptor(*args)

class Adaptor2d_Curve2d(object):
    """
    Root class for 2D curves on which geometric
    algorithms work.
    An adapted curve is an interface between the
    services provided by a curve, and those required of
    the curve by algorithms, which use it.
    A derived concrete class is provided:
    Geom2dAdaptor_Curve for a curve from the Geom2d package.

    Polynomial coefficients of BSpline curves used for their evaluation are
    cached for better performance. Therefore these evaluations are not
    thread-safe and parallel evaluations need to be prevented.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FirstParameter(self, *args):
        """
        FirstParameter(Adaptor2d_Curve2d self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Adaptor2d.Adaptor2d_Curve2d_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Adaptor2d_Curve2d self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Adaptor2d.Adaptor2d_Curve2d_LastParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Adaptor2d_Curve2d self) -> GeomAbs_Shape

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Adaptor2d.Adaptor2d_Curve2d_Continuity(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Adaptor2d_Curve2d self, GeomAbs_Shape const S) -> Standard_Integer

        If necessary,  breaks the  curve in  intervals  of
        continuity  <S>.    And  returns   the number   of
        intervals.

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Adaptor2d_Curve2d_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Adaptor2d_Curve2d self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Adaptor2d.Adaptor2d_Curve2d_Intervals(self, *args)


    def Trim(self, *args):
        """
        Trim(Adaptor2d_Curve2d self, Standard_Real const First, Standard_Real const Last, Standard_Real const Tol) -> Handle_Adaptor2d_HCurve2d

        Returns    a  curve equivalent   of  <me>  between
        parameters <First>  and <Last>. <Tol>  is used  to
        test for 3d points confusion.
        If <First> >= <Last>

        :type First: float
        :type Last: float
        :type Tol: float
        :rtype: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        return _Adaptor2d.Adaptor2d_Curve2d_Trim(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Adaptor2d_Curve2d self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Adaptor2d.Adaptor2d_Curve2d_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Adaptor2d_Curve2d self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Adaptor2d.Adaptor2d_Curve2d_IsPeriodic(self, *args)


    def Period(self, *args):
        """
        Period(Adaptor2d_Curve2d self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Adaptor2d.Adaptor2d_Curve2d_Period(self, *args)


    def Value(self, *args):
        """
        Value(Adaptor2d_Curve2d self, Standard_Real const U) -> gp_Pnt2d

        Computes the point of parameter U on the curve.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Adaptor2d.Adaptor2d_Curve2d_Value(self, *args)


    def D0(self, *args):
        """
        D0(Adaptor2d_Curve2d self, Standard_Real const U, gp_Pnt2d P)

        Computes the point of parameter U on the curve.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Adaptor2d.Adaptor2d_Curve2d_D0(self, *args)


    def D1(self, *args):
        """
        D1(Adaptor2d_Curve2d self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V)

        Computes the point of parameter U on the curve with its
        first derivative.
        Raised if the continuity of the current interval
        is not C1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V: OCC.wrapper.gp.gp_Vec2d

        """
        return _Adaptor2d.Adaptor2d_Curve2d_D1(self, *args)


    def D2(self, *args):
        """
        D2(Adaptor2d_Curve2d self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2.
        Raised if the continuity of the current interval
        is not C2.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Adaptor2d.Adaptor2d_Curve2d_D2(self, *args)


    def D3(self, *args):
        """
        D3(Adaptor2d_Curve2d self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        Returns the point P of parameter U, the first, the second
        and the third derivative.
        Raised if the continuity of the current interval
        is not C3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Adaptor2d.Adaptor2d_Curve2d_D3(self, *args)


    def DN(self, *args):
        """
        DN(Adaptor2d_Curve2d self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        The returned vector gives the value of the derivative for the
        order of derivation N.
        Raised if the continuity of the current interval
        is not CN.
        Raised if N < 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Adaptor2d.Adaptor2d_Curve2d_DN(self, *args)


    def Resolution(self, *args):
        """
        Resolution(Adaptor2d_Curve2d self, Standard_Real const R3d) -> Standard_Real

        Returns the parametric  resolution corresponding
        to the real space resolution <R3d>.

        :type R3d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Adaptor2d.Adaptor2d_Curve2d_Resolution(self, *args)


    def GetType(self, *args):
        """
        GetType(Adaptor2d_Curve2d self) -> GeomAbs_CurveType

        Returns  the  type of the   curve  in the  current
        interval :   Line,   Circle,   Ellipse, Hyperbola,
        Parabola, BezierCurve, BSplineCurve, OtherCurve.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

        """
        return _Adaptor2d.Adaptor2d_Curve2d_GetType(self, *args)


    def Line(self, *args):
        """
        Line(Adaptor2d_Curve2d self) -> gp_Lin2d

        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _Adaptor2d.Adaptor2d_Curve2d_Line(self, *args)


    def Circle(self, *args):
        """
        Circle(Adaptor2d_Curve2d self) -> gp_Circ2d

        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _Adaptor2d.Adaptor2d_Curve2d_Circle(self, *args)


    def Ellipse(self, *args):
        """
        Ellipse(Adaptor2d_Curve2d self) -> gp_Elips2d

        :rtype: OCC.wrapper.gp.gp_Elips2d

        """
        return _Adaptor2d.Adaptor2d_Curve2d_Ellipse(self, *args)


    def Hyperbola(self, *args):
        """
        Hyperbola(Adaptor2d_Curve2d self) -> gp_Hypr2d

        :rtype: OCC.wrapper.gp.gp_Hypr2d

        """
        return _Adaptor2d.Adaptor2d_Curve2d_Hyperbola(self, *args)


    def Parabola(self, *args):
        """
        Parabola(Adaptor2d_Curve2d self) -> gp_Parab2d

        :rtype: OCC.wrapper.gp.gp_Parab2d

        """
        return _Adaptor2d.Adaptor2d_Curve2d_Parabola(self, *args)


    def Degree(self, *args):
        """
        Degree(Adaptor2d_Curve2d self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Adaptor2d_Curve2d_Degree(self, *args)


    def IsRational(self, *args):
        """
        IsRational(Adaptor2d_Curve2d self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Adaptor2d.Adaptor2d_Curve2d_IsRational(self, *args)


    def NbPoles(self, *args):
        """
        NbPoles(Adaptor2d_Curve2d self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Adaptor2d_Curve2d_NbPoles(self, *args)


    def NbKnots(self, *args):
        """
        NbKnots(Adaptor2d_Curve2d self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Adaptor2d_Curve2d_NbKnots(self, *args)


    def NbSamples(self, *args):
        """
        NbSamples(Adaptor2d_Curve2d self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Adaptor2d_Curve2d_NbSamples(self, *args)


    def Bezier(self, *args):
        """
        Bezier(Adaptor2d_Curve2d self) -> Handle_Geom2d_BezierCurve

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BezierCurve

        """
        return _Adaptor2d.Adaptor2d_Curve2d_Bezier(self, *args)


    def BSpline(self, *args):
        """
        BSpline(Adaptor2d_Curve2d self) -> Handle_Geom2d_BSplineCurve

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

        """
        return _Adaptor2d.Adaptor2d_Curve2d_BSpline(self, *args)


    def __init__(self):
        """
        Root class for 2D curves on which geometric
        algorithms work.
        An adapted curve is an interface between the
        services provided by a curve, and those required of
        the curve by algorithms, which use it.
        A derived concrete class is provided:
        Geom2dAdaptor_Curve for a curve from the Geom2d package.

        Polynomial coefficients of BSpline curves used for their evaluation are
        cached for better performance. Therefore these evaluations are not
        thread-safe and parallel evaluations need to be prevented.
        """
        this = _Adaptor2d.new_Adaptor2d_Curve2d()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Adaptor2d.delete_Adaptor2d_Curve2d
Adaptor2d_Curve2d_swigregister = _Adaptor2d.Adaptor2d_Curve2d_swigregister
Adaptor2d_Curve2d_swigregister(Adaptor2d_Curve2d)

class Handle_Adaptor2d_HLine2d(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Adaptor2d_HLine2d self)

        Nullify the handle


        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Adaptor2d_HLine2d self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Adaptor2d_HLine2d self, Adaptor2d_HLine2d thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Adaptor2d_HLine2d self, Handle_Adaptor2d_HLine2d theHandle) -> Handle_Adaptor2d_HLine2d
        assign(Handle_Adaptor2d_HLine2d self, Adaptor2d_HLine2d thePtr) -> Handle_Adaptor2d_HLine2d
        assign(Handle_Adaptor2d_HLine2d self, Handle_Adaptor2d_HLine2d theHandle) -> Handle_Adaptor2d_HLine2d

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Adaptor2d_HLine2d self) -> Adaptor2d_HLine2d

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Adaptor2d_HLine2d self) -> Adaptor2d_HLine2d

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Adaptor2d_HLine2d self) -> Adaptor2d_HLine2d

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d___ref__(self, *args)


    def __hash__(self):
        return _Adaptor2d.Handle_Adaptor2d_HLine2d___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Adaptor2d.Handle_Adaptor2d_HLine2d___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Adaptor2d.new_Handle_Adaptor2d_HLine2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Adaptor2d.Handle_Adaptor2d_HLine2d_DownCast)
    __swig_destroy__ = _Adaptor2d.delete_Handle_Adaptor2d_HLine2d

    def Set(self, *args):
        """
        Set(Handle_Adaptor2d_HLine2d self, Adaptor2d_Line2d C)

        Sets the field of the GenHCurve2d.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_Line2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_Set(self, *args)


    def Curve2d(self, *args):
        """
        Returns the curve used to create the GenHCurve2d.
        This is redefined from HCurve2d, cannot be inline.

        :rtype: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d

        """
        res = _Adaptor2d.Handle_Adaptor2d_HLine2d_Curve2d(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeCurve2d(self, *args):
        """
        ChangeCurve2d(Handle_Adaptor2d_HLine2d self) -> Adaptor2d_Line2d

        Returns the curve used to create the GenHCurve.

        :rtype: OCC.wrapper.Adaptor2d.Adaptor2d_Line2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_ChangeCurve2d(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Adaptor2d_HLine2d self) -> char const *

        :rtype: const char *

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Adaptor2d.Handle_Adaptor2d_HLine2d_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Adaptor2d.Handle_Adaptor2d_HLine2d_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_Adaptor2d_HLine2d self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_Adaptor2d_HLine2d self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_LastParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Adaptor2d_HLine2d self) -> GeomAbs_Shape

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_Continuity(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_Adaptor2d_HLine2d self, GeomAbs_Shape const S) -> Standard_Integer

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_Adaptor2d_HLine2d self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_Intervals(self, *args)


    def Trim(self, *args):
        """
        Trim(Handle_Adaptor2d_HLine2d self, Standard_Real const First, Standard_Real const Last, Standard_Real const Tol) -> Handle_Adaptor2d_HCurve2d

        If <First> >= <Last>

        :type First: float
        :type Last: float
        :type Tol: float
        :rtype: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_Trim(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_Adaptor2d_HLine2d self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_Adaptor2d_HLine2d self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_IsPeriodic(self, *args)


    def Period(self, *args):
        """
        Period(Handle_Adaptor2d_HLine2d self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_Period(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Adaptor2d_HLine2d self, Standard_Real const U) -> gp_Pnt2d

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_Value(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Adaptor2d_HLine2d self, Standard_Real const U, gp_Pnt2d P)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Adaptor2d_HLine2d self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V: OCC.wrapper.gp.gp_Vec2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Adaptor2d_HLine2d self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Adaptor2d_HLine2d self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Adaptor2d_HLine2d self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_DN(self, *args)


    def Resolution(self, *args):
        """
        Resolution(Handle_Adaptor2d_HLine2d self, Standard_Real const R3d) -> Standard_Real

        :type R3d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_Resolution(self, *args)


    def GetType(self, *args):
        """
        GetType(Handle_Adaptor2d_HLine2d self) -> GeomAbs_CurveType

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_GetType(self, *args)


    def Line(self, *args):
        """
        Line(Handle_Adaptor2d_HLine2d self) -> gp_Lin2d

        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_Line(self, *args)


    def Circle(self, *args):
        """
        Circle(Handle_Adaptor2d_HLine2d self) -> gp_Circ2d

        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_Circle(self, *args)


    def Ellipse(self, *args):
        """
        Ellipse(Handle_Adaptor2d_HLine2d self) -> gp_Elips2d

        :rtype: OCC.wrapper.gp.gp_Elips2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_Ellipse(self, *args)


    def Hyperbola(self, *args):
        """
        Hyperbola(Handle_Adaptor2d_HLine2d self) -> gp_Hypr2d

        :rtype: OCC.wrapper.gp.gp_Hypr2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_Hyperbola(self, *args)


    def Parabola(self, *args):
        """
        Parabola(Handle_Adaptor2d_HLine2d self) -> gp_Parab2d

        :rtype: OCC.wrapper.gp.gp_Parab2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_Parabola(self, *args)


    def Degree(self, *args):
        """
        Degree(Handle_Adaptor2d_HLine2d self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_Degree(self, *args)


    def IsRational(self, *args):
        """
        IsRational(Handle_Adaptor2d_HLine2d self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_IsRational(self, *args)


    def NbPoles(self, *args):
        """
        NbPoles(Handle_Adaptor2d_HLine2d self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_NbPoles(self, *args)


    def NbKnots(self, *args):
        """
        NbKnots(Handle_Adaptor2d_HLine2d self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_NbKnots(self, *args)


    def Bezier(self, *args):
        """
        Bezier(Handle_Adaptor2d_HLine2d self) -> Handle_Geom2d_BezierCurve

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BezierCurve

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_Bezier(self, *args)


    def BSpline(self, *args):
        """
        BSpline(Handle_Adaptor2d_HLine2d self) -> Handle_Geom2d_BSplineCurve

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_BSpline(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Adaptor2d_HLine2d self)

        Memory deallocator for transient classes


        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Adaptor2d_HLine2d self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Adaptor2d_HLine2d self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Adaptor2d_HLine2d self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Adaptor2d_HLine2d self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Adaptor2d_HLine2d self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Adaptor2d_HLine2d self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Adaptor2d_HLine2d self)

        Increments the reference counter of this object


        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Adaptor2d_HLine2d self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Handle_Adaptor2d_HLine2d_DecrementRefCounter(self, *args)

Handle_Adaptor2d_HLine2d_swigregister = _Adaptor2d.Handle_Adaptor2d_HLine2d_swigregister
Handle_Adaptor2d_HLine2d_swigregister(Handle_Adaptor2d_HLine2d)

def Handle_Adaptor2d_HLine2d_DownCast(thing):
    return _Adaptor2d.Handle_Adaptor2d_HLine2d_DownCast(thing)
Handle_Adaptor2d_HLine2d_DownCast = _Adaptor2d.Handle_Adaptor2d_HLine2d_DownCast

class Adaptor2d_OffsetCurve(Adaptor2d_Curve2d):
    """Defines an Offset curve (algorithmic 2d curve)."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Adaptor2d_OffsetCurve self) -> Adaptor2d_OffsetCurve
        __init__(Adaptor2d_OffsetCurve self, Handle_Adaptor2d_HCurve2d C) -> Adaptor2d_OffsetCurve
        __init__(Adaptor2d_OffsetCurve self, Handle_Adaptor2d_HCurve2d C, Standard_Real const Offset) -> Adaptor2d_OffsetCurve
        __init__(Adaptor2d_OffsetCurve self, Handle_Adaptor2d_HCurve2d C, Standard_Real const Offset, Standard_Real const WFirst, Standard_Real const WLast) -> Adaptor2d_OffsetCurve

        Create an Offset curve.
        WFirst,WLast define the bounds of the Offset curve.

        :type C: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type Offset: float
        :type WFirst: float
        :type WLast: float

        """
        this = _Adaptor2d.new_Adaptor2d_OffsetCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Load(self, *args):
        """
        Load(Adaptor2d_OffsetCurve self, Handle_Adaptor2d_HCurve2d S)
        Load(Adaptor2d_OffsetCurve self, Standard_Real const Offset)
        Load(Adaptor2d_OffsetCurve self, Standard_Real const Offset, Standard_Real const WFirst, Standard_Real const WLast)

        Changes the Offset Curve on the current Curve.

        :type Offset: float
        :type WFirst: float
        :type WLast: float

        """
        return _Adaptor2d.Adaptor2d_OffsetCurve_Load(self, *args)


    def Curve(self, *args):
        """
        :rtype: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        res = _Adaptor2d.Adaptor2d_OffsetCurve_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Offset(self, *args):
        """
        Offset(Adaptor2d_OffsetCurve self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Adaptor2d.Adaptor2d_OffsetCurve_Offset(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Adaptor2d_OffsetCurve self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Adaptor2d.Adaptor2d_OffsetCurve_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Adaptor2d_OffsetCurve self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Adaptor2d.Adaptor2d_OffsetCurve_LastParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Adaptor2d_OffsetCurve self) -> GeomAbs_Shape

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Adaptor2d.Adaptor2d_OffsetCurve_Continuity(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Adaptor2d_OffsetCurve self, GeomAbs_Shape const S) -> Standard_Integer

        If necessary,  breaks the  curve in  intervals  of
        continuity  <S>.    And  returns   the number   of
        intervals.

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Adaptor2d_OffsetCurve_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Adaptor2d_OffsetCurve self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Adaptor2d.Adaptor2d_OffsetCurve_Intervals(self, *args)


    def Trim(self, *args):
        """
        Trim(Adaptor2d_OffsetCurve self, Standard_Real const First, Standard_Real const Last, Standard_Real const Tol) -> Handle_Adaptor2d_HCurve2d

        Returns    a  curve equivalent   of  <me>  between
        parameters <First>  and <Last>. <Tol>  is used  to
        test for 3d points confusion.
        If <First> >= <Last>

        :type First: float
        :type Last: float
        :type Tol: float
        :rtype: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        return _Adaptor2d.Adaptor2d_OffsetCurve_Trim(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Adaptor2d_OffsetCurve self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Adaptor2d.Adaptor2d_OffsetCurve_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Adaptor2d_OffsetCurve self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Adaptor2d.Adaptor2d_OffsetCurve_IsPeriodic(self, *args)


    def Period(self, *args):
        """
        Period(Adaptor2d_OffsetCurve self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Adaptor2d.Adaptor2d_OffsetCurve_Period(self, *args)


    def Value(self, *args):
        """
        Value(Adaptor2d_OffsetCurve self, Standard_Real const U) -> gp_Pnt2d

        Computes the point of parameter U on the curve.

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Adaptor2d.Adaptor2d_OffsetCurve_Value(self, *args)


    def D0(self, *args):
        """
        D0(Adaptor2d_OffsetCurve self, Standard_Real const U, gp_Pnt2d P)

        Computes the point of parameter U on the curve.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Adaptor2d.Adaptor2d_OffsetCurve_D0(self, *args)


    def D1(self, *args):
        """
        D1(Adaptor2d_OffsetCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V)

        Computes the point of parameter U on the curve with its
        first derivative.
        Raised if the continuity of the current interval
        is not C1.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V: OCC.wrapper.gp.gp_Vec2d

        """
        return _Adaptor2d.Adaptor2d_OffsetCurve_D1(self, *args)


    def D2(self, *args):
        """
        D2(Adaptor2d_OffsetCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        Returns the point P of parameter U, the first and second
        derivatives V1 and V2.
        Raised if the continuity of the current interval
        is not C2.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Adaptor2d.Adaptor2d_OffsetCurve_D2(self, *args)


    def D3(self, *args):
        """
        D3(Adaptor2d_OffsetCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        Returns the point P of parameter U, the first, the second
        and the third derivative.
        Raised if the continuity of the current interval
        is not C3.

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Adaptor2d.Adaptor2d_OffsetCurve_D3(self, *args)


    def DN(self, *args):
        """
        DN(Adaptor2d_OffsetCurve self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        The returned vector gives the value of the derivative for the
        order of derivation N.
        Raised if the continuity of the current interval
        is not CN.
        Raised if N < 1.

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Adaptor2d.Adaptor2d_OffsetCurve_DN(self, *args)


    def Resolution(self, *args):
        """
        Resolution(Adaptor2d_OffsetCurve self, Standard_Real const R3d) -> Standard_Real

        Returns the parametric  resolution corresponding
        to the real space resolution <R3d>.

        :type R3d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Adaptor2d.Adaptor2d_OffsetCurve_Resolution(self, *args)


    def GetType(self, *args):
        """
        GetType(Adaptor2d_OffsetCurve self) -> GeomAbs_CurveType

        Returns  the  type of the   curve  in the  current
        interval :   Line,   Circle,   Ellipse, Hyperbola,
        Parabola, BezierCurve, BSplineCurve, OtherCurve.

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

        """
        return _Adaptor2d.Adaptor2d_OffsetCurve_GetType(self, *args)


    def Line(self, *args):
        """
        Line(Adaptor2d_OffsetCurve self) -> gp_Lin2d

        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _Adaptor2d.Adaptor2d_OffsetCurve_Line(self, *args)


    def Circle(self, *args):
        """
        Circle(Adaptor2d_OffsetCurve self) -> gp_Circ2d

        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _Adaptor2d.Adaptor2d_OffsetCurve_Circle(self, *args)


    def Ellipse(self, *args):
        """
        Ellipse(Adaptor2d_OffsetCurve self) -> gp_Elips2d

        :rtype: OCC.wrapper.gp.gp_Elips2d

        """
        return _Adaptor2d.Adaptor2d_OffsetCurve_Ellipse(self, *args)


    def Hyperbola(self, *args):
        """
        Hyperbola(Adaptor2d_OffsetCurve self) -> gp_Hypr2d

        :rtype: OCC.wrapper.gp.gp_Hypr2d

        """
        return _Adaptor2d.Adaptor2d_OffsetCurve_Hyperbola(self, *args)


    def Parabola(self, *args):
        """
        Parabola(Adaptor2d_OffsetCurve self) -> gp_Parab2d

        :rtype: OCC.wrapper.gp.gp_Parab2d

        """
        return _Adaptor2d.Adaptor2d_OffsetCurve_Parabola(self, *args)


    def Degree(self, *args):
        """
        Degree(Adaptor2d_OffsetCurve self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Adaptor2d_OffsetCurve_Degree(self, *args)


    def IsRational(self, *args):
        """
        IsRational(Adaptor2d_OffsetCurve self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Adaptor2d.Adaptor2d_OffsetCurve_IsRational(self, *args)


    def NbPoles(self, *args):
        """
        NbPoles(Adaptor2d_OffsetCurve self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Adaptor2d_OffsetCurve_NbPoles(self, *args)


    def NbKnots(self, *args):
        """
        NbKnots(Adaptor2d_OffsetCurve self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Adaptor2d_OffsetCurve_NbKnots(self, *args)


    def Bezier(self, *args):
        """
        Bezier(Adaptor2d_OffsetCurve self) -> Handle_Geom2d_BezierCurve

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BezierCurve

        """
        return _Adaptor2d.Adaptor2d_OffsetCurve_Bezier(self, *args)


    def BSpline(self, *args):
        """
        BSpline(Adaptor2d_OffsetCurve self) -> Handle_Geom2d_BSplineCurve

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

        """
        return _Adaptor2d.Adaptor2d_OffsetCurve_BSpline(self, *args)

    __swig_destroy__ = _Adaptor2d.delete_Adaptor2d_OffsetCurve
Adaptor2d_OffsetCurve_swigregister = _Adaptor2d.Adaptor2d_OffsetCurve_swigregister
Adaptor2d_OffsetCurve_swigregister(Adaptor2d_OffsetCurve)

class Adaptor2d_HOffsetCurve(Adaptor2d_HCurve2d):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_Adaptor2d_HOffsetCurve
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_Adaptor2d_HOffsetCurve(self) 
            return h


    def __init__(self, *args):
        """
        __init__(Adaptor2d_HOffsetCurve self) -> Adaptor2d_HOffsetCurve
        __init__(Adaptor2d_HOffsetCurve self, Adaptor2d_OffsetCurve C) -> Adaptor2d_HOffsetCurve

        Creates a GenHCurve2d from a Curve

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_OffsetCurve

        """
        this = _Adaptor2d.new_Adaptor2d_HOffsetCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Set(self, *args):
        """
        Set(Adaptor2d_HOffsetCurve self, Adaptor2d_OffsetCurve C)

        Sets the field of the GenHCurve2d.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_OffsetCurve

        """
        return _Adaptor2d.Adaptor2d_HOffsetCurve_Set(self, *args)


    def Curve2d(self, *args):
        """
        Returns the curve used to create the GenHCurve2d.
        This is redefined from HCurve2d, cannot be inline.

        :rtype: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d

        """
        res = _Adaptor2d.Adaptor2d_HOffsetCurve_Curve2d(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeCurve2d(self, *args):
        """
        ChangeCurve2d(Adaptor2d_HOffsetCurve self) -> Adaptor2d_OffsetCurve

        Returns the curve used to create the GenHCurve.

        :rtype: OCC.wrapper.Adaptor2d.Adaptor2d_OffsetCurve

        """
        return _Adaptor2d.Adaptor2d_HOffsetCurve_ChangeCurve2d(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _Adaptor2d.Adaptor2d_HOffsetCurve_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _Adaptor2d.Adaptor2d_HOffsetCurve_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Adaptor2d.Adaptor2d_HOffsetCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _Adaptor2d.delete_Adaptor2d_HOffsetCurve
Adaptor2d_HOffsetCurve_swigregister = _Adaptor2d.Adaptor2d_HOffsetCurve_swigregister
Adaptor2d_HOffsetCurve_swigregister(Adaptor2d_HOffsetCurve)

def Adaptor2d_HOffsetCurve_get_type_name(*args):
    """
    Adaptor2d_HOffsetCurve_get_type_name() -> char const *

    :rtype: const char *

    """
    return _Adaptor2d.Adaptor2d_HOffsetCurve_get_type_name(*args)

def Adaptor2d_HOffsetCurve_get_type_descriptor(*args):
    """
    Adaptor2d_HOffsetCurve_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _Adaptor2d.Adaptor2d_HOffsetCurve_get_type_descriptor(*args)

class Handle_Adaptor2d_HOffsetCurve(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Adaptor2d_HOffsetCurve self)

        Nullify the handle


        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Adaptor2d_HOffsetCurve self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Adaptor2d_HOffsetCurve self, Adaptor2d_HOffsetCurve thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Adaptor2d_HOffsetCurve self, Handle_Adaptor2d_HOffsetCurve theHandle) -> Handle_Adaptor2d_HOffsetCurve
        assign(Handle_Adaptor2d_HOffsetCurve self, Adaptor2d_HOffsetCurve thePtr) -> Handle_Adaptor2d_HOffsetCurve
        assign(Handle_Adaptor2d_HOffsetCurve self, Handle_Adaptor2d_HOffsetCurve theHandle) -> Handle_Adaptor2d_HOffsetCurve

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Adaptor2d_HOffsetCurve self) -> Adaptor2d_HOffsetCurve

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Adaptor2d_HOffsetCurve self) -> Adaptor2d_HOffsetCurve

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Adaptor2d_HOffsetCurve self) -> Adaptor2d_HOffsetCurve

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve___ref__(self, *args)


    def __hash__(self):
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Adaptor2d.new_Handle_Adaptor2d_HOffsetCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Adaptor2d.Handle_Adaptor2d_HOffsetCurve_DownCast)
    __swig_destroy__ = _Adaptor2d.delete_Handle_Adaptor2d_HOffsetCurve

    def Set(self, *args):
        """
        Set(Handle_Adaptor2d_HOffsetCurve self, Adaptor2d_OffsetCurve C)

        Sets the field of the GenHCurve2d.

        :type C: OCC.wrapper.Adaptor2d.Adaptor2d_OffsetCurve

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_Set(self, *args)


    def Curve2d(self, *args):
        """
        Returns the curve used to create the GenHCurve2d.
        This is redefined from HCurve2d, cannot be inline.

        :rtype: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d

        """
        res = _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_Curve2d(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeCurve2d(self, *args):
        """
        ChangeCurve2d(Handle_Adaptor2d_HOffsetCurve self) -> Adaptor2d_OffsetCurve

        Returns the curve used to create the GenHCurve.

        :rtype: OCC.wrapper.Adaptor2d.Adaptor2d_OffsetCurve

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_ChangeCurve2d(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Adaptor2d_HOffsetCurve self) -> char const *

        :rtype: const char *

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_Adaptor2d_HOffsetCurve self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_Adaptor2d_HOffsetCurve self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_LastParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Adaptor2d_HOffsetCurve self) -> GeomAbs_Shape

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_Continuity(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_Adaptor2d_HOffsetCurve self, GeomAbs_Shape const S) -> Standard_Integer

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_Adaptor2d_HOffsetCurve self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_Intervals(self, *args)


    def Trim(self, *args):
        """
        Trim(Handle_Adaptor2d_HOffsetCurve self, Standard_Real const First, Standard_Real const Last, Standard_Real const Tol) -> Handle_Adaptor2d_HCurve2d

        If <First> >= <Last>

        :type First: float
        :type Last: float
        :type Tol: float
        :rtype: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_Trim(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_Adaptor2d_HOffsetCurve self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_Adaptor2d_HOffsetCurve self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_IsPeriodic(self, *args)


    def Period(self, *args):
        """
        Period(Handle_Adaptor2d_HOffsetCurve self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_Period(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Adaptor2d_HOffsetCurve self, Standard_Real const U) -> gp_Pnt2d

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_Value(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Adaptor2d_HOffsetCurve self, Standard_Real const U, gp_Pnt2d P)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Adaptor2d_HOffsetCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V: OCC.wrapper.gp.gp_Vec2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Adaptor2d_HOffsetCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Adaptor2d_HOffsetCurve self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Adaptor2d_HOffsetCurve self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_DN(self, *args)


    def Resolution(self, *args):
        """
        Resolution(Handle_Adaptor2d_HOffsetCurve self, Standard_Real const R3d) -> Standard_Real

        :type R3d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_Resolution(self, *args)


    def GetType(self, *args):
        """
        GetType(Handle_Adaptor2d_HOffsetCurve self) -> GeomAbs_CurveType

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_GetType(self, *args)


    def Line(self, *args):
        """
        Line(Handle_Adaptor2d_HOffsetCurve self) -> gp_Lin2d

        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_Line(self, *args)


    def Circle(self, *args):
        """
        Circle(Handle_Adaptor2d_HOffsetCurve self) -> gp_Circ2d

        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_Circle(self, *args)


    def Ellipse(self, *args):
        """
        Ellipse(Handle_Adaptor2d_HOffsetCurve self) -> gp_Elips2d

        :rtype: OCC.wrapper.gp.gp_Elips2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_Ellipse(self, *args)


    def Hyperbola(self, *args):
        """
        Hyperbola(Handle_Adaptor2d_HOffsetCurve self) -> gp_Hypr2d

        :rtype: OCC.wrapper.gp.gp_Hypr2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_Hyperbola(self, *args)


    def Parabola(self, *args):
        """
        Parabola(Handle_Adaptor2d_HOffsetCurve self) -> gp_Parab2d

        :rtype: OCC.wrapper.gp.gp_Parab2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_Parabola(self, *args)


    def Degree(self, *args):
        """
        Degree(Handle_Adaptor2d_HOffsetCurve self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_Degree(self, *args)


    def IsRational(self, *args):
        """
        IsRational(Handle_Adaptor2d_HOffsetCurve self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_IsRational(self, *args)


    def NbPoles(self, *args):
        """
        NbPoles(Handle_Adaptor2d_HOffsetCurve self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_NbPoles(self, *args)


    def NbKnots(self, *args):
        """
        NbKnots(Handle_Adaptor2d_HOffsetCurve self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_NbKnots(self, *args)


    def Bezier(self, *args):
        """
        Bezier(Handle_Adaptor2d_HOffsetCurve self) -> Handle_Geom2d_BezierCurve

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BezierCurve

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_Bezier(self, *args)


    def BSpline(self, *args):
        """
        BSpline(Handle_Adaptor2d_HOffsetCurve self) -> Handle_Geom2d_BSplineCurve

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_BSpline(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_Adaptor2d_HOffsetCurve self)

        Memory deallocator for transient classes


        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Adaptor2d_HOffsetCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Adaptor2d_HOffsetCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Adaptor2d_HOffsetCurve self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Adaptor2d_HOffsetCurve self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Adaptor2d_HOffsetCurve self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Adaptor2d_HOffsetCurve self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Adaptor2d_HOffsetCurve self)

        Increments the reference counter of this object


        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Adaptor2d_HOffsetCurve self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_DecrementRefCounter(self, *args)

Handle_Adaptor2d_HOffsetCurve_swigregister = _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_swigregister
Handle_Adaptor2d_HOffsetCurve_swigregister(Handle_Adaptor2d_HOffsetCurve)

def Handle_Adaptor2d_HOffsetCurve_DownCast(thing):
    return _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_DownCast(thing)
Handle_Adaptor2d_HOffsetCurve_DownCast = _Adaptor2d.Handle_Adaptor2d_HOffsetCurve_DownCast

class Handle_Adaptor2d_HCurve2d(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_Adaptor2d_HCurve2d self)

        Nullify the handle


        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_Adaptor2d_HCurve2d self) -> bool

        Check for being null

        :rtype: bool

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_Adaptor2d_HCurve2d self, Adaptor2d_HCurve2d thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_Adaptor2d_HCurve2d self, Handle_Adaptor2d_HCurve2d theHandle) -> Handle_Adaptor2d_HCurve2d
        assign(Handle_Adaptor2d_HCurve2d self, Adaptor2d_HCurve2d thePtr) -> Handle_Adaptor2d_HCurve2d
        assign(Handle_Adaptor2d_HCurve2d self, Handle_Adaptor2d_HCurve2d theHandle) -> Handle_Adaptor2d_HCurve2d

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_Adaptor2d_HCurve2d self) -> Adaptor2d_HCurve2d

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_Adaptor2d_HCurve2d self) -> Adaptor2d_HCurve2d

        Member access operator (note non-const)

        :rtype: T *

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_Adaptor2d_HCurve2d self) -> Adaptor2d_HCurve2d

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d___ref__(self, *args)


    def __hash__(self):
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _Adaptor2d.Handle_Adaptor2d_HCurve2d___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _Adaptor2d.new_Handle_Adaptor2d_HCurve2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_Adaptor2d.Handle_Adaptor2d_HCurve2d_DownCast)
    __swig_destroy__ = _Adaptor2d.delete_Handle_Adaptor2d_HCurve2d

    def Curve2d(self, *args):
        """
        Returns a reference to the Curve2d inside the HCurve2d.

        :rtype: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2d

        """
        res = _Adaptor2d.Handle_Adaptor2d_HCurve2d_Curve2d(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FirstParameter(self, *args):
        """
        FirstParameter(Handle_Adaptor2d_HCurve2d self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Handle_Adaptor2d_HCurve2d self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_LastParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_Adaptor2d_HCurve2d self) -> GeomAbs_Shape

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_Continuity(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Handle_Adaptor2d_HCurve2d self, GeomAbs_Shape const S) -> Standard_Integer

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Handle_Adaptor2d_HCurve2d self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_Intervals(self, *args)


    def Trim(self, *args):
        """
        Trim(Handle_Adaptor2d_HCurve2d self, Standard_Real const First, Standard_Real const Last, Standard_Real const Tol) -> Handle_Adaptor2d_HCurve2d

        If <First> >= <Last>

        :type First: float
        :type Last: float
        :type Tol: float
        :rtype: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_Trim(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Handle_Adaptor2d_HCurve2d self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Handle_Adaptor2d_HCurve2d self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_IsPeriodic(self, *args)


    def Period(self, *args):
        """
        Period(Handle_Adaptor2d_HCurve2d self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_Period(self, *args)


    def Value(self, *args):
        """
        Value(Handle_Adaptor2d_HCurve2d self, Standard_Real const U) -> gp_Pnt2d

        :type U: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_Value(self, *args)


    def D0(self, *args):
        """
        D0(Handle_Adaptor2d_HCurve2d self, Standard_Real const U, gp_Pnt2d P)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_D0(self, *args)


    def D1(self, *args):
        """
        D1(Handle_Adaptor2d_HCurve2d self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V: OCC.wrapper.gp.gp_Vec2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_D1(self, *args)


    def D2(self, *args):
        """
        D2(Handle_Adaptor2d_HCurve2d self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_D2(self, *args)


    def D3(self, *args):
        """
        D3(Handle_Adaptor2d_HCurve2d self, Standard_Real const U, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        :type U: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_D3(self, *args)


    def DN(self, *args):
        """
        DN(Handle_Adaptor2d_HCurve2d self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_DN(self, *args)


    def Resolution(self, *args):
        """
        Resolution(Handle_Adaptor2d_HCurve2d self, Standard_Real const R3d) -> Standard_Real

        :type R3d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_Resolution(self, *args)


    def GetType(self, *args):
        """
        GetType(Handle_Adaptor2d_HCurve2d self) -> GeomAbs_CurveType

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_GetType(self, *args)


    def Line(self, *args):
        """
        Line(Handle_Adaptor2d_HCurve2d self) -> gp_Lin2d

        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_Line(self, *args)


    def Circle(self, *args):
        """
        Circle(Handle_Adaptor2d_HCurve2d self) -> gp_Circ2d

        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_Circle(self, *args)


    def Ellipse(self, *args):
        """
        Ellipse(Handle_Adaptor2d_HCurve2d self) -> gp_Elips2d

        :rtype: OCC.wrapper.gp.gp_Elips2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_Ellipse(self, *args)


    def Hyperbola(self, *args):
        """
        Hyperbola(Handle_Adaptor2d_HCurve2d self) -> gp_Hypr2d

        :rtype: OCC.wrapper.gp.gp_Hypr2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_Hyperbola(self, *args)


    def Parabola(self, *args):
        """
        Parabola(Handle_Adaptor2d_HCurve2d self) -> gp_Parab2d

        :rtype: OCC.wrapper.gp.gp_Parab2d

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_Parabola(self, *args)


    def Degree(self, *args):
        """
        Degree(Handle_Adaptor2d_HCurve2d self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_Degree(self, *args)


    def IsRational(self, *args):
        """
        IsRational(Handle_Adaptor2d_HCurve2d self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_IsRational(self, *args)


    def NbPoles(self, *args):
        """
        NbPoles(Handle_Adaptor2d_HCurve2d self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_NbPoles(self, *args)


    def NbKnots(self, *args):
        """
        NbKnots(Handle_Adaptor2d_HCurve2d self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_NbKnots(self, *args)


    def Bezier(self, *args):
        """
        Bezier(Handle_Adaptor2d_HCurve2d self) -> Handle_Geom2d_BezierCurve

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BezierCurve

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_Bezier(self, *args)


    def BSpline(self, *args):
        """
        BSpline(Handle_Adaptor2d_HCurve2d self) -> Handle_Geom2d_BSplineCurve

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_BSpline(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_Adaptor2d_HCurve2d self) -> char const *

        :rtype: const char *

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Adaptor2d.Handle_Adaptor2d_HCurve2d_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _Adaptor2d.Handle_Adaptor2d_HCurve2d_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_Adaptor2d_HCurve2d self)

        Memory deallocator for transient classes


        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_Adaptor2d_HCurve2d self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_Adaptor2d_HCurve2d self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_Adaptor2d_HCurve2d self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_Adaptor2d_HCurve2d self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_Adaptor2d_HCurve2d self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_Adaptor2d_HCurve2d self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_Adaptor2d_HCurve2d self)

        Increments the reference counter of this object


        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_Adaptor2d_HCurve2d self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Handle_Adaptor2d_HCurve2d_DecrementRefCounter(self, *args)

Handle_Adaptor2d_HCurve2d_swigregister = _Adaptor2d.Handle_Adaptor2d_HCurve2d_swigregister
Handle_Adaptor2d_HCurve2d_swigregister(Handle_Adaptor2d_HCurve2d)

def Handle_Adaptor2d_HCurve2d_DownCast(thing):
    return _Adaptor2d.Handle_Adaptor2d_HCurve2d_DownCast(thing)
Handle_Adaptor2d_HCurve2d_DownCast = _Adaptor2d.Handle_Adaptor2d_HCurve2d_DownCast

class Adaptor2d_Line2d(Adaptor2d_Curve2d):
    """Use by the TopolTool to trim a surface."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Adaptor2d_Line2d self) -> Adaptor2d_Line2d
        __init__(Adaptor2d_Line2d self, gp_Pnt2d P, gp_Dir2d D, Standard_Real const UFirst, Standard_Real const ULast) -> Adaptor2d_Line2d

        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type D: OCC.wrapper.gp.gp_Dir2d
        :type UFirst: float
        :type ULast: float

        """
        this = _Adaptor2d.new_Adaptor2d_Line2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Load(self, *args):
        """
        Load(Adaptor2d_Line2d self, gp_Lin2d L)
        Load(Adaptor2d_Line2d self, gp_Lin2d L, Standard_Real const UFirst, Standard_Real const ULast)

        :type L: OCC.wrapper.gp.gp_Lin2d
        :type UFirst: float
        :type ULast: float

        """
        return _Adaptor2d.Adaptor2d_Line2d_Load(self, *args)


    def FirstParameter(self, *args):
        """
        FirstParameter(Adaptor2d_Line2d self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Adaptor2d.Adaptor2d_Line2d_FirstParameter(self, *args)


    def LastParameter(self, *args):
        """
        LastParameter(Adaptor2d_Line2d self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Adaptor2d.Adaptor2d_Line2d_LastParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Adaptor2d_Line2d self) -> GeomAbs_Shape

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Adaptor2d.Adaptor2d_Line2d_Continuity(self, *args)


    def NbIntervals(self, *args):
        """
        NbIntervals(Adaptor2d_Line2d self, GeomAbs_Shape const S) -> Standard_Integer

        If necessary,  breaks the  curve in  intervals  of
        continuity  <S>.    And  returns   the number   of
        intervals.

        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Adaptor2d_Line2d_NbIntervals(self, *args)


    def Intervals(self, *args):
        """
        Intervals(Adaptor2d_Line2d self, NCollection_Array1_Standard_Real T, GeomAbs_Shape const S)

        Stores in <T> the  parameters bounding the intervals
        of continuity <S>.

        The array must provide  enough room to  accomodate
        for the parameters. i.e. T.Length() > NbIntervals()

        :type T: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type S: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _Adaptor2d.Adaptor2d_Line2d_Intervals(self, *args)


    def Trim(self, *args):
        """
        Trim(Adaptor2d_Line2d self, Standard_Real const First, Standard_Real const Last, Standard_Real const Tol) -> Handle_Adaptor2d_HCurve2d

        Returns    a  curve equivalent   of  <me>  between
        parameters <First>  and <Last>. <Tol>  is used  to
        test for 3d points confusion.
        If <First> >= <Last>

        :type First: float
        :type Last: float
        :type Tol: float
        :rtype: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d

        """
        return _Adaptor2d.Adaptor2d_Line2d_Trim(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(Adaptor2d_Line2d self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Adaptor2d.Adaptor2d_Line2d_IsClosed(self, *args)


    def IsPeriodic(self, *args):
        """
        IsPeriodic(Adaptor2d_Line2d self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Adaptor2d.Adaptor2d_Line2d_IsPeriodic(self, *args)


    def Period(self, *args):
        """
        Period(Adaptor2d_Line2d self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Adaptor2d.Adaptor2d_Line2d_Period(self, *args)


    def Value(self, *args):
        """
        Value(Adaptor2d_Line2d self, Standard_Real const X) -> gp_Pnt2d

        :type X: float
        :rtype: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Adaptor2d.Adaptor2d_Line2d_Value(self, *args)


    def D0(self, *args):
        """
        D0(Adaptor2d_Line2d self, Standard_Real const X, gp_Pnt2d P)

        :type X: float
        :type P: OCC.wrapper.gp.gp_Pnt2d

        """
        return _Adaptor2d.Adaptor2d_Line2d_D0(self, *args)


    def D1(self, *args):
        """
        D1(Adaptor2d_Line2d self, Standard_Real const X, gp_Pnt2d P, gp_Vec2d V)

        :type X: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V: OCC.wrapper.gp.gp_Vec2d

        """
        return _Adaptor2d.Adaptor2d_Line2d_D1(self, *args)


    def D2(self, *args):
        """
        D2(Adaptor2d_Line2d self, Standard_Real const X, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2)

        :type X: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d

        """
        return _Adaptor2d.Adaptor2d_Line2d_D2(self, *args)


    def D3(self, *args):
        """
        D3(Adaptor2d_Line2d self, Standard_Real const X, gp_Pnt2d P, gp_Vec2d V1, gp_Vec2d V2, gp_Vec2d V3)

        :type X: float
        :type P: OCC.wrapper.gp.gp_Pnt2d
        :type V1: OCC.wrapper.gp.gp_Vec2d
        :type V2: OCC.wrapper.gp.gp_Vec2d
        :type V3: OCC.wrapper.gp.gp_Vec2d

        """
        return _Adaptor2d.Adaptor2d_Line2d_D3(self, *args)


    def DN(self, *args):
        """
        DN(Adaptor2d_Line2d self, Standard_Real const U, Standard_Integer const N) -> gp_Vec2d

        :type U: float
        :type N: int
        :rtype: OCC.wrapper.gp.gp_Vec2d

        """
        return _Adaptor2d.Adaptor2d_Line2d_DN(self, *args)


    def Resolution(self, *args):
        """
        Resolution(Adaptor2d_Line2d self, Standard_Real const R3d) -> Standard_Real

        :type R3d: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Adaptor2d.Adaptor2d_Line2d_Resolution(self, *args)


    def GetType(self, *args):
        """
        GetType(Adaptor2d_Line2d self) -> GeomAbs_CurveType

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_CurveType

        """
        return _Adaptor2d.Adaptor2d_Line2d_GetType(self, *args)


    def Line(self, *args):
        """
        Line(Adaptor2d_Line2d self) -> gp_Lin2d

        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _Adaptor2d.Adaptor2d_Line2d_Line(self, *args)


    def Circle(self, *args):
        """
        Circle(Adaptor2d_Line2d self) -> gp_Circ2d

        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        return _Adaptor2d.Adaptor2d_Line2d_Circle(self, *args)


    def Ellipse(self, *args):
        """
        Ellipse(Adaptor2d_Line2d self) -> gp_Elips2d

        :rtype: OCC.wrapper.gp.gp_Elips2d

        """
        return _Adaptor2d.Adaptor2d_Line2d_Ellipse(self, *args)


    def Hyperbola(self, *args):
        """
        Hyperbola(Adaptor2d_Line2d self) -> gp_Hypr2d

        :rtype: OCC.wrapper.gp.gp_Hypr2d

        """
        return _Adaptor2d.Adaptor2d_Line2d_Hyperbola(self, *args)


    def Parabola(self, *args):
        """
        Parabola(Adaptor2d_Line2d self) -> gp_Parab2d

        :rtype: OCC.wrapper.gp.gp_Parab2d

        """
        return _Adaptor2d.Adaptor2d_Line2d_Parabola(self, *args)


    def Degree(self, *args):
        """
        Degree(Adaptor2d_Line2d self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Adaptor2d_Line2d_Degree(self, *args)


    def IsRational(self, *args):
        """
        IsRational(Adaptor2d_Line2d self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Adaptor2d.Adaptor2d_Line2d_IsRational(self, *args)


    def NbPoles(self, *args):
        """
        NbPoles(Adaptor2d_Line2d self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Adaptor2d_Line2d_NbPoles(self, *args)


    def NbKnots(self, *args):
        """
        NbKnots(Adaptor2d_Line2d self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Adaptor2d.Adaptor2d_Line2d_NbKnots(self, *args)


    def Bezier(self, *args):
        """
        Bezier(Adaptor2d_Line2d self) -> Handle_Geom2d_BezierCurve

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BezierCurve

        """
        return _Adaptor2d.Adaptor2d_Line2d_Bezier(self, *args)


    def BSpline(self, *args):
        """
        BSpline(Adaptor2d_Line2d self) -> Handle_Geom2d_BSplineCurve

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

        """
        return _Adaptor2d.Adaptor2d_Line2d_BSpline(self, *args)

    __swig_destroy__ = _Adaptor2d.delete_Adaptor2d_Line2d
Adaptor2d_Line2d_swigregister = _Adaptor2d.Adaptor2d_Line2d_swigregister
Adaptor2d_Line2d_swigregister(Adaptor2d_Line2d)




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_TFunction')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_TFunction')
    _TFunction = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_TFunction', [dirname(__file__)])
        except ImportError:
            import _TFunction
            return _TFunction
        try:
            _mod = imp.load_module('_TFunction', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _TFunction = swig_import_helper()
    del swig_import_helper
else:
    import _TFunction
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _TFunction.delete_SwigPyIterator

    def value(self):
        return _TFunction.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _TFunction.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _TFunction.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _TFunction.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _TFunction.SwigPyIterator_equal(self, x)

    def copy(self):
        return _TFunction.SwigPyIterator_copy(self)

    def next(self):
        return _TFunction.SwigPyIterator_next(self)

    def __next__(self):
        return _TFunction.SwigPyIterator___next__(self)

    def previous(self):
        return _TFunction.SwigPyIterator_previous(self)

    def advance(self, n):
        return _TFunction.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _TFunction.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _TFunction.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _TFunction.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _TFunction.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _TFunction.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _TFunction.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _TFunction.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _TFunction.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_TFunction.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _TFunction.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _TFunction.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TFunction.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _TFunction.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _TFunction.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _TFunction.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _TFunction.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_TFunction.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _TFunction.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _TFunction.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TFunction.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _TFunction.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _TFunction.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _TFunction.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _TFunction.ptr_to_number(item)
ptr_to_number = _TFunction.ptr_to_number

def HashCode(*args):
    return _TFunction.HashCode(*args)
HashCode = _TFunction.HashCode

def ptr_equal(a, b):
    return _TFunction.ptr_equal(a, b)
ptr_equal = _TFunction.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TDF
else:
    import TDF
del _swig_python_version_info
TFunction_ES_WrongDefinition = _TFunction.TFunction_ES_WrongDefinition
TFunction_ES_NotExecuted = _TFunction.TFunction_ES_NotExecuted
TFunction_ES_Executing = _TFunction.TFunction_ES_Executing
TFunction_ES_Succeeded = _TFunction.TFunction_ES_Succeeded
TFunction_ES_Failed = _TFunction.TFunction_ES_Failed
class TFunction_Function(TDF.TDF_Attribute):
    """
    Provides the following two services
    -   a link to an evaluation driver
    -   the means of providing a link between a
    function and an evaluation driver.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TFunction_Function
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TFunction_Function(self) 
            return h


    def Set(*args):
        """
        Set(TDF_Label L) -> Handle_TFunction_Function
        Set(TDF_Label L, Standard_GUID DriverID) -> Handle_TFunction_Function

        Finds or Creates a function attribute on the label <L>.
        Sets a driver ID to the function.
        Returns the function attribute.

        :type L: OCC.wrapper.TDF.TDF_Label
        :type DriverID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.TFunction.Handle_TFunction_Function

        """
        return _TFunction.TFunction_Function_Set(*args)

    Set = staticmethod(Set)

    def GetID(*args):
        """
        GetID() -> Standard_GUID

        Returns the GUID for functions.
        Returns a function found on the label.
        Instance methods:
        ================

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TFunction.TFunction_Function_GetID(*args)

    GetID = staticmethod(GetID)

    def __init__(self, *args):
        """
        __init__(TFunction_Function self) -> TFunction_Function

        Provides the following two services
        -   a link to an evaluation driver
        -   the means of providing a link between a
        function and an evaluation driver.
        """
        this = _TFunction.new_TFunction_Function(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def GetDriverGUID(self, *args):
        """
        Returns the GUID for this function's driver.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TFunction.TFunction_Function_GetDriverGUID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDriverGUID(self, *args):
        """
        SetDriverGUID(TFunction_Function self, Standard_GUID guid)

        Sets the driver for this function as that
        indentified by the GUID guid.

        :type guid: OCC.wrapper.Standard.Standard_GUID

        """
        return _TFunction.TFunction_Function_SetDriverGUID(self, *args)


    def Failed(self, *args):
        """
        Failed(TFunction_Function self) -> Standard_Boolean

        Returns true if the execution failed

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.TFunction_Function_Failed(self, *args)


    def SetFailure(self, *args):
        """
        SetFailure(TFunction_Function self, Standard_Integer const mode=0)

        Sets the failed index.

        :type mode: int

        """
        return _TFunction.TFunction_Function_SetFailure(self, *args)


    def GetFailure(self, *args):
        """
        GetFailure(TFunction_Function self) -> Standard_Integer

        Returns an index of failure if the execution of this function failed.
        If this integer value is 0, no failure has occurred.
        Implementation of Attribute methods:
        ===================================

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.TFunction_Function_GetFailure(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TFunction.TFunction_Function_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TFunction_Function self, Handle_TDF_Attribute arg2)

        :type with: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TFunction.TFunction_Function_Restore(self, *args)


    def Paste(self, *args):
        """
        Paste(TFunction_Function self, Handle_TDF_Attribute into, Handle_TDF_RelocationTable RT)

        :type into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TFunction.TFunction_Function_Paste(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TFunction_Function self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TFunction.TFunction_Function_NewEmpty(self, *args)


    def References(self, *args):
        """
        References(TFunction_Function self, Handle_TDF_DataSet aDataSet)

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TFunction.TFunction_Function_References(self, *args)


    def Dump(self, *args):
        """
        Dump(TFunction_Function self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TFunction.TFunction_Function_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TFunction.TFunction_Function_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TFunction.TFunction_Function_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TFunction.TFunction_Function_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TFunction.delete_TFunction_Function
TFunction_Function_swigregister = _TFunction.TFunction_Function_swigregister
TFunction_Function_swigregister(TFunction_Function)

def TFunction_Function_Set(*args):
    """
    Set(TDF_Label L) -> Handle_TFunction_Function
    TFunction_Function_Set(TDF_Label L, Standard_GUID DriverID) -> Handle_TFunction_Function

    Finds or Creates a function attribute on the label <L>.
    Sets a driver ID to the function.
    Returns the function attribute.

    :type L: OCC.wrapper.TDF.TDF_Label
    :type DriverID: OCC.wrapper.Standard.Standard_GUID
    :rtype: OCC.wrapper.TFunction.Handle_TFunction_Function

    """
    return _TFunction.TFunction_Function_Set(*args)

def TFunction_Function_GetID(*args):
    """
    TFunction_Function_GetID() -> Standard_GUID

    Returns the GUID for functions.
    Returns a function found on the label.
    Instance methods:
    ================

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TFunction.TFunction_Function_GetID(*args)

def TFunction_Function_get_type_name(*args):
    """
    TFunction_Function_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TFunction.TFunction_Function_get_type_name(*args)

def TFunction_Function_get_type_descriptor(*args):
    """
    TFunction_Function_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TFunction.TFunction_Function_get_type_descriptor(*args)

class TFunction_Driver(Standard.Standard_Transient):
    """
    This  driver  class provide  services  around function
    execution.   One instance of  this class is  built for
    the whole  session.    The driver  is bound   to   the
    DriverGUID in the DriverTable class.
    It allows you to create classes which inherit from
    this abstract class.
    These subclasses identify the various algorithms
    which can be applied to the data contained in the
    attributes of sub-labels of a model.
    A single instance of this class and each of its
    subclasses is built for the whole session.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TFunction_Driver
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TFunction_Driver(self) 
            return h


    def Init(self, *args):
        """
        Init(TFunction_Driver self, TDF_Label L)

        Initializes the label L for this function prior to its  execution.

        :type L: OCC.wrapper.TDF.TDF_Label

        """
        return _TFunction.TFunction_Driver_Init(self, *args)


    def Label(self, *args):
        """
        Label(TFunction_Driver self) -> TDF_Label

        Returns the label of the driver for this function.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TFunction.TFunction_Driver_Label(self, *args)


    def Validate(self, *args):
        """
        Validate(TFunction_Driver self, Handle_TFunction_Logbook log)

        Validates labels of a function  in <log>.
        This function is the one initialized in this function driver.
        Warning
        In regeneration mode, the solver must call this
        method even if the function is not executed.
        execution of function
        =====================

        :type log: OCC.wrapper.TFunction.Handle_TFunction_Logbook

        """
        return _TFunction.TFunction_Driver_Validate(self, *args)


    def MustExecute(self, *args):
        """
        MustExecute(TFunction_Driver self, Handle_TFunction_Logbook log) -> Standard_Boolean

        Analyzes the labels in the logbook log.
        Returns true if attributes have been modified.
        If the function label itself has been modified, the function must be executed.

        :type log: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.TFunction_Driver_MustExecute(self, *args)


    def Execute(self, *args):
        """
        Execute(TFunction_Driver self, Handle_TFunction_Logbook log) -> Standard_Integer

        Executes the function in this function driver and
        puts the impacted labels in the logbook log.
        arguments & results of functions
        ================================

        :type log: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.TFunction_Driver_Execute(self, *args)


    def Arguments(self, *args):
        """
        Arguments(TFunction_Driver self, NCollection_List_TDF_Label args)

        The method fills-in the list by labels,
        where the arguments of the function are located.

        :type args: OCC.wrapper.TDF.TDF_LabelList

        """
        return _TFunction.TFunction_Driver_Arguments(self, *args)


    def Results(self, *args):
        """
        Results(TFunction_Driver self, NCollection_List_TDF_Label res)

        The method fills-in the list by labels,
        where the results of the function are located.

        :type res: OCC.wrapper.TDF.TDF_LabelList

        """
        return _TFunction.TFunction_Driver_Results(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TFunction.TFunction_Driver_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TFunction.TFunction_Driver_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TFunction.TFunction_Driver_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TFunction.delete_TFunction_Driver
TFunction_Driver_swigregister = _TFunction.TFunction_Driver_swigregister
TFunction_Driver_swigregister(TFunction_Driver)

def TFunction_Driver_get_type_name(*args):
    """
    TFunction_Driver_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TFunction.TFunction_Driver_get_type_name(*args)

def TFunction_Driver_get_type_descriptor(*args):
    """
    TFunction_Driver_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TFunction.TFunction_Driver_get_type_descriptor(*args)

class TFunction_Logbook(TDF.TDF_Attribute):
    """
    This class contains information which is written and
    read during the solving process. Information is divided
    in three groups.

    * Touched Labels  (modified by the end user),
    * Impacted Labels (modified during execution of the function),
    * Valid Labels    (within the valid label scope).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TFunction_Logbook
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TFunction_Logbook(self) 
            return h


    def Set(*args):
        """
        Set(TDF_Label Access) -> Handle_TFunction_Logbook

        Finds or Creates a TFunction_Logbook attribute at the root label accessed by <Access>.
        Returns the attribute.

        :type Access: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TFunction.Handle_TFunction_Logbook

        """
        return _TFunction.TFunction_Logbook_Set(*args)

    Set = staticmethod(Set)

    def GetID(*args):
        """
        GetID() -> Standard_GUID

        Returns the GUID for logbook attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TFunction.TFunction_Logbook_GetID(*args)

    GetID = staticmethod(GetID)

    def __init__(self, *args):
        """
        __init__(TFunction_Logbook self) -> TFunction_Logbook

        Constructor (empty).


        """
        this = _TFunction.new_TFunction_Logbook(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Clear(self, *args):
        """
        Clear(TFunction_Logbook self)

        Clears this logbook to its default, empty state.


        """
        return _TFunction.TFunction_Logbook_Clear(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(TFunction_Logbook self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.TFunction_Logbook_IsEmpty(self, *args)


    def SetTouched(self, *args):
        """
        SetTouched(TFunction_Logbook self, TDF_Label L)

        Sets the label L as a touched label in this logbook.
        In other words, L is understood to have been modified by the end user.

        :type L: OCC.wrapper.TDF.TDF_Label

        """
        return _TFunction.TFunction_Logbook_SetTouched(self, *args)


    def SetImpacted(self, *args):
        """
        SetImpacted(TFunction_Logbook self, TDF_Label L, Standard_Boolean const WithChildren)

        Sets the label L as an impacted label in this logbook.
        This method is called by execution of the function driver.

        :type L: OCC.wrapper.TDF.TDF_Label
        :type WithChildren: bool

        """
        return _TFunction.TFunction_Logbook_SetImpacted(self, *args)


    def SetValid(self, *args):
        """
        SetValid(TFunction_Logbook self, TDF_Label L, Standard_Boolean const WithChildren)
        SetValid(TFunction_Logbook self, NCollection_Map_TDF_Label_TDF_LabelMapHasher Ls)

        :type Ls: OCC.wrapper.TDF.TDF_LabelMap

        """
        return _TFunction.TFunction_Logbook_SetValid(self, *args)


    def IsModified(self, *args):
        """
        IsModified(TFunction_Logbook self, TDF_Label L, Standard_Boolean const WithChildren) -> Standard_Boolean

        Returns True if the label L is touched  or impacted. This method
        is called by <TFunction_FunctionDriver::MustExecute>.
        If <WithChildren> is set to true, the method checks
        all the sublabels of <L> too.

        :type L: OCC.wrapper.TDF.TDF_Label
        :type WithChildren: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.TFunction_Logbook_IsModified(self, *args)


    def GetTouched(self, *args):
        """
        Returns the map of touched labels in this logbook.
        A touched label is the one modified by the end user.

        :rtype: OCC.wrapper.TDF.TDF_LabelMap

        """
        res = _TFunction.TFunction_Logbook_GetTouched(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetImpacted(self, *args):
        """
        Returns the map of impacted labels contained in this logbook.

        :rtype: OCC.wrapper.TDF.TDF_LabelMap

        """
        res = _TFunction.TFunction_Logbook_GetImpacted(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetValid(self, *args):
        """
        Returns the map of valid labels in this logbook.

        :rtype: OCC.wrapper.TDF.TDF_LabelMap

        """
        res = _TFunction.TFunction_Logbook_GetValid(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Done(self, *args):
        """
        Done(TFunction_Logbook self, Standard_Boolean const status)

        Sets status of execution.

        :type status: bool

        """
        return _TFunction.TFunction_Logbook_Done(self, *args)


    def IsDone(self, *args):
        """
        IsDone(TFunction_Logbook self) -> Standard_Boolean

        Returns status of execution.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.TFunction_Logbook_IsDone(self, *args)


    def ID(self, *args):
        """
        Returns the ID of the attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TFunction.TFunction_Logbook_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TFunction_Logbook self, Handle_TDF_Attribute arg2)

        Undos (and redos) the attribute.

        :type with: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TFunction.TFunction_Logbook_Restore(self, *args)


    def Paste(self, *args):
        """
        Paste(TFunction_Logbook self, Handle_TDF_Attribute into, Handle_TDF_RelocationTable RT)

        Pastes the attribute to another label.

        :type into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TFunction.TFunction_Logbook_Paste(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TFunction_Logbook self) -> Handle_TDF_Attribute

        Returns a new empty instance of the attribute.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TFunction.TFunction_Logbook_NewEmpty(self, *args)


    def Dump(self, *args):
        """
        Dump(TFunction_Logbook self, Standard_OStream & anOS) -> Standard_OStream &

        Prints th data of the attributes (touched, impacted and valid labels).

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TFunction.TFunction_Logbook_Dump(self, *args)

    __swig_destroy__ = _TFunction.delete_TFunction_Logbook
TFunction_Logbook_swigregister = _TFunction.TFunction_Logbook_swigregister
TFunction_Logbook_swigregister(TFunction_Logbook)

def TFunction_Logbook_Set(*args):
    """
    TFunction_Logbook_Set(TDF_Label Access) -> Handle_TFunction_Logbook

    Finds or Creates a TFunction_Logbook attribute at the root label accessed by <Access>.
    Returns the attribute.

    :type Access: OCC.wrapper.TDF.TDF_Label
    :rtype: OCC.wrapper.TFunction.Handle_TFunction_Logbook

    """
    return _TFunction.TFunction_Logbook_Set(*args)

def TFunction_Logbook_GetID(*args):
    """
    TFunction_Logbook_GetID() -> Standard_GUID

    Returns the GUID for logbook attribute.

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TFunction.TFunction_Logbook_GetID(*args)

class TFunction_HArray1OfDataMapOfGUIDDriver(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TFunction_HArray1OfDataMapOfGUIDDriver
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TFunction_HArray1OfDataMapOfGUIDDriver(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TFunction_HArray1OfDataMapOfGUIDDriver self, Standard_Integer const theLower, Standard_Integer const theUpper) -> TFunction_HArray1OfDataMapOfGUIDDriver
        __init__(TFunction_HArray1OfDataMapOfGUIDDriver self, Standard_Integer const theLower, Standard_Integer const theUpper, NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID theValue) -> TFunction_HArray1OfDataMapOfGUIDDriver
        __init__(TFunction_HArray1OfDataMapOfGUIDDriver self, NCollection_Array1_TFunction_DataMapOfGUIDDriver theOther) -> TFunction_HArray1OfDataMapOfGUIDDriver

        :type theOther: OCC.wrapper.TFunction.TFunction_Array1OfDataMapOfGUIDDriver

        """
        this = _TFunction.new_TFunction_HArray1OfDataMapOfGUIDDriver(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.TFunction.TFunction_Array1OfDataMapOfGUIDDriver

        """
        res = _TFunction.TFunction_HArray1OfDataMapOfGUIDDriver_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(TFunction_HArray1OfDataMapOfGUIDDriver self) -> NCollection_Array1_TFunction_DataMapOfGUIDDriver

        :rtype: OCC.wrapper.TFunction.TFunction_Array1OfDataMapOfGUIDDriver

        """
        return _TFunction.TFunction_HArray1OfDataMapOfGUIDDriver_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TFunction.TFunction_HArray1OfDataMapOfGUIDDriver_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TFunction.TFunction_HArray1OfDataMapOfGUIDDriver_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TFunction.TFunction_HArray1OfDataMapOfGUIDDriver_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TFunction.delete_TFunction_HArray1OfDataMapOfGUIDDriver
TFunction_HArray1OfDataMapOfGUIDDriver_swigregister = _TFunction.TFunction_HArray1OfDataMapOfGUIDDriver_swigregister
TFunction_HArray1OfDataMapOfGUIDDriver_swigregister(TFunction_HArray1OfDataMapOfGUIDDriver)

def TFunction_HArray1OfDataMapOfGUIDDriver_get_type_name(*args):
    """
    TFunction_HArray1OfDataMapOfGUIDDriver_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TFunction.TFunction_HArray1OfDataMapOfGUIDDriver_get_type_name(*args)

def TFunction_HArray1OfDataMapOfGUIDDriver_get_type_descriptor(*args):
    """
    TFunction_HArray1OfDataMapOfGUIDDriver_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TFunction.TFunction_HArray1OfDataMapOfGUIDDriver_get_type_descriptor(*args)

class TFunction_GraphNode(TDF.TDF_Attribute):
    """Provides links between functions."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TFunction_GraphNode
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TFunction_GraphNode(self) 
            return h


    def Set(*args):
        """
        Set(TDF_Label L) -> Handle_TFunction_GraphNode

        Static methods
        ==============
        Finds or Creates a graph node attribute at the label <L>.
        Returns the attribute.

        :type L: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TFunction.Handle_TFunction_GraphNode

        """
        return _TFunction.TFunction_GraphNode_Set(*args)

    Set = staticmethod(Set)

    def GetID(*args):
        """
        GetID() -> Standard_GUID

        Returns the GUID for GraphNode attribute.
        Instant methods
        ===============
        Constructor (empty).

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TFunction.TFunction_GraphNode_GetID(*args)

    GetID = staticmethod(GetID)

    def __init__(self, *args):
        """
        __init__(TFunction_GraphNode self) -> TFunction_GraphNode

        Provides links between functions.
        """
        this = _TFunction.new_TFunction_GraphNode(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def AddPrevious(self, *args):
        """
        AddPrevious(TFunction_GraphNode self, Standard_Integer const funcID) -> Standard_Boolean
        AddPrevious(TFunction_GraphNode self, TDF_Label func) -> Standard_Boolean

        Defines a reference to the function as a previous one.

        :type func: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.TFunction_GraphNode_AddPrevious(self, *args)


    def RemovePrevious(self, *args):
        """
        RemovePrevious(TFunction_GraphNode self, Standard_Integer const funcID) -> Standard_Boolean
        RemovePrevious(TFunction_GraphNode self, TDF_Label func) -> Standard_Boolean

        Removes a reference to the function as a previous one.

        :type func: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.TFunction_GraphNode_RemovePrevious(self, *args)


    def GetPrevious(self, *args):
        """
        Returns a map of previous functions.

        :rtype: OCC.wrapper.TColStd.TColStd_MapOfInteger

        """
        res = _TFunction.TFunction_GraphNode_GetPrevious(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RemoveAllPrevious(self, *args):
        """
        RemoveAllPrevious(TFunction_GraphNode self)

        Clears a map of previous functions.


        """
        return _TFunction.TFunction_GraphNode_RemoveAllPrevious(self, *args)


    def AddNext(self, *args):
        """
        AddNext(TFunction_GraphNode self, Standard_Integer const funcID) -> Standard_Boolean
        AddNext(TFunction_GraphNode self, TDF_Label func) -> Standard_Boolean

        Defines a reference to the function as a next one.

        :type func: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.TFunction_GraphNode_AddNext(self, *args)


    def RemoveNext(self, *args):
        """
        RemoveNext(TFunction_GraphNode self, Standard_Integer const funcID) -> Standard_Boolean
        RemoveNext(TFunction_GraphNode self, TDF_Label func) -> Standard_Boolean

        Removes a reference to the function as a next one.

        :type func: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.TFunction_GraphNode_RemoveNext(self, *args)


    def GetNext(self, *args):
        """
        Returns a map of next functions.

        :rtype: OCC.wrapper.TColStd.TColStd_MapOfInteger

        """
        res = _TFunction.TFunction_GraphNode_GetNext(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RemoveAllNext(self, *args):
        """
        RemoveAllNext(TFunction_GraphNode self)

        Clears a map of next functions.


        """
        return _TFunction.TFunction_GraphNode_RemoveAllNext(self, *args)


    def GetStatus(self, *args):
        """
        GetStatus(TFunction_GraphNode self) -> TFunction_ExecutionStatus

        Returns the execution status of the function.

        :rtype: OCC.wrapper.TFunction.TFunction_ExecutionStatus

        """
        return _TFunction.TFunction_GraphNode_GetStatus(self, *args)


    def SetStatus(self, *args):
        """
        SetStatus(TFunction_GraphNode self, TFunction_ExecutionStatus const status)

        Defines an execution status for a function.
        Implementation of Attribute methods
        ===================================

        :type status: OCC.wrapper.TFunction.TFunction_ExecutionStatus

        """
        return _TFunction.TFunction_GraphNode_SetStatus(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TFunction.TFunction_GraphNode_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TFunction_GraphNode self, Handle_TDF_Attribute arg2)

        :type with: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TFunction.TFunction_GraphNode_Restore(self, *args)


    def Paste(self, *args):
        """
        Paste(TFunction_GraphNode self, Handle_TDF_Attribute into, Handle_TDF_RelocationTable RT)

        :type into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TFunction.TFunction_GraphNode_Paste(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TFunction_GraphNode self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TFunction.TFunction_GraphNode_NewEmpty(self, *args)


    def References(self, *args):
        """
        References(TFunction_GraphNode self, Handle_TDF_DataSet aDataSet)

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TFunction.TFunction_GraphNode_References(self, *args)


    def Dump(self, *args):
        """
        Dump(TFunction_GraphNode self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TFunction.TFunction_GraphNode_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TFunction.TFunction_GraphNode_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TFunction.TFunction_GraphNode_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TFunction.TFunction_GraphNode_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TFunction.delete_TFunction_GraphNode
TFunction_GraphNode_swigregister = _TFunction.TFunction_GraphNode_swigregister
TFunction_GraphNode_swigregister(TFunction_GraphNode)

def TFunction_GraphNode_Set(*args):
    """
    TFunction_GraphNode_Set(TDF_Label L) -> Handle_TFunction_GraphNode

    Static methods
    ==============
    Finds or Creates a graph node attribute at the label <L>.
    Returns the attribute.

    :type L: OCC.wrapper.TDF.TDF_Label
    :rtype: OCC.wrapper.TFunction.Handle_TFunction_GraphNode

    """
    return _TFunction.TFunction_GraphNode_Set(*args)

def TFunction_GraphNode_GetID(*args):
    """
    TFunction_GraphNode_GetID() -> Standard_GUID

    Returns the GUID for GraphNode attribute.
    Instant methods
    ===============
    Constructor (empty).

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TFunction.TFunction_GraphNode_GetID(*args)

def TFunction_GraphNode_get_type_name(*args):
    """
    TFunction_GraphNode_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TFunction.TFunction_GraphNode_get_type_name(*args)

def TFunction_GraphNode_get_type_descriptor(*args):
    """
    TFunction_GraphNode_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TFunction.TFunction_GraphNode_get_type_descriptor(*args)

class TFunction_Scope(TDF.TDF_Attribute):
    """Keeps a scope of functions."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TFunction_Scope
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TFunction_Scope(self) 
            return h


    def Set(*args):
        """
        Set(TDF_Label Access) -> Handle_TFunction_Scope

        Static methods
        ==============
        Finds or Creates a TFunction_Scope attribute at the root label accessed by <Access>.
        Returns the attribute.

        :type Access: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TFunction.Handle_TFunction_Scope

        """
        return _TFunction.TFunction_Scope_Set(*args)

    Set = staticmethod(Set)

    def GetID(*args):
        """
        GetID() -> Standard_GUID

        Returns the GUID for Scope attribute.
        Instant methods
        ===============
        Constructor (empty).

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TFunction.TFunction_Scope_GetID(*args)

    GetID = staticmethod(GetID)

    def __init__(self, *args):
        """
        __init__(TFunction_Scope self) -> TFunction_Scope

        Keeps a scope of functions.
        """
        this = _TFunction.new_TFunction_Scope(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def AddFunction(self, *args):
        """
        AddFunction(TFunction_Scope self, TDF_Label L) -> Standard_Boolean

        Adds a function to the scope of functions.

        :type L: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.TFunction_Scope_AddFunction(self, *args)


    def RemoveFunction(self, *args):
        """
        RemoveFunction(TFunction_Scope self, TDF_Label L) -> Standard_Boolean
        RemoveFunction(TFunction_Scope self, Standard_Integer const ID) -> Standard_Boolean

        Removes a function from the scope of functions.

        :type ID: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.TFunction_Scope_RemoveFunction(self, *args)


    def RemoveAllFunctions(self, *args):
        """
        RemoveAllFunctions(TFunction_Scope self)

        Removes all functions from the scope of functions.


        """
        return _TFunction.TFunction_Scope_RemoveAllFunctions(self, *args)


    def HasFunction(self, *args):
        """
        HasFunction(TFunction_Scope self, Standard_Integer const ID) -> Standard_Boolean
        HasFunction(TFunction_Scope self, TDF_Label L) -> Standard_Boolean

        Returns true if the label contains a function of this scope.

        :type L: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.TFunction_Scope_HasFunction(self, *args)


    def GetFunction(self, *args):
        """
        Returns the label of the function with this ID.

        :type ID: int
        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        res = _TFunction.TFunction_Scope_GetFunction(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetLogbook(self, *args):
        """
        GetLogbook(TFunction_Scope self) -> Handle_TFunction_Logbook

        Returns the Logbook used in TFunction_Driver methods.
        Implementation of Attribute methods
        ===================================

        :rtype: OCC.wrapper.TFunction.Handle_TFunction_Logbook

        """
        return _TFunction.TFunction_Scope_GetLogbook(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TFunction.TFunction_Scope_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TFunction_Scope self, Handle_TDF_Attribute arg2)

        :type with: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TFunction.TFunction_Scope_Restore(self, *args)


    def Paste(self, *args):
        """
        Paste(TFunction_Scope self, Handle_TDF_Attribute into, Handle_TDF_RelocationTable RT)

        :type into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TFunction.TFunction_Scope_Paste(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TFunction_Scope self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TFunction.TFunction_Scope_NewEmpty(self, *args)


    def Dump(self, *args):
        """
        Dump(TFunction_Scope self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TFunction.TFunction_Scope_Dump(self, *args)


    def GetFunctions(self, *args):
        """
        Returns the scope of functions.

        :rtype: OCC.wrapper.TFunction.TFunction_DoubleMapOfIntegerLabel

        """
        res = _TFunction.TFunction_Scope_GetFunctions(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFunctions(self, *args):
        """
        ChangeFunctions(TFunction_Scope self) -> NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher

        Returns the scope of functions for modification.
        Warning: Don't use this method if You are not sure what You do!

        :rtype: OCC.wrapper.TFunction.TFunction_DoubleMapOfIntegerLabel

        """
        return _TFunction.TFunction_Scope_ChangeFunctions(self, *args)


    def SetFreeID(self, *args):
        """
        SetFreeID(TFunction_Scope self, Standard_Integer const ID)

        :type ID: int

        """
        return _TFunction.TFunction_Scope_SetFreeID(self, *args)


    def GetFreeID(self, *args):
        """
        GetFreeID(TFunction_Scope self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.TFunction_Scope_GetFreeID(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TFunction.TFunction_Scope_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TFunction.TFunction_Scope_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TFunction.TFunction_Scope_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TFunction.delete_TFunction_Scope
TFunction_Scope_swigregister = _TFunction.TFunction_Scope_swigregister
TFunction_Scope_swigregister(TFunction_Scope)

def TFunction_Scope_Set(*args):
    """
    TFunction_Scope_Set(TDF_Label Access) -> Handle_TFunction_Scope

    Static methods
    ==============
    Finds or Creates a TFunction_Scope attribute at the root label accessed by <Access>.
    Returns the attribute.

    :type Access: OCC.wrapper.TDF.TDF_Label
    :rtype: OCC.wrapper.TFunction.Handle_TFunction_Scope

    """
    return _TFunction.TFunction_Scope_Set(*args)

def TFunction_Scope_GetID(*args):
    """
    TFunction_Scope_GetID() -> Standard_GUID

    Returns the GUID for Scope attribute.
    Instant methods
    ===============
    Constructor (empty).

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TFunction.TFunction_Scope_GetID(*args)

def TFunction_Scope_get_type_name(*args):
    """
    TFunction_Scope_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TFunction.TFunction_Scope_get_type_name(*args)

def TFunction_Scope_get_type_descriptor(*args):
    """
    TFunction_Scope_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TFunction.TFunction_Scope_get_type_descriptor(*args)

class Handle_TFunction_Scope(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TFunction_Scope self)

        Nullify the handle


        """
        return _TFunction.Handle_TFunction_Scope_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TFunction_Scope self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TFunction.Handle_TFunction_Scope_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TFunction_Scope self, TFunction_Scope thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TFunction.Handle_TFunction_Scope_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TFunction_Scope self, Handle_TFunction_Scope theHandle) -> Handle_TFunction_Scope
        assign(Handle_TFunction_Scope self, TFunction_Scope thePtr) -> Handle_TFunction_Scope
        assign(Handle_TFunction_Scope self, Handle_TFunction_Scope theHandle) -> Handle_TFunction_Scope

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TFunction.Handle_TFunction_Scope_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TFunction_Scope self) -> TFunction_Scope

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TFunction.Handle_TFunction_Scope_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TFunction_Scope self) -> TFunction_Scope

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TFunction.Handle_TFunction_Scope___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TFunction_Scope self) -> TFunction_Scope

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TFunction.Handle_TFunction_Scope___ref__(self, *args)


    def __hash__(self):
        return _TFunction.Handle_TFunction_Scope___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TFunction.Handle_TFunction_Scope___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TFunction.new_Handle_TFunction_Scope(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TFunction.Handle_TFunction_Scope_DownCast)
    __swig_destroy__ = _TFunction.delete_Handle_TFunction_Scope

    def Set(self, *args):
        """
        Set(Handle_TFunction_Scope self, TDF_Label Access) -> Handle_TFunction_Scope

        Static methods
        ==============
        Finds or Creates a TFunction_Scope attribute at the root label accessed by <Access>.
        Returns the attribute.

        :type Access: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TFunction.Handle_TFunction_Scope

        """
        return _TFunction.Handle_TFunction_Scope_Set(self, *args)


    def GetID(self, *args):
        """
        Returns the GUID for Scope attribute.
        Instant methods
        ===============
        Constructor (empty).

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TFunction.Handle_TFunction_Scope_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AddFunction(self, *args):
        """
        AddFunction(Handle_TFunction_Scope self, TDF_Label L) -> Standard_Boolean

        Adds a function to the scope of functions.

        :type L: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Scope_AddFunction(self, *args)


    def RemoveFunction(self, *args):
        """
        RemoveFunction(Handle_TFunction_Scope self, TDF_Label L) -> Standard_Boolean
        RemoveFunction(Handle_TFunction_Scope self, Standard_Integer const ID) -> Standard_Boolean

        Removes a function from the scope of functions.

        :type ID: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Scope_RemoveFunction(self, *args)


    def RemoveAllFunctions(self, *args):
        """
        RemoveAllFunctions(Handle_TFunction_Scope self)

        Removes all functions from the scope of functions.


        """
        return _TFunction.Handle_TFunction_Scope_RemoveAllFunctions(self, *args)


    def HasFunction(self, *args):
        """
        HasFunction(Handle_TFunction_Scope self, Standard_Integer const ID) -> Standard_Boolean
        HasFunction(Handle_TFunction_Scope self, TDF_Label L) -> Standard_Boolean

        Returns true if the label contains a function of this scope.

        :type L: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Scope_HasFunction(self, *args)


    def GetFunction(self, *args):
        """
        Returns the label of the function with this ID.

        :type ID: int
        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        res = _TFunction.Handle_TFunction_Scope_GetFunction(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetLogbook(self, *args):
        """
        GetLogbook(Handle_TFunction_Scope self) -> Handle_TFunction_Logbook

        Returns the Logbook used in TFunction_Driver methods.
        Implementation of Attribute methods
        ===================================

        :rtype: OCC.wrapper.TFunction.Handle_TFunction_Logbook

        """
        return _TFunction.Handle_TFunction_Scope_GetLogbook(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TFunction.Handle_TFunction_Scope_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TFunction_Scope self, Handle_TDF_Attribute arg2)

        :type with: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TFunction.Handle_TFunction_Scope_Restore(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TFunction_Scope self, Handle_TDF_Attribute into, Handle_TDF_RelocationTable RT)

        :type into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TFunction.Handle_TFunction_Scope_Paste(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TFunction_Scope self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TFunction.Handle_TFunction_Scope_NewEmpty(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TFunction_Scope self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TFunction.Handle_TFunction_Scope_Dump(self, *args)


    def GetFunctions(self, *args):
        """
        Returns the scope of functions.

        :rtype: OCC.wrapper.TFunction.TFunction_DoubleMapOfIntegerLabel

        """
        res = _TFunction.Handle_TFunction_Scope_GetFunctions(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFunctions(self, *args):
        """
        ChangeFunctions(Handle_TFunction_Scope self) -> NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher

        Returns the scope of functions for modification.
        Warning: Don't use this method if You are not sure what You do!

        :rtype: OCC.wrapper.TFunction.TFunction_DoubleMapOfIntegerLabel

        """
        return _TFunction.Handle_TFunction_Scope_ChangeFunctions(self, *args)


    def SetFreeID(self, *args):
        """
        SetFreeID(Handle_TFunction_Scope self, Standard_Integer const ID)

        :type ID: int

        """
        return _TFunction.Handle_TFunction_Scope_SetFreeID(self, *args)


    def GetFreeID(self, *args):
        """
        GetFreeID(Handle_TFunction_Scope self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.Handle_TFunction_Scope_GetFreeID(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TFunction_Scope self) -> char const *

        :rtype: const char *

        """
        return _TFunction.Handle_TFunction_Scope_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TFunction.Handle_TFunction_Scope_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TFunction.Handle_TFunction_Scope_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetID(self, *args):
        """
        SetID(Handle_TFunction_Scope self, Standard_GUID arg2)
        SetID(Handle_TFunction_Scope self)

        Sets default ID defined in nested class (to be used for attributes having User ID feature).


        """
        return _TFunction.Handle_TFunction_Scope_SetID(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TFunction_Scope self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TFunction.Handle_TFunction_Scope_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TFunction_Scope self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.Handle_TFunction_Scope_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TFunction_Scope self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.Handle_TFunction_Scope_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TFunction_Scope self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Scope_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TFunction_Scope self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Scope_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TFunction_Scope self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Scope_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TFunction_Scope self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Scope_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TFunction_Scope self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Scope_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TFunction_Scope self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TFunction.Handle_TFunction_Scope_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TFunction_Scope self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Scope_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TFunction_Scope self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TFunction.Handle_TFunction_Scope_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TFunction_Scope self)

        Something to do after adding an Attribute to a label.


        """
        return _TFunction.Handle_TFunction_Scope_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TFunction_Scope self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TFunction.Handle_TFunction_Scope_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TFunction_Scope self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TFunction.Handle_TFunction_Scope_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TFunction_Scope self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TFunction.Handle_TFunction_Scope_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TFunction_Scope self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Scope_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TFunction_Scope self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Scope_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TFunction_Scope self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Scope_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TFunction_Scope self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TFunction.Handle_TFunction_Scope_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TFunction_Scope self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TFunction.Handle_TFunction_Scope_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TFunction_Scope self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Scope_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TFunction_Scope self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TFunction.Handle_TFunction_Scope_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TFunction_Scope self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TFunction.Handle_TFunction_Scope_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TFunction_Scope self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TFunction.Handle_TFunction_Scope_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TFunction_Scope self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TFunction.Handle_TFunction_Scope_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TFunction_Scope self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TFunction.Handle_TFunction_Scope_DeltaOnRemoval(self, *args)


    def References(self, *args):
        """
        References(Handle_TFunction_Scope self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TFunction.Handle_TFunction_Scope_References(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TFunction_Scope self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TFunction.Handle_TFunction_Scope___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TFunction_Scope self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TFunction.Handle_TFunction_Scope_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TFunction_Scope self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TFunction.Handle_TFunction_Scope_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TFunction_Scope self)

        Memory deallocator for transient classes


        """
        return _TFunction.Handle_TFunction_Scope_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TFunction_Scope self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TFunction_Scope self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Scope_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TFunction_Scope self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TFunction_Scope self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Scope_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TFunction_Scope self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TFunction.Handle_TFunction_Scope_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TFunction_Scope self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.Handle_TFunction_Scope_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TFunction_Scope self)

        Increments the reference counter of this object


        """
        return _TFunction.Handle_TFunction_Scope_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TFunction_Scope self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.Handle_TFunction_Scope_DecrementRefCounter(self, *args)

Handle_TFunction_Scope_swigregister = _TFunction.Handle_TFunction_Scope_swigregister
Handle_TFunction_Scope_swigregister(Handle_TFunction_Scope)

def Handle_TFunction_Scope_DownCast(thing):
    return _TFunction.Handle_TFunction_Scope_DownCast(thing)
Handle_TFunction_Scope_DownCast = _TFunction.Handle_TFunction_Scope_DownCast

class NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID self) -> NCollection_DataMap< Standard_GUID,opencascade::handle< TFunction_Driver >,Standard_GUID >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TFunction.NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID self) -> NCollection_DataMap< Standard_GUID,opencascade::handle< TFunction_Driver >,Standard_GUID >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TFunction.NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID self) -> NCollection_DataMap< Standard_GUID,opencascade::handle< TFunction_Driver >,Standard_GUID >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TFunction.NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID self) -> NCollection_DataMap< Standard_GUID,opencascade::handle< TFunction_Driver >,Standard_GUID >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TFunction.NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TFunction.new_NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID self, NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TFunction.NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID self, NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID theOther) -> NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TFunction.NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID self, NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID theOther) -> NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TFunction.NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TFunction.NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID self, Standard_GUID theKey, Handle_TFunction_Driver theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID self, Standard_GUID theKey, Handle_TFunction_Driver theItem) -> Handle_TFunction_Driver

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TFunction.NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID self, Standard_GUID theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID self, Standard_GUID theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID self, Standard_GUID theKey) -> Handle_TFunction_Driver

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TFunction.NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TFunction.NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID self, Standard_GUID theKey) -> Handle_TFunction_Driver

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TFunction.NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID self, Standard_GUID theKey) -> Handle_TFunction_Driver

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TFunction.NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TFunction.NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TFunction.NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID_Size(self, *args)


    def __iter__(self):
        return _TFunction.NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID___iter__(self)
    __swig_destroy__ = _TFunction.delete_NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID
NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID_swigregister = _TFunction.NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID_swigregister
NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID_swigregister(NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID)

class NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TFunction.new_NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TFunction.delete_NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID_IteratorHelper

    def __next__(self):
        return _TFunction.NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID_IteratorHelper___next__(self)
NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID_IteratorHelper_swigregister = _TFunction.NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID_IteratorHelper_swigregister
NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID_IteratorHelper_swigregister(NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID_IteratorHelper)


try:
	TFunction_DataMapOfGUIDDriver = NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID
except NameError:
	pass # does not exist, probably ignored


try:
	TDF_LabelList = TDF.NCollection_List_TDF_Label
except AttributeError:
	pass # does not exist, probably ignored

class Handle_TFunction_Logbook(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TFunction_Logbook self)

        Nullify the handle


        """
        return _TFunction.Handle_TFunction_Logbook_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TFunction_Logbook self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TFunction.Handle_TFunction_Logbook_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TFunction_Logbook self, TFunction_Logbook thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TFunction.Handle_TFunction_Logbook_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TFunction_Logbook self, Handle_TFunction_Logbook theHandle) -> Handle_TFunction_Logbook
        assign(Handle_TFunction_Logbook self, TFunction_Logbook thePtr) -> Handle_TFunction_Logbook
        assign(Handle_TFunction_Logbook self, Handle_TFunction_Logbook theHandle) -> Handle_TFunction_Logbook

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TFunction.Handle_TFunction_Logbook_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TFunction_Logbook self) -> TFunction_Logbook

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TFunction.Handle_TFunction_Logbook_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TFunction_Logbook self) -> TFunction_Logbook

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TFunction.Handle_TFunction_Logbook___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TFunction_Logbook self) -> TFunction_Logbook

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TFunction.Handle_TFunction_Logbook___ref__(self, *args)


    def __hash__(self):
        return _TFunction.Handle_TFunction_Logbook___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TFunction.Handle_TFunction_Logbook___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TFunction.new_Handle_TFunction_Logbook(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TFunction.Handle_TFunction_Logbook_DownCast)
    __swig_destroy__ = _TFunction.delete_Handle_TFunction_Logbook

    def Set(self, *args):
        """
        Set(Handle_TFunction_Logbook self, TDF_Label Access) -> Handle_TFunction_Logbook

        Finds or Creates a TFunction_Logbook attribute at the root label accessed by <Access>.
        Returns the attribute.

        :type Access: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TFunction.Handle_TFunction_Logbook

        """
        return _TFunction.Handle_TFunction_Logbook_Set(self, *args)


    def GetID(self, *args):
        """
        Returns the GUID for logbook attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TFunction.Handle_TFunction_Logbook_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(Handle_TFunction_Logbook self)

        Clears this logbook to its default, empty state.


        """
        return _TFunction.Handle_TFunction_Logbook_Clear(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_TFunction_Logbook self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Logbook_IsEmpty(self, *args)


    def SetTouched(self, *args):
        """
        SetTouched(Handle_TFunction_Logbook self, TDF_Label L)

        Sets the label L as a touched label in this logbook.
        In other words, L is understood to have been modified by the end user.

        :type L: OCC.wrapper.TDF.TDF_Label

        """
        return _TFunction.Handle_TFunction_Logbook_SetTouched(self, *args)


    def SetImpacted(self, *args):
        """
        SetImpacted(Handle_TFunction_Logbook self, TDF_Label L, Standard_Boolean const WithChildren)

        Sets the label L as an impacted label in this logbook.
        This method is called by execution of the function driver.

        :type L: OCC.wrapper.TDF.TDF_Label
        :type WithChildren: bool

        """
        return _TFunction.Handle_TFunction_Logbook_SetImpacted(self, *args)


    def SetValid(self, *args):
        """
        SetValid(Handle_TFunction_Logbook self, TDF_Label L, Standard_Boolean const WithChildren)
        SetValid(Handle_TFunction_Logbook self, NCollection_Map_TDF_Label_TDF_LabelMapHasher Ls)

        :type Ls: OCC.wrapper.TDF.TDF_LabelMap

        """
        return _TFunction.Handle_TFunction_Logbook_SetValid(self, *args)


    def IsModified(self, *args):
        """
        IsModified(Handle_TFunction_Logbook self, TDF_Label L, Standard_Boolean const WithChildren) -> Standard_Boolean

        Returns True if the label L is touched  or impacted. This method
        is called by <TFunction_FunctionDriver::MustExecute>.
        If <WithChildren> is set to true, the method checks
        all the sublabels of <L> too.

        :type L: OCC.wrapper.TDF.TDF_Label
        :type WithChildren: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Logbook_IsModified(self, *args)


    def GetTouched(self, *args):
        """
        Returns the map of touched labels in this logbook.
        A touched label is the one modified by the end user.

        :rtype: OCC.wrapper.TDF.TDF_LabelMap

        """
        res = _TFunction.Handle_TFunction_Logbook_GetTouched(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetImpacted(self, *args):
        """
        Returns the map of impacted labels contained in this logbook.

        :rtype: OCC.wrapper.TDF.TDF_LabelMap

        """
        res = _TFunction.Handle_TFunction_Logbook_GetImpacted(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetValid(self, *args):
        """
        Returns the map of valid labels in this logbook.

        :rtype: OCC.wrapper.TDF.TDF_LabelMap

        """
        res = _TFunction.Handle_TFunction_Logbook_GetValid(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Done(self, *args):
        """
        Done(Handle_TFunction_Logbook self, Standard_Boolean const status)

        Sets status of execution.

        :type status: bool

        """
        return _TFunction.Handle_TFunction_Logbook_Done(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Handle_TFunction_Logbook self) -> Standard_Boolean

        Returns status of execution.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Logbook_IsDone(self, *args)


    def ID(self, *args):
        """
        Returns the ID of the attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TFunction.Handle_TFunction_Logbook_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TFunction_Logbook self, Handle_TDF_Attribute arg2)

        Undos (and redos) the attribute.

        :type with: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TFunction.Handle_TFunction_Logbook_Restore(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TFunction_Logbook self, Handle_TDF_Attribute into, Handle_TDF_RelocationTable RT)

        Pastes the attribute to another label.

        :type into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TFunction.Handle_TFunction_Logbook_Paste(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TFunction_Logbook self) -> Handle_TDF_Attribute

        Returns a new empty instance of the attribute.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TFunction.Handle_TFunction_Logbook_NewEmpty(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TFunction_Logbook self, Standard_OStream & anOS) -> Standard_OStream &

        Prints th data of the attributes (touched, impacted and valid labels).

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TFunction.Handle_TFunction_Logbook_Dump(self, *args)


    def SetID(self, *args):
        """
        SetID(Handle_TFunction_Logbook self, Standard_GUID arg2)
        SetID(Handle_TFunction_Logbook self)

        Sets default ID defined in nested class (to be used for attributes having User ID feature).


        """
        return _TFunction.Handle_TFunction_Logbook_SetID(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TFunction_Logbook self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TFunction.Handle_TFunction_Logbook_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TFunction_Logbook self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.Handle_TFunction_Logbook_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TFunction_Logbook self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.Handle_TFunction_Logbook_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TFunction_Logbook self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Logbook_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TFunction_Logbook self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Logbook_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TFunction_Logbook self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Logbook_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TFunction_Logbook self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Logbook_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TFunction_Logbook self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Logbook_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TFunction_Logbook self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TFunction.Handle_TFunction_Logbook_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TFunction_Logbook self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Logbook_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TFunction_Logbook self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TFunction.Handle_TFunction_Logbook_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TFunction_Logbook self)

        Something to do after adding an Attribute to a label.


        """
        return _TFunction.Handle_TFunction_Logbook_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TFunction_Logbook self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TFunction.Handle_TFunction_Logbook_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TFunction_Logbook self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TFunction.Handle_TFunction_Logbook_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TFunction_Logbook self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TFunction.Handle_TFunction_Logbook_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TFunction_Logbook self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Logbook_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TFunction_Logbook self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Logbook_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TFunction_Logbook self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Logbook_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TFunction_Logbook self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TFunction.Handle_TFunction_Logbook_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TFunction_Logbook self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TFunction.Handle_TFunction_Logbook_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TFunction_Logbook self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Logbook_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TFunction_Logbook self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TFunction.Handle_TFunction_Logbook_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TFunction_Logbook self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TFunction.Handle_TFunction_Logbook_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TFunction_Logbook self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TFunction.Handle_TFunction_Logbook_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TFunction_Logbook self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TFunction.Handle_TFunction_Logbook_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TFunction_Logbook self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TFunction.Handle_TFunction_Logbook_DeltaOnRemoval(self, *args)


    def References(self, *args):
        """
        References(Handle_TFunction_Logbook self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TFunction.Handle_TFunction_Logbook_References(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TFunction_Logbook self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TFunction.Handle_TFunction_Logbook___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TFunction_Logbook self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TFunction.Handle_TFunction_Logbook_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TFunction_Logbook self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TFunction.Handle_TFunction_Logbook_Forget(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TFunction_Logbook self) -> char const *

        :rtype: const char *

        """
        return _TFunction.Handle_TFunction_Logbook_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TFunction.Handle_TFunction_Logbook_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TFunction.Handle_TFunction_Logbook_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TFunction_Logbook self)

        Memory deallocator for transient classes


        """
        return _TFunction.Handle_TFunction_Logbook_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TFunction_Logbook self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TFunction_Logbook self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Logbook_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TFunction_Logbook self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TFunction_Logbook self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Logbook_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TFunction_Logbook self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TFunction.Handle_TFunction_Logbook_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TFunction_Logbook self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.Handle_TFunction_Logbook_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TFunction_Logbook self)

        Increments the reference counter of this object


        """
        return _TFunction.Handle_TFunction_Logbook_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TFunction_Logbook self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.Handle_TFunction_Logbook_DecrementRefCounter(self, *args)

Handle_TFunction_Logbook_swigregister = _TFunction.Handle_TFunction_Logbook_swigregister
Handle_TFunction_Logbook_swigregister(Handle_TFunction_Logbook)

def Handle_TFunction_Logbook_DownCast(thing):
    return _TFunction.Handle_TFunction_Logbook_DownCast(thing)
Handle_TFunction_Logbook_DownCast = _TFunction.Handle_TFunction_Logbook_DownCast

class NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher self) -> NCollection_DataMap< TDF_Label,TDF_LabelList,TDF_LabelMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TFunction.NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher self) -> NCollection_DataMap< TDF_Label,TDF_LabelList,TDF_LabelMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TFunction.NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher self) -> NCollection_DataMap< TDF_Label,TDF_LabelList,TDF_LabelMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TFunction.NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher self) -> NCollection_DataMap< TDF_Label,TDF_LabelList,TDF_LabelMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TFunction.NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TFunction.new_NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher self, NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TFunction.NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher self, NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher theOther) -> NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TFunction.NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher self, NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher theOther) -> NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TFunction.NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TFunction.NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher self, TDF_Label theKey, NCollection_List_TDF_Label theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher self, TDF_Label theKey, NCollection_List_TDF_Label theItem) -> NCollection_List_TDF_Label

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TFunction.NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher self, TDF_Label theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher self, TDF_Label theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher self, TDF_Label theKey) -> NCollection_List_TDF_Label

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TFunction.NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TFunction.NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher self, TDF_Label theKey) -> NCollection_List_TDF_Label

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TFunction.NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher self, TDF_Label theKey) -> NCollection_List_TDF_Label

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TFunction.NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TFunction.NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TFunction.NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher_Size(self, *args)


    def __iter__(self):
        return _TFunction.NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher___iter__(self)
    __swig_destroy__ = _TFunction.delete_NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher
NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher_swigregister = _TFunction.NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher_swigregister
NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher_swigregister(NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher)

class NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TFunction.new_NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TFunction.delete_NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher_IteratorHelper

    def __next__(self):
        return _TFunction.NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher_IteratorHelper_swigregister = _TFunction.NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher_IteratorHelper)


try:
	TFunction_DataMapOfLabelListOfLabel = NCollection_DataMap_TDF_Label_TDF_LabelList_TDF_LabelMapHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DoubleMap  is used to  bind  pairs (Key1,Key2)
    and retrieve them in linear time.

    See Map from NCollection for a discussion about the number
    of buckets
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Purpose:     The DoubleMap  is used to  bind  pairs (Key1,Key2)
        and retrieve them in linear time.

        See Map from NCollection for a discussion about the number
        of buckets
        """
        this = _TFunction.new_NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher self, NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DoubleMap

        """
        return _TFunction.NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher self, NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher theOther) -> NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DoubleMap
        :rtype: OCC.wrapper.NCollection.NCollection_DoubleMap

        """
        return _TFunction.NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher self, NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher theOther) -> NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DoubleMap
        :rtype: OCC.wrapper.NCollection.NCollection_DoubleMap

        """
        return _TFunction.NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TFunction.NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher self, int const & theKey1, TDF_Label theKey2)

        Bind

        :type theKey1: const TheKey1Type &
        :type theKey2: const TheKey2Type &

        """
        return _TFunction.NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher_Bind(self, *args)


    def AreBound(self, *args):
        """
        AreBound(NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher self, int const & theKey1, TDF_Label theKey2) -> Standard_Boolean

        * AreBound

        :type theKey1: const TheKey1Type &
        :type theKey2: const TheKey2Type &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher_AreBound(self, *args)


    def IsBound1(self, *args):
        """
        IsBound1(NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher self, int const & theKey1) -> Standard_Boolean

        IsBound1

        :type theKey1: const TheKey1Type &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher_IsBound1(self, *args)


    def IsBound2(self, *args):
        """
        IsBound2(NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher self, TDF_Label theKey2) -> Standard_Boolean

        IsBound2

        :type theKey2: const TheKey2Type &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher_IsBound2(self, *args)


    def UnBind1(self, *args):
        """
        UnBind1(NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher self, int const & theKey1) -> Standard_Boolean

        UnBind1

        :type theKey1: const TheKey1Type &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher_UnBind1(self, *args)


    def UnBind2(self, *args):
        """
        UnBind2(NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher self, TDF_Label theKey2) -> Standard_Boolean

        UnBind2

        :type theKey2: const TheKey2Type &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher_UnBind2(self, *args)


    def Find1(self, *args):
        """
        Find1

        :type theKey1: const TheKey1Type &
        :rtype: const TheKey2Type &

        """
        res = _TFunction.NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher_Find1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Find2(self, *args):
        """
        Find2

        :type theKey2: const TheKey2Type &
        :rtype: const TheKey1Type &

        """
        res = _TFunction.NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher_Find2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TFunction.NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher_Size(self, *args)

    __swig_destroy__ = _TFunction.delete_NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher
NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher_swigregister = _TFunction.NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher_swigregister
NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher_swigregister(NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher)


try:
	TFunction_DoubleMapOfIntegerLabel = NCollection_DoubleMap_Standard_Integer_TDF_Label_TColStd_MapIntegerHasher_TDF_LabelMapHasher
except NameError:
	pass # does not exist, probably ignored

class TFunction_Iterator(object):
    """Iterator of the graph of functions"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TFunction_Iterator self) -> TFunction_Iterator
        __init__(TFunction_Iterator self, TDF_Label Access) -> TFunction_Iterator

        A constructor.
        Initializes the iterator.

        :type Access: OCC.wrapper.TDF.TDF_Label

        """
        this = _TFunction.new_TFunction_Iterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(TFunction_Iterator self, TDF_Label Access)

        Initializes the Iterator.

        :type Access: OCC.wrapper.TDF.TDF_Label

        """
        return _TFunction.TFunction_Iterator_Init(self, *args)


    def SetUsageOfExecutionStatus(self, *args):
        """
        SetUsageOfExecutionStatus(TFunction_Iterator self, Standard_Boolean const usage)

        Defines the mode of iteration - usage or not of the execution status.
        If the iterator takes into account the execution status,
        the method ::Current() returns only "not executed" functions
        while their status is not changed.
        If the iterator ignores the execution status,
        the method ::Current() returns the functions
        following their dependencies and ignoring the execution status.

        :type usage: bool

        """
        return _TFunction.TFunction_Iterator_SetUsageOfExecutionStatus(self, *args)


    def GetUsageOfExecutionStatus(self, *args):
        """
        GetUsageOfExecutionStatus(TFunction_Iterator self) -> Standard_Boolean

        Returns usage of execution status by the iterator.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.TFunction_Iterator_GetUsageOfExecutionStatus(self, *args)


    def GetMaxNbThreads(self, *args):
        """
        GetMaxNbThreads(TFunction_Iterator self) -> Standard_Integer

        Analyses the graph of dependencies and returns
        maximum number of threads may be used to calculate the model.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.TFunction_Iterator_GetMaxNbThreads(self, *args)


    def Current(self, *args):
        """
        Returns the current list of functions.
        If the iterator uses the execution status,
        the returned list contains only the functions
        with "not executed" status.

        :rtype: OCC.wrapper.TDF.TDF_LabelList

        """
        res = _TFunction.TFunction_Iterator_Current(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def More(self, *args):
        """
        More(TFunction_Iterator self) -> Standard_Boolean

        Returns false if the graph of functions is fully iterated.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.TFunction_Iterator_More(self, *args)


    def Next(self, *args):
        """
        Next(TFunction_Iterator self)

        Switches the iterator to the next list of current functions.


        """
        return _TFunction.TFunction_Iterator_Next(self, *args)


    def GetStatus(self, *args):
        """
        GetStatus(TFunction_Iterator self, TDF_Label func) -> TFunction_ExecutionStatus

        A help-function aimed to help the user to check the status of retrurned function.
        It calls TFunction_GraphNode::GetStatus() inside.

        :type func: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TFunction.TFunction_ExecutionStatus

        """
        return _TFunction.TFunction_Iterator_GetStatus(self, *args)


    def SetStatus(self, *args):
        """
        SetStatus(TFunction_Iterator self, TDF_Label func, TFunction_ExecutionStatus const status)

        A help-function aimed to help the user to change the execution status of a function.
        It calls TFunction_GraphNode::SetStatus() inside.

        :type func: OCC.wrapper.TDF.TDF_Label
        :type status: OCC.wrapper.TFunction.TFunction_ExecutionStatus

        """
        return _TFunction.TFunction_Iterator_SetStatus(self, *args)


    def Dump(self, *args):
        """
        Dump(TFunction_Iterator self, Standard_OStream & OS) -> Standard_OStream &

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TFunction.TFunction_Iterator_Dump(self, *args)

    __swig_destroy__ = _TFunction.delete_TFunction_Iterator
TFunction_Iterator_swigregister = _TFunction.TFunction_Iterator_swigregister
TFunction_Iterator_swigregister(TFunction_Iterator)

class Handle_TFunction_HArray1OfDataMapOfGUIDDriver(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TFunction_HArray1OfDataMapOfGUIDDriver self)

        Nullify the handle


        """
        return _TFunction.Handle_TFunction_HArray1OfDataMapOfGUIDDriver_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TFunction_HArray1OfDataMapOfGUIDDriver self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TFunction.Handle_TFunction_HArray1OfDataMapOfGUIDDriver_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TFunction_HArray1OfDataMapOfGUIDDriver self, TFunction_HArray1OfDataMapOfGUIDDriver thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TFunction.Handle_TFunction_HArray1OfDataMapOfGUIDDriver_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TFunction_HArray1OfDataMapOfGUIDDriver self, Handle_TFunction_HArray1OfDataMapOfGUIDDriver theHandle) -> Handle_TFunction_HArray1OfDataMapOfGUIDDriver
        assign(Handle_TFunction_HArray1OfDataMapOfGUIDDriver self, TFunction_HArray1OfDataMapOfGUIDDriver thePtr) -> Handle_TFunction_HArray1OfDataMapOfGUIDDriver
        assign(Handle_TFunction_HArray1OfDataMapOfGUIDDriver self, Handle_TFunction_HArray1OfDataMapOfGUIDDriver theHandle) -> Handle_TFunction_HArray1OfDataMapOfGUIDDriver

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TFunction.Handle_TFunction_HArray1OfDataMapOfGUIDDriver_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TFunction_HArray1OfDataMapOfGUIDDriver self) -> TFunction_HArray1OfDataMapOfGUIDDriver

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TFunction.Handle_TFunction_HArray1OfDataMapOfGUIDDriver_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TFunction_HArray1OfDataMapOfGUIDDriver self) -> TFunction_HArray1OfDataMapOfGUIDDriver

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TFunction.Handle_TFunction_HArray1OfDataMapOfGUIDDriver___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TFunction_HArray1OfDataMapOfGUIDDriver self) -> TFunction_HArray1OfDataMapOfGUIDDriver

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TFunction.Handle_TFunction_HArray1OfDataMapOfGUIDDriver___ref__(self, *args)


    def __hash__(self):
        return _TFunction.Handle_TFunction_HArray1OfDataMapOfGUIDDriver___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TFunction.Handle_TFunction_HArray1OfDataMapOfGUIDDriver___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TFunction.new_Handle_TFunction_HArray1OfDataMapOfGUIDDriver(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TFunction.Handle_TFunction_HArray1OfDataMapOfGUIDDriver_DownCast)
    __swig_destroy__ = _TFunction.delete_Handle_TFunction_HArray1OfDataMapOfGUIDDriver

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.TFunction.TFunction_Array1OfDataMapOfGUIDDriver

        """
        res = _TFunction.Handle_TFunction_HArray1OfDataMapOfGUIDDriver_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_TFunction_HArray1OfDataMapOfGUIDDriver self) -> NCollection_Array1_TFunction_DataMapOfGUIDDriver

        :rtype: OCC.wrapper.TFunction.TFunction_Array1OfDataMapOfGUIDDriver

        """
        return _TFunction.Handle_TFunction_HArray1OfDataMapOfGUIDDriver_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TFunction_HArray1OfDataMapOfGUIDDriver self) -> char const *

        :rtype: const char *

        """
        return _TFunction.Handle_TFunction_HArray1OfDataMapOfGUIDDriver_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TFunction.Handle_TFunction_HArray1OfDataMapOfGUIDDriver_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TFunction.Handle_TFunction_HArray1OfDataMapOfGUIDDriver_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TFunction_HArray1OfDataMapOfGUIDDriver self)

        Memory deallocator for transient classes


        """
        return _TFunction.Handle_TFunction_HArray1OfDataMapOfGUIDDriver_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TFunction_HArray1OfDataMapOfGUIDDriver self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TFunction_HArray1OfDataMapOfGUIDDriver self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_HArray1OfDataMapOfGUIDDriver_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TFunction_HArray1OfDataMapOfGUIDDriver self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TFunction_HArray1OfDataMapOfGUIDDriver self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_HArray1OfDataMapOfGUIDDriver_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TFunction_HArray1OfDataMapOfGUIDDriver self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TFunction.Handle_TFunction_HArray1OfDataMapOfGUIDDriver_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TFunction_HArray1OfDataMapOfGUIDDriver self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.Handle_TFunction_HArray1OfDataMapOfGUIDDriver_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TFunction_HArray1OfDataMapOfGUIDDriver self)

        Increments the reference counter of this object


        """
        return _TFunction.Handle_TFunction_HArray1OfDataMapOfGUIDDriver_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TFunction_HArray1OfDataMapOfGUIDDriver self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.Handle_TFunction_HArray1OfDataMapOfGUIDDriver_DecrementRefCounter(self, *args)

Handle_TFunction_HArray1OfDataMapOfGUIDDriver_swigregister = _TFunction.Handle_TFunction_HArray1OfDataMapOfGUIDDriver_swigregister
Handle_TFunction_HArray1OfDataMapOfGUIDDriver_swigregister(Handle_TFunction_HArray1OfDataMapOfGUIDDriver)

def Handle_TFunction_HArray1OfDataMapOfGUIDDriver_DownCast(thing):
    return _TFunction.Handle_TFunction_HArray1OfDataMapOfGUIDDriver_DownCast(thing)
Handle_TFunction_HArray1OfDataMapOfGUIDDriver_DownCast = _TFunction.Handle_TFunction_HArray1OfDataMapOfGUIDDriver_DownCast

class NCollection_Array1_TFunction_DataMapOfGUIDDriver(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_TFunction_DataMapOfGUIDDriver self) -> NCollection_Array1< TFunction_DataMapOfGUIDDriver >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _TFunction.NCollection_Array1_TFunction_DataMapOfGUIDDriver_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_TFunction_DataMapOfGUIDDriver self) -> NCollection_Array1< TFunction_DataMapOfGUIDDriver >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _TFunction.NCollection_Array1_TFunction_DataMapOfGUIDDriver_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_TFunction_DataMapOfGUIDDriver self) -> NCollection_Array1< TFunction_DataMapOfGUIDDriver >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _TFunction.NCollection_Array1_TFunction_DataMapOfGUIDDriver_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_TFunction_DataMapOfGUIDDriver self) -> NCollection_Array1< TFunction_DataMapOfGUIDDriver >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _TFunction.NCollection_Array1_TFunction_DataMapOfGUIDDriver_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _TFunction.new_NCollection_Array1_TFunction_DataMapOfGUIDDriver(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_TFunction_DataMapOfGUIDDriver self, NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _TFunction.NCollection_Array1_TFunction_DataMapOfGUIDDriver_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_TFunction_DataMapOfGUIDDriver self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.NCollection_Array1_TFunction_DataMapOfGUIDDriver_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_TFunction_DataMapOfGUIDDriver self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.NCollection_Array1_TFunction_DataMapOfGUIDDriver_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_TFunction_DataMapOfGUIDDriver self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.NCollection_Array1_TFunction_DataMapOfGUIDDriver_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_TFunction_DataMapOfGUIDDriver self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.NCollection_Array1_TFunction_DataMapOfGUIDDriver_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_TFunction_DataMapOfGUIDDriver self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.NCollection_Array1_TFunction_DataMapOfGUIDDriver_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_TFunction_DataMapOfGUIDDriver self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.NCollection_Array1_TFunction_DataMapOfGUIDDriver_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_TFunction_DataMapOfGUIDDriver self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.NCollection_Array1_TFunction_DataMapOfGUIDDriver_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_TFunction_DataMapOfGUIDDriver self, NCollection_Array1_TFunction_DataMapOfGUIDDriver theOther) -> NCollection_Array1_TFunction_DataMapOfGUIDDriver

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TFunction.NCollection_Array1_TFunction_DataMapOfGUIDDriver_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_TFunction_DataMapOfGUIDDriver self, NCollection_Array1_TFunction_DataMapOfGUIDDriver theOther) -> NCollection_Array1_TFunction_DataMapOfGUIDDriver

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TFunction.NCollection_Array1_TFunction_DataMapOfGUIDDriver_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_TFunction_DataMapOfGUIDDriver self, NCollection_Array1_TFunction_DataMapOfGUIDDriver theOther) -> NCollection_Array1_TFunction_DataMapOfGUIDDriver
        assign(NCollection_Array1_TFunction_DataMapOfGUIDDriver self, NCollection_Array1_TFunction_DataMapOfGUIDDriver theOther) -> NCollection_Array1_TFunction_DataMapOfGUIDDriver

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TFunction.NCollection_Array1_TFunction_DataMapOfGUIDDriver_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _TFunction.NCollection_Array1_TFunction_DataMapOfGUIDDriver_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_TFunction_DataMapOfGUIDDriver self) -> NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID

        @return first element

        :rtype: TheItemType &

        """
        return _TFunction.NCollection_Array1_TFunction_DataMapOfGUIDDriver_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _TFunction.NCollection_Array1_TFunction_DataMapOfGUIDDriver_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_TFunction_DataMapOfGUIDDriver self) -> NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID

        @return last element

        :rtype: TheItemType &

        """
        return _TFunction.NCollection_Array1_TFunction_DataMapOfGUIDDriver_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TFunction.NCollection_Array1_TFunction_DataMapOfGUIDDriver_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_TFunction_DataMapOfGUIDDriver self, Standard_Integer const theIndex) -> NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TFunction.NCollection_Array1_TFunction_DataMapOfGUIDDriver_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TFunction.NCollection_Array1_TFunction_DataMapOfGUIDDriver___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TFunction.NCollection_Array1_TFunction_DataMapOfGUIDDriver_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_TFunction_DataMapOfGUIDDriver self, Standard_Integer const theIndex, NCollection_DataMap_Standard_GUID_Handle_TFunction_Driver_Standard_GUID theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TFunction.NCollection_Array1_TFunction_DataMapOfGUIDDriver_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_TFunction_DataMapOfGUIDDriver self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _TFunction.NCollection_Array1_TFunction_DataMapOfGUIDDriver_Resize(self, *args)

    __swig_destroy__ = _TFunction.delete_NCollection_Array1_TFunction_DataMapOfGUIDDriver
NCollection_Array1_TFunction_DataMapOfGUIDDriver_swigregister = _TFunction.NCollection_Array1_TFunction_DataMapOfGUIDDriver_swigregister
NCollection_Array1_TFunction_DataMapOfGUIDDriver_swigregister(NCollection_Array1_TFunction_DataMapOfGUIDDriver)


try:
	TFunction_Array1OfDataMapOfGUIDDriver = NCollection_Array1_TFunction_DataMapOfGUIDDriver
except NameError:
	pass # does not exist, probably ignored

class Handle_TFunction_Function(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TFunction_Function self)

        Nullify the handle


        """
        return _TFunction.Handle_TFunction_Function_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TFunction_Function self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TFunction.Handle_TFunction_Function_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TFunction_Function self, TFunction_Function thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TFunction.Handle_TFunction_Function_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TFunction_Function self, Handle_TFunction_Function theHandle) -> Handle_TFunction_Function
        assign(Handle_TFunction_Function self, TFunction_Function thePtr) -> Handle_TFunction_Function
        assign(Handle_TFunction_Function self, Handle_TFunction_Function theHandle) -> Handle_TFunction_Function

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TFunction.Handle_TFunction_Function_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TFunction_Function self) -> TFunction_Function

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TFunction.Handle_TFunction_Function_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TFunction_Function self) -> TFunction_Function

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TFunction.Handle_TFunction_Function___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TFunction_Function self) -> TFunction_Function

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TFunction.Handle_TFunction_Function___ref__(self, *args)


    def __hash__(self):
        return _TFunction.Handle_TFunction_Function___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TFunction.Handle_TFunction_Function___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TFunction.new_Handle_TFunction_Function(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TFunction.Handle_TFunction_Function_DownCast)
    __swig_destroy__ = _TFunction.delete_Handle_TFunction_Function

    def Set(self, *args):
        """
        Set(Handle_TFunction_Function self, TDF_Label L) -> Handle_TFunction_Function
        Set(Handle_TFunction_Function self, TDF_Label L, Standard_GUID DriverID) -> Handle_TFunction_Function

        Finds or Creates a function attribute on the label <L>.
        Sets a driver ID to the function.
        Returns the function attribute.

        :type L: OCC.wrapper.TDF.TDF_Label
        :type DriverID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.TFunction.Handle_TFunction_Function

        """
        return _TFunction.Handle_TFunction_Function_Set(self, *args)


    def GetID(self, *args):
        """
        Returns the GUID for functions.
        Returns a function found on the label.
        Instance methods:
        ================

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TFunction.Handle_TFunction_Function_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetDriverGUID(self, *args):
        """
        Returns the GUID for this function's driver.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TFunction.Handle_TFunction_Function_GetDriverGUID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetDriverGUID(self, *args):
        """
        SetDriverGUID(Handle_TFunction_Function self, Standard_GUID guid)

        Sets the driver for this function as that
        indentified by the GUID guid.

        :type guid: OCC.wrapper.Standard.Standard_GUID

        """
        return _TFunction.Handle_TFunction_Function_SetDriverGUID(self, *args)


    def Failed(self, *args):
        """
        Failed(Handle_TFunction_Function self) -> Standard_Boolean

        Returns true if the execution failed

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Function_Failed(self, *args)


    def SetFailure(self, *args):
        """
        SetFailure(Handle_TFunction_Function self, Standard_Integer const mode=0)

        Sets the failed index.

        :type mode: int

        """
        return _TFunction.Handle_TFunction_Function_SetFailure(self, *args)


    def GetFailure(self, *args):
        """
        GetFailure(Handle_TFunction_Function self) -> Standard_Integer

        Returns an index of failure if the execution of this function failed.
        If this integer value is 0, no failure has occurred.
        Implementation of Attribute methods:
        ===================================

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.Handle_TFunction_Function_GetFailure(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TFunction.Handle_TFunction_Function_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TFunction_Function self, Handle_TDF_Attribute arg2)

        :type with: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TFunction.Handle_TFunction_Function_Restore(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TFunction_Function self, Handle_TDF_Attribute into, Handle_TDF_RelocationTable RT)

        :type into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TFunction.Handle_TFunction_Function_Paste(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TFunction_Function self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TFunction.Handle_TFunction_Function_NewEmpty(self, *args)


    def References(self, *args):
        """
        References(Handle_TFunction_Function self, Handle_TDF_DataSet aDataSet)

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TFunction.Handle_TFunction_Function_References(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TFunction_Function self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TFunction.Handle_TFunction_Function_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TFunction_Function self) -> char const *

        :rtype: const char *

        """
        return _TFunction.Handle_TFunction_Function_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TFunction.Handle_TFunction_Function_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TFunction.Handle_TFunction_Function_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetID(self, *args):
        """
        SetID(Handle_TFunction_Function self, Standard_GUID arg2)
        SetID(Handle_TFunction_Function self)

        Sets default ID defined in nested class (to be used for attributes having User ID feature).


        """
        return _TFunction.Handle_TFunction_Function_SetID(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TFunction_Function self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TFunction.Handle_TFunction_Function_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TFunction_Function self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.Handle_TFunction_Function_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TFunction_Function self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.Handle_TFunction_Function_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TFunction_Function self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Function_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TFunction_Function self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Function_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TFunction_Function self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Function_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TFunction_Function self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Function_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TFunction_Function self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Function_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TFunction_Function self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TFunction.Handle_TFunction_Function_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TFunction_Function self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Function_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TFunction_Function self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TFunction.Handle_TFunction_Function_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TFunction_Function self)

        Something to do after adding an Attribute to a label.


        """
        return _TFunction.Handle_TFunction_Function_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TFunction_Function self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TFunction.Handle_TFunction_Function_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TFunction_Function self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TFunction.Handle_TFunction_Function_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TFunction_Function self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TFunction.Handle_TFunction_Function_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TFunction_Function self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Function_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TFunction_Function self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Function_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TFunction_Function self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Function_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TFunction_Function self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TFunction.Handle_TFunction_Function_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TFunction_Function self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TFunction.Handle_TFunction_Function_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TFunction_Function self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Function_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TFunction_Function self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TFunction.Handle_TFunction_Function_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TFunction_Function self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TFunction.Handle_TFunction_Function_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TFunction_Function self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TFunction.Handle_TFunction_Function_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TFunction_Function self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TFunction.Handle_TFunction_Function_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TFunction_Function self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TFunction.Handle_TFunction_Function_DeltaOnRemoval(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TFunction_Function self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TFunction.Handle_TFunction_Function___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TFunction_Function self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TFunction.Handle_TFunction_Function_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TFunction_Function self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TFunction.Handle_TFunction_Function_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TFunction_Function self)

        Memory deallocator for transient classes


        """
        return _TFunction.Handle_TFunction_Function_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TFunction_Function self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TFunction_Function self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Function_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TFunction_Function self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TFunction_Function self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Function_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TFunction_Function self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TFunction.Handle_TFunction_Function_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TFunction_Function self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.Handle_TFunction_Function_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TFunction_Function self)

        Increments the reference counter of this object


        """
        return _TFunction.Handle_TFunction_Function_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TFunction_Function self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.Handle_TFunction_Function_DecrementRefCounter(self, *args)

Handle_TFunction_Function_swigregister = _TFunction.Handle_TFunction_Function_swigregister
Handle_TFunction_Function_swigregister(Handle_TFunction_Function)

def Handle_TFunction_Function_DownCast(thing):
    return _TFunction.Handle_TFunction_Function_DownCast(thing)
Handle_TFunction_Function_DownCast = _TFunction.Handle_TFunction_Function_DownCast

class Handle_TFunction_GraphNode(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TFunction_GraphNode self)

        Nullify the handle


        """
        return _TFunction.Handle_TFunction_GraphNode_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TFunction_GraphNode self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TFunction.Handle_TFunction_GraphNode_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TFunction_GraphNode self, TFunction_GraphNode thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TFunction.Handle_TFunction_GraphNode_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TFunction_GraphNode self, Handle_TFunction_GraphNode theHandle) -> Handle_TFunction_GraphNode
        assign(Handle_TFunction_GraphNode self, TFunction_GraphNode thePtr) -> Handle_TFunction_GraphNode
        assign(Handle_TFunction_GraphNode self, Handle_TFunction_GraphNode theHandle) -> Handle_TFunction_GraphNode

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TFunction.Handle_TFunction_GraphNode_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TFunction_GraphNode self) -> TFunction_GraphNode

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TFunction.Handle_TFunction_GraphNode_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TFunction_GraphNode self) -> TFunction_GraphNode

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TFunction.Handle_TFunction_GraphNode___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TFunction_GraphNode self) -> TFunction_GraphNode

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TFunction.Handle_TFunction_GraphNode___ref__(self, *args)


    def __hash__(self):
        return _TFunction.Handle_TFunction_GraphNode___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TFunction.Handle_TFunction_GraphNode___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TFunction.new_Handle_TFunction_GraphNode(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TFunction.Handle_TFunction_GraphNode_DownCast)
    __swig_destroy__ = _TFunction.delete_Handle_TFunction_GraphNode

    def Set(self, *args):
        """
        Set(Handle_TFunction_GraphNode self, TDF_Label L) -> Handle_TFunction_GraphNode

        Static methods
        ==============
        Finds or Creates a graph node attribute at the label <L>.
        Returns the attribute.

        :type L: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TFunction.Handle_TFunction_GraphNode

        """
        return _TFunction.Handle_TFunction_GraphNode_Set(self, *args)


    def GetID(self, *args):
        """
        Returns the GUID for GraphNode attribute.
        Instant methods
        ===============
        Constructor (empty).

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TFunction.Handle_TFunction_GraphNode_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AddPrevious(self, *args):
        """
        AddPrevious(Handle_TFunction_GraphNode self, Standard_Integer const funcID) -> Standard_Boolean
        AddPrevious(Handle_TFunction_GraphNode self, TDF_Label func) -> Standard_Boolean

        Defines a reference to the function as a previous one.

        :type func: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_GraphNode_AddPrevious(self, *args)


    def RemovePrevious(self, *args):
        """
        RemovePrevious(Handle_TFunction_GraphNode self, Standard_Integer const funcID) -> Standard_Boolean
        RemovePrevious(Handle_TFunction_GraphNode self, TDF_Label func) -> Standard_Boolean

        Removes a reference to the function as a previous one.

        :type func: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_GraphNode_RemovePrevious(self, *args)


    def GetPrevious(self, *args):
        """
        Returns a map of previous functions.

        :rtype: OCC.wrapper.TColStd.TColStd_MapOfInteger

        """
        res = _TFunction.Handle_TFunction_GraphNode_GetPrevious(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RemoveAllPrevious(self, *args):
        """
        RemoveAllPrevious(Handle_TFunction_GraphNode self)

        Clears a map of previous functions.


        """
        return _TFunction.Handle_TFunction_GraphNode_RemoveAllPrevious(self, *args)


    def AddNext(self, *args):
        """
        AddNext(Handle_TFunction_GraphNode self, Standard_Integer const funcID) -> Standard_Boolean
        AddNext(Handle_TFunction_GraphNode self, TDF_Label func) -> Standard_Boolean

        Defines a reference to the function as a next one.

        :type func: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_GraphNode_AddNext(self, *args)


    def RemoveNext(self, *args):
        """
        RemoveNext(Handle_TFunction_GraphNode self, Standard_Integer const funcID) -> Standard_Boolean
        RemoveNext(Handle_TFunction_GraphNode self, TDF_Label func) -> Standard_Boolean

        Removes a reference to the function as a next one.

        :type func: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_GraphNode_RemoveNext(self, *args)


    def GetNext(self, *args):
        """
        Returns a map of next functions.

        :rtype: OCC.wrapper.TColStd.TColStd_MapOfInteger

        """
        res = _TFunction.Handle_TFunction_GraphNode_GetNext(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def RemoveAllNext(self, *args):
        """
        RemoveAllNext(Handle_TFunction_GraphNode self)

        Clears a map of next functions.


        """
        return _TFunction.Handle_TFunction_GraphNode_RemoveAllNext(self, *args)


    def GetStatus(self, *args):
        """
        GetStatus(Handle_TFunction_GraphNode self) -> TFunction_ExecutionStatus

        Returns the execution status of the function.

        :rtype: OCC.wrapper.TFunction.TFunction_ExecutionStatus

        """
        return _TFunction.Handle_TFunction_GraphNode_GetStatus(self, *args)


    def SetStatus(self, *args):
        """
        SetStatus(Handle_TFunction_GraphNode self, TFunction_ExecutionStatus const status)

        Defines an execution status for a function.
        Implementation of Attribute methods
        ===================================

        :type status: OCC.wrapper.TFunction.TFunction_ExecutionStatus

        """
        return _TFunction.Handle_TFunction_GraphNode_SetStatus(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TFunction.Handle_TFunction_GraphNode_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TFunction_GraphNode self, Handle_TDF_Attribute arg2)

        :type with: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TFunction.Handle_TFunction_GraphNode_Restore(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TFunction_GraphNode self, Handle_TDF_Attribute into, Handle_TDF_RelocationTable RT)

        :type into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TFunction.Handle_TFunction_GraphNode_Paste(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TFunction_GraphNode self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TFunction.Handle_TFunction_GraphNode_NewEmpty(self, *args)


    def References(self, *args):
        """
        References(Handle_TFunction_GraphNode self, Handle_TDF_DataSet aDataSet)

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TFunction.Handle_TFunction_GraphNode_References(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TFunction_GraphNode self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TFunction.Handle_TFunction_GraphNode_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TFunction_GraphNode self) -> char const *

        :rtype: const char *

        """
        return _TFunction.Handle_TFunction_GraphNode_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TFunction.Handle_TFunction_GraphNode_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TFunction.Handle_TFunction_GraphNode_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetID(self, *args):
        """
        SetID(Handle_TFunction_GraphNode self, Standard_GUID arg2)
        SetID(Handle_TFunction_GraphNode self)

        Sets default ID defined in nested class (to be used for attributes having User ID feature).


        """
        return _TFunction.Handle_TFunction_GraphNode_SetID(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TFunction_GraphNode self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TFunction.Handle_TFunction_GraphNode_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TFunction_GraphNode self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.Handle_TFunction_GraphNode_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TFunction_GraphNode self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.Handle_TFunction_GraphNode_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TFunction_GraphNode self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_GraphNode_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TFunction_GraphNode self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_GraphNode_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TFunction_GraphNode self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_GraphNode_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TFunction_GraphNode self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_GraphNode_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TFunction_GraphNode self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_GraphNode_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TFunction_GraphNode self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TFunction.Handle_TFunction_GraphNode_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TFunction_GraphNode self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_GraphNode_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TFunction_GraphNode self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TFunction.Handle_TFunction_GraphNode_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TFunction_GraphNode self)

        Something to do after adding an Attribute to a label.


        """
        return _TFunction.Handle_TFunction_GraphNode_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TFunction_GraphNode self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TFunction.Handle_TFunction_GraphNode_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TFunction_GraphNode self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TFunction.Handle_TFunction_GraphNode_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TFunction_GraphNode self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TFunction.Handle_TFunction_GraphNode_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TFunction_GraphNode self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_GraphNode_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TFunction_GraphNode self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_GraphNode_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TFunction_GraphNode self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_GraphNode_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TFunction_GraphNode self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TFunction.Handle_TFunction_GraphNode_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TFunction_GraphNode self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TFunction.Handle_TFunction_GraphNode_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TFunction_GraphNode self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_GraphNode_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TFunction_GraphNode self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TFunction.Handle_TFunction_GraphNode_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TFunction_GraphNode self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TFunction.Handle_TFunction_GraphNode_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TFunction_GraphNode self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TFunction.Handle_TFunction_GraphNode_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TFunction_GraphNode self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TFunction.Handle_TFunction_GraphNode_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TFunction_GraphNode self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TFunction.Handle_TFunction_GraphNode_DeltaOnRemoval(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TFunction_GraphNode self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TFunction.Handle_TFunction_GraphNode___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TFunction_GraphNode self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TFunction.Handle_TFunction_GraphNode_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TFunction_GraphNode self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TFunction.Handle_TFunction_GraphNode_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TFunction_GraphNode self)

        Memory deallocator for transient classes


        """
        return _TFunction.Handle_TFunction_GraphNode_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TFunction_GraphNode self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TFunction_GraphNode self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_GraphNode_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TFunction_GraphNode self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TFunction_GraphNode self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_GraphNode_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TFunction_GraphNode self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TFunction.Handle_TFunction_GraphNode_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TFunction_GraphNode self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.Handle_TFunction_GraphNode_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TFunction_GraphNode self)

        Increments the reference counter of this object


        """
        return _TFunction.Handle_TFunction_GraphNode_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TFunction_GraphNode self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.Handle_TFunction_GraphNode_DecrementRefCounter(self, *args)

Handle_TFunction_GraphNode_swigregister = _TFunction.Handle_TFunction_GraphNode_swigregister
Handle_TFunction_GraphNode_swigregister(Handle_TFunction_GraphNode)

def Handle_TFunction_GraphNode_DownCast(thing):
    return _TFunction.Handle_TFunction_GraphNode_DownCast(thing)
Handle_TFunction_GraphNode_DownCast = _TFunction.Handle_TFunction_GraphNode_DownCast

class TFunction_DriverTable(Standard.Standard_Transient):
    """
    A container for instances of drivers.
    You create a new instance of TFunction_Driver
    and use the method AddDriver to load it into the driver table.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TFunction_DriverTable
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TFunction_DriverTable(self) 
            return h


    def Get(*args):
        """
        Get() -> Handle_TFunction_DriverTable

        Returns the driver table. If a driver does not exist, creates it.

        :rtype: OCC.wrapper.TFunction.Handle_TFunction_DriverTable

        """
        return _TFunction.TFunction_DriverTable_Get(*args)

    Get = staticmethod(Get)

    def __init__(self, *args):
        """
        __init__(TFunction_DriverTable self) -> TFunction_DriverTable

        Default constructor


        """
        this = _TFunction.new_TFunction_DriverTable(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def AddDriver(self, *args):
        """
        AddDriver(TFunction_DriverTable self, Standard_GUID guid, Handle_TFunction_Driver driver, Standard_Integer const thread=0) -> Standard_Boolean

        Returns true if the driver has been added successfully to the driver table.

        :type guid: OCC.wrapper.Standard.Standard_GUID
        :type driver: OCC.wrapper.TFunction.Handle_TFunction_Driver
        :type thread: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.TFunction_DriverTable_AddDriver(self, *args)


    def HasDriver(self, *args):
        """
        HasDriver(TFunction_DriverTable self, Standard_GUID guid, Standard_Integer const thread=0) -> Standard_Boolean

        Returns true if the driver exists in the driver table.

        :type guid: OCC.wrapper.Standard.Standard_GUID
        :type thread: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.TFunction_DriverTable_HasDriver(self, *args)


    def FindDriver(self, *args):
        """
        FindDriver(TFunction_DriverTable self, Standard_GUID guid, Handle_TFunction_Driver driver, Standard_Integer const thread=0) -> Standard_Boolean

        Returns true if the driver was found.

        :type guid: OCC.wrapper.Standard.Standard_GUID
        :type driver: OCC.wrapper.TFunction.Handle_TFunction_Driver
        :type thread: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.TFunction_DriverTable_FindDriver(self, *args)


    def Dump(self, *args):
        """
        Dump(TFunction_DriverTable self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TFunction.TFunction_DriverTable_Dump(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(TFunction_DriverTable self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TFunction.TFunction_DriverTable___lshift__(self, *args)


    def RemoveDriver(self, *args):
        """
        RemoveDriver(TFunction_DriverTable self, Standard_GUID guid, Standard_Integer const thread=0) -> Standard_Boolean

        Removes a driver with the given GUID.
        Returns true if the driver has been removed successfully.

        :type guid: OCC.wrapper.Standard.Standard_GUID
        :type thread: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.TFunction_DriverTable_RemoveDriver(self, *args)


    def Clear(self, *args):
        """
        Clear(TFunction_DriverTable self)

        Removes all drivers. Returns true if the driver has been removed successfully.


        """
        return _TFunction.TFunction_DriverTable_Clear(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TFunction.TFunction_DriverTable_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TFunction.TFunction_DriverTable_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TFunction.TFunction_DriverTable_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TFunction.delete_TFunction_DriverTable
TFunction_DriverTable_swigregister = _TFunction.TFunction_DriverTable_swigregister
TFunction_DriverTable_swigregister(TFunction_DriverTable)

def TFunction_DriverTable_Get(*args):
    """
    TFunction_DriverTable_Get() -> Handle_TFunction_DriverTable

    Returns the driver table. If a driver does not exist, creates it.

    :rtype: OCC.wrapper.TFunction.Handle_TFunction_DriverTable

    """
    return _TFunction.TFunction_DriverTable_Get(*args)

def TFunction_DriverTable_get_type_name(*args):
    """
    TFunction_DriverTable_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TFunction.TFunction_DriverTable_get_type_name(*args)

def TFunction_DriverTable_get_type_descriptor(*args):
    """
    TFunction_DriverTable_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TFunction.TFunction_DriverTable_get_type_descriptor(*args)

class Handle_TFunction_DriverTable(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TFunction_DriverTable self)

        Nullify the handle


        """
        return _TFunction.Handle_TFunction_DriverTable_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TFunction_DriverTable self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TFunction.Handle_TFunction_DriverTable_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TFunction_DriverTable self, TFunction_DriverTable thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TFunction.Handle_TFunction_DriverTable_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TFunction_DriverTable self, Handle_TFunction_DriverTable theHandle) -> Handle_TFunction_DriverTable
        assign(Handle_TFunction_DriverTable self, TFunction_DriverTable thePtr) -> Handle_TFunction_DriverTable
        assign(Handle_TFunction_DriverTable self, Handle_TFunction_DriverTable theHandle) -> Handle_TFunction_DriverTable

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TFunction.Handle_TFunction_DriverTable_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TFunction_DriverTable self) -> TFunction_DriverTable

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TFunction.Handle_TFunction_DriverTable_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TFunction_DriverTable self) -> TFunction_DriverTable

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TFunction.Handle_TFunction_DriverTable___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TFunction_DriverTable self) -> TFunction_DriverTable

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TFunction.Handle_TFunction_DriverTable___ref__(self, *args)


    def __hash__(self):
        return _TFunction.Handle_TFunction_DriverTable___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TFunction.Handle_TFunction_DriverTable___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TFunction.new_Handle_TFunction_DriverTable(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TFunction.Handle_TFunction_DriverTable_DownCast)
    __swig_destroy__ = _TFunction.delete_Handle_TFunction_DriverTable

    def Get(self, *args):
        """
        Get(Handle_TFunction_DriverTable self) -> Handle_TFunction_DriverTable

        Returns the driver table. If a driver does not exist, creates it.

        :rtype: OCC.wrapper.TFunction.Handle_TFunction_DriverTable

        """
        return _TFunction.Handle_TFunction_DriverTable_Get(self, *args)


    def AddDriver(self, *args):
        """
        AddDriver(Handle_TFunction_DriverTable self, Standard_GUID guid, Handle_TFunction_Driver driver, Standard_Integer const thread=0) -> Standard_Boolean

        Returns true if the driver has been added successfully to the driver table.

        :type guid: OCC.wrapper.Standard.Standard_GUID
        :type driver: OCC.wrapper.TFunction.Handle_TFunction_Driver
        :type thread: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_DriverTable_AddDriver(self, *args)


    def HasDriver(self, *args):
        """
        HasDriver(Handle_TFunction_DriverTable self, Standard_GUID guid, Standard_Integer const thread=0) -> Standard_Boolean

        Returns true if the driver exists in the driver table.

        :type guid: OCC.wrapper.Standard.Standard_GUID
        :type thread: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_DriverTable_HasDriver(self, *args)


    def FindDriver(self, *args):
        """
        FindDriver(Handle_TFunction_DriverTable self, Standard_GUID guid, Handle_TFunction_Driver driver, Standard_Integer const thread=0) -> Standard_Boolean

        Returns true if the driver was found.

        :type guid: OCC.wrapper.Standard.Standard_GUID
        :type driver: OCC.wrapper.TFunction.Handle_TFunction_Driver
        :type thread: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_DriverTable_FindDriver(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TFunction_DriverTable self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TFunction.Handle_TFunction_DriverTable_Dump(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TFunction_DriverTable self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TFunction.Handle_TFunction_DriverTable___lshift__(self, *args)


    def RemoveDriver(self, *args):
        """
        RemoveDriver(Handle_TFunction_DriverTable self, Standard_GUID guid, Standard_Integer const thread=0) -> Standard_Boolean

        Removes a driver with the given GUID.
        Returns true if the driver has been removed successfully.

        :type guid: OCC.wrapper.Standard.Standard_GUID
        :type thread: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_DriverTable_RemoveDriver(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_TFunction_DriverTable self)

        Removes all drivers. Returns true if the driver has been removed successfully.


        """
        return _TFunction.Handle_TFunction_DriverTable_Clear(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TFunction_DriverTable self) -> char const *

        :rtype: const char *

        """
        return _TFunction.Handle_TFunction_DriverTable_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TFunction.Handle_TFunction_DriverTable_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TFunction.Handle_TFunction_DriverTable_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TFunction_DriverTable self)

        Memory deallocator for transient classes


        """
        return _TFunction.Handle_TFunction_DriverTable_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TFunction_DriverTable self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TFunction_DriverTable self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_DriverTable_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TFunction_DriverTable self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TFunction_DriverTable self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_DriverTable_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TFunction_DriverTable self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TFunction.Handle_TFunction_DriverTable_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TFunction_DriverTable self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.Handle_TFunction_DriverTable_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TFunction_DriverTable self)

        Increments the reference counter of this object


        """
        return _TFunction.Handle_TFunction_DriverTable_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TFunction_DriverTable self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.Handle_TFunction_DriverTable_DecrementRefCounter(self, *args)

Handle_TFunction_DriverTable_swigregister = _TFunction.Handle_TFunction_DriverTable_swigregister
Handle_TFunction_DriverTable_swigregister(Handle_TFunction_DriverTable)

def Handle_TFunction_DriverTable_DownCast(thing):
    return _TFunction.Handle_TFunction_DriverTable_DownCast(thing)
Handle_TFunction_DriverTable_DownCast = _TFunction.Handle_TFunction_DriverTable_DownCast

class TFunction_IFunction(object):
    """Interface class for usage of Function Mechanism"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def NewFunction(*args):
        """
        NewFunction(TDF_Label L, Standard_GUID ID) -> Standard_Boolean

        Sets a new function attached to a label <L> with <ID>.
        It creates a new TFunction_Function attribute initialized by the <ID>,
        a new TFunction_GraphNode with an empty list of dependencies and
        the status equal to TFunction_ES_WrongDefinition.
        It registers the function in the scope of functions for this document.

        :type L: OCC.wrapper.TDF.TDF_Label
        :type ID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.TFunction_IFunction_NewFunction(*args)

    NewFunction = staticmethod(NewFunction)

    def DeleteFunction(*args):
        """
        DeleteFunction(TDF_Label L) -> Standard_Boolean

        Deletes a function attached to a label <L>.
        It deletes a TFunction_Function attribute and a TFunction_GraphNode.
        It deletes the functions from the scope of function of this document.

        :type L: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.TFunction_IFunction_DeleteFunction(*args)

    DeleteFunction = staticmethod(DeleteFunction)

    def __init__(self, *args):
        """
        __init__(TFunction_IFunction self) -> TFunction_IFunction
        __init__(TFunction_IFunction self, TDF_Label L) -> TFunction_IFunction

        A constructor.
        Initializes the interface by the label of function.

        :type L: OCC.wrapper.TDF.TDF_Label

        """
        this = _TFunction.new_TFunction_IFunction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(TFunction_IFunction self, TDF_Label L)

        Initializes the interface by the label of function.

        :type L: OCC.wrapper.TDF.TDF_Label

        """
        return _TFunction.TFunction_IFunction_Init(self, *args)


    def Label(self, *args):
        """
        Returns a label of the function.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        res = _TFunction.TFunction_IFunction_Label(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UpdateDependencies(self, *args):
        """
        UpdateDependencies(TFunction_IFunction self, TDF_Label Access) -> Standard_Boolean
        UpdateDependencies(TFunction_IFunction self) -> Standard_Boolean

        Updates the dependencies of this function only.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.TFunction_IFunction_UpdateDependencies(self, *args)


    def Arguments(self, *args):
        """
        Arguments(TFunction_IFunction self, NCollection_List_TDF_Label args)

        The method fills-in the list by labels,
        where the arguments of the function are located.

        :type args: OCC.wrapper.TDF.TDF_LabelList

        """
        return _TFunction.TFunction_IFunction_Arguments(self, *args)


    def Results(self, *args):
        """
        Results(TFunction_IFunction self, NCollection_List_TDF_Label res)

        The method fills-in the list by labels,
        where the results of the function are located.

        :type res: OCC.wrapper.TDF.TDF_LabelList

        """
        return _TFunction.TFunction_IFunction_Results(self, *args)


    def GetPrevious(self, *args):
        """
        GetPrevious(TFunction_IFunction self, NCollection_List_TDF_Label prev)

        Returns a list of previous functions.

        :type prev: OCC.wrapper.TDF.TDF_LabelList

        """
        return _TFunction.TFunction_IFunction_GetPrevious(self, *args)


    def GetNext(self, *args):
        """
        GetNext(TFunction_IFunction self, NCollection_List_TDF_Label prev)

        Returns a list of next functions.

        :type prev: OCC.wrapper.TDF.TDF_LabelList

        """
        return _TFunction.TFunction_IFunction_GetNext(self, *args)


    def GetStatus(self, *args):
        """
        GetStatus(TFunction_IFunction self) -> TFunction_ExecutionStatus

        Returns the execution status of the function.

        :rtype: OCC.wrapper.TFunction.TFunction_ExecutionStatus

        """
        return _TFunction.TFunction_IFunction_GetStatus(self, *args)


    def SetStatus(self, *args):
        """
        SetStatus(TFunction_IFunction self, TFunction_ExecutionStatus const status)

        Defines an execution status for a function.

        :type status: OCC.wrapper.TFunction.TFunction_ExecutionStatus

        """
        return _TFunction.TFunction_IFunction_SetStatus(self, *args)


    def GetAllFunctions(self, *args):
        """
        Returns the scope of all functions.

        :rtype: OCC.wrapper.TFunction.TFunction_DoubleMapOfIntegerLabel

        """
        res = _TFunction.TFunction_IFunction_GetAllFunctions(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetLogbook(self, *args):
        """
        GetLogbook(TFunction_IFunction self) -> Handle_TFunction_Logbook

        Returns the Logbook - keeper of modifications.

        :rtype: OCC.wrapper.TFunction.Handle_TFunction_Logbook

        """
        return _TFunction.TFunction_IFunction_GetLogbook(self, *args)


    def GetDriver(self, *args):
        """
        GetDriver(TFunction_IFunction self, Standard_Integer const thread=0) -> Handle_TFunction_Driver

        Returns a driver of the function.

        :type thread: int
        :rtype: OCC.wrapper.TFunction.Handle_TFunction_Driver

        """
        return _TFunction.TFunction_IFunction_GetDriver(self, *args)


    def GetGraphNode(self, *args):
        """
        GetGraphNode(TFunction_IFunction self) -> Handle_TFunction_GraphNode

        Returns a graph node of the function.

        :rtype: OCC.wrapper.TFunction.Handle_TFunction_GraphNode

        """
        return _TFunction.TFunction_IFunction_GetGraphNode(self, *args)

    __swig_destroy__ = _TFunction.delete_TFunction_IFunction
TFunction_IFunction_swigregister = _TFunction.TFunction_IFunction_swigregister
TFunction_IFunction_swigregister(TFunction_IFunction)

def TFunction_IFunction_NewFunction(*args):
    """
    TFunction_IFunction_NewFunction(TDF_Label L, Standard_GUID ID) -> Standard_Boolean

    Sets a new function attached to a label <L> with <ID>.
    It creates a new TFunction_Function attribute initialized by the <ID>,
    a new TFunction_GraphNode with an empty list of dependencies and
    the status equal to TFunction_ES_WrongDefinition.
    It registers the function in the scope of functions for this document.

    :type L: OCC.wrapper.TDF.TDF_Label
    :type ID: OCC.wrapper.Standard.Standard_GUID
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TFunction.TFunction_IFunction_NewFunction(*args)

def TFunction_IFunction_DeleteFunction(*args):
    """
    TFunction_IFunction_DeleteFunction(TDF_Label L) -> Standard_Boolean

    Deletes a function attached to a label <L>.
    It deletes a TFunction_Function attribute and a TFunction_GraphNode.
    It deletes the functions from the scope of function of this document.

    :type L: OCC.wrapper.TDF.TDF_Label
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TFunction.TFunction_IFunction_DeleteFunction(*args)


try:
	TColStd_MapIntegerHasher = TColStd.NCollection_DefaultHasher_Standard_Integer
except AttributeError:
	pass # does not exist, probably ignored

class Handle_TFunction_Driver(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TFunction_Driver self)

        Nullify the handle


        """
        return _TFunction.Handle_TFunction_Driver_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TFunction_Driver self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TFunction.Handle_TFunction_Driver_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TFunction_Driver self, TFunction_Driver thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TFunction.Handle_TFunction_Driver_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TFunction_Driver self, Handle_TFunction_Driver theHandle) -> Handle_TFunction_Driver
        assign(Handle_TFunction_Driver self, TFunction_Driver thePtr) -> Handle_TFunction_Driver
        assign(Handle_TFunction_Driver self, Handle_TFunction_Driver theHandle) -> Handle_TFunction_Driver

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TFunction.Handle_TFunction_Driver_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TFunction_Driver self) -> TFunction_Driver

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TFunction.Handle_TFunction_Driver_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TFunction_Driver self) -> TFunction_Driver

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TFunction.Handle_TFunction_Driver___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TFunction_Driver self) -> TFunction_Driver

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TFunction.Handle_TFunction_Driver___ref__(self, *args)


    def __hash__(self):
        return _TFunction.Handle_TFunction_Driver___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TFunction.Handle_TFunction_Driver___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TFunction.new_Handle_TFunction_Driver(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TFunction.Handle_TFunction_Driver_DownCast)
    __swig_destroy__ = _TFunction.delete_Handle_TFunction_Driver

    def Init(self, *args):
        """
        Init(Handle_TFunction_Driver self, TDF_Label L)

        Initializes the label L for this function prior to its  execution.

        :type L: OCC.wrapper.TDF.TDF_Label

        """
        return _TFunction.Handle_TFunction_Driver_Init(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TFunction_Driver self) -> TDF_Label

        Returns the label of the driver for this function.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TFunction.Handle_TFunction_Driver_Label(self, *args)


    def Validate(self, *args):
        """
        Validate(Handle_TFunction_Driver self, Handle_TFunction_Logbook log)

        Validates labels of a function  in <log>.
        This function is the one initialized in this function driver.
        Warning
        In regeneration mode, the solver must call this
        method even if the function is not executed.
        execution of function
        =====================

        :type log: OCC.wrapper.TFunction.Handle_TFunction_Logbook

        """
        return _TFunction.Handle_TFunction_Driver_Validate(self, *args)


    def MustExecute(self, *args):
        """
        MustExecute(Handle_TFunction_Driver self, Handle_TFunction_Logbook log) -> Standard_Boolean

        Analyzes the labels in the logbook log.
        Returns true if attributes have been modified.
        If the function label itself has been modified, the function must be executed.

        :type log: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Driver_MustExecute(self, *args)


    def Execute(self, *args):
        """
        Execute(Handle_TFunction_Driver self, Handle_TFunction_Logbook log) -> Standard_Integer

        Executes the function in this function driver and
        puts the impacted labels in the logbook log.
        arguments & results of functions
        ================================

        :type log: OCC.wrapper.TFunction.Handle_TFunction_Logbook
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.Handle_TFunction_Driver_Execute(self, *args)


    def Arguments(self, *args):
        """
        Arguments(Handle_TFunction_Driver self, NCollection_List_TDF_Label args)

        The method fills-in the list by labels,
        where the arguments of the function are located.

        :type args: OCC.wrapper.TDF.TDF_LabelList

        """
        return _TFunction.Handle_TFunction_Driver_Arguments(self, *args)


    def Results(self, *args):
        """
        Results(Handle_TFunction_Driver self, NCollection_List_TDF_Label res)

        The method fills-in the list by labels,
        where the results of the function are located.

        :type res: OCC.wrapper.TDF.TDF_LabelList

        """
        return _TFunction.Handle_TFunction_Driver_Results(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TFunction_Driver self) -> char const *

        :rtype: const char *

        """
        return _TFunction.Handle_TFunction_Driver_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TFunction.Handle_TFunction_Driver_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TFunction.Handle_TFunction_Driver_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TFunction_Driver self)

        Memory deallocator for transient classes


        """
        return _TFunction.Handle_TFunction_Driver_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TFunction_Driver self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TFunction_Driver self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Driver_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TFunction_Driver self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TFunction_Driver self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TFunction.Handle_TFunction_Driver_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TFunction_Driver self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TFunction.Handle_TFunction_Driver_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TFunction_Driver self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.Handle_TFunction_Driver_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TFunction_Driver self)

        Increments the reference counter of this object


        """
        return _TFunction.Handle_TFunction_Driver_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TFunction_Driver self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TFunction.Handle_TFunction_Driver_DecrementRefCounter(self, *args)

Handle_TFunction_Driver_swigregister = _TFunction.Handle_TFunction_Driver_swigregister
Handle_TFunction_Driver_swigregister(Handle_TFunction_Driver)

def Handle_TFunction_Driver_DownCast(thing):
    return _TFunction.Handle_TFunction_Driver_DownCast(thing)
Handle_TFunction_Driver_DownCast = _TFunction.Handle_TFunction_Driver_DownCast




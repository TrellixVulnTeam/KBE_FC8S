# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_StepFEA')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_StepFEA')
    _StepFEA = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_StepFEA', [dirname(__file__)])
        except ImportError:
            import _StepFEA
            return _StepFEA
        try:
            _mod = imp.load_module('_StepFEA', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _StepFEA = swig_import_helper()
    del swig_import_helper
else:
    import _StepFEA
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _StepFEA.delete_SwigPyIterator

    def value(self):
        return _StepFEA.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _StepFEA.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _StepFEA.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _StepFEA.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _StepFEA.SwigPyIterator_equal(self, x)

    def copy(self):
        return _StepFEA.SwigPyIterator_copy(self)

    def next(self):
        return _StepFEA.SwigPyIterator_next(self)

    def __next__(self):
        return _StepFEA.SwigPyIterator___next__(self)

    def previous(self):
        return _StepFEA.SwigPyIterator_previous(self)

    def advance(self, n):
        return _StepFEA.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _StepFEA.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _StepFEA.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _StepFEA.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _StepFEA.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _StepFEA.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _StepFEA.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _StepFEA.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _StepFEA.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_StepFEA.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _StepFEA.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _StepFEA.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StepFEA.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _StepFEA.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _StepFEA.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _StepFEA.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _StepFEA.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_StepFEA.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _StepFEA.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _StepFEA.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StepFEA.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _StepFEA.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _StepFEA.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _StepFEA.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _StepFEA.ptr_to_number(item)
ptr_to_number = _StepFEA.ptr_to_number

def HashCode(*args):
    return _StepFEA.HashCode(*args)
HashCode = _StepFEA.HashCode

def ptr_equal(a, b):
    return _StepFEA.ptr_equal(a, b)
ptr_equal = _StepFEA.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepBasic
else:
    import StepBasic
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepData
else:
    import StepData
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Interface
else:
    import Interface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import MoniTool
else:
    import MoniTool
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import OSD
else:
    import OSD
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepGeom
else:
    import StepGeom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepRepr
else:
    import StepRepr
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepShape
else:
    import StepShape
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepElement
else:
    import StepElement
del _swig_python_version_info
StepFEA_XTranslation = _StepFEA.StepFEA_XTranslation
StepFEA_YTranslation = _StepFEA.StepFEA_YTranslation
StepFEA_ZTranslation = _StepFEA.StepFEA_ZTranslation
StepFEA_XRotation = _StepFEA.StepFEA_XRotation
StepFEA_YRotation = _StepFEA.StepFEA_YRotation
StepFEA_ZRotation = _StepFEA.StepFEA_ZRotation
StepFEA_Warp = _StepFEA.StepFEA_Warp
StepFEA_Cartesian = _StepFEA.StepFEA_Cartesian
StepFEA_Cylindrical = _StepFEA.StepFEA_Cylindrical
StepFEA_Spherical = _StepFEA.StepFEA_Spherical
StepFEA_ElementEdge = _StepFEA.StepFEA_ElementEdge
StepFEA_Volume = _StepFEA.StepFEA_Volume
StepFEA_Unspecified = _StepFEA.StepFEA_Unspecified
class StepFEA_NodeRepresentation(StepRepr.StepRepr_Representation):
    """Representation of STEP entity NodeRepresentation"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_NodeRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_NodeRepresentation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_NodeRepresentation self) -> StepFEA_NodeRepresentation

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_NodeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_NodeRepresentation self, Handle_TCollection_HAsciiString aRepresentation_Name, Handle_StepRepr_HArray1OfRepresentationItem aRepresentation_Items, Handle_StepRepr_RepresentationContext aRepresentation_ContextOfItems, Handle_StepFEA_FeaModel aModelRef)

        Initialize all fields (own and inherited)

        :type aRepresentation_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRepresentation_Items: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aRepresentation_ContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext
        :type aModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel

        """
        return _StepFEA.StepFEA_NodeRepresentation_Init(self, *args)


    def ModelRef(self, *args):
        """
        ModelRef(StepFEA_NodeRepresentation self) -> Handle_StepFEA_FeaModel

        Returns field ModelRef

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel

        """
        return _StepFEA.StepFEA_NodeRepresentation_ModelRef(self, *args)


    def SetModelRef(self, *args):
        """
        SetModelRef(StepFEA_NodeRepresentation self, Handle_StepFEA_FeaModel ModelRef)

        Set field ModelRef

        :type ModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel

        """
        return _StepFEA.StepFEA_NodeRepresentation_SetModelRef(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_NodeRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_NodeRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_NodeRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_NodeRepresentation
StepFEA_NodeRepresentation_swigregister = _StepFEA.StepFEA_NodeRepresentation_swigregister
StepFEA_NodeRepresentation_swigregister(StepFEA_NodeRepresentation)

def StepFEA_NodeRepresentation_get_type_name(*args):
    """
    StepFEA_NodeRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_NodeRepresentation_get_type_name(*args)

def StepFEA_NodeRepresentation_get_type_descriptor(*args):
    """
    StepFEA_NodeRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_NodeRepresentation_get_type_descriptor(*args)

class StepFEA_FeaMaterialPropertyRepresentationItem(StepRepr.StepRepr_RepresentationItem):
    """Representation of STEP entity FeaMaterialPropertyRepresentationItem"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_FeaMaterialPropertyRepresentationItem
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_FeaMaterialPropertyRepresentationItem(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_FeaMaterialPropertyRepresentationItem self) -> StepFEA_FeaMaterialPropertyRepresentationItem

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_FeaMaterialPropertyRepresentationItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_FeaMaterialPropertyRepresentationItem_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_FeaMaterialPropertyRepresentationItem_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_FeaMaterialPropertyRepresentationItem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_FeaMaterialPropertyRepresentationItem
StepFEA_FeaMaterialPropertyRepresentationItem_swigregister = _StepFEA.StepFEA_FeaMaterialPropertyRepresentationItem_swigregister
StepFEA_FeaMaterialPropertyRepresentationItem_swigregister(StepFEA_FeaMaterialPropertyRepresentationItem)

def StepFEA_FeaMaterialPropertyRepresentationItem_get_type_name(*args):
    """
    StepFEA_FeaMaterialPropertyRepresentationItem_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_FeaMaterialPropertyRepresentationItem_get_type_name(*args)

def StepFEA_FeaMaterialPropertyRepresentationItem_get_type_descriptor(*args):
    """
    StepFEA_FeaMaterialPropertyRepresentationItem_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_FeaMaterialPropertyRepresentationItem_get_type_descriptor(*args)

class StepFEA_Node(StepFEA_NodeRepresentation):
    """Representation of STEP entity Node"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_Node
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_Node(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_Node self) -> StepFEA_Node

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_Node(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_Node_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_Node_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_Node_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_Node
StepFEA_Node_swigregister = _StepFEA.StepFEA_Node_swigregister
StepFEA_Node_swigregister(StepFEA_Node)

def StepFEA_Node_get_type_name(*args):
    """
    StepFEA_Node_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_Node_get_type_name(*args)

def StepFEA_Node_get_type_descriptor(*args):
    """
    StepFEA_Node_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_Node_get_type_descriptor(*args)

class StepFEA_ElementRepresentation(StepRepr.StepRepr_Representation):
    """Representation of STEP entity ElementRepresentation"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_ElementRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_ElementRepresentation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_ElementRepresentation self) -> StepFEA_ElementRepresentation

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_ElementRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_ElementRepresentation self, Handle_TCollection_HAsciiString aRepresentation_Name, Handle_StepRepr_HArray1OfRepresentationItem aRepresentation_Items, Handle_StepRepr_RepresentationContext aRepresentation_ContextOfItems, Handle_StepFEA_HArray1OfNodeRepresentation aNodeList)

        Initialize all fields (own and inherited)

        :type aRepresentation_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRepresentation_Items: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aRepresentation_ContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext
        :type aNodeList: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation

        """
        return _StepFEA.StepFEA_ElementRepresentation_Init(self, *args)


    def NodeList(self, *args):
        """
        NodeList(StepFEA_ElementRepresentation self) -> Handle_StepFEA_HArray1OfNodeRepresentation

        Returns field NodeList

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation

        """
        return _StepFEA.StepFEA_ElementRepresentation_NodeList(self, *args)


    def SetNodeList(self, *args):
        """
        SetNodeList(StepFEA_ElementRepresentation self, Handle_StepFEA_HArray1OfNodeRepresentation NodeList)

        Set field NodeList

        :type NodeList: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation

        """
        return _StepFEA.StepFEA_ElementRepresentation_SetNodeList(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_ElementRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_ElementRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_ElementRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_ElementRepresentation
StepFEA_ElementRepresentation_swigregister = _StepFEA.StepFEA_ElementRepresentation_swigregister
StepFEA_ElementRepresentation_swigregister(StepFEA_ElementRepresentation)

def StepFEA_ElementRepresentation_get_type_name(*args):
    """
    StepFEA_ElementRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_ElementRepresentation_get_type_name(*args)

def StepFEA_ElementRepresentation_get_type_descriptor(*args):
    """
    StepFEA_ElementRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_ElementRepresentation_get_type_descriptor(*args)

class StepFEA_FeaAxis2Placement3d(StepGeom.StepGeom_Axis2Placement3d):
    """Representation of STEP entity FeaAxis2Placement3d"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_FeaAxis2Placement3d
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_FeaAxis2Placement3d(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_FeaAxis2Placement3d self) -> StepFEA_FeaAxis2Placement3d

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_FeaAxis2Placement3d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_FeaAxis2Placement3d self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Handle_StepGeom_CartesianPoint aPlacement_Location, Standard_Boolean const hasAxis2Placement3d_Axis, Handle_StepGeom_Direction aAxis2Placement3d_Axis, Standard_Boolean const hasAxis2Placement3d_RefDirection, Handle_StepGeom_Direction aAxis2Placement3d_RefDirection, StepFEA_CoordinateSystemType const aSystemType, Handle_TCollection_HAsciiString aDescription)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPlacement_Location: OCC.wrapper.StepFEA.Handle_StepGeom_CartesianPoint
        :type hasAxis2Placement3d_Axis: bool
        :type aAxis2Placement3d_Axis: OCC.wrapper.StepFEA.Handle_StepGeom_Direction
        :type hasAxis2Placement3d_RefDirection: bool
        :type aAxis2Placement3d_RefDirection: OCC.wrapper.StepFEA.Handle_StepGeom_Direction
        :type aSystemType: OCC.wrapper.StepFEA.StepFEA_CoordinateSystemType
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.StepFEA_FeaAxis2Placement3d_Init(self, *args)


    def SystemType(self, *args):
        """
        SystemType(StepFEA_FeaAxis2Placement3d self) -> StepFEA_CoordinateSystemType

        Returns field SystemType

        :rtype: OCC.wrapper.StepFEA.StepFEA_CoordinateSystemType

        """
        return _StepFEA.StepFEA_FeaAxis2Placement3d_SystemType(self, *args)


    def SetSystemType(self, *args):
        """
        SetSystemType(StepFEA_FeaAxis2Placement3d self, StepFEA_CoordinateSystemType const SystemType)

        Set field SystemType

        :type SystemType: OCC.wrapper.StepFEA.StepFEA_CoordinateSystemType

        """
        return _StepFEA.StepFEA_FeaAxis2Placement3d_SetSystemType(self, *args)


    def Description(self, *args):
        """
        Description(StepFEA_FeaAxis2Placement3d self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.StepFEA_FeaAxis2Placement3d_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(StepFEA_FeaAxis2Placement3d self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.StepFEA_FeaAxis2Placement3d_SetDescription(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_FeaAxis2Placement3d_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_FeaAxis2Placement3d_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_FeaAxis2Placement3d_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_FeaAxis2Placement3d
StepFEA_FeaAxis2Placement3d_swigregister = _StepFEA.StepFEA_FeaAxis2Placement3d_swigregister
StepFEA_FeaAxis2Placement3d_swigregister(StepFEA_FeaAxis2Placement3d)

def StepFEA_FeaAxis2Placement3d_get_type_name(*args):
    """
    StepFEA_FeaAxis2Placement3d_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_FeaAxis2Placement3d_get_type_name(*args)

def StepFEA_FeaAxis2Placement3d_get_type_descriptor(*args):
    """
    StepFEA_FeaAxis2Placement3d_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_FeaAxis2Placement3d_get_type_descriptor(*args)

class StepFEA_FeaGroup(StepBasic.StepBasic_Group):
    """Representation of STEP entity FeaGroup"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_FeaGroup
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_FeaGroup(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_FeaGroup self) -> StepFEA_FeaGroup

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_FeaGroup(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_FeaGroup self, Handle_TCollection_HAsciiString aGroup_Name, Handle_TCollection_HAsciiString aGroup_Description, Handle_StepFEA_FeaModel aModelRef)

        Initialize all fields (own and inherited)

        :type aGroup_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aGroup_Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel

        """
        return _StepFEA.StepFEA_FeaGroup_Init(self, *args)


    def ModelRef(self, *args):
        """
        ModelRef(StepFEA_FeaGroup self) -> Handle_StepFEA_FeaModel

        Returns field ModelRef

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel

        """
        return _StepFEA.StepFEA_FeaGroup_ModelRef(self, *args)


    def SetModelRef(self, *args):
        """
        SetModelRef(StepFEA_FeaGroup self, Handle_StepFEA_FeaModel ModelRef)

        Set field ModelRef

        :type ModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel

        """
        return _StepFEA.StepFEA_FeaGroup_SetModelRef(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_FeaGroup_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_FeaGroup_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_FeaGroup_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_FeaGroup
StepFEA_FeaGroup_swigregister = _StepFEA.StepFEA_FeaGroup_swigregister
StepFEA_FeaGroup_swigregister(StepFEA_FeaGroup)

def StepFEA_FeaGroup_get_type_name(*args):
    """
    StepFEA_FeaGroup_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_FeaGroup_get_type_name(*args)

def StepFEA_FeaGroup_get_type_descriptor(*args):
    """
    StepFEA_FeaGroup_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_FeaGroup_get_type_descriptor(*args)

class StepFEA_DegreeOfFreedomMember(StepData.StepData_SelectNamed):
    """Representation of member for  STEP SELECT type CurveElementFreedom"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_DegreeOfFreedomMember
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_DegreeOfFreedomMember(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_DegreeOfFreedomMember self) -> StepFEA_DegreeOfFreedomMember

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_DegreeOfFreedomMember(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def HasName(self, *args):
        """
        HasName(StepFEA_DegreeOfFreedomMember self) -> Standard_Boolean

        Returns True if has name

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.StepFEA_DegreeOfFreedomMember_HasName(self, *args)


    def Name(self, *args):
        """
        Name(StepFEA_DegreeOfFreedomMember self) -> Standard_CString

        Returns set name

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepFEA.StepFEA_DegreeOfFreedomMember_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(StepFEA_DegreeOfFreedomMember self, Standard_CString const name) -> Standard_Boolean

        Set name

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.StepFEA_DegreeOfFreedomMember_SetName(self, *args)


    def Matches(self, *args):
        """
        Matches(StepFEA_DegreeOfFreedomMember self, Standard_CString const name) -> Standard_Boolean

        Tells if the name of a SelectMember matches a given one;

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.StepFEA_DegreeOfFreedomMember_Matches(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_DegreeOfFreedomMember_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_DegreeOfFreedomMember_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_DegreeOfFreedomMember_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_DegreeOfFreedomMember
StepFEA_DegreeOfFreedomMember_swigregister = _StepFEA.StepFEA_DegreeOfFreedomMember_swigregister
StepFEA_DegreeOfFreedomMember_swigregister(StepFEA_DegreeOfFreedomMember)

def StepFEA_DegreeOfFreedomMember_get_type_name(*args):
    """
    StepFEA_DegreeOfFreedomMember_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_DegreeOfFreedomMember_get_type_name(*args)

def StepFEA_DegreeOfFreedomMember_get_type_descriptor(*args):
    """
    StepFEA_DegreeOfFreedomMember_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_DegreeOfFreedomMember_get_type_descriptor(*args)

class StepFEA_SymmetricTensor43dMember(StepData.StepData_SelectArrReal):
    """Representation of member for  STEP SELECT type SymmetricTensor43d"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_SymmetricTensor43dMember
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_SymmetricTensor43dMember(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_SymmetricTensor43dMember self) -> StepFEA_SymmetricTensor43dMember

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_SymmetricTensor43dMember(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def HasName(self, *args):
        """
        HasName(StepFEA_SymmetricTensor43dMember self) -> Standard_Boolean

        Returns True if has name

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.StepFEA_SymmetricTensor43dMember_HasName(self, *args)


    def Name(self, *args):
        """
        Name(StepFEA_SymmetricTensor43dMember self) -> Standard_CString

        Returns set name

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepFEA.StepFEA_SymmetricTensor43dMember_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(StepFEA_SymmetricTensor43dMember self, Standard_CString const name) -> Standard_Boolean

        Set name

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.StepFEA_SymmetricTensor43dMember_SetName(self, *args)


    def Matches(self, *args):
        """
        Matches(StepFEA_SymmetricTensor43dMember self, Standard_CString const name) -> Standard_Boolean

        Tells if the name of a SelectMember matches a given one;

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.StepFEA_SymmetricTensor43dMember_Matches(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_SymmetricTensor43dMember_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_SymmetricTensor43dMember_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_SymmetricTensor43dMember_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_SymmetricTensor43dMember
StepFEA_SymmetricTensor43dMember_swigregister = _StepFEA.StepFEA_SymmetricTensor43dMember_swigregister
StepFEA_SymmetricTensor43dMember_swigregister(StepFEA_SymmetricTensor43dMember)

def StepFEA_SymmetricTensor43dMember_get_type_name(*args):
    """
    StepFEA_SymmetricTensor43dMember_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_SymmetricTensor43dMember_get_type_name(*args)

def StepFEA_SymmetricTensor43dMember_get_type_descriptor(*args):
    """
    StepFEA_SymmetricTensor43dMember_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_SymmetricTensor43dMember_get_type_descriptor(*args)

class StepFEA_NodeDefinition(StepRepr.StepRepr_ShapeAspect):
    """Representation of STEP entity NodeDefinition"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_NodeDefinition
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_NodeDefinition(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_NodeDefinition self) -> StepFEA_NodeDefinition

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_NodeDefinition(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_NodeDefinition_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_NodeDefinition_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_NodeDefinition_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_NodeDefinition
StepFEA_NodeDefinition_swigregister = _StepFEA.StepFEA_NodeDefinition_swigregister
StepFEA_NodeDefinition_swigregister(StepFEA_NodeDefinition)

def StepFEA_NodeDefinition_get_type_name(*args):
    """
    StepFEA_NodeDefinition_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_NodeDefinition_get_type_name(*args)

def StepFEA_NodeDefinition_get_type_descriptor(*args):
    """
    StepFEA_NodeDefinition_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_NodeDefinition_get_type_descriptor(*args)

class StepFEA_NodeWithVector(StepFEA_Node):
    """Representation of STEP entity NodeWithVector"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_NodeWithVector
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_NodeWithVector(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_NodeWithVector self) -> StepFEA_NodeWithVector

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_NodeWithVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_NodeWithVector_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_NodeWithVector_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_NodeWithVector_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_NodeWithVector
StepFEA_NodeWithVector_swigregister = _StepFEA.StepFEA_NodeWithVector_swigregister
StepFEA_NodeWithVector_swigregister(StepFEA_NodeWithVector)

def StepFEA_NodeWithVector_get_type_name(*args):
    """
    StepFEA_NodeWithVector_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_NodeWithVector_get_type_name(*args)

def StepFEA_NodeWithVector_get_type_descriptor(*args):
    """
    StepFEA_NodeWithVector_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_NodeWithVector_get_type_descriptor(*args)

class StepFEA_FeaShellShearStiffness(StepFEA_FeaMaterialPropertyRepresentationItem):
    """Representation of STEP entity FeaShellShearStiffness"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_FeaShellShearStiffness
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_FeaShellShearStiffness(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_FeaShellShearStiffness self) -> StepFEA_FeaShellShearStiffness

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_FeaShellShearStiffness(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_FeaShellShearStiffness self, Handle_TCollection_HAsciiString aRepresentationItem_Name, StepFEA_SymmetricTensor22d aFeaConstants)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFeaConstants: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor22d

        """
        return _StepFEA.StepFEA_FeaShellShearStiffness_Init(self, *args)


    def FeaConstants(self, *args):
        """
        FeaConstants(StepFEA_FeaShellShearStiffness self) -> StepFEA_SymmetricTensor22d

        Returns field FeaConstants

        :rtype: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor22d

        """
        return _StepFEA.StepFEA_FeaShellShearStiffness_FeaConstants(self, *args)


    def SetFeaConstants(self, *args):
        """
        SetFeaConstants(StepFEA_FeaShellShearStiffness self, StepFEA_SymmetricTensor22d FeaConstants)

        Set field FeaConstants

        :type FeaConstants: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor22d

        """
        return _StepFEA.StepFEA_FeaShellShearStiffness_SetFeaConstants(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_FeaShellShearStiffness_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_FeaShellShearStiffness_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_FeaShellShearStiffness_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_FeaShellShearStiffness
StepFEA_FeaShellShearStiffness_swigregister = _StepFEA.StepFEA_FeaShellShearStiffness_swigregister
StepFEA_FeaShellShearStiffness_swigregister(StepFEA_FeaShellShearStiffness)

def StepFEA_FeaShellShearStiffness_get_type_name(*args):
    """
    StepFEA_FeaShellShearStiffness_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_FeaShellShearStiffness_get_type_name(*args)

def StepFEA_FeaShellShearStiffness_get_type_descriptor(*args):
    """
    StepFEA_FeaShellShearStiffness_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_FeaShellShearStiffness_get_type_descriptor(*args)

class StepFEA_FeaCurveSectionGeometricRelationship(Standard.Standard_Transient):
    """Representation of STEP entity FeaCurveSectionGeometricRelationship"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_FeaCurveSectionGeometricRelationship
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_FeaCurveSectionGeometricRelationship(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_FeaCurveSectionGeometricRelationship self) -> StepFEA_FeaCurveSectionGeometricRelationship

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_FeaCurveSectionGeometricRelationship(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_FeaCurveSectionGeometricRelationship self, Handle_StepElement_CurveElementSectionDefinition aSectionRef, Handle_StepElement_AnalysisItemWithinRepresentation aItem)

        Initialize all fields (own and inherited)

        :type aSectionRef: OCC.wrapper.StepElement.Handle_StepElement_CurveElementSectionDefinition
        :type aItem: OCC.wrapper.StepElement.Handle_StepElement_AnalysisItemWithinRepresentation

        """
        return _StepFEA.StepFEA_FeaCurveSectionGeometricRelationship_Init(self, *args)


    def SectionRef(self, *args):
        """
        SectionRef(StepFEA_FeaCurveSectionGeometricRelationship self) -> Handle_StepElement_CurveElementSectionDefinition

        Returns field SectionRef

        :rtype: OCC.wrapper.StepElement.Handle_StepElement_CurveElementSectionDefinition

        """
        return _StepFEA.StepFEA_FeaCurveSectionGeometricRelationship_SectionRef(self, *args)


    def SetSectionRef(self, *args):
        """
        SetSectionRef(StepFEA_FeaCurveSectionGeometricRelationship self, Handle_StepElement_CurveElementSectionDefinition SectionRef)

        Set field SectionRef

        :type SectionRef: OCC.wrapper.StepElement.Handle_StepElement_CurveElementSectionDefinition

        """
        return _StepFEA.StepFEA_FeaCurveSectionGeometricRelationship_SetSectionRef(self, *args)


    def Item(self, *args):
        """
        Item(StepFEA_FeaCurveSectionGeometricRelationship self) -> Handle_StepElement_AnalysisItemWithinRepresentation

        Returns field Item

        :rtype: OCC.wrapper.StepElement.Handle_StepElement_AnalysisItemWithinRepresentation

        """
        return _StepFEA.StepFEA_FeaCurveSectionGeometricRelationship_Item(self, *args)


    def SetItem(self, *args):
        """
        SetItem(StepFEA_FeaCurveSectionGeometricRelationship self, Handle_StepElement_AnalysisItemWithinRepresentation Item)

        Set field Item

        :type Item: OCC.wrapper.StepElement.Handle_StepElement_AnalysisItemWithinRepresentation

        """
        return _StepFEA.StepFEA_FeaCurveSectionGeometricRelationship_SetItem(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_FeaCurveSectionGeometricRelationship_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_FeaCurveSectionGeometricRelationship_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_FeaCurveSectionGeometricRelationship_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_FeaCurveSectionGeometricRelationship
StepFEA_FeaCurveSectionGeometricRelationship_swigregister = _StepFEA.StepFEA_FeaCurveSectionGeometricRelationship_swigregister
StepFEA_FeaCurveSectionGeometricRelationship_swigregister(StepFEA_FeaCurveSectionGeometricRelationship)

def StepFEA_FeaCurveSectionGeometricRelationship_get_type_name(*args):
    """
    StepFEA_FeaCurveSectionGeometricRelationship_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_FeaCurveSectionGeometricRelationship_get_type_name(*args)

def StepFEA_FeaCurveSectionGeometricRelationship_get_type_descriptor(*args):
    """
    StepFEA_FeaCurveSectionGeometricRelationship_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_FeaCurveSectionGeometricRelationship_get_type_descriptor(*args)

class StepFEA_Curve3dElementRepresentation(StepFEA_ElementRepresentation):
    """Representation of STEP entity Curve3dElementRepresentation"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_Curve3dElementRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_Curve3dElementRepresentation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_Curve3dElementRepresentation self) -> StepFEA_Curve3dElementRepresentation

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_Curve3dElementRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_Curve3dElementRepresentation self, Handle_TCollection_HAsciiString aRepresentation_Name, Handle_StepRepr_HArray1OfRepresentationItem aRepresentation_Items, Handle_StepRepr_RepresentationContext aRepresentation_ContextOfItems, Handle_StepFEA_HArray1OfNodeRepresentation aElementRepresentation_NodeList, Handle_StepFEA_FeaModel3d aModelRef, Handle_StepElement_Curve3dElementDescriptor aElementDescriptor, Handle_StepFEA_Curve3dElementProperty aProperty, Handle_StepElement_ElementMaterial aMaterial)

        Initialize all fields (own and inherited)

        :type aRepresentation_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRepresentation_Items: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aRepresentation_ContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext
        :type aElementRepresentation_NodeList: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation
        :type aModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel3d
        :type aElementDescriptor: OCC.wrapper.StepElement.Handle_StepElement_Curve3dElementDescriptor
        :type aProperty: OCC.wrapper.StepFEA.Handle_StepFEA_Curve3dElementProperty
        :type aMaterial: OCC.wrapper.StepElement.Handle_StepElement_ElementMaterial

        """
        return _StepFEA.StepFEA_Curve3dElementRepresentation_Init(self, *args)


    def ModelRef(self, *args):
        """
        ModelRef(StepFEA_Curve3dElementRepresentation self) -> Handle_StepFEA_FeaModel3d

        Returns field ModelRef

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel3d

        """
        return _StepFEA.StepFEA_Curve3dElementRepresentation_ModelRef(self, *args)


    def SetModelRef(self, *args):
        """
        SetModelRef(StepFEA_Curve3dElementRepresentation self, Handle_StepFEA_FeaModel3d ModelRef)

        Set field ModelRef

        :type ModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel3d

        """
        return _StepFEA.StepFEA_Curve3dElementRepresentation_SetModelRef(self, *args)


    def ElementDescriptor(self, *args):
        """
        ElementDescriptor(StepFEA_Curve3dElementRepresentation self) -> Handle_StepElement_Curve3dElementDescriptor

        Returns field ElementDescriptor

        :rtype: OCC.wrapper.StepElement.Handle_StepElement_Curve3dElementDescriptor

        """
        return _StepFEA.StepFEA_Curve3dElementRepresentation_ElementDescriptor(self, *args)


    def SetElementDescriptor(self, *args):
        """
        SetElementDescriptor(StepFEA_Curve3dElementRepresentation self, Handle_StepElement_Curve3dElementDescriptor ElementDescriptor)

        Set field ElementDescriptor

        :type ElementDescriptor: OCC.wrapper.StepElement.Handle_StepElement_Curve3dElementDescriptor

        """
        return _StepFEA.StepFEA_Curve3dElementRepresentation_SetElementDescriptor(self, *args)


    def Property(self, *args):
        """
        Property(StepFEA_Curve3dElementRepresentation self) -> Handle_StepFEA_Curve3dElementProperty

        Returns field Property

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_Curve3dElementProperty

        """
        return _StepFEA.StepFEA_Curve3dElementRepresentation_Property(self, *args)


    def SetProperty(self, *args):
        """
        SetProperty(StepFEA_Curve3dElementRepresentation self, Handle_StepFEA_Curve3dElementProperty Property)

        Set field Property

        :type Property: OCC.wrapper.StepFEA.Handle_StepFEA_Curve3dElementProperty

        """
        return _StepFEA.StepFEA_Curve3dElementRepresentation_SetProperty(self, *args)


    def Material(self, *args):
        """
        Material(StepFEA_Curve3dElementRepresentation self) -> Handle_StepElement_ElementMaterial

        Returns field Material

        :rtype: OCC.wrapper.StepElement.Handle_StepElement_ElementMaterial

        """
        return _StepFEA.StepFEA_Curve3dElementRepresentation_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(StepFEA_Curve3dElementRepresentation self, Handle_StepElement_ElementMaterial Material)

        Set field Material

        :type Material: OCC.wrapper.StepElement.Handle_StepElement_ElementMaterial

        """
        return _StepFEA.StepFEA_Curve3dElementRepresentation_SetMaterial(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_Curve3dElementRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_Curve3dElementRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_Curve3dElementRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_Curve3dElementRepresentation
StepFEA_Curve3dElementRepresentation_swigregister = _StepFEA.StepFEA_Curve3dElementRepresentation_swigregister
StepFEA_Curve3dElementRepresentation_swigregister(StepFEA_Curve3dElementRepresentation)

def StepFEA_Curve3dElementRepresentation_get_type_name(*args):
    """
    StepFEA_Curve3dElementRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_Curve3dElementRepresentation_get_type_name(*args)

def StepFEA_Curve3dElementRepresentation_get_type_descriptor(*args):
    """
    StepFEA_Curve3dElementRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_Curve3dElementRepresentation_get_type_descriptor(*args)

class StepFEA_HSequenceOfElementRepresentation(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_HSequenceOfElementRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_HSequenceOfElementRepresentation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_HSequenceOfElementRepresentation self) -> StepFEA_HSequenceOfElementRepresentation
        __init__(StepFEA_HSequenceOfElementRepresentation self, NCollection_Sequence_Handle_StepFEA_ElementRepresentation theOther) -> StepFEA_HSequenceOfElementRepresentation

        :type theOther: OCC.wrapper.StepFEA.StepFEA_SequenceOfElementRepresentation

        """
        this = _StepFEA.new_StepFEA_HSequenceOfElementRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.StepFEA.StepFEA_SequenceOfElementRepresentation

        """
        res = _StepFEA.StepFEA_HSequenceOfElementRepresentation_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(StepFEA_HSequenceOfElementRepresentation self, Handle_StepFEA_ElementRepresentation theItem)
        Append(StepFEA_HSequenceOfElementRepresentation self, NCollection_Sequence_Handle_StepFEA_ElementRepresentation theSequence)

        :type theSequence: OCC.wrapper.StepFEA.StepFEA_SequenceOfElementRepresentation

        """
        return _StepFEA.StepFEA_HSequenceOfElementRepresentation_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(StepFEA_HSequenceOfElementRepresentation self) -> NCollection_Sequence_Handle_StepFEA_ElementRepresentation

        :rtype: OCC.wrapper.StepFEA.StepFEA_SequenceOfElementRepresentation

        """
        return _StepFEA.StepFEA_HSequenceOfElementRepresentation_ChangeSequence(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_HSequenceOfElementRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_HSequenceOfElementRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_HSequenceOfElementRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_HSequenceOfElementRepresentation
StepFEA_HSequenceOfElementRepresentation_swigregister = _StepFEA.StepFEA_HSequenceOfElementRepresentation_swigregister
StepFEA_HSequenceOfElementRepresentation_swigregister(StepFEA_HSequenceOfElementRepresentation)

def StepFEA_HSequenceOfElementRepresentation_get_type_name(*args):
    """
    StepFEA_HSequenceOfElementRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_HSequenceOfElementRepresentation_get_type_name(*args)

def StepFEA_HSequenceOfElementRepresentation_get_type_descriptor(*args):
    """
    StepFEA_HSequenceOfElementRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_HSequenceOfElementRepresentation_get_type_descriptor(*args)

class StepFEA_FeaLinearElasticity(StepFEA_FeaMaterialPropertyRepresentationItem):
    """Representation of STEP entity FeaLinearElasticity"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_FeaLinearElasticity
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_FeaLinearElasticity(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_FeaLinearElasticity self) -> StepFEA_FeaLinearElasticity

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_FeaLinearElasticity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_FeaLinearElasticity self, Handle_TCollection_HAsciiString aRepresentationItem_Name, StepFEA_SymmetricTensor43d aFeaConstants)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFeaConstants: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor43d

        """
        return _StepFEA.StepFEA_FeaLinearElasticity_Init(self, *args)


    def FeaConstants(self, *args):
        """
        FeaConstants(StepFEA_FeaLinearElasticity self) -> StepFEA_SymmetricTensor43d

        Returns field FeaConstants

        :rtype: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor43d

        """
        return _StepFEA.StepFEA_FeaLinearElasticity_FeaConstants(self, *args)


    def SetFeaConstants(self, *args):
        """
        SetFeaConstants(StepFEA_FeaLinearElasticity self, StepFEA_SymmetricTensor43d FeaConstants)

        Set field FeaConstants

        :type FeaConstants: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor43d

        """
        return _StepFEA.StepFEA_FeaLinearElasticity_SetFeaConstants(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_FeaLinearElasticity_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_FeaLinearElasticity_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_FeaLinearElasticity_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_FeaLinearElasticity
StepFEA_FeaLinearElasticity_swigregister = _StepFEA.StepFEA_FeaLinearElasticity_swigregister
StepFEA_FeaLinearElasticity_swigregister(StepFEA_FeaLinearElasticity)

def StepFEA_FeaLinearElasticity_get_type_name(*args):
    """
    StepFEA_FeaLinearElasticity_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_FeaLinearElasticity_get_type_name(*args)

def StepFEA_FeaLinearElasticity_get_type_descriptor(*args):
    """
    StepFEA_FeaLinearElasticity_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_FeaLinearElasticity_get_type_descriptor(*args)

class StepFEA_CurveElementInterval(Standard.Standard_Transient):
    """Representation of STEP entity CurveElementInterval"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_CurveElementInterval
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_CurveElementInterval(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_CurveElementInterval self) -> StepFEA_CurveElementInterval

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_CurveElementInterval(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_CurveElementInterval self, Handle_StepFEA_CurveElementLocation aFinishPosition, Handle_StepBasic_EulerAngles aEuAngles)

        Initialize all fields (own and inherited)

        :type aFinishPosition: OCC.wrapper.StepFEA.Handle_StepFEA_CurveElementLocation
        :type aEuAngles: OCC.wrapper.StepBasic.Handle_StepBasic_EulerAngles

        """
        return _StepFEA.StepFEA_CurveElementInterval_Init(self, *args)


    def FinishPosition(self, *args):
        """
        FinishPosition(StepFEA_CurveElementInterval self) -> Handle_StepFEA_CurveElementLocation

        Returns field FinishPosition

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_CurveElementLocation

        """
        return _StepFEA.StepFEA_CurveElementInterval_FinishPosition(self, *args)


    def SetFinishPosition(self, *args):
        """
        SetFinishPosition(StepFEA_CurveElementInterval self, Handle_StepFEA_CurveElementLocation FinishPosition)

        Set field FinishPosition

        :type FinishPosition: OCC.wrapper.StepFEA.Handle_StepFEA_CurveElementLocation

        """
        return _StepFEA.StepFEA_CurveElementInterval_SetFinishPosition(self, *args)


    def EuAngles(self, *args):
        """
        EuAngles(StepFEA_CurveElementInterval self) -> Handle_StepBasic_EulerAngles

        Returns field EuAngles

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_EulerAngles

        """
        return _StepFEA.StepFEA_CurveElementInterval_EuAngles(self, *args)


    def SetEuAngles(self, *args):
        """
        SetEuAngles(StepFEA_CurveElementInterval self, Handle_StepBasic_EulerAngles EuAngles)

        Set field EuAngles

        :type EuAngles: OCC.wrapper.StepBasic.Handle_StepBasic_EulerAngles

        """
        return _StepFEA.StepFEA_CurveElementInterval_SetEuAngles(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_CurveElementInterval_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_CurveElementInterval_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_CurveElementInterval_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_CurveElementInterval
StepFEA_CurveElementInterval_swigregister = _StepFEA.StepFEA_CurveElementInterval_swigregister
StepFEA_CurveElementInterval_swigregister(StepFEA_CurveElementInterval)

def StepFEA_CurveElementInterval_get_type_name(*args):
    """
    StepFEA_CurveElementInterval_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_CurveElementInterval_get_type_name(*args)

def StepFEA_CurveElementInterval_get_type_descriptor(*args):
    """
    StepFEA_CurveElementInterval_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_CurveElementInterval_get_type_descriptor(*args)

class StepFEA_DummyNode(StepFEA_NodeRepresentation):
    """Representation of STEP entity DummyNode"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_DummyNode
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_DummyNode(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_DummyNode self) -> StepFEA_DummyNode

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_DummyNode(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_DummyNode_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_DummyNode_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_DummyNode_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_DummyNode
StepFEA_DummyNode_swigregister = _StepFEA.StepFEA_DummyNode_swigregister
StepFEA_DummyNode_swigregister(StepFEA_DummyNode)

def StepFEA_DummyNode_get_type_name(*args):
    """
    StepFEA_DummyNode_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_DummyNode_get_type_name(*args)

def StepFEA_DummyNode_get_type_descriptor(*args):
    """
    StepFEA_DummyNode_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_DummyNode_get_type_descriptor(*args)

class StepFEA_FeaMassDensity(StepFEA_FeaMaterialPropertyRepresentationItem):
    """Representation of STEP entity FeaMassDensity"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_FeaMassDensity
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_FeaMassDensity(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_FeaMassDensity self) -> StepFEA_FeaMassDensity

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_FeaMassDensity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_FeaMassDensity self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Standard_Real const aFeaConstant)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFeaConstant: float

        """
        return _StepFEA.StepFEA_FeaMassDensity_Init(self, *args)


    def FeaConstant(self, *args):
        """
        FeaConstant(StepFEA_FeaMassDensity self) -> Standard_Real

        Returns field FeaConstant

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepFEA.StepFEA_FeaMassDensity_FeaConstant(self, *args)


    def SetFeaConstant(self, *args):
        """
        SetFeaConstant(StepFEA_FeaMassDensity self, Standard_Real const FeaConstant)

        Set field FeaConstant

        :type FeaConstant: float

        """
        return _StepFEA.StepFEA_FeaMassDensity_SetFeaConstant(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_FeaMassDensity_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_FeaMassDensity_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_FeaMassDensity_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_FeaMassDensity
StepFEA_FeaMassDensity_swigregister = _StepFEA.StepFEA_FeaMassDensity_swigregister
StepFEA_FeaMassDensity_swigregister(StepFEA_FeaMassDensity)

def StepFEA_FeaMassDensity_get_type_name(*args):
    """
    StepFEA_FeaMassDensity_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_FeaMassDensity_get_type_name(*args)

def StepFEA_FeaMassDensity_get_type_descriptor(*args):
    """
    StepFEA_FeaMassDensity_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_FeaMassDensity_get_type_descriptor(*args)

class StepFEA_FeaShellMembraneStiffness(StepFEA_FeaMaterialPropertyRepresentationItem):
    """Representation of STEP entity FeaShellMembraneStiffness"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_FeaShellMembraneStiffness
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_FeaShellMembraneStiffness(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_FeaShellMembraneStiffness self) -> StepFEA_FeaShellMembraneStiffness

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_FeaShellMembraneStiffness(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_FeaShellMembraneStiffness self, Handle_TCollection_HAsciiString aRepresentationItem_Name, StepFEA_SymmetricTensor42d aFeaConstants)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFeaConstants: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor42d

        """
        return _StepFEA.StepFEA_FeaShellMembraneStiffness_Init(self, *args)


    def FeaConstants(self, *args):
        """
        FeaConstants(StepFEA_FeaShellMembraneStiffness self) -> StepFEA_SymmetricTensor42d

        Returns field FeaConstants

        :rtype: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor42d

        """
        return _StepFEA.StepFEA_FeaShellMembraneStiffness_FeaConstants(self, *args)


    def SetFeaConstants(self, *args):
        """
        SetFeaConstants(StepFEA_FeaShellMembraneStiffness self, StepFEA_SymmetricTensor42d FeaConstants)

        Set field FeaConstants

        :type FeaConstants: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor42d

        """
        return _StepFEA.StepFEA_FeaShellMembraneStiffness_SetFeaConstants(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_FeaShellMembraneStiffness_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_FeaShellMembraneStiffness_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_FeaShellMembraneStiffness_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_FeaShellMembraneStiffness
StepFEA_FeaShellMembraneStiffness_swigregister = _StepFEA.StepFEA_FeaShellMembraneStiffness_swigregister
StepFEA_FeaShellMembraneStiffness_swigregister(StepFEA_FeaShellMembraneStiffness)

def StepFEA_FeaShellMembraneStiffness_get_type_name(*args):
    """
    StepFEA_FeaShellMembraneStiffness_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_FeaShellMembraneStiffness_get_type_name(*args)

def StepFEA_FeaShellMembraneStiffness_get_type_descriptor(*args):
    """
    StepFEA_FeaShellMembraneStiffness_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_FeaShellMembraneStiffness_get_type_descriptor(*args)

class StepFEA_CurveElementIntervalConstant(StepFEA_CurveElementInterval):
    """Representation of STEP entity CurveElementIntervalConstant"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_CurveElementIntervalConstant
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_CurveElementIntervalConstant(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_CurveElementIntervalConstant self) -> StepFEA_CurveElementIntervalConstant

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_CurveElementIntervalConstant(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_CurveElementIntervalConstant self, Handle_StepFEA_CurveElementLocation aCurveElementInterval_FinishPosition, Handle_StepBasic_EulerAngles aCurveElementInterval_EuAngles, Handle_StepElement_CurveElementSectionDefinition aSection)

        Initialize all fields (own and inherited)

        :type aCurveElementInterval_FinishPosition: OCC.wrapper.StepFEA.Handle_StepFEA_CurveElementLocation
        :type aCurveElementInterval_EuAngles: OCC.wrapper.StepBasic.Handle_StepBasic_EulerAngles
        :type aSection: OCC.wrapper.StepElement.Handle_StepElement_CurveElementSectionDefinition

        """
        return _StepFEA.StepFEA_CurveElementIntervalConstant_Init(self, *args)


    def Section(self, *args):
        """
        Section(StepFEA_CurveElementIntervalConstant self) -> Handle_StepElement_CurveElementSectionDefinition

        Returns field Section

        :rtype: OCC.wrapper.StepElement.Handle_StepElement_CurveElementSectionDefinition

        """
        return _StepFEA.StepFEA_CurveElementIntervalConstant_Section(self, *args)


    def SetSection(self, *args):
        """
        SetSection(StepFEA_CurveElementIntervalConstant self, Handle_StepElement_CurveElementSectionDefinition Section)

        Set field Section

        :type Section: OCC.wrapper.StepElement.Handle_StepElement_CurveElementSectionDefinition

        """
        return _StepFEA.StepFEA_CurveElementIntervalConstant_SetSection(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_CurveElementIntervalConstant_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_CurveElementIntervalConstant_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_CurveElementIntervalConstant_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_CurveElementIntervalConstant
StepFEA_CurveElementIntervalConstant_swigregister = _StepFEA.StepFEA_CurveElementIntervalConstant_swigregister
StepFEA_CurveElementIntervalConstant_swigregister(StepFEA_CurveElementIntervalConstant)

def StepFEA_CurveElementIntervalConstant_get_type_name(*args):
    """
    StepFEA_CurveElementIntervalConstant_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_CurveElementIntervalConstant_get_type_name(*args)

def StepFEA_CurveElementIntervalConstant_get_type_descriptor(*args):
    """
    StepFEA_CurveElementIntervalConstant_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_CurveElementIntervalConstant_get_type_descriptor(*args)

class StepFEA_DegreeOfFreedom(StepData.StepData_SelectType):
    """Representation of STEP SELECT type DegreeOfFreedom"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepFEA_DegreeOfFreedom self) -> StepFEA_DegreeOfFreedom

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_DegreeOfFreedom(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepFEA_DegreeOfFreedom self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a kind of CurveElementFreedom select type
        return 0

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.StepFEA_DegreeOfFreedom_CaseNum(self, *args)


    def CaseMem(self, *args):
        """
        CaseMem(StepFEA_DegreeOfFreedom self, Handle_StepData_SelectMember ent) -> Standard_Integer

        Recognizes a items of select member CurveElementFreedomMember
        1 -> EnumeratedCurveElementFreedom
        2 -> ApplicationDefinedDegreeOfFreedom
        0 else

        :type ent: OCC.wrapper.StepData.Handle_StepData_SelectMember
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.StepFEA_DegreeOfFreedom_CaseMem(self, *args)


    def NewMember(self, *args):
        """
        NewMember(StepFEA_DegreeOfFreedom self) -> Handle_StepData_SelectMember

        Returns a new select member the type CurveElementFreedomMember

        :rtype: OCC.wrapper.StepData.Handle_StepData_SelectMember

        """
        return _StepFEA.StepFEA_DegreeOfFreedom_NewMember(self, *args)


    def SetEnumeratedDegreeOfFreedom(self, *args):
        """
        SetEnumeratedDegreeOfFreedom(StepFEA_DegreeOfFreedom self, StepFEA_EnumeratedDegreeOfFreedom const aVal)

        Returns Value as EnumeratedDegreeOfFreedom (or Null if another type)

        :type aVal: OCC.wrapper.StepFEA.StepFEA_EnumeratedDegreeOfFreedom

        """
        return _StepFEA.StepFEA_DegreeOfFreedom_SetEnumeratedDegreeOfFreedom(self, *args)


    def EnumeratedDegreeOfFreedom(self, *args):
        """
        EnumeratedDegreeOfFreedom(StepFEA_DegreeOfFreedom self) -> StepFEA_EnumeratedDegreeOfFreedom

        Returns Value as EnumeratedDegreeOfFreedom (or Null if another type)

        :rtype: OCC.wrapper.StepFEA.StepFEA_EnumeratedDegreeOfFreedom

        """
        return _StepFEA.StepFEA_DegreeOfFreedom_EnumeratedDegreeOfFreedom(self, *args)


    def SetApplicationDefinedDegreeOfFreedom(self, *args):
        """
        SetApplicationDefinedDegreeOfFreedom(StepFEA_DegreeOfFreedom self, Handle_TCollection_HAsciiString aVal)

        Set Value for ApplicationDefinedDegreeOfFreedom

        :type aVal: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.StepFEA_DegreeOfFreedom_SetApplicationDefinedDegreeOfFreedom(self, *args)


    def ApplicationDefinedDegreeOfFreedom(self, *args):
        """
        ApplicationDefinedDegreeOfFreedom(StepFEA_DegreeOfFreedom self) -> Handle_TCollection_HAsciiString

        Returns Value as ApplicationDefinedDegreeOfFreedom (or Null if another type)

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.StepFEA_DegreeOfFreedom_ApplicationDefinedDegreeOfFreedom(self, *args)

    __swig_destroy__ = _StepFEA.delete_StepFEA_DegreeOfFreedom
StepFEA_DegreeOfFreedom_swigregister = _StepFEA.StepFEA_DegreeOfFreedom_swigregister
StepFEA_DegreeOfFreedom_swigregister(StepFEA_DegreeOfFreedom)

class StepFEA_FeaParametricPoint(StepGeom.StepGeom_Point):
    """Representation of STEP entity FeaParametricPoint"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_FeaParametricPoint
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_FeaParametricPoint(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_FeaParametricPoint self) -> StepFEA_FeaParametricPoint

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_FeaParametricPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_FeaParametricPoint self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Handle_TColStd_HArray1OfReal aCoordinates)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aCoordinates: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepFEA.StepFEA_FeaParametricPoint_Init(self, *args)


    def Coordinates(self, *args):
        """
        Coordinates(StepFEA_FeaParametricPoint self) -> Handle_TColStd_HArray1OfReal

        Returns field Coordinates

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepFEA.StepFEA_FeaParametricPoint_Coordinates(self, *args)


    def SetCoordinates(self, *args):
        """
        SetCoordinates(StepFEA_FeaParametricPoint self, Handle_TColStd_HArray1OfReal Coordinates)

        Set field Coordinates

        :type Coordinates: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepFEA.StepFEA_FeaParametricPoint_SetCoordinates(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_FeaParametricPoint_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_FeaParametricPoint_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_FeaParametricPoint_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_FeaParametricPoint
StepFEA_FeaParametricPoint_swigregister = _StepFEA.StepFEA_FeaParametricPoint_swigregister
StepFEA_FeaParametricPoint_swigregister(StepFEA_FeaParametricPoint)

def StepFEA_FeaParametricPoint_get_type_name(*args):
    """
    StepFEA_FeaParametricPoint_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_FeaParametricPoint_get_type_name(*args)

def StepFEA_FeaParametricPoint_get_type_descriptor(*args):
    """
    StepFEA_FeaParametricPoint_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_FeaParametricPoint_get_type_descriptor(*args)

class StepFEA_CurveElementEndRelease(Standard.Standard_Transient):
    """Representation of STEP entity CurveElementEndRelease"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_CurveElementEndRelease
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_CurveElementEndRelease(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_CurveElementEndRelease self) -> StepFEA_CurveElementEndRelease

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_CurveElementEndRelease(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_CurveElementEndRelease self, StepFEA_CurveElementEndCoordinateSystem aCoordinateSystem, Handle_StepElement_HArray1OfCurveElementEndReleasePacket aReleases)

        Initialize all fields (own and inherited)

        :type aCoordinateSystem: OCC.wrapper.StepFEA.StepFEA_CurveElementEndCoordinateSystem
        :type aReleases: OCC.wrapper.StepElement.Handle_StepElement_HArray1OfCurveElementEndReleasePacket

        """
        return _StepFEA.StepFEA_CurveElementEndRelease_Init(self, *args)


    def CoordinateSystem(self, *args):
        """
        CoordinateSystem(StepFEA_CurveElementEndRelease self) -> StepFEA_CurveElementEndCoordinateSystem

        Returns field CoordinateSystem

        :rtype: OCC.wrapper.StepFEA.StepFEA_CurveElementEndCoordinateSystem

        """
        return _StepFEA.StepFEA_CurveElementEndRelease_CoordinateSystem(self, *args)


    def SetCoordinateSystem(self, *args):
        """
        SetCoordinateSystem(StepFEA_CurveElementEndRelease self, StepFEA_CurveElementEndCoordinateSystem CoordinateSystem)

        Set field CoordinateSystem

        :type CoordinateSystem: OCC.wrapper.StepFEA.StepFEA_CurveElementEndCoordinateSystem

        """
        return _StepFEA.StepFEA_CurveElementEndRelease_SetCoordinateSystem(self, *args)


    def Releases(self, *args):
        """
        Releases(StepFEA_CurveElementEndRelease self) -> Handle_StepElement_HArray1OfCurveElementEndReleasePacket

        Returns field Releases

        :rtype: OCC.wrapper.StepElement.Handle_StepElement_HArray1OfCurveElementEndReleasePacket

        """
        return _StepFEA.StepFEA_CurveElementEndRelease_Releases(self, *args)


    def SetReleases(self, *args):
        """
        SetReleases(StepFEA_CurveElementEndRelease self, Handle_StepElement_HArray1OfCurveElementEndReleasePacket Releases)

        Set field Releases

        :type Releases: OCC.wrapper.StepElement.Handle_StepElement_HArray1OfCurveElementEndReleasePacket

        """
        return _StepFEA.StepFEA_CurveElementEndRelease_SetReleases(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_CurveElementEndRelease_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_CurveElementEndRelease_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_CurveElementEndRelease_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_CurveElementEndRelease
StepFEA_CurveElementEndRelease_swigregister = _StepFEA.StepFEA_CurveElementEndRelease_swigregister
StepFEA_CurveElementEndRelease_swigregister(StepFEA_CurveElementEndRelease)

def StepFEA_CurveElementEndRelease_get_type_name(*args):
    """
    StepFEA_CurveElementEndRelease_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_CurveElementEndRelease_get_type_name(*args)

def StepFEA_CurveElementEndRelease_get_type_descriptor(*args):
    """
    StepFEA_CurveElementEndRelease_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_CurveElementEndRelease_get_type_descriptor(*args)

class StepFEA_FeaMoistureAbsorption(StepFEA_FeaMaterialPropertyRepresentationItem):
    """Representation of STEP entity FeaMoistureAbsorption"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_FeaMoistureAbsorption
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_FeaMoistureAbsorption(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_FeaMoistureAbsorption self) -> StepFEA_FeaMoistureAbsorption

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_FeaMoistureAbsorption(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_FeaMoistureAbsorption self, Handle_TCollection_HAsciiString aRepresentationItem_Name, StepFEA_SymmetricTensor23d aFeaConstants)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFeaConstants: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor23d

        """
        return _StepFEA.StepFEA_FeaMoistureAbsorption_Init(self, *args)


    def FeaConstants(self, *args):
        """
        FeaConstants(StepFEA_FeaMoistureAbsorption self) -> StepFEA_SymmetricTensor23d

        Returns field FeaConstants

        :rtype: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor23d

        """
        return _StepFEA.StepFEA_FeaMoistureAbsorption_FeaConstants(self, *args)


    def SetFeaConstants(self, *args):
        """
        SetFeaConstants(StepFEA_FeaMoistureAbsorption self, StepFEA_SymmetricTensor23d FeaConstants)

        Set field FeaConstants

        :type FeaConstants: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor23d

        """
        return _StepFEA.StepFEA_FeaMoistureAbsorption_SetFeaConstants(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_FeaMoistureAbsorption_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_FeaMoistureAbsorption_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_FeaMoistureAbsorption_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_FeaMoistureAbsorption
StepFEA_FeaMoistureAbsorption_swigregister = _StepFEA.StepFEA_FeaMoistureAbsorption_swigregister
StepFEA_FeaMoistureAbsorption_swigregister(StepFEA_FeaMoistureAbsorption)

def StepFEA_FeaMoistureAbsorption_get_type_name(*args):
    """
    StepFEA_FeaMoistureAbsorption_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_FeaMoistureAbsorption_get_type_name(*args)

def StepFEA_FeaMoistureAbsorption_get_type_descriptor(*args):
    """
    StepFEA_FeaMoistureAbsorption_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_FeaMoistureAbsorption_get_type_descriptor(*args)

class StepFEA_FeaModel(StepRepr.StepRepr_Representation):
    """Representation of STEP entity FeaModel"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_FeaModel
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_FeaModel(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_FeaModel self) -> StepFEA_FeaModel

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_FeaModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_FeaModel self, Handle_TCollection_HAsciiString aRepresentation_Name, Handle_StepRepr_HArray1OfRepresentationItem aRepresentation_Items, Handle_StepRepr_RepresentationContext aRepresentation_ContextOfItems, Handle_TCollection_HAsciiString aCreatingSoftware, Handle_TColStd_HArray1OfAsciiString aIntendedAnalysisCode, Handle_TCollection_HAsciiString aDescription, Handle_TCollection_HAsciiString aAnalysisType)

        Initialize all fields (own and inherited)

        :type aRepresentation_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRepresentation_Items: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aRepresentation_ContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext
        :type aCreatingSoftware: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aIntendedAnalysisCode: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfAsciiString
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aAnalysisType: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.StepFEA_FeaModel_Init(self, *args)


    def CreatingSoftware(self, *args):
        """
        CreatingSoftware(StepFEA_FeaModel self) -> Handle_TCollection_HAsciiString

        Returns field CreatingSoftware

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.StepFEA_FeaModel_CreatingSoftware(self, *args)


    def SetCreatingSoftware(self, *args):
        """
        SetCreatingSoftware(StepFEA_FeaModel self, Handle_TCollection_HAsciiString CreatingSoftware)

        Set field CreatingSoftware

        :type CreatingSoftware: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.StepFEA_FeaModel_SetCreatingSoftware(self, *args)


    def IntendedAnalysisCode(self, *args):
        """
        IntendedAnalysisCode(StepFEA_FeaModel self) -> Handle_TColStd_HArray1OfAsciiString

        Returns field IntendedAnalysisCode

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfAsciiString

        """
        return _StepFEA.StepFEA_FeaModel_IntendedAnalysisCode(self, *args)


    def SetIntendedAnalysisCode(self, *args):
        """
        SetIntendedAnalysisCode(StepFEA_FeaModel self, Handle_TColStd_HArray1OfAsciiString IntendedAnalysisCode)

        Set field IntendedAnalysisCode

        :type IntendedAnalysisCode: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfAsciiString

        """
        return _StepFEA.StepFEA_FeaModel_SetIntendedAnalysisCode(self, *args)


    def Description(self, *args):
        """
        Description(StepFEA_FeaModel self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.StepFEA_FeaModel_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(StepFEA_FeaModel self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.StepFEA_FeaModel_SetDescription(self, *args)


    def AnalysisType(self, *args):
        """
        AnalysisType(StepFEA_FeaModel self) -> Handle_TCollection_HAsciiString

        Returns field AnalysisType

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.StepFEA_FeaModel_AnalysisType(self, *args)


    def SetAnalysisType(self, *args):
        """
        SetAnalysisType(StepFEA_FeaModel self, Handle_TCollection_HAsciiString AnalysisType)

        Set field AnalysisType

        :type AnalysisType: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.StepFEA_FeaModel_SetAnalysisType(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_FeaModel_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_FeaModel_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_FeaModel_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_FeaModel
StepFEA_FeaModel_swigregister = _StepFEA.StepFEA_FeaModel_swigregister
StepFEA_FeaModel_swigregister(StepFEA_FeaModel)

def StepFEA_FeaModel_get_type_name(*args):
    """
    StepFEA_FeaModel_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_FeaModel_get_type_name(*args)

def StepFEA_FeaModel_get_type_descriptor(*args):
    """
    StepFEA_FeaModel_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_FeaModel_get_type_descriptor(*args)

class StepFEA_FreedomAndCoefficient(Standard.Standard_Transient):
    """Representation of STEP entity FreedomAndCoefficient"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_FreedomAndCoefficient
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_FreedomAndCoefficient(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_FreedomAndCoefficient self) -> StepFEA_FreedomAndCoefficient

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_FreedomAndCoefficient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_FreedomAndCoefficient self, StepFEA_DegreeOfFreedom aFreedom, StepElement_MeasureOrUnspecifiedValue aA)

        Initialize all fields (own and inherited)

        :type aFreedom: OCC.wrapper.StepFEA.StepFEA_DegreeOfFreedom
        :type aA: OCC.wrapper.StepElement.StepElement_MeasureOrUnspecifiedValue

        """
        return _StepFEA.StepFEA_FreedomAndCoefficient_Init(self, *args)


    def Freedom(self, *args):
        """
        Freedom(StepFEA_FreedomAndCoefficient self) -> StepFEA_DegreeOfFreedom

        Returns field Freedom

        :rtype: OCC.wrapper.StepFEA.StepFEA_DegreeOfFreedom

        """
        return _StepFEA.StepFEA_FreedomAndCoefficient_Freedom(self, *args)


    def SetFreedom(self, *args):
        """
        SetFreedom(StepFEA_FreedomAndCoefficient self, StepFEA_DegreeOfFreedom Freedom)

        Set field Freedom

        :type Freedom: OCC.wrapper.StepFEA.StepFEA_DegreeOfFreedom

        """
        return _StepFEA.StepFEA_FreedomAndCoefficient_SetFreedom(self, *args)


    def A(self, *args):
        """
        A(StepFEA_FreedomAndCoefficient self) -> StepElement_MeasureOrUnspecifiedValue

        Returns field A

        :rtype: OCC.wrapper.StepElement.StepElement_MeasureOrUnspecifiedValue

        """
        return _StepFEA.StepFEA_FreedomAndCoefficient_A(self, *args)


    def SetA(self, *args):
        """
        SetA(StepFEA_FreedomAndCoefficient self, StepElement_MeasureOrUnspecifiedValue A)

        Set field A

        :type A: OCC.wrapper.StepElement.StepElement_MeasureOrUnspecifiedValue

        """
        return _StepFEA.StepFEA_FreedomAndCoefficient_SetA(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_FreedomAndCoefficient_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_FreedomAndCoefficient_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_FreedomAndCoefficient_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_FreedomAndCoefficient
StepFEA_FreedomAndCoefficient_swigregister = _StepFEA.StepFEA_FreedomAndCoefficient_swigregister
StepFEA_FreedomAndCoefficient_swigregister(StepFEA_FreedomAndCoefficient)

def StepFEA_FreedomAndCoefficient_get_type_name(*args):
    """
    StepFEA_FreedomAndCoefficient_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_FreedomAndCoefficient_get_type_name(*args)

def StepFEA_FreedomAndCoefficient_get_type_descriptor(*args):
    """
    StepFEA_FreedomAndCoefficient_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_FreedomAndCoefficient_get_type_descriptor(*args)

class StepFEA_FeaModelDefinition(StepRepr.StepRepr_ShapeAspect):
    """Representation of STEP entity FeaModelDefinition"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_FeaModelDefinition
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_FeaModelDefinition(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_FeaModelDefinition self) -> StepFEA_FeaModelDefinition

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_FeaModelDefinition(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_FeaModelDefinition_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_FeaModelDefinition_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_FeaModelDefinition_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_FeaModelDefinition
StepFEA_FeaModelDefinition_swigregister = _StepFEA.StepFEA_FeaModelDefinition_swigregister
StepFEA_FeaModelDefinition_swigregister(StepFEA_FeaModelDefinition)

def StepFEA_FeaModelDefinition_get_type_name(*args):
    """
    StepFEA_FeaModelDefinition_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_FeaModelDefinition_get_type_name(*args)

def StepFEA_FeaModelDefinition_get_type_descriptor(*args):
    """
    StepFEA_FeaModelDefinition_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_FeaModelDefinition_get_type_descriptor(*args)

class StepFEA_Curve3dElementProperty(Standard.Standard_Transient):
    """Representation of STEP entity Curve3dElementProperty"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_Curve3dElementProperty
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_Curve3dElementProperty(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_Curve3dElementProperty self) -> StepFEA_Curve3dElementProperty

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_Curve3dElementProperty(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_Curve3dElementProperty self, Handle_TCollection_HAsciiString aPropertyId, Handle_TCollection_HAsciiString aDescription, Handle_StepFEA_HArray1OfCurveElementInterval aIntervalDefinitions, Handle_StepFEA_HArray1OfCurveElementEndOffset aEndOffsets, Handle_StepFEA_HArray1OfCurveElementEndRelease aEndReleases)

        Initialize all fields (own and inherited)

        :type aPropertyId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aIntervalDefinitions: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfCurveElementInterval
        :type aEndOffsets: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfCurveElementEndOffset
        :type aEndReleases: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfCurveElementEndRelease

        """
        return _StepFEA.StepFEA_Curve3dElementProperty_Init(self, *args)


    def PropertyId(self, *args):
        """
        PropertyId(StepFEA_Curve3dElementProperty self) -> Handle_TCollection_HAsciiString

        Returns field PropertyId

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.StepFEA_Curve3dElementProperty_PropertyId(self, *args)


    def SetPropertyId(self, *args):
        """
        SetPropertyId(StepFEA_Curve3dElementProperty self, Handle_TCollection_HAsciiString PropertyId)

        Set field PropertyId

        :type PropertyId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.StepFEA_Curve3dElementProperty_SetPropertyId(self, *args)


    def Description(self, *args):
        """
        Description(StepFEA_Curve3dElementProperty self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.StepFEA_Curve3dElementProperty_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(StepFEA_Curve3dElementProperty self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.StepFEA_Curve3dElementProperty_SetDescription(self, *args)


    def IntervalDefinitions(self, *args):
        """
        IntervalDefinitions(StepFEA_Curve3dElementProperty self) -> Handle_StepFEA_HArray1OfCurveElementInterval

        Returns field IntervalDefinitions

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfCurveElementInterval

        """
        return _StepFEA.StepFEA_Curve3dElementProperty_IntervalDefinitions(self, *args)


    def SetIntervalDefinitions(self, *args):
        """
        SetIntervalDefinitions(StepFEA_Curve3dElementProperty self, Handle_StepFEA_HArray1OfCurveElementInterval IntervalDefinitions)

        Set field IntervalDefinitions

        :type IntervalDefinitions: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfCurveElementInterval

        """
        return _StepFEA.StepFEA_Curve3dElementProperty_SetIntervalDefinitions(self, *args)


    def EndOffsets(self, *args):
        """
        EndOffsets(StepFEA_Curve3dElementProperty self) -> Handle_StepFEA_HArray1OfCurveElementEndOffset

        Returns field EndOffsets

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfCurveElementEndOffset

        """
        return _StepFEA.StepFEA_Curve3dElementProperty_EndOffsets(self, *args)


    def SetEndOffsets(self, *args):
        """
        SetEndOffsets(StepFEA_Curve3dElementProperty self, Handle_StepFEA_HArray1OfCurveElementEndOffset EndOffsets)

        Set field EndOffsets

        :type EndOffsets: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfCurveElementEndOffset

        """
        return _StepFEA.StepFEA_Curve3dElementProperty_SetEndOffsets(self, *args)


    def EndReleases(self, *args):
        """
        EndReleases(StepFEA_Curve3dElementProperty self) -> Handle_StepFEA_HArray1OfCurveElementEndRelease

        Returns field EndReleases

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfCurveElementEndRelease

        """
        return _StepFEA.StepFEA_Curve3dElementProperty_EndReleases(self, *args)


    def SetEndReleases(self, *args):
        """
        SetEndReleases(StepFEA_Curve3dElementProperty self, Handle_StepFEA_HArray1OfCurveElementEndRelease EndReleases)

        Set field EndReleases

        :type EndReleases: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfCurveElementEndRelease

        """
        return _StepFEA.StepFEA_Curve3dElementProperty_SetEndReleases(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_Curve3dElementProperty_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_Curve3dElementProperty_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_Curve3dElementProperty_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_Curve3dElementProperty
StepFEA_Curve3dElementProperty_swigregister = _StepFEA.StepFEA_Curve3dElementProperty_swigregister
StepFEA_Curve3dElementProperty_swigregister(StepFEA_Curve3dElementProperty)

def StepFEA_Curve3dElementProperty_get_type_name(*args):
    """
    StepFEA_Curve3dElementProperty_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_Curve3dElementProperty_get_type_name(*args)

def StepFEA_Curve3dElementProperty_get_type_descriptor(*args):
    """
    StepFEA_Curve3dElementProperty_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_Curve3dElementProperty_get_type_descriptor(*args)

class StepFEA_FeaModel3d(StepFEA_FeaModel):
    """Representation of STEP entity FeaModel3d"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_FeaModel3d
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_FeaModel3d(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_FeaModel3d self) -> StepFEA_FeaModel3d

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_FeaModel3d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_FeaModel3d_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_FeaModel3d_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_FeaModel3d_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_FeaModel3d
StepFEA_FeaModel3d_swigregister = _StepFEA.StepFEA_FeaModel3d_swigregister
StepFEA_FeaModel3d_swigregister(StepFEA_FeaModel3d)

def StepFEA_FeaModel3d_get_type_name(*args):
    """
    StepFEA_FeaModel3d_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_FeaModel3d_get_type_name(*args)

def StepFEA_FeaModel3d_get_type_descriptor(*args):
    """
    StepFEA_FeaModel3d_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_FeaModel3d_get_type_descriptor(*args)

class StepFEA_HArray1OfCurveElementInterval(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_HArray1OfCurveElementInterval
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_HArray1OfCurveElementInterval(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_HArray1OfCurveElementInterval self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepFEA_HArray1OfCurveElementInterval
        __init__(StepFEA_HArray1OfCurveElementInterval self, Standard_Integer const theLower, Standard_Integer const theUpper, Handle_StepFEA_CurveElementInterval theValue) -> StepFEA_HArray1OfCurveElementInterval
        __init__(StepFEA_HArray1OfCurveElementInterval self, NCollection_Array1_Handle_StepFEA_CurveElementInterval theOther) -> StepFEA_HArray1OfCurveElementInterval

        :type theOther: OCC.wrapper.StepFEA.StepFEA_Array1OfCurveElementInterval

        """
        this = _StepFEA.new_StepFEA_HArray1OfCurveElementInterval(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepFEA.StepFEA_Array1OfCurveElementInterval

        """
        res = _StepFEA.StepFEA_HArray1OfCurveElementInterval_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepFEA_HArray1OfCurveElementInterval self) -> NCollection_Array1_Handle_StepFEA_CurveElementInterval

        :rtype: OCC.wrapper.StepFEA.StepFEA_Array1OfCurveElementInterval

        """
        return _StepFEA.StepFEA_HArray1OfCurveElementInterval_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_HArray1OfCurveElementInterval_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_HArray1OfCurveElementInterval_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_HArray1OfCurveElementInterval_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_HArray1OfCurveElementInterval
StepFEA_HArray1OfCurveElementInterval_swigregister = _StepFEA.StepFEA_HArray1OfCurveElementInterval_swigregister
StepFEA_HArray1OfCurveElementInterval_swigregister(StepFEA_HArray1OfCurveElementInterval)

def StepFEA_HArray1OfCurveElementInterval_get_type_name(*args):
    """
    StepFEA_HArray1OfCurveElementInterval_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_HArray1OfCurveElementInterval_get_type_name(*args)

def StepFEA_HArray1OfCurveElementInterval_get_type_descriptor(*args):
    """
    StepFEA_HArray1OfCurveElementInterval_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_HArray1OfCurveElementInterval_get_type_descriptor(*args)

class StepFEA_FeaRepresentationItem(StepRepr.StepRepr_RepresentationItem):
    """Representation of STEP entity FeaRepresentationItem"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_FeaRepresentationItem
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_FeaRepresentationItem(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_FeaRepresentationItem self) -> StepFEA_FeaRepresentationItem

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_FeaRepresentationItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_FeaRepresentationItem_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_FeaRepresentationItem_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_FeaRepresentationItem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_FeaRepresentationItem
StepFEA_FeaRepresentationItem_swigregister = _StepFEA.StepFEA_FeaRepresentationItem_swigregister
StepFEA_FeaRepresentationItem_swigregister(StepFEA_FeaRepresentationItem)

def StepFEA_FeaRepresentationItem_get_type_name(*args):
    """
    StepFEA_FeaRepresentationItem_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_FeaRepresentationItem_get_type_name(*args)

def StepFEA_FeaRepresentationItem_get_type_descriptor(*args):
    """
    StepFEA_FeaRepresentationItem_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_FeaRepresentationItem_get_type_descriptor(*args)

class StepFEA_FeaMaterialPropertyRepresentation(StepRepr.StepRepr_MaterialPropertyRepresentation):
    """Representation of STEP entity FeaMaterialPropertyRepresentation"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_FeaMaterialPropertyRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_FeaMaterialPropertyRepresentation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_FeaMaterialPropertyRepresentation self) -> StepFEA_FeaMaterialPropertyRepresentation

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_FeaMaterialPropertyRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_FeaMaterialPropertyRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_FeaMaterialPropertyRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_FeaMaterialPropertyRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_FeaMaterialPropertyRepresentation
StepFEA_FeaMaterialPropertyRepresentation_swigregister = _StepFEA.StepFEA_FeaMaterialPropertyRepresentation_swigregister
StepFEA_FeaMaterialPropertyRepresentation_swigregister(StepFEA_FeaMaterialPropertyRepresentation)

def StepFEA_FeaMaterialPropertyRepresentation_get_type_name(*args):
    """
    StepFEA_FeaMaterialPropertyRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_FeaMaterialPropertyRepresentation_get_type_name(*args)

def StepFEA_FeaMaterialPropertyRepresentation_get_type_descriptor(*args):
    """
    StepFEA_FeaMaterialPropertyRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_FeaMaterialPropertyRepresentation_get_type_descriptor(*args)

class StepFEA_CurveElementIntervalLinearlyVarying(StepFEA_CurveElementInterval):
    """Representation of STEP entity CurveElementIntervalLinearlyVarying"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_CurveElementIntervalLinearlyVarying
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_CurveElementIntervalLinearlyVarying(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_CurveElementIntervalLinearlyVarying self) -> StepFEA_CurveElementIntervalLinearlyVarying

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_CurveElementIntervalLinearlyVarying(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_CurveElementIntervalLinearlyVarying self, Handle_StepFEA_CurveElementLocation aCurveElementInterval_FinishPosition, Handle_StepBasic_EulerAngles aCurveElementInterval_EuAngles, Handle_StepElement_HArray1OfCurveElementSectionDefinition aSections)

        Initialize all fields (own and inherited)

        :type aCurveElementInterval_FinishPosition: OCC.wrapper.StepFEA.Handle_StepFEA_CurveElementLocation
        :type aCurveElementInterval_EuAngles: OCC.wrapper.StepBasic.Handle_StepBasic_EulerAngles
        :type aSections: OCC.wrapper.StepElement.Handle_StepElement_HArray1OfCurveElementSectionDefinition

        """
        return _StepFEA.StepFEA_CurveElementIntervalLinearlyVarying_Init(self, *args)


    def Sections(self, *args):
        """
        Sections(StepFEA_CurveElementIntervalLinearlyVarying self) -> Handle_StepElement_HArray1OfCurveElementSectionDefinition

        Returns field Sections

        :rtype: OCC.wrapper.StepElement.Handle_StepElement_HArray1OfCurveElementSectionDefinition

        """
        return _StepFEA.StepFEA_CurveElementIntervalLinearlyVarying_Sections(self, *args)


    def SetSections(self, *args):
        """
        SetSections(StepFEA_CurveElementIntervalLinearlyVarying self, Handle_StepElement_HArray1OfCurveElementSectionDefinition Sections)

        Set field Sections

        :type Sections: OCC.wrapper.StepElement.Handle_StepElement_HArray1OfCurveElementSectionDefinition

        """
        return _StepFEA.StepFEA_CurveElementIntervalLinearlyVarying_SetSections(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_CurveElementIntervalLinearlyVarying_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_CurveElementIntervalLinearlyVarying_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_CurveElementIntervalLinearlyVarying_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_CurveElementIntervalLinearlyVarying
StepFEA_CurveElementIntervalLinearlyVarying_swigregister = _StepFEA.StepFEA_CurveElementIntervalLinearlyVarying_swigregister
StepFEA_CurveElementIntervalLinearlyVarying_swigregister(StepFEA_CurveElementIntervalLinearlyVarying)

def StepFEA_CurveElementIntervalLinearlyVarying_get_type_name(*args):
    """
    StepFEA_CurveElementIntervalLinearlyVarying_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_CurveElementIntervalLinearlyVarying_get_type_name(*args)

def StepFEA_CurveElementIntervalLinearlyVarying_get_type_descriptor(*args):
    """
    StepFEA_CurveElementIntervalLinearlyVarying_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_CurveElementIntervalLinearlyVarying_get_type_descriptor(*args)

class StepFEA_ParametricSurface3dElementCoordinateSystem(StepFEA_FeaRepresentationItem):
    """Representation of STEP entity ParametricSurface3dElementCoordinateSystem"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_ParametricSurface3dElementCoordinateSystem
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_ParametricSurface3dElementCoordinateSystem(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_ParametricSurface3dElementCoordinateSystem self) -> StepFEA_ParametricSurface3dElementCoordinateSystem

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_ParametricSurface3dElementCoordinateSystem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_ParametricSurface3dElementCoordinateSystem self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Standard_Integer const aAxis, Standard_Real const aAngle)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aAxis: int
        :type aAngle: float

        """
        return _StepFEA.StepFEA_ParametricSurface3dElementCoordinateSystem_Init(self, *args)


    def Axis(self, *args):
        """
        Axis(StepFEA_ParametricSurface3dElementCoordinateSystem self) -> Standard_Integer

        Returns field Axis

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.StepFEA_ParametricSurface3dElementCoordinateSystem_Axis(self, *args)


    def SetAxis(self, *args):
        """
        SetAxis(StepFEA_ParametricSurface3dElementCoordinateSystem self, Standard_Integer const Axis)

        Set field Axis

        :type Axis: int

        """
        return _StepFEA.StepFEA_ParametricSurface3dElementCoordinateSystem_SetAxis(self, *args)


    def Angle(self, *args):
        """
        Angle(StepFEA_ParametricSurface3dElementCoordinateSystem self) -> Standard_Real

        Returns field Angle

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepFEA.StepFEA_ParametricSurface3dElementCoordinateSystem_Angle(self, *args)


    def SetAngle(self, *args):
        """
        SetAngle(StepFEA_ParametricSurface3dElementCoordinateSystem self, Standard_Real const Angle)

        Set field Angle

        :type Angle: float

        """
        return _StepFEA.StepFEA_ParametricSurface3dElementCoordinateSystem_SetAngle(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_ParametricSurface3dElementCoordinateSystem_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_ParametricSurface3dElementCoordinateSystem_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_ParametricSurface3dElementCoordinateSystem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_ParametricSurface3dElementCoordinateSystem
StepFEA_ParametricSurface3dElementCoordinateSystem_swigregister = _StepFEA.StepFEA_ParametricSurface3dElementCoordinateSystem_swigregister
StepFEA_ParametricSurface3dElementCoordinateSystem_swigregister(StepFEA_ParametricSurface3dElementCoordinateSystem)

def StepFEA_ParametricSurface3dElementCoordinateSystem_get_type_name(*args):
    """
    StepFEA_ParametricSurface3dElementCoordinateSystem_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_ParametricSurface3dElementCoordinateSystem_get_type_name(*args)

def StepFEA_ParametricSurface3dElementCoordinateSystem_get_type_descriptor(*args):
    """
    StepFEA_ParametricSurface3dElementCoordinateSystem_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_ParametricSurface3dElementCoordinateSystem_get_type_descriptor(*args)

class StepFEA_NodeSet(StepGeom.StepGeom_GeometricRepresentationItem):
    """Representation of STEP entity NodeSet"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_NodeSet
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_NodeSet(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_NodeSet self) -> StepFEA_NodeSet

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_NodeSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_NodeSet self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Handle_StepFEA_HArray1OfNodeRepresentation aNodes)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aNodes: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation

        """
        return _StepFEA.StepFEA_NodeSet_Init(self, *args)


    def Nodes(self, *args):
        """
        Nodes(StepFEA_NodeSet self) -> Handle_StepFEA_HArray1OfNodeRepresentation

        Returns field Nodes

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation

        """
        return _StepFEA.StepFEA_NodeSet_Nodes(self, *args)


    def SetNodes(self, *args):
        """
        SetNodes(StepFEA_NodeSet self, Handle_StepFEA_HArray1OfNodeRepresentation Nodes)

        Set field Nodes

        :type Nodes: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation

        """
        return _StepFEA.StepFEA_NodeSet_SetNodes(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_NodeSet_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_NodeSet_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_NodeSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_NodeSet
StepFEA_NodeSet_swigregister = _StepFEA.StepFEA_NodeSet_swigregister
StepFEA_NodeSet_swigregister(StepFEA_NodeSet)

def StepFEA_NodeSet_get_type_name(*args):
    """
    StepFEA_NodeSet_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_NodeSet_get_type_name(*args)

def StepFEA_NodeSet_get_type_descriptor(*args):
    """
    StepFEA_NodeSet_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_NodeSet_get_type_descriptor(*args)

class StepFEA_NodeGroup(StepFEA_FeaGroup):
    """Representation of STEP entity NodeGroup"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_NodeGroup
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_NodeGroup(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_NodeGroup self) -> StepFEA_NodeGroup

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_NodeGroup(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_NodeGroup self, Handle_TCollection_HAsciiString aGroup_Name, Handle_TCollection_HAsciiString aGroup_Description, Handle_StepFEA_FeaModel aFeaGroup_ModelRef, Handle_StepFEA_HArray1OfNodeRepresentation aNodes)

        Initialize all fields (own and inherited)

        :type aGroup_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aGroup_Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFeaGroup_ModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel
        :type aNodes: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation

        """
        return _StepFEA.StepFEA_NodeGroup_Init(self, *args)


    def Nodes(self, *args):
        """
        Nodes(StepFEA_NodeGroup self) -> Handle_StepFEA_HArray1OfNodeRepresentation

        Returns field Nodes

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation

        """
        return _StepFEA.StepFEA_NodeGroup_Nodes(self, *args)


    def SetNodes(self, *args):
        """
        SetNodes(StepFEA_NodeGroup self, Handle_StepFEA_HArray1OfNodeRepresentation Nodes)

        Set field Nodes

        :type Nodes: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation

        """
        return _StepFEA.StepFEA_NodeGroup_SetNodes(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_NodeGroup_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_NodeGroup_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_NodeGroup_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_NodeGroup
StepFEA_NodeGroup_swigregister = _StepFEA.StepFEA_NodeGroup_swigregister
StepFEA_NodeGroup_swigregister(StepFEA_NodeGroup)

def StepFEA_NodeGroup_get_type_name(*args):
    """
    StepFEA_NodeGroup_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_NodeGroup_get_type_name(*args)

def StepFEA_NodeGroup_get_type_descriptor(*args):
    """
    StepFEA_NodeGroup_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_NodeGroup_get_type_descriptor(*args)

class StepFEA_ElementGroup(StepFEA_FeaGroup):
    """Representation of STEP entity ElementGroup"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_ElementGroup
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_ElementGroup(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_ElementGroup self) -> StepFEA_ElementGroup

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_ElementGroup(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_ElementGroup self, Handle_TCollection_HAsciiString aGroup_Name, Handle_TCollection_HAsciiString aGroup_Description, Handle_StepFEA_FeaModel aFeaGroup_ModelRef, Handle_StepFEA_HArray1OfElementRepresentation aElements)

        Initialize all fields (own and inherited)

        :type aGroup_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aGroup_Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFeaGroup_ModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel
        :type aElements: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfElementRepresentation

        """
        return _StepFEA.StepFEA_ElementGroup_Init(self, *args)


    def Elements(self, *args):
        """
        Elements(StepFEA_ElementGroup self) -> Handle_StepFEA_HArray1OfElementRepresentation

        Returns field Elements

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfElementRepresentation

        """
        return _StepFEA.StepFEA_ElementGroup_Elements(self, *args)


    def SetElements(self, *args):
        """
        SetElements(StepFEA_ElementGroup self, Handle_StepFEA_HArray1OfElementRepresentation Elements)

        Set field Elements

        :type Elements: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfElementRepresentation

        """
        return _StepFEA.StepFEA_ElementGroup_SetElements(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_ElementGroup_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_ElementGroup_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_ElementGroup_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_ElementGroup
StepFEA_ElementGroup_swigregister = _StepFEA.StepFEA_ElementGroup_swigregister
StepFEA_ElementGroup_swigregister(StepFEA_ElementGroup)

def StepFEA_ElementGroup_get_type_name(*args):
    """
    StepFEA_ElementGroup_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_ElementGroup_get_type_name(*args)

def StepFEA_ElementGroup_get_type_descriptor(*args):
    """
    StepFEA_ElementGroup_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_ElementGroup_get_type_descriptor(*args)

class StepFEA_HSequenceOfCurve3dElementProperty(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_HSequenceOfCurve3dElementProperty
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_HSequenceOfCurve3dElementProperty(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_HSequenceOfCurve3dElementProperty self) -> StepFEA_HSequenceOfCurve3dElementProperty
        __init__(StepFEA_HSequenceOfCurve3dElementProperty self, NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty theOther) -> StepFEA_HSequenceOfCurve3dElementProperty

        :type theOther: OCC.wrapper.StepFEA.StepFEA_SequenceOfCurve3dElementProperty

        """
        this = _StepFEA.new_StepFEA_HSequenceOfCurve3dElementProperty(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.StepFEA.StepFEA_SequenceOfCurve3dElementProperty

        """
        res = _StepFEA.StepFEA_HSequenceOfCurve3dElementProperty_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(StepFEA_HSequenceOfCurve3dElementProperty self, Handle_StepFEA_Curve3dElementProperty theItem)
        Append(StepFEA_HSequenceOfCurve3dElementProperty self, NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty theSequence)

        :type theSequence: OCC.wrapper.StepFEA.StepFEA_SequenceOfCurve3dElementProperty

        """
        return _StepFEA.StepFEA_HSequenceOfCurve3dElementProperty_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(StepFEA_HSequenceOfCurve3dElementProperty self) -> NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty

        :rtype: OCC.wrapper.StepFEA.StepFEA_SequenceOfCurve3dElementProperty

        """
        return _StepFEA.StepFEA_HSequenceOfCurve3dElementProperty_ChangeSequence(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_HSequenceOfCurve3dElementProperty_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_HSequenceOfCurve3dElementProperty_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_HSequenceOfCurve3dElementProperty_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_HSequenceOfCurve3dElementProperty
StepFEA_HSequenceOfCurve3dElementProperty_swigregister = _StepFEA.StepFEA_HSequenceOfCurve3dElementProperty_swigregister
StepFEA_HSequenceOfCurve3dElementProperty_swigregister(StepFEA_HSequenceOfCurve3dElementProperty)

def StepFEA_HSequenceOfCurve3dElementProperty_get_type_name(*args):
    """
    StepFEA_HSequenceOfCurve3dElementProperty_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_HSequenceOfCurve3dElementProperty_get_type_name(*args)

def StepFEA_HSequenceOfCurve3dElementProperty_get_type_descriptor(*args):
    """
    StepFEA_HSequenceOfCurve3dElementProperty_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_HSequenceOfCurve3dElementProperty_get_type_descriptor(*args)

class StepFEA_CurveElementLocation(Standard.Standard_Transient):
    """Representation of STEP entity CurveElementLocation"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_CurveElementLocation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_CurveElementLocation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_CurveElementLocation self) -> StepFEA_CurveElementLocation

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_CurveElementLocation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_CurveElementLocation self, Handle_StepFEA_FeaParametricPoint aCoordinate)

        Initialize all fields (own and inherited)

        :type aCoordinate: OCC.wrapper.StepFEA.Handle_StepFEA_FeaParametricPoint

        """
        return _StepFEA.StepFEA_CurveElementLocation_Init(self, *args)


    def Coordinate(self, *args):
        """
        Coordinate(StepFEA_CurveElementLocation self) -> Handle_StepFEA_FeaParametricPoint

        Returns field Coordinate

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_FeaParametricPoint

        """
        return _StepFEA.StepFEA_CurveElementLocation_Coordinate(self, *args)


    def SetCoordinate(self, *args):
        """
        SetCoordinate(StepFEA_CurveElementLocation self, Handle_StepFEA_FeaParametricPoint Coordinate)

        Set field Coordinate

        :type Coordinate: OCC.wrapper.StepFEA.Handle_StepFEA_FeaParametricPoint

        """
        return _StepFEA.StepFEA_CurveElementLocation_SetCoordinate(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_CurveElementLocation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_CurveElementLocation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_CurveElementLocation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_CurveElementLocation
StepFEA_CurveElementLocation_swigregister = _StepFEA.StepFEA_CurveElementLocation_swigregister
StepFEA_CurveElementLocation_swigregister(StepFEA_CurveElementLocation)

def StepFEA_CurveElementLocation_get_type_name(*args):
    """
    StepFEA_CurveElementLocation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_CurveElementLocation_get_type_name(*args)

def StepFEA_CurveElementLocation_get_type_descriptor(*args):
    """
    StepFEA_CurveElementLocation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_CurveElementLocation_get_type_descriptor(*args)

class StepFEA_HArray1OfDegreeOfFreedom(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_HArray1OfDegreeOfFreedom
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_HArray1OfDegreeOfFreedom(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_HArray1OfDegreeOfFreedom self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepFEA_HArray1OfDegreeOfFreedom
        __init__(StepFEA_HArray1OfDegreeOfFreedom self, Standard_Integer const theLower, Standard_Integer const theUpper, StepFEA_DegreeOfFreedom theValue) -> StepFEA_HArray1OfDegreeOfFreedom
        __init__(StepFEA_HArray1OfDegreeOfFreedom self, NCollection_Array1_StepFEA_DegreeOfFreedom theOther) -> StepFEA_HArray1OfDegreeOfFreedom

        :type theOther: OCC.wrapper.StepFEA.StepFEA_Array1OfDegreeOfFreedom

        """
        this = _StepFEA.new_StepFEA_HArray1OfDegreeOfFreedom(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepFEA.StepFEA_Array1OfDegreeOfFreedom

        """
        res = _StepFEA.StepFEA_HArray1OfDegreeOfFreedom_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepFEA_HArray1OfDegreeOfFreedom self) -> NCollection_Array1_StepFEA_DegreeOfFreedom

        :rtype: OCC.wrapper.StepFEA.StepFEA_Array1OfDegreeOfFreedom

        """
        return _StepFEA.StepFEA_HArray1OfDegreeOfFreedom_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_HArray1OfDegreeOfFreedom_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_HArray1OfDegreeOfFreedom_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_HArray1OfDegreeOfFreedom_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_HArray1OfDegreeOfFreedom
StepFEA_HArray1OfDegreeOfFreedom_swigregister = _StepFEA.StepFEA_HArray1OfDegreeOfFreedom_swigregister
StepFEA_HArray1OfDegreeOfFreedom_swigregister(StepFEA_HArray1OfDegreeOfFreedom)

def StepFEA_HArray1OfDegreeOfFreedom_get_type_name(*args):
    """
    StepFEA_HArray1OfDegreeOfFreedom_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_HArray1OfDegreeOfFreedom_get_type_name(*args)

def StepFEA_HArray1OfDegreeOfFreedom_get_type_descriptor(*args):
    """
    StepFEA_HArray1OfDegreeOfFreedom_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_HArray1OfDegreeOfFreedom_get_type_descriptor(*args)

class Handle_StepFEA_FeaAxis2Placement3d(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_FeaAxis2Placement3d self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_FeaAxis2Placement3d self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_FeaAxis2Placement3d self, StepFEA_FeaAxis2Placement3d thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_FeaAxis2Placement3d self, Handle_StepFEA_FeaAxis2Placement3d theHandle) -> Handle_StepFEA_FeaAxis2Placement3d
        assign(Handle_StepFEA_FeaAxis2Placement3d self, StepFEA_FeaAxis2Placement3d thePtr) -> Handle_StepFEA_FeaAxis2Placement3d
        assign(Handle_StepFEA_FeaAxis2Placement3d self, Handle_StepFEA_FeaAxis2Placement3d theHandle) -> Handle_StepFEA_FeaAxis2Placement3d

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_FeaAxis2Placement3d self) -> StepFEA_FeaAxis2Placement3d

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_FeaAxis2Placement3d self) -> StepFEA_FeaAxis2Placement3d

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_FeaAxis2Placement3d self) -> StepFEA_FeaAxis2Placement3d

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_FeaAxis2Placement3d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_FeaAxis2Placement3d_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_FeaAxis2Placement3d

    def Init(self, *args):
        """
        Init(Handle_StepFEA_FeaAxis2Placement3d self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Handle_StepGeom_CartesianPoint aPlacement_Location, Standard_Boolean const hasAxis2Placement3d_Axis, Handle_StepGeom_Direction aAxis2Placement3d_Axis, Standard_Boolean const hasAxis2Placement3d_RefDirection, Handle_StepGeom_Direction aAxis2Placement3d_RefDirection, StepFEA_CoordinateSystemType const aSystemType, Handle_TCollection_HAsciiString aDescription)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aPlacement_Location: OCC.wrapper.StepFEA.Handle_StepGeom_CartesianPoint
        :type hasAxis2Placement3d_Axis: bool
        :type aAxis2Placement3d_Axis: OCC.wrapper.StepFEA.Handle_StepGeom_Direction
        :type hasAxis2Placement3d_RefDirection: bool
        :type aAxis2Placement3d_RefDirection: OCC.wrapper.StepFEA.Handle_StepGeom_Direction
        :type aSystemType: OCC.wrapper.StepFEA.StepFEA_CoordinateSystemType
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_Init(self, *args)


    def SystemType(self, *args):
        """
        SystemType(Handle_StepFEA_FeaAxis2Placement3d self) -> StepFEA_CoordinateSystemType

        Returns field SystemType

        :rtype: OCC.wrapper.StepFEA.StepFEA_CoordinateSystemType

        """
        return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_SystemType(self, *args)


    def SetSystemType(self, *args):
        """
        SetSystemType(Handle_StepFEA_FeaAxis2Placement3d self, StepFEA_CoordinateSystemType const SystemType)

        Set field SystemType

        :type SystemType: OCC.wrapper.StepFEA.StepFEA_CoordinateSystemType

        """
        return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_SetSystemType(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepFEA_FeaAxis2Placement3d self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepFEA_FeaAxis2Placement3d self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_SetDescription(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_FeaAxis2Placement3d self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetAxis(self, *args):
        """
        SetAxis(Handle_StepFEA_FeaAxis2Placement3d self, Handle_StepGeom_Direction aAxis)

        :type aAxis: OCC.wrapper.StepGeom.Handle_StepGeom_Direction

        """
        return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_SetAxis(self, *args)


    def UnSetAxis(self, *args):
        """UnSetAxis(Handle_StepFEA_FeaAxis2Placement3d self)"""
        return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_UnSetAxis(self, *args)


    def Axis(self, *args):
        """
        Axis(Handle_StepFEA_FeaAxis2Placement3d self) -> Handle_StepGeom_Direction

        :rtype: OCC.wrapper.StepGeom.Handle_StepGeom_Direction

        """
        return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_Axis(self, *args)


    def HasAxis(self, *args):
        """
        HasAxis(Handle_StepFEA_FeaAxis2Placement3d self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_HasAxis(self, *args)


    def SetRefDirection(self, *args):
        """
        SetRefDirection(Handle_StepFEA_FeaAxis2Placement3d self, Handle_StepGeom_Direction aRefDirection)

        :type aRefDirection: OCC.wrapper.StepGeom.Handle_StepGeom_Direction

        """
        return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_SetRefDirection(self, *args)


    def UnSetRefDirection(self, *args):
        """UnSetRefDirection(Handle_StepFEA_FeaAxis2Placement3d self)"""
        return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_UnSetRefDirection(self, *args)


    def RefDirection(self, *args):
        """
        RefDirection(Handle_StepFEA_FeaAxis2Placement3d self) -> Handle_StepGeom_Direction

        :rtype: OCC.wrapper.StepGeom.Handle_StepGeom_Direction

        """
        return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_RefDirection(self, *args)


    def HasRefDirection(self, *args):
        """
        HasRefDirection(Handle_StepFEA_FeaAxis2Placement3d self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_HasRefDirection(self, *args)


    def SetLocation(self, *args):
        """
        SetLocation(Handle_StepFEA_FeaAxis2Placement3d self, Handle_StepGeom_CartesianPoint aLocation)

        :type aLocation: OCC.wrapper.StepGeom.Handle_StepGeom_CartesianPoint

        """
        return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_SetLocation(self, *args)


    def Location(self, *args):
        """
        Location(Handle_StepFEA_FeaAxis2Placement3d self) -> Handle_StepGeom_CartesianPoint

        :rtype: OCC.wrapper.StepGeom.Handle_StepGeom_CartesianPoint

        """
        return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_Location(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_FeaAxis2Placement3d self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_FeaAxis2Placement3d self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_FeaAxis2Placement3d self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_FeaAxis2Placement3d self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_FeaAxis2Placement3d self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_FeaAxis2Placement3d self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_FeaAxis2Placement3d self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_FeaAxis2Placement3d self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_FeaAxis2Placement3d self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_FeaAxis2Placement3d self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_FeaAxis2Placement3d self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_DecrementRefCounter(self, *args)

Handle_StepFEA_FeaAxis2Placement3d_swigregister = _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_swigregister
Handle_StepFEA_FeaAxis2Placement3d_swigregister(Handle_StepFEA_FeaAxis2Placement3d)

def Handle_StepFEA_FeaAxis2Placement3d_DownCast(thing):
    return _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_DownCast(thing)
Handle_StepFEA_FeaAxis2Placement3d_DownCast = _StepFEA.Handle_StepFEA_FeaAxis2Placement3d_DownCast

class StepFEA_FeaAreaDensity(StepFEA_FeaMaterialPropertyRepresentationItem):
    """Representation of STEP entity FeaAreaDensity"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_FeaAreaDensity
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_FeaAreaDensity(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_FeaAreaDensity self) -> StepFEA_FeaAreaDensity

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_FeaAreaDensity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_FeaAreaDensity self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Standard_Real const aFeaConstant)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFeaConstant: float

        """
        return _StepFEA.StepFEA_FeaAreaDensity_Init(self, *args)


    def FeaConstant(self, *args):
        """
        FeaConstant(StepFEA_FeaAreaDensity self) -> Standard_Real

        Returns field FeaConstant

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepFEA.StepFEA_FeaAreaDensity_FeaConstant(self, *args)


    def SetFeaConstant(self, *args):
        """
        SetFeaConstant(StepFEA_FeaAreaDensity self, Standard_Real const FeaConstant)

        Set field FeaConstant

        :type FeaConstant: float

        """
        return _StepFEA.StepFEA_FeaAreaDensity_SetFeaConstant(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_FeaAreaDensity_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_FeaAreaDensity_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_FeaAreaDensity_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_FeaAreaDensity
StepFEA_FeaAreaDensity_swigregister = _StepFEA.StepFEA_FeaAreaDensity_swigregister
StepFEA_FeaAreaDensity_swigregister(StepFEA_FeaAreaDensity)

def StepFEA_FeaAreaDensity_get_type_name(*args):
    """
    StepFEA_FeaAreaDensity_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_FeaAreaDensity_get_type_name(*args)

def StepFEA_FeaAreaDensity_get_type_descriptor(*args):
    """
    StepFEA_FeaAreaDensity_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_FeaAreaDensity_get_type_descriptor(*args)

class StepFEA_ParametricCurve3dElementCoordinateDirection(StepFEA_FeaRepresentationItem):
    """Representation of STEP entity ParametricCurve3dElementCoordinateDirection"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_ParametricCurve3dElementCoordinateDirection
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_ParametricCurve3dElementCoordinateDirection(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_ParametricCurve3dElementCoordinateDirection self) -> StepFEA_ParametricCurve3dElementCoordinateDirection

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_ParametricCurve3dElementCoordinateDirection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_ParametricCurve3dElementCoordinateDirection self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Handle_StepGeom_Direction aOrientation)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aOrientation: OCC.wrapper.StepFEA.Handle_StepGeom_Direction

        """
        return _StepFEA.StepFEA_ParametricCurve3dElementCoordinateDirection_Init(self, *args)


    def Orientation(self, *args):
        """
        Orientation(StepFEA_ParametricCurve3dElementCoordinateDirection self) -> Handle_StepGeom_Direction

        Returns field Orientation

        :rtype: OCC.wrapper.StepFEA.Handle_StepGeom_Direction

        """
        return _StepFEA.StepFEA_ParametricCurve3dElementCoordinateDirection_Orientation(self, *args)


    def SetOrientation(self, *args):
        """
        SetOrientation(StepFEA_ParametricCurve3dElementCoordinateDirection self, Handle_StepGeom_Direction Orientation)

        Set field Orientation

        :type Orientation: OCC.wrapper.StepFEA.Handle_StepGeom_Direction

        """
        return _StepFEA.StepFEA_ParametricCurve3dElementCoordinateDirection_SetOrientation(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_ParametricCurve3dElementCoordinateDirection_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_ParametricCurve3dElementCoordinateDirection_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_ParametricCurve3dElementCoordinateDirection_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_ParametricCurve3dElementCoordinateDirection
StepFEA_ParametricCurve3dElementCoordinateDirection_swigregister = _StepFEA.StepFEA_ParametricCurve3dElementCoordinateDirection_swigregister
StepFEA_ParametricCurve3dElementCoordinateDirection_swigregister(StepFEA_ParametricCurve3dElementCoordinateDirection)

def StepFEA_ParametricCurve3dElementCoordinateDirection_get_type_name(*args):
    """
    StepFEA_ParametricCurve3dElementCoordinateDirection_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_ParametricCurve3dElementCoordinateDirection_get_type_name(*args)

def StepFEA_ParametricCurve3dElementCoordinateDirection_get_type_descriptor(*args):
    """
    StepFEA_ParametricCurve3dElementCoordinateDirection_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_ParametricCurve3dElementCoordinateDirection_get_type_descriptor(*args)

class Handle_StepFEA_NodeDefinition(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_NodeDefinition self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_NodeDefinition_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_NodeDefinition self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_NodeDefinition_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_NodeDefinition self, StepFEA_NodeDefinition thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_NodeDefinition_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_NodeDefinition self, Handle_StepFEA_NodeDefinition theHandle) -> Handle_StepFEA_NodeDefinition
        assign(Handle_StepFEA_NodeDefinition self, StepFEA_NodeDefinition thePtr) -> Handle_StepFEA_NodeDefinition
        assign(Handle_StepFEA_NodeDefinition self, Handle_StepFEA_NodeDefinition theHandle) -> Handle_StepFEA_NodeDefinition

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_NodeDefinition_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_NodeDefinition self) -> StepFEA_NodeDefinition

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_NodeDefinition_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_NodeDefinition self) -> StepFEA_NodeDefinition

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_NodeDefinition___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_NodeDefinition self) -> StepFEA_NodeDefinition

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_NodeDefinition___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_NodeDefinition___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_NodeDefinition___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_NodeDefinition(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_NodeDefinition_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_NodeDefinition

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_NodeDefinition self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_NodeDefinition_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_NodeDefinition_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_NodeDefinition_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepFEA_NodeDefinition self, Handle_TCollection_HAsciiString aName, Handle_TCollection_HAsciiString aDescription, Handle_StepRepr_ProductDefinitionShape aOfShape, StepData_Logical const aProductDefinitional)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aOfShape: OCC.wrapper.StepRepr.Handle_StepRepr_ProductDefinitionShape
        :type aProductDefinitional: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepFEA.Handle_StepFEA_NodeDefinition_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_NodeDefinition self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_NodeDefinition_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_NodeDefinition self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_NodeDefinition_Name(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepFEA_NodeDefinition self, Handle_TCollection_HAsciiString aDescription)

        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_NodeDefinition_SetDescription(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepFEA_NodeDefinition self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_NodeDefinition_Description(self, *args)


    def SetOfShape(self, *args):
        """
        SetOfShape(Handle_StepFEA_NodeDefinition self, Handle_StepRepr_ProductDefinitionShape aOfShape)

        :type aOfShape: OCC.wrapper.StepRepr.Handle_StepRepr_ProductDefinitionShape

        """
        return _StepFEA.Handle_StepFEA_NodeDefinition_SetOfShape(self, *args)


    def OfShape(self, *args):
        """
        OfShape(Handle_StepFEA_NodeDefinition self) -> Handle_StepRepr_ProductDefinitionShape

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_ProductDefinitionShape

        """
        return _StepFEA.Handle_StepFEA_NodeDefinition_OfShape(self, *args)


    def SetProductDefinitional(self, *args):
        """
        SetProductDefinitional(Handle_StepFEA_NodeDefinition self, StepData_Logical const aProductDefinitional)

        :type aProductDefinitional: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepFEA.Handle_StepFEA_NodeDefinition_SetProductDefinitional(self, *args)


    def ProductDefinitional(self, *args):
        """
        ProductDefinitional(Handle_StepFEA_NodeDefinition self) -> StepData_Logical

        :rtype: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepFEA.Handle_StepFEA_NodeDefinition_ProductDefinitional(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_NodeDefinition self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_NodeDefinition_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_NodeDefinition self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_NodeDefinition self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_NodeDefinition_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_NodeDefinition self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_NodeDefinition self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_NodeDefinition_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_NodeDefinition self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_NodeDefinition_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_NodeDefinition self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_NodeDefinition_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_NodeDefinition self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_NodeDefinition_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_NodeDefinition self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_NodeDefinition_DecrementRefCounter(self, *args)

Handle_StepFEA_NodeDefinition_swigregister = _StepFEA.Handle_StepFEA_NodeDefinition_swigregister
Handle_StepFEA_NodeDefinition_swigregister(Handle_StepFEA_NodeDefinition)

def Handle_StepFEA_NodeDefinition_DownCast(thing):
    return _StepFEA.Handle_StepFEA_NodeDefinition_DownCast(thing)
Handle_StepFEA_NodeDefinition_DownCast = _StepFEA.Handle_StepFEA_NodeDefinition_DownCast

class Handle_StepFEA_FeaModel3d(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_FeaModel3d self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_FeaModel3d_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_FeaModel3d self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_FeaModel3d_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_FeaModel3d self, StepFEA_FeaModel3d thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_FeaModel3d_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_FeaModel3d self, Handle_StepFEA_FeaModel3d theHandle) -> Handle_StepFEA_FeaModel3d
        assign(Handle_StepFEA_FeaModel3d self, StepFEA_FeaModel3d thePtr) -> Handle_StepFEA_FeaModel3d
        assign(Handle_StepFEA_FeaModel3d self, Handle_StepFEA_FeaModel3d theHandle) -> Handle_StepFEA_FeaModel3d

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_FeaModel3d_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_FeaModel3d self) -> StepFEA_FeaModel3d

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaModel3d_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_FeaModel3d self) -> StepFEA_FeaModel3d

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaModel3d___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_FeaModel3d self) -> StepFEA_FeaModel3d

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_FeaModel3d___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_FeaModel3d___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_FeaModel3d___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_FeaModel3d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_FeaModel3d_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_FeaModel3d

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_FeaModel3d self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_FeaModel3d_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaModel3d_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaModel3d_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepFEA_FeaModel3d self, Handle_TCollection_HAsciiString aRepresentation_Name, Handle_StepRepr_HArray1OfRepresentationItem aRepresentation_Items, Handle_StepRepr_RepresentationContext aRepresentation_ContextOfItems, Handle_TCollection_HAsciiString aCreatingSoftware, Handle_TColStd_HArray1OfAsciiString aIntendedAnalysisCode, Handle_TCollection_HAsciiString aDescription, Handle_TCollection_HAsciiString aAnalysisType)

        Initialize all fields (own and inherited)

        :type aRepresentation_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRepresentation_Items: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aRepresentation_ContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext
        :type aCreatingSoftware: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aIntendedAnalysisCode: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfAsciiString
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aAnalysisType: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaModel3d_Init(self, *args)


    def CreatingSoftware(self, *args):
        """
        CreatingSoftware(Handle_StepFEA_FeaModel3d self) -> Handle_TCollection_HAsciiString

        Returns field CreatingSoftware

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaModel3d_CreatingSoftware(self, *args)


    def SetCreatingSoftware(self, *args):
        """
        SetCreatingSoftware(Handle_StepFEA_FeaModel3d self, Handle_TCollection_HAsciiString CreatingSoftware)

        Set field CreatingSoftware

        :type CreatingSoftware: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaModel3d_SetCreatingSoftware(self, *args)


    def IntendedAnalysisCode(self, *args):
        """
        IntendedAnalysisCode(Handle_StepFEA_FeaModel3d self) -> Handle_TColStd_HArray1OfAsciiString

        Returns field IntendedAnalysisCode

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaModel3d_IntendedAnalysisCode(self, *args)


    def SetIntendedAnalysisCode(self, *args):
        """
        SetIntendedAnalysisCode(Handle_StepFEA_FeaModel3d self, Handle_TColStd_HArray1OfAsciiString IntendedAnalysisCode)

        Set field IntendedAnalysisCode

        :type IntendedAnalysisCode: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaModel3d_SetIntendedAnalysisCode(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepFEA_FeaModel3d self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaModel3d_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepFEA_FeaModel3d self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaModel3d_SetDescription(self, *args)


    def AnalysisType(self, *args):
        """
        AnalysisType(Handle_StepFEA_FeaModel3d self) -> Handle_TCollection_HAsciiString

        Returns field AnalysisType

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaModel3d_AnalysisType(self, *args)


    def SetAnalysisType(self, *args):
        """
        SetAnalysisType(Handle_StepFEA_FeaModel3d self, Handle_TCollection_HAsciiString AnalysisType)

        Set field AnalysisType

        :type AnalysisType: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaModel3d_SetAnalysisType(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_FeaModel3d self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaModel3d_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_FeaModel3d self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaModel3d_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepFEA_FeaModel3d self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepFEA.Handle_StepFEA_FeaModel3d_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepFEA_FeaModel3d self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepFEA.Handle_StepFEA_FeaModel3d_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepFEA_FeaModel3d self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepFEA.Handle_StepFEA_FeaModel3d_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepFEA_FeaModel3d self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaModel3d_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepFEA_FeaModel3d self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepFEA.Handle_StepFEA_FeaModel3d_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepFEA_FeaModel3d self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepFEA.Handle_StepFEA_FeaModel3d_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_FeaModel3d self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_FeaModel3d_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_FeaModel3d self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_FeaModel3d self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaModel3d_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_FeaModel3d self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_FeaModel3d self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaModel3d_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_FeaModel3d self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_FeaModel3d_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_FeaModel3d self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaModel3d_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_FeaModel3d self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_FeaModel3d_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_FeaModel3d self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaModel3d_DecrementRefCounter(self, *args)

Handle_StepFEA_FeaModel3d_swigregister = _StepFEA.Handle_StepFEA_FeaModel3d_swigregister
Handle_StepFEA_FeaModel3d_swigregister(Handle_StepFEA_FeaModel3d)

def Handle_StepFEA_FeaModel3d_DownCast(thing):
    return _StepFEA.Handle_StepFEA_FeaModel3d_DownCast(thing)
Handle_StepFEA_FeaModel3d_DownCast = _StepFEA.Handle_StepFEA_FeaModel3d_DownCast

class Handle_StepFEA_NodeWithVector(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_NodeWithVector self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_NodeWithVector_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_NodeWithVector self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_NodeWithVector_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_NodeWithVector self, StepFEA_NodeWithVector thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_NodeWithVector_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_NodeWithVector self, Handle_StepFEA_NodeWithVector theHandle) -> Handle_StepFEA_NodeWithVector
        assign(Handle_StepFEA_NodeWithVector self, StepFEA_NodeWithVector thePtr) -> Handle_StepFEA_NodeWithVector
        assign(Handle_StepFEA_NodeWithVector self, Handle_StepFEA_NodeWithVector theHandle) -> Handle_StepFEA_NodeWithVector

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_NodeWithVector_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_NodeWithVector self) -> StepFEA_NodeWithVector

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_NodeWithVector_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_NodeWithVector self) -> StepFEA_NodeWithVector

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_NodeWithVector___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_NodeWithVector self) -> StepFEA_NodeWithVector

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_NodeWithVector___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_NodeWithVector___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_NodeWithVector___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_NodeWithVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_NodeWithVector_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_NodeWithVector

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_NodeWithVector self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_NodeWithVector_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_NodeWithVector_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_NodeWithVector_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepFEA_NodeWithVector self, Handle_TCollection_HAsciiString aRepresentation_Name, Handle_StepRepr_HArray1OfRepresentationItem aRepresentation_Items, Handle_StepRepr_RepresentationContext aRepresentation_ContextOfItems, Handle_StepFEA_FeaModel aModelRef)

        Initialize all fields (own and inherited)

        :type aRepresentation_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRepresentation_Items: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aRepresentation_ContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext
        :type aModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel

        """
        return _StepFEA.Handle_StepFEA_NodeWithVector_Init(self, *args)


    def ModelRef(self, *args):
        """
        ModelRef(Handle_StepFEA_NodeWithVector self) -> Handle_StepFEA_FeaModel

        Returns field ModelRef

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel

        """
        return _StepFEA.Handle_StepFEA_NodeWithVector_ModelRef(self, *args)


    def SetModelRef(self, *args):
        """
        SetModelRef(Handle_StepFEA_NodeWithVector self, Handle_StepFEA_FeaModel ModelRef)

        Set field ModelRef

        :type ModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel

        """
        return _StepFEA.Handle_StepFEA_NodeWithVector_SetModelRef(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_NodeWithVector self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_NodeWithVector_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_NodeWithVector self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_NodeWithVector_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepFEA_NodeWithVector self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepFEA.Handle_StepFEA_NodeWithVector_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepFEA_NodeWithVector self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepFEA.Handle_StepFEA_NodeWithVector_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepFEA_NodeWithVector self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepFEA.Handle_StepFEA_NodeWithVector_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepFEA_NodeWithVector self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_NodeWithVector_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepFEA_NodeWithVector self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepFEA.Handle_StepFEA_NodeWithVector_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepFEA_NodeWithVector self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepFEA.Handle_StepFEA_NodeWithVector_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_NodeWithVector self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_NodeWithVector_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_NodeWithVector self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_NodeWithVector self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_NodeWithVector_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_NodeWithVector self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_NodeWithVector self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_NodeWithVector_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_NodeWithVector self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_NodeWithVector_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_NodeWithVector self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_NodeWithVector_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_NodeWithVector self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_NodeWithVector_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_NodeWithVector self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_NodeWithVector_DecrementRefCounter(self, *args)

Handle_StepFEA_NodeWithVector_swigregister = _StepFEA.Handle_StepFEA_NodeWithVector_swigregister
Handle_StepFEA_NodeWithVector_swigregister(Handle_StepFEA_NodeWithVector)

def Handle_StepFEA_NodeWithVector_DownCast(thing):
    return _StepFEA.Handle_StepFEA_NodeWithVector_DownCast(thing)
Handle_StepFEA_NodeWithVector_DownCast = _StepFEA.Handle_StepFEA_NodeWithVector_DownCast

class Handle_StepFEA_FeaShellShearStiffness(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_FeaShellShearStiffness self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_FeaShellShearStiffness_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_FeaShellShearStiffness self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_FeaShellShearStiffness_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_FeaShellShearStiffness self, StepFEA_FeaShellShearStiffness thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_FeaShellShearStiffness_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_FeaShellShearStiffness self, Handle_StepFEA_FeaShellShearStiffness theHandle) -> Handle_StepFEA_FeaShellShearStiffness
        assign(Handle_StepFEA_FeaShellShearStiffness self, StepFEA_FeaShellShearStiffness thePtr) -> Handle_StepFEA_FeaShellShearStiffness
        assign(Handle_StepFEA_FeaShellShearStiffness self, Handle_StepFEA_FeaShellShearStiffness theHandle) -> Handle_StepFEA_FeaShellShearStiffness

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_FeaShellShearStiffness_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_FeaShellShearStiffness self) -> StepFEA_FeaShellShearStiffness

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaShellShearStiffness_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_FeaShellShearStiffness self) -> StepFEA_FeaShellShearStiffness

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaShellShearStiffness___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_FeaShellShearStiffness self) -> StepFEA_FeaShellShearStiffness

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_FeaShellShearStiffness___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_FeaShellShearStiffness___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_FeaShellShearStiffness___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_FeaShellShearStiffness(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_FeaShellShearStiffness_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_FeaShellShearStiffness

    def Init(self, *args):
        """
        Init(Handle_StepFEA_FeaShellShearStiffness self, Handle_TCollection_HAsciiString aRepresentationItem_Name, StepFEA_SymmetricTensor22d aFeaConstants)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFeaConstants: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor22d

        """
        return _StepFEA.Handle_StepFEA_FeaShellShearStiffness_Init(self, *args)


    def FeaConstants(self, *args):
        """
        FeaConstants(Handle_StepFEA_FeaShellShearStiffness self) -> StepFEA_SymmetricTensor22d

        Returns field FeaConstants

        :rtype: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor22d

        """
        return _StepFEA.Handle_StepFEA_FeaShellShearStiffness_FeaConstants(self, *args)


    def SetFeaConstants(self, *args):
        """
        SetFeaConstants(Handle_StepFEA_FeaShellShearStiffness self, StepFEA_SymmetricTensor22d FeaConstants)

        Set field FeaConstants

        :type FeaConstants: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor22d

        """
        return _StepFEA.Handle_StepFEA_FeaShellShearStiffness_SetFeaConstants(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_FeaShellShearStiffness self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_FeaShellShearStiffness_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaShellShearStiffness_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaShellShearStiffness_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_FeaShellShearStiffness self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaShellShearStiffness_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_FeaShellShearStiffness self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaShellShearStiffness_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_FeaShellShearStiffness self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_FeaShellShearStiffness_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_FeaShellShearStiffness self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_FeaShellShearStiffness self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaShellShearStiffness_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_FeaShellShearStiffness self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_FeaShellShearStiffness self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaShellShearStiffness_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_FeaShellShearStiffness self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_FeaShellShearStiffness_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_FeaShellShearStiffness self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaShellShearStiffness_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_FeaShellShearStiffness self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_FeaShellShearStiffness_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_FeaShellShearStiffness self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaShellShearStiffness_DecrementRefCounter(self, *args)

Handle_StepFEA_FeaShellShearStiffness_swigregister = _StepFEA.Handle_StepFEA_FeaShellShearStiffness_swigregister
Handle_StepFEA_FeaShellShearStiffness_swigregister(Handle_StepFEA_FeaShellShearStiffness)

def Handle_StepFEA_FeaShellShearStiffness_DownCast(thing):
    return _StepFEA.Handle_StepFEA_FeaShellShearStiffness_DownCast(thing)
Handle_StepFEA_FeaShellShearStiffness_DownCast = _StepFEA.Handle_StepFEA_FeaShellShearStiffness_DownCast

class StepFEA_FeaShellBendingStiffness(StepFEA_FeaMaterialPropertyRepresentationItem):
    """Representation of STEP entity FeaShellBendingStiffness"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_FeaShellBendingStiffness
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_FeaShellBendingStiffness(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_FeaShellBendingStiffness self) -> StepFEA_FeaShellBendingStiffness

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_FeaShellBendingStiffness(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_FeaShellBendingStiffness self, Handle_TCollection_HAsciiString aRepresentationItem_Name, StepFEA_SymmetricTensor42d aFeaConstants)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFeaConstants: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor42d

        """
        return _StepFEA.StepFEA_FeaShellBendingStiffness_Init(self, *args)


    def FeaConstants(self, *args):
        """
        FeaConstants(StepFEA_FeaShellBendingStiffness self) -> StepFEA_SymmetricTensor42d

        Returns field FeaConstants

        :rtype: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor42d

        """
        return _StepFEA.StepFEA_FeaShellBendingStiffness_FeaConstants(self, *args)


    def SetFeaConstants(self, *args):
        """
        SetFeaConstants(StepFEA_FeaShellBendingStiffness self, StepFEA_SymmetricTensor42d FeaConstants)

        Set field FeaConstants

        :type FeaConstants: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor42d

        """
        return _StepFEA.StepFEA_FeaShellBendingStiffness_SetFeaConstants(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_FeaShellBendingStiffness_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_FeaShellBendingStiffness_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_FeaShellBendingStiffness_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_FeaShellBendingStiffness
StepFEA_FeaShellBendingStiffness_swigregister = _StepFEA.StepFEA_FeaShellBendingStiffness_swigregister
StepFEA_FeaShellBendingStiffness_swigregister(StepFEA_FeaShellBendingStiffness)

def StepFEA_FeaShellBendingStiffness_get_type_name(*args):
    """
    StepFEA_FeaShellBendingStiffness_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_FeaShellBendingStiffness_get_type_name(*args)

def StepFEA_FeaShellBendingStiffness_get_type_descriptor(*args):
    """
    StepFEA_FeaShellBendingStiffness_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_FeaShellBendingStiffness_get_type_descriptor(*args)

class Handle_StepFEA_NodeRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_NodeRepresentation self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_NodeRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_NodeRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_NodeRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_NodeRepresentation self, StepFEA_NodeRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_NodeRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_NodeRepresentation self, Handle_StepFEA_NodeRepresentation theHandle) -> Handle_StepFEA_NodeRepresentation
        assign(Handle_StepFEA_NodeRepresentation self, StepFEA_NodeRepresentation thePtr) -> Handle_StepFEA_NodeRepresentation
        assign(Handle_StepFEA_NodeRepresentation self, Handle_StepFEA_NodeRepresentation theHandle) -> Handle_StepFEA_NodeRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_NodeRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_NodeRepresentation self) -> StepFEA_NodeRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_NodeRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_NodeRepresentation self) -> StepFEA_NodeRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_NodeRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_NodeRepresentation self) -> StepFEA_NodeRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_NodeRepresentation___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_NodeRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_NodeRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_NodeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_NodeRepresentation_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_NodeRepresentation

    def Init(self, *args):
        """
        Init(Handle_StepFEA_NodeRepresentation self, Handle_TCollection_HAsciiString aRepresentation_Name, Handle_StepRepr_HArray1OfRepresentationItem aRepresentation_Items, Handle_StepRepr_RepresentationContext aRepresentation_ContextOfItems, Handle_StepFEA_FeaModel aModelRef)

        Initialize all fields (own and inherited)

        :type aRepresentation_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRepresentation_Items: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aRepresentation_ContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext
        :type aModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel

        """
        return _StepFEA.Handle_StepFEA_NodeRepresentation_Init(self, *args)


    def ModelRef(self, *args):
        """
        ModelRef(Handle_StepFEA_NodeRepresentation self) -> Handle_StepFEA_FeaModel

        Returns field ModelRef

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel

        """
        return _StepFEA.Handle_StepFEA_NodeRepresentation_ModelRef(self, *args)


    def SetModelRef(self, *args):
        """
        SetModelRef(Handle_StepFEA_NodeRepresentation self, Handle_StepFEA_FeaModel ModelRef)

        Set field ModelRef

        :type ModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel

        """
        return _StepFEA.Handle_StepFEA_NodeRepresentation_SetModelRef(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_NodeRepresentation self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_NodeRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_NodeRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_NodeRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_NodeRepresentation self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_NodeRepresentation_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_NodeRepresentation self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_NodeRepresentation_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepFEA_NodeRepresentation self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepFEA.Handle_StepFEA_NodeRepresentation_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepFEA_NodeRepresentation self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepFEA.Handle_StepFEA_NodeRepresentation_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepFEA_NodeRepresentation self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepFEA.Handle_StepFEA_NodeRepresentation_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepFEA_NodeRepresentation self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_NodeRepresentation_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepFEA_NodeRepresentation self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepFEA.Handle_StepFEA_NodeRepresentation_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepFEA_NodeRepresentation self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepFEA.Handle_StepFEA_NodeRepresentation_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_NodeRepresentation self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_NodeRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_NodeRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_NodeRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_NodeRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_NodeRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_NodeRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_NodeRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_NodeRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_NodeRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_NodeRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_NodeRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_NodeRepresentation self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_NodeRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_NodeRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_NodeRepresentation_DecrementRefCounter(self, *args)

Handle_StepFEA_NodeRepresentation_swigregister = _StepFEA.Handle_StepFEA_NodeRepresentation_swigregister
Handle_StepFEA_NodeRepresentation_swigregister(Handle_StepFEA_NodeRepresentation)

def Handle_StepFEA_NodeRepresentation_DownCast(thing):
    return _StepFEA.Handle_StepFEA_NodeRepresentation_DownCast(thing)
Handle_StepFEA_NodeRepresentation_DownCast = _StepFEA.Handle_StepFEA_NodeRepresentation_DownCast

class Handle_StepFEA_FeaParametricPoint(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_FeaParametricPoint self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_FeaParametricPoint_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_FeaParametricPoint self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_FeaParametricPoint_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_FeaParametricPoint self, StepFEA_FeaParametricPoint thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_FeaParametricPoint_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_FeaParametricPoint self, Handle_StepFEA_FeaParametricPoint theHandle) -> Handle_StepFEA_FeaParametricPoint
        assign(Handle_StepFEA_FeaParametricPoint self, StepFEA_FeaParametricPoint thePtr) -> Handle_StepFEA_FeaParametricPoint
        assign(Handle_StepFEA_FeaParametricPoint self, Handle_StepFEA_FeaParametricPoint theHandle) -> Handle_StepFEA_FeaParametricPoint

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_FeaParametricPoint_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_FeaParametricPoint self) -> StepFEA_FeaParametricPoint

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaParametricPoint_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_FeaParametricPoint self) -> StepFEA_FeaParametricPoint

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaParametricPoint___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_FeaParametricPoint self) -> StepFEA_FeaParametricPoint

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_FeaParametricPoint___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_FeaParametricPoint___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_FeaParametricPoint___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_FeaParametricPoint(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_FeaParametricPoint_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_FeaParametricPoint

    def Init(self, *args):
        """
        Init(Handle_StepFEA_FeaParametricPoint self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Handle_TColStd_HArray1OfReal aCoordinates)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aCoordinates: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepFEA.Handle_StepFEA_FeaParametricPoint_Init(self, *args)


    def Coordinates(self, *args):
        """
        Coordinates(Handle_StepFEA_FeaParametricPoint self) -> Handle_TColStd_HArray1OfReal

        Returns field Coordinates

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepFEA.Handle_StepFEA_FeaParametricPoint_Coordinates(self, *args)


    def SetCoordinates(self, *args):
        """
        SetCoordinates(Handle_StepFEA_FeaParametricPoint self, Handle_TColStd_HArray1OfReal Coordinates)

        Set field Coordinates

        :type Coordinates: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepFEA.Handle_StepFEA_FeaParametricPoint_SetCoordinates(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_FeaParametricPoint self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_FeaParametricPoint_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaParametricPoint_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaParametricPoint_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_FeaParametricPoint self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaParametricPoint_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_FeaParametricPoint self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaParametricPoint_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_FeaParametricPoint self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_FeaParametricPoint_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_FeaParametricPoint self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_FeaParametricPoint self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaParametricPoint_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_FeaParametricPoint self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_FeaParametricPoint self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaParametricPoint_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_FeaParametricPoint self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_FeaParametricPoint_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_FeaParametricPoint self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaParametricPoint_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_FeaParametricPoint self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_FeaParametricPoint_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_FeaParametricPoint self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaParametricPoint_DecrementRefCounter(self, *args)

Handle_StepFEA_FeaParametricPoint_swigregister = _StepFEA.Handle_StepFEA_FeaParametricPoint_swigregister
Handle_StepFEA_FeaParametricPoint_swigregister(Handle_StepFEA_FeaParametricPoint)

def Handle_StepFEA_FeaParametricPoint_DownCast(thing):
    return _StepFEA.Handle_StepFEA_FeaParametricPoint_DownCast(thing)
Handle_StepFEA_FeaParametricPoint_DownCast = _StepFEA.Handle_StepFEA_FeaParametricPoint_DownCast

class StepFEA_ConstantSurface3dElementCoordinateSystem(StepFEA_FeaRepresentationItem):
    """Representation of STEP entity ConstantSurface3dElementCoordinateSystem"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_ConstantSurface3dElementCoordinateSystem
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_ConstantSurface3dElementCoordinateSystem(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_ConstantSurface3dElementCoordinateSystem self) -> StepFEA_ConstantSurface3dElementCoordinateSystem

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_ConstantSurface3dElementCoordinateSystem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_ConstantSurface3dElementCoordinateSystem self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Standard_Integer const aAxis, Standard_Real const aAngle)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aAxis: int
        :type aAngle: float

        """
        return _StepFEA.StepFEA_ConstantSurface3dElementCoordinateSystem_Init(self, *args)


    def Axis(self, *args):
        """
        Axis(StepFEA_ConstantSurface3dElementCoordinateSystem self) -> Standard_Integer

        Returns field Axis

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.StepFEA_ConstantSurface3dElementCoordinateSystem_Axis(self, *args)


    def SetAxis(self, *args):
        """
        SetAxis(StepFEA_ConstantSurface3dElementCoordinateSystem self, Standard_Integer const Axis)

        Set field Axis

        :type Axis: int

        """
        return _StepFEA.StepFEA_ConstantSurface3dElementCoordinateSystem_SetAxis(self, *args)


    def Angle(self, *args):
        """
        Angle(StepFEA_ConstantSurface3dElementCoordinateSystem self) -> Standard_Real

        Returns field Angle

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepFEA.StepFEA_ConstantSurface3dElementCoordinateSystem_Angle(self, *args)


    def SetAngle(self, *args):
        """
        SetAngle(StepFEA_ConstantSurface3dElementCoordinateSystem self, Standard_Real const Angle)

        Set field Angle

        :type Angle: float

        """
        return _StepFEA.StepFEA_ConstantSurface3dElementCoordinateSystem_SetAngle(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_ConstantSurface3dElementCoordinateSystem_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_ConstantSurface3dElementCoordinateSystem_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_ConstantSurface3dElementCoordinateSystem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_ConstantSurface3dElementCoordinateSystem
StepFEA_ConstantSurface3dElementCoordinateSystem_swigregister = _StepFEA.StepFEA_ConstantSurface3dElementCoordinateSystem_swigregister
StepFEA_ConstantSurface3dElementCoordinateSystem_swigregister(StepFEA_ConstantSurface3dElementCoordinateSystem)

def StepFEA_ConstantSurface3dElementCoordinateSystem_get_type_name(*args):
    """
    StepFEA_ConstantSurface3dElementCoordinateSystem_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_ConstantSurface3dElementCoordinateSystem_get_type_name(*args)

def StepFEA_ConstantSurface3dElementCoordinateSystem_get_type_descriptor(*args):
    """
    StepFEA_ConstantSurface3dElementCoordinateSystem_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_ConstantSurface3dElementCoordinateSystem_get_type_descriptor(*args)

class Handle_StepFEA_SymmetricTensor43dMember(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_SymmetricTensor43dMember self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_SymmetricTensor43dMember self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_SymmetricTensor43dMember self, StepFEA_SymmetricTensor43dMember thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_SymmetricTensor43dMember self, Handle_StepFEA_SymmetricTensor43dMember theHandle) -> Handle_StepFEA_SymmetricTensor43dMember
        assign(Handle_StepFEA_SymmetricTensor43dMember self, StepFEA_SymmetricTensor43dMember thePtr) -> Handle_StepFEA_SymmetricTensor43dMember
        assign(Handle_StepFEA_SymmetricTensor43dMember self, Handle_StepFEA_SymmetricTensor43dMember theHandle) -> Handle_StepFEA_SymmetricTensor43dMember

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_SymmetricTensor43dMember self) -> StepFEA_SymmetricTensor43dMember

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_SymmetricTensor43dMember self) -> StepFEA_SymmetricTensor43dMember

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_SymmetricTensor43dMember self) -> StepFEA_SymmetricTensor43dMember

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_SymmetricTensor43dMember(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_SymmetricTensor43dMember_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_SymmetricTensor43dMember

    def HasName(self, *args):
        """
        HasName(Handle_StepFEA_SymmetricTensor43dMember self) -> Standard_Boolean

        Returns True if has name

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_HasName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_SymmetricTensor43dMember self) -> Standard_CString

        Returns set name

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_SymmetricTensor43dMember self, Standard_CString const name) -> Standard_Boolean

        Set name

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_SetName(self, *args)


    def Matches(self, *args):
        """
        Matches(Handle_StepFEA_SymmetricTensor43dMember self, Standard_CString const name) -> Standard_Boolean

        Tells if the name of a SelectMember matches a given one;

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_Matches(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_SymmetricTensor43dMember self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Kind(self, *args):
        """
        Kind(Handle_StepFEA_SymmetricTensor43dMember self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_Kind(self, *args)


    def ArrReal(self, *args):
        """
        ArrReal(Handle_StepFEA_SymmetricTensor43dMember self) -> Handle_TColStd_HArray1OfReal

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_ArrReal(self, *args)


    def SetArrReal(self, *args):
        """
        SetArrReal(Handle_StepFEA_SymmetricTensor43dMember self, Handle_TColStd_HArray1OfReal arr)

        :type arr: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_SetArrReal(self, *args)


    def Field(self, *args):
        """
        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        res = _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_Field(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CField(self, *args):
        """
        CField(Handle_StepFEA_SymmetricTensor43dMember self) -> StepData_Field

        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_CField(self, *args)


    def SetKind(self, *args):
        """
        SetKind(Handle_StepFEA_SymmetricTensor43dMember self, Standard_Integer const kind)

        :type kind: int

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_SetKind(self, *args)


    def Int(self, *args):
        """
        Int(Handle_StepFEA_SymmetricTensor43dMember self) -> Standard_Integer

        This internal method gives access to a value implemented by an
        Integer (to read it)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_Int(self, *args)


    def SetInt(self, *args):
        """
        SetInt(Handle_StepFEA_SymmetricTensor43dMember self, Standard_Integer const val)

        This internal method gives access to a value implemented by an
        Integer (to set it)

        :type val: int

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_SetInt(self, *args)


    def Real(self, *args):
        """
        Real(Handle_StepFEA_SymmetricTensor43dMember self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_Real(self, *args)


    def SetReal(self, *args):
        """
        SetReal(Handle_StepFEA_SymmetricTensor43dMember self, Standard_Real const val)

        :type val: float

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_SetReal(self, *args)


    def String(self, *args):
        """
        String(Handle_StepFEA_SymmetricTensor43dMember self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_String(self, *args)


    def SetString(self, *args):
        """
        SetString(Handle_StepFEA_SymmetricTensor43dMember self, Standard_CString const val)

        :type val: OCC.wrapper.Standard.Standard_CString

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_SetString(self, *args)


    def ParamType(self, *args):
        """
        ParamType(Handle_StepFEA_SymmetricTensor43dMember self) -> Interface_ParamType

        Returns the Kind of the SelectMember, under the form of an
        enum ParamType

        :rtype: OCC.wrapper.Interface.Interface_ParamType

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_ParamType(self, *args)


    def Integer(self, *args):
        """
        Integer(Handle_StepFEA_SymmetricTensor43dMember self) -> Standard_Integer

        Gets the value as an Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_Integer(self, *args)


    def SetInteger(self, *args):
        """
        SetInteger(Handle_StepFEA_SymmetricTensor43dMember self, Standard_Integer const val)

        :type val: int

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_SetInteger(self, *args)


    def Boolean(self, *args):
        """
        Boolean(Handle_StepFEA_SymmetricTensor43dMember self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_Boolean(self, *args)


    def SetBoolean(self, *args):
        """
        SetBoolean(Handle_StepFEA_SymmetricTensor43dMember self, Standard_Boolean const val)

        :type val: bool

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_SetBoolean(self, *args)


    def Logical(self, *args):
        """
        Logical(Handle_StepFEA_SymmetricTensor43dMember self) -> StepData_Logical

        :rtype: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_Logical(self, *args)


    def SetLogical(self, *args):
        """
        SetLogical(Handle_StepFEA_SymmetricTensor43dMember self, StepData_Logical const val)

        :type val: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_SetLogical(self, *args)


    def Enum(self, *args):
        """
        Enum(Handle_StepFEA_SymmetricTensor43dMember self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_Enum(self, *args)


    def EnumText(self, *args):
        """
        EnumText(Handle_StepFEA_SymmetricTensor43dMember self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_EnumText(self, *args)


    def SetEnum(self, *args):
        """
        SetEnum(Handle_StepFEA_SymmetricTensor43dMember self, Standard_Integer const val, Standard_CString const text)

        :type val: int
        :type text: OCC.wrapper.Standard.Standard_CString

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_SetEnum(self, *args)


    def SetEnumText(self, *args):
        """
        SetEnumText(Handle_StepFEA_SymmetricTensor43dMember self, Standard_Integer const val, Standard_CString const text)

        :type val: int
        :type text: OCC.wrapper.Standard.Standard_CString

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_SetEnumText(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_SymmetricTensor43dMember self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_SymmetricTensor43dMember self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_SymmetricTensor43dMember self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_SymmetricTensor43dMember self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_SymmetricTensor43dMember self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_SymmetricTensor43dMember self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_SymmetricTensor43dMember self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_SymmetricTensor43dMember self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_SymmetricTensor43dMember self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_DecrementRefCounter(self, *args)

Handle_StepFEA_SymmetricTensor43dMember_swigregister = _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_swigregister
Handle_StepFEA_SymmetricTensor43dMember_swigregister(Handle_StepFEA_SymmetricTensor43dMember)

def Handle_StepFEA_SymmetricTensor43dMember_DownCast(thing):
    return _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_DownCast(thing)
Handle_StepFEA_SymmetricTensor43dMember_DownCast = _StepFEA.Handle_StepFEA_SymmetricTensor43dMember_DownCast

class Handle_StepFEA_DegreeOfFreedomMember(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_DegreeOfFreedomMember self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_DegreeOfFreedomMember self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_DegreeOfFreedomMember self, StepFEA_DegreeOfFreedomMember thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_DegreeOfFreedomMember self, Handle_StepFEA_DegreeOfFreedomMember theHandle) -> Handle_StepFEA_DegreeOfFreedomMember
        assign(Handle_StepFEA_DegreeOfFreedomMember self, StepFEA_DegreeOfFreedomMember thePtr) -> Handle_StepFEA_DegreeOfFreedomMember
        assign(Handle_StepFEA_DegreeOfFreedomMember self, Handle_StepFEA_DegreeOfFreedomMember theHandle) -> Handle_StepFEA_DegreeOfFreedomMember

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_DegreeOfFreedomMember self) -> StepFEA_DegreeOfFreedomMember

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_DegreeOfFreedomMember self) -> StepFEA_DegreeOfFreedomMember

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_DegreeOfFreedomMember self) -> StepFEA_DegreeOfFreedomMember

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_DegreeOfFreedomMember(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_DegreeOfFreedomMember_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_DegreeOfFreedomMember

    def HasName(self, *args):
        """
        HasName(Handle_StepFEA_DegreeOfFreedomMember self) -> Standard_Boolean

        Returns True if has name

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_HasName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_DegreeOfFreedomMember self) -> Standard_CString

        Returns set name

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_DegreeOfFreedomMember self, Standard_CString const name) -> Standard_Boolean

        Set name

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_SetName(self, *args)


    def Matches(self, *args):
        """
        Matches(Handle_StepFEA_DegreeOfFreedomMember self, Standard_CString const name) -> Standard_Boolean

        Tells if the name of a SelectMember matches a given one;

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_Matches(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_DegreeOfFreedomMember self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Field(self, *args):
        """
        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        res = _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_Field(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CField(self, *args):
        """
        CField(Handle_StepFEA_DegreeOfFreedomMember self) -> StepData_Field

        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_CField(self, *args)


    def Kind(self, *args):
        """
        Kind(Handle_StepFEA_DegreeOfFreedomMember self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_Kind(self, *args)


    def SetKind(self, *args):
        """
        SetKind(Handle_StepFEA_DegreeOfFreedomMember self, Standard_Integer const kind)

        :type kind: int

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_SetKind(self, *args)


    def Int(self, *args):
        """
        Int(Handle_StepFEA_DegreeOfFreedomMember self) -> Standard_Integer

        This internal method gives access to a value implemented by an
        Integer (to read it)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_Int(self, *args)


    def SetInt(self, *args):
        """
        SetInt(Handle_StepFEA_DegreeOfFreedomMember self, Standard_Integer const val)

        This internal method gives access to a value implemented by an
        Integer (to set it)

        :type val: int

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_SetInt(self, *args)


    def Real(self, *args):
        """
        Real(Handle_StepFEA_DegreeOfFreedomMember self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_Real(self, *args)


    def SetReal(self, *args):
        """
        SetReal(Handle_StepFEA_DegreeOfFreedomMember self, Standard_Real const val)

        :type val: float

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_SetReal(self, *args)


    def String(self, *args):
        """
        String(Handle_StepFEA_DegreeOfFreedomMember self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_String(self, *args)


    def SetString(self, *args):
        """
        SetString(Handle_StepFEA_DegreeOfFreedomMember self, Standard_CString const val)

        :type val: OCC.wrapper.Standard.Standard_CString

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_SetString(self, *args)


    def ParamType(self, *args):
        """
        ParamType(Handle_StepFEA_DegreeOfFreedomMember self) -> Interface_ParamType

        Returns the Kind of the SelectMember, under the form of an
        enum ParamType

        :rtype: OCC.wrapper.Interface.Interface_ParamType

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_ParamType(self, *args)


    def Integer(self, *args):
        """
        Integer(Handle_StepFEA_DegreeOfFreedomMember self) -> Standard_Integer

        Gets the value as an Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_Integer(self, *args)


    def SetInteger(self, *args):
        """
        SetInteger(Handle_StepFEA_DegreeOfFreedomMember self, Standard_Integer const val)

        :type val: int

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_SetInteger(self, *args)


    def Boolean(self, *args):
        """
        Boolean(Handle_StepFEA_DegreeOfFreedomMember self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_Boolean(self, *args)


    def SetBoolean(self, *args):
        """
        SetBoolean(Handle_StepFEA_DegreeOfFreedomMember self, Standard_Boolean const val)

        :type val: bool

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_SetBoolean(self, *args)


    def Logical(self, *args):
        """
        Logical(Handle_StepFEA_DegreeOfFreedomMember self) -> StepData_Logical

        :rtype: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_Logical(self, *args)


    def SetLogical(self, *args):
        """
        SetLogical(Handle_StepFEA_DegreeOfFreedomMember self, StepData_Logical const val)

        :type val: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_SetLogical(self, *args)


    def Enum(self, *args):
        """
        Enum(Handle_StepFEA_DegreeOfFreedomMember self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_Enum(self, *args)


    def EnumText(self, *args):
        """
        EnumText(Handle_StepFEA_DegreeOfFreedomMember self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_EnumText(self, *args)


    def SetEnum(self, *args):
        """
        SetEnum(Handle_StepFEA_DegreeOfFreedomMember self, Standard_Integer const val, Standard_CString const text)

        :type val: int
        :type text: OCC.wrapper.Standard.Standard_CString

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_SetEnum(self, *args)


    def SetEnumText(self, *args):
        """
        SetEnumText(Handle_StepFEA_DegreeOfFreedomMember self, Standard_Integer const val, Standard_CString const text)

        :type val: int
        :type text: OCC.wrapper.Standard.Standard_CString

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_SetEnumText(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_DegreeOfFreedomMember self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_DegreeOfFreedomMember self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_DegreeOfFreedomMember self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_DegreeOfFreedomMember self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_DegreeOfFreedomMember self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_DegreeOfFreedomMember self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_DegreeOfFreedomMember self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_DegreeOfFreedomMember self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_DegreeOfFreedomMember self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_DecrementRefCounter(self, *args)

Handle_StepFEA_DegreeOfFreedomMember_swigregister = _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_swigregister
Handle_StepFEA_DegreeOfFreedomMember_swigregister(Handle_StepFEA_DegreeOfFreedomMember)

def Handle_StepFEA_DegreeOfFreedomMember_DownCast(thing):
    return _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_DownCast(thing)
Handle_StepFEA_DegreeOfFreedomMember_DownCast = _StepFEA.Handle_StepFEA_DegreeOfFreedomMember_DownCast

class Handle_StepFEA_FeaShellBendingStiffness(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_FeaShellBendingStiffness self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_FeaShellBendingStiffness_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_FeaShellBendingStiffness self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_FeaShellBendingStiffness_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_FeaShellBendingStiffness self, StepFEA_FeaShellBendingStiffness thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_FeaShellBendingStiffness_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_FeaShellBendingStiffness self, Handle_StepFEA_FeaShellBendingStiffness theHandle) -> Handle_StepFEA_FeaShellBendingStiffness
        assign(Handle_StepFEA_FeaShellBendingStiffness self, StepFEA_FeaShellBendingStiffness thePtr) -> Handle_StepFEA_FeaShellBendingStiffness
        assign(Handle_StepFEA_FeaShellBendingStiffness self, Handle_StepFEA_FeaShellBendingStiffness theHandle) -> Handle_StepFEA_FeaShellBendingStiffness

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_FeaShellBendingStiffness_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_FeaShellBendingStiffness self) -> StepFEA_FeaShellBendingStiffness

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaShellBendingStiffness_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_FeaShellBendingStiffness self) -> StepFEA_FeaShellBendingStiffness

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaShellBendingStiffness___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_FeaShellBendingStiffness self) -> StepFEA_FeaShellBendingStiffness

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_FeaShellBendingStiffness___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_FeaShellBendingStiffness___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_FeaShellBendingStiffness___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_FeaShellBendingStiffness(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_FeaShellBendingStiffness_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_FeaShellBendingStiffness

    def Init(self, *args):
        """
        Init(Handle_StepFEA_FeaShellBendingStiffness self, Handle_TCollection_HAsciiString aRepresentationItem_Name, StepFEA_SymmetricTensor42d aFeaConstants)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFeaConstants: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor42d

        """
        return _StepFEA.Handle_StepFEA_FeaShellBendingStiffness_Init(self, *args)


    def FeaConstants(self, *args):
        """
        FeaConstants(Handle_StepFEA_FeaShellBendingStiffness self) -> StepFEA_SymmetricTensor42d

        Returns field FeaConstants

        :rtype: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor42d

        """
        return _StepFEA.Handle_StepFEA_FeaShellBendingStiffness_FeaConstants(self, *args)


    def SetFeaConstants(self, *args):
        """
        SetFeaConstants(Handle_StepFEA_FeaShellBendingStiffness self, StepFEA_SymmetricTensor42d FeaConstants)

        Set field FeaConstants

        :type FeaConstants: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor42d

        """
        return _StepFEA.Handle_StepFEA_FeaShellBendingStiffness_SetFeaConstants(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_FeaShellBendingStiffness self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_FeaShellBendingStiffness_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaShellBendingStiffness_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaShellBendingStiffness_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_FeaShellBendingStiffness self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaShellBendingStiffness_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_FeaShellBendingStiffness self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaShellBendingStiffness_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_FeaShellBendingStiffness self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_FeaShellBendingStiffness_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_FeaShellBendingStiffness self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_FeaShellBendingStiffness self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaShellBendingStiffness_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_FeaShellBendingStiffness self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_FeaShellBendingStiffness self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaShellBendingStiffness_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_FeaShellBendingStiffness self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_FeaShellBendingStiffness_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_FeaShellBendingStiffness self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaShellBendingStiffness_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_FeaShellBendingStiffness self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_FeaShellBendingStiffness_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_FeaShellBendingStiffness self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaShellBendingStiffness_DecrementRefCounter(self, *args)

Handle_StepFEA_FeaShellBendingStiffness_swigregister = _StepFEA.Handle_StepFEA_FeaShellBendingStiffness_swigregister
Handle_StepFEA_FeaShellBendingStiffness_swigregister(Handle_StepFEA_FeaShellBendingStiffness)

def Handle_StepFEA_FeaShellBendingStiffness_DownCast(thing):
    return _StepFEA.Handle_StepFEA_FeaShellBendingStiffness_DownCast(thing)
Handle_StepFEA_FeaShellBendingStiffness_DownCast = _StepFEA.Handle_StepFEA_FeaShellBendingStiffness_DownCast

class Handle_StepFEA_FeaMassDensity(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_FeaMassDensity self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_FeaMassDensity_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_FeaMassDensity self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_FeaMassDensity_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_FeaMassDensity self, StepFEA_FeaMassDensity thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_FeaMassDensity_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_FeaMassDensity self, Handle_StepFEA_FeaMassDensity theHandle) -> Handle_StepFEA_FeaMassDensity
        assign(Handle_StepFEA_FeaMassDensity self, StepFEA_FeaMassDensity thePtr) -> Handle_StepFEA_FeaMassDensity
        assign(Handle_StepFEA_FeaMassDensity self, Handle_StepFEA_FeaMassDensity theHandle) -> Handle_StepFEA_FeaMassDensity

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_FeaMassDensity_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_FeaMassDensity self) -> StepFEA_FeaMassDensity

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaMassDensity_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_FeaMassDensity self) -> StepFEA_FeaMassDensity

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaMassDensity___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_FeaMassDensity self) -> StepFEA_FeaMassDensity

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_FeaMassDensity___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_FeaMassDensity___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_FeaMassDensity___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_FeaMassDensity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_FeaMassDensity_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_FeaMassDensity

    def Init(self, *args):
        """
        Init(Handle_StepFEA_FeaMassDensity self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Standard_Real const aFeaConstant)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFeaConstant: float

        """
        return _StepFEA.Handle_StepFEA_FeaMassDensity_Init(self, *args)


    def FeaConstant(self, *args):
        """
        FeaConstant(Handle_StepFEA_FeaMassDensity self) -> Standard_Real

        Returns field FeaConstant

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepFEA.Handle_StepFEA_FeaMassDensity_FeaConstant(self, *args)


    def SetFeaConstant(self, *args):
        """
        SetFeaConstant(Handle_StepFEA_FeaMassDensity self, Standard_Real const FeaConstant)

        Set field FeaConstant

        :type FeaConstant: float

        """
        return _StepFEA.Handle_StepFEA_FeaMassDensity_SetFeaConstant(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_FeaMassDensity self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_FeaMassDensity_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaMassDensity_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaMassDensity_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_FeaMassDensity self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaMassDensity_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_FeaMassDensity self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaMassDensity_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_FeaMassDensity self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_FeaMassDensity_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_FeaMassDensity self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_FeaMassDensity self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaMassDensity_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_FeaMassDensity self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_FeaMassDensity self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaMassDensity_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_FeaMassDensity self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_FeaMassDensity_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_FeaMassDensity self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaMassDensity_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_FeaMassDensity self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_FeaMassDensity_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_FeaMassDensity self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaMassDensity_DecrementRefCounter(self, *args)

Handle_StepFEA_FeaMassDensity_swigregister = _StepFEA.Handle_StepFEA_FeaMassDensity_swigregister
Handle_StepFEA_FeaMassDensity_swigregister(Handle_StepFEA_FeaMassDensity)

def Handle_StepFEA_FeaMassDensity_DownCast(thing):
    return _StepFEA.Handle_StepFEA_FeaMassDensity_DownCast(thing)
Handle_StepFEA_FeaMassDensity_DownCast = _StepFEA.Handle_StepFEA_FeaMassDensity_DownCast

class StepFEA_AlignedSurface3dElementCoordinateSystem(StepFEA_FeaRepresentationItem):
    """Representation of STEP entity AlignedSurface3dElementCoordinateSystem"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_AlignedSurface3dElementCoordinateSystem
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_AlignedSurface3dElementCoordinateSystem(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_AlignedSurface3dElementCoordinateSystem self) -> StepFEA_AlignedSurface3dElementCoordinateSystem

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_AlignedSurface3dElementCoordinateSystem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_AlignedSurface3dElementCoordinateSystem self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Handle_StepFEA_FeaAxis2Placement3d aCoordinateSystem)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aCoordinateSystem: OCC.wrapper.StepFEA.Handle_StepFEA_FeaAxis2Placement3d

        """
        return _StepFEA.StepFEA_AlignedSurface3dElementCoordinateSystem_Init(self, *args)


    def CoordinateSystem(self, *args):
        """
        CoordinateSystem(StepFEA_AlignedSurface3dElementCoordinateSystem self) -> Handle_StepFEA_FeaAxis2Placement3d

        Returns field CoordinateSystem

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_FeaAxis2Placement3d

        """
        return _StepFEA.StepFEA_AlignedSurface3dElementCoordinateSystem_CoordinateSystem(self, *args)


    def SetCoordinateSystem(self, *args):
        """
        SetCoordinateSystem(StepFEA_AlignedSurface3dElementCoordinateSystem self, Handle_StepFEA_FeaAxis2Placement3d CoordinateSystem)

        Set field CoordinateSystem

        :type CoordinateSystem: OCC.wrapper.StepFEA.Handle_StepFEA_FeaAxis2Placement3d

        """
        return _StepFEA.StepFEA_AlignedSurface3dElementCoordinateSystem_SetCoordinateSystem(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_AlignedSurface3dElementCoordinateSystem_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_AlignedSurface3dElementCoordinateSystem_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_AlignedSurface3dElementCoordinateSystem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_AlignedSurface3dElementCoordinateSystem
StepFEA_AlignedSurface3dElementCoordinateSystem_swigregister = _StepFEA.StepFEA_AlignedSurface3dElementCoordinateSystem_swigregister
StepFEA_AlignedSurface3dElementCoordinateSystem_swigregister(StepFEA_AlignedSurface3dElementCoordinateSystem)

def StepFEA_AlignedSurface3dElementCoordinateSystem_get_type_name(*args):
    """
    StepFEA_AlignedSurface3dElementCoordinateSystem_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_AlignedSurface3dElementCoordinateSystem_get_type_name(*args)

def StepFEA_AlignedSurface3dElementCoordinateSystem_get_type_descriptor(*args):
    """
    StepFEA_AlignedSurface3dElementCoordinateSystem_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_AlignedSurface3dElementCoordinateSystem_get_type_descriptor(*args)

class StepFEA_AlignedCurve3dElementCoordinateSystem(StepFEA_FeaRepresentationItem):
    """Representation of STEP entity AlignedCurve3dElementCoordinateSystem"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_AlignedCurve3dElementCoordinateSystem
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_AlignedCurve3dElementCoordinateSystem(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_AlignedCurve3dElementCoordinateSystem self) -> StepFEA_AlignedCurve3dElementCoordinateSystem

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_AlignedCurve3dElementCoordinateSystem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_AlignedCurve3dElementCoordinateSystem self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Handle_StepFEA_FeaAxis2Placement3d aCoordinateSystem)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aCoordinateSystem: OCC.wrapper.StepFEA.Handle_StepFEA_FeaAxis2Placement3d

        """
        return _StepFEA.StepFEA_AlignedCurve3dElementCoordinateSystem_Init(self, *args)


    def CoordinateSystem(self, *args):
        """
        CoordinateSystem(StepFEA_AlignedCurve3dElementCoordinateSystem self) -> Handle_StepFEA_FeaAxis2Placement3d

        Returns field CoordinateSystem

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_FeaAxis2Placement3d

        """
        return _StepFEA.StepFEA_AlignedCurve3dElementCoordinateSystem_CoordinateSystem(self, *args)


    def SetCoordinateSystem(self, *args):
        """
        SetCoordinateSystem(StepFEA_AlignedCurve3dElementCoordinateSystem self, Handle_StepFEA_FeaAxis2Placement3d CoordinateSystem)

        Set field CoordinateSystem

        :type CoordinateSystem: OCC.wrapper.StepFEA.Handle_StepFEA_FeaAxis2Placement3d

        """
        return _StepFEA.StepFEA_AlignedCurve3dElementCoordinateSystem_SetCoordinateSystem(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_AlignedCurve3dElementCoordinateSystem_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_AlignedCurve3dElementCoordinateSystem_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_AlignedCurve3dElementCoordinateSystem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_AlignedCurve3dElementCoordinateSystem
StepFEA_AlignedCurve3dElementCoordinateSystem_swigregister = _StepFEA.StepFEA_AlignedCurve3dElementCoordinateSystem_swigregister
StepFEA_AlignedCurve3dElementCoordinateSystem_swigregister(StepFEA_AlignedCurve3dElementCoordinateSystem)

def StepFEA_AlignedCurve3dElementCoordinateSystem_get_type_name(*args):
    """
    StepFEA_AlignedCurve3dElementCoordinateSystem_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_AlignedCurve3dElementCoordinateSystem_get_type_name(*args)

def StepFEA_AlignedCurve3dElementCoordinateSystem_get_type_descriptor(*args):
    """
    StepFEA_AlignedCurve3dElementCoordinateSystem_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_AlignedCurve3dElementCoordinateSystem_get_type_descriptor(*args)

class Handle_StepFEA_FeaLinearElasticity(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_FeaLinearElasticity self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_FeaLinearElasticity_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_FeaLinearElasticity self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_FeaLinearElasticity_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_FeaLinearElasticity self, StepFEA_FeaLinearElasticity thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_FeaLinearElasticity_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_FeaLinearElasticity self, Handle_StepFEA_FeaLinearElasticity theHandle) -> Handle_StepFEA_FeaLinearElasticity
        assign(Handle_StepFEA_FeaLinearElasticity self, StepFEA_FeaLinearElasticity thePtr) -> Handle_StepFEA_FeaLinearElasticity
        assign(Handle_StepFEA_FeaLinearElasticity self, Handle_StepFEA_FeaLinearElasticity theHandle) -> Handle_StepFEA_FeaLinearElasticity

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_FeaLinearElasticity_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_FeaLinearElasticity self) -> StepFEA_FeaLinearElasticity

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaLinearElasticity_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_FeaLinearElasticity self) -> StepFEA_FeaLinearElasticity

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaLinearElasticity___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_FeaLinearElasticity self) -> StepFEA_FeaLinearElasticity

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_FeaLinearElasticity___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_FeaLinearElasticity___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_FeaLinearElasticity___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_FeaLinearElasticity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_FeaLinearElasticity_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_FeaLinearElasticity

    def Init(self, *args):
        """
        Init(Handle_StepFEA_FeaLinearElasticity self, Handle_TCollection_HAsciiString aRepresentationItem_Name, StepFEA_SymmetricTensor43d aFeaConstants)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFeaConstants: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor43d

        """
        return _StepFEA.Handle_StepFEA_FeaLinearElasticity_Init(self, *args)


    def FeaConstants(self, *args):
        """
        FeaConstants(Handle_StepFEA_FeaLinearElasticity self) -> StepFEA_SymmetricTensor43d

        Returns field FeaConstants

        :rtype: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor43d

        """
        return _StepFEA.Handle_StepFEA_FeaLinearElasticity_FeaConstants(self, *args)


    def SetFeaConstants(self, *args):
        """
        SetFeaConstants(Handle_StepFEA_FeaLinearElasticity self, StepFEA_SymmetricTensor43d FeaConstants)

        Set field FeaConstants

        :type FeaConstants: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor43d

        """
        return _StepFEA.Handle_StepFEA_FeaLinearElasticity_SetFeaConstants(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_FeaLinearElasticity self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_FeaLinearElasticity_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaLinearElasticity_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaLinearElasticity_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_FeaLinearElasticity self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaLinearElasticity_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_FeaLinearElasticity self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaLinearElasticity_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_FeaLinearElasticity self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_FeaLinearElasticity_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_FeaLinearElasticity self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_FeaLinearElasticity self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaLinearElasticity_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_FeaLinearElasticity self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_FeaLinearElasticity self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaLinearElasticity_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_FeaLinearElasticity self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_FeaLinearElasticity_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_FeaLinearElasticity self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaLinearElasticity_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_FeaLinearElasticity self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_FeaLinearElasticity_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_FeaLinearElasticity self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaLinearElasticity_DecrementRefCounter(self, *args)

Handle_StepFEA_FeaLinearElasticity_swigregister = _StepFEA.Handle_StepFEA_FeaLinearElasticity_swigregister
Handle_StepFEA_FeaLinearElasticity_swigregister(Handle_StepFEA_FeaLinearElasticity)

def Handle_StepFEA_FeaLinearElasticity_DownCast(thing):
    return _StepFEA.Handle_StepFEA_FeaLinearElasticity_DownCast(thing)
Handle_StepFEA_FeaLinearElasticity_DownCast = _StepFEA.Handle_StepFEA_FeaLinearElasticity_DownCast

class Handle_StepFEA_CurveElementLocation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_CurveElementLocation self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_CurveElementLocation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_CurveElementLocation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_CurveElementLocation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_CurveElementLocation self, StepFEA_CurveElementLocation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_CurveElementLocation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_CurveElementLocation self, Handle_StepFEA_CurveElementLocation theHandle) -> Handle_StepFEA_CurveElementLocation
        assign(Handle_StepFEA_CurveElementLocation self, StepFEA_CurveElementLocation thePtr) -> Handle_StepFEA_CurveElementLocation
        assign(Handle_StepFEA_CurveElementLocation self, Handle_StepFEA_CurveElementLocation theHandle) -> Handle_StepFEA_CurveElementLocation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_CurveElementLocation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_CurveElementLocation self) -> StepFEA_CurveElementLocation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_CurveElementLocation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_CurveElementLocation self) -> StepFEA_CurveElementLocation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_CurveElementLocation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_CurveElementLocation self) -> StepFEA_CurveElementLocation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_CurveElementLocation___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_CurveElementLocation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_CurveElementLocation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_CurveElementLocation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_CurveElementLocation_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_CurveElementLocation

    def Init(self, *args):
        """
        Init(Handle_StepFEA_CurveElementLocation self, Handle_StepFEA_FeaParametricPoint aCoordinate)

        Initialize all fields (own and inherited)

        :type aCoordinate: OCC.wrapper.StepFEA.Handle_StepFEA_FeaParametricPoint

        """
        return _StepFEA.Handle_StepFEA_CurveElementLocation_Init(self, *args)


    def Coordinate(self, *args):
        """
        Coordinate(Handle_StepFEA_CurveElementLocation self) -> Handle_StepFEA_FeaParametricPoint

        Returns field Coordinate

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_FeaParametricPoint

        """
        return _StepFEA.Handle_StepFEA_CurveElementLocation_Coordinate(self, *args)


    def SetCoordinate(self, *args):
        """
        SetCoordinate(Handle_StepFEA_CurveElementLocation self, Handle_StepFEA_FeaParametricPoint Coordinate)

        Set field Coordinate

        :type Coordinate: OCC.wrapper.StepFEA.Handle_StepFEA_FeaParametricPoint

        """
        return _StepFEA.Handle_StepFEA_CurveElementLocation_SetCoordinate(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_CurveElementLocation self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_CurveElementLocation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_CurveElementLocation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_CurveElementLocation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_CurveElementLocation self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_CurveElementLocation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_CurveElementLocation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_CurveElementLocation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_CurveElementLocation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_CurveElementLocation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_CurveElementLocation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_CurveElementLocation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_CurveElementLocation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_CurveElementLocation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_CurveElementLocation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_CurveElementLocation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_CurveElementLocation self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_CurveElementLocation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_CurveElementLocation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_CurveElementLocation_DecrementRefCounter(self, *args)

Handle_StepFEA_CurveElementLocation_swigregister = _StepFEA.Handle_StepFEA_CurveElementLocation_swigregister
Handle_StepFEA_CurveElementLocation_swigregister(Handle_StepFEA_CurveElementLocation)

def Handle_StepFEA_CurveElementLocation_DownCast(thing):
    return _StepFEA.Handle_StepFEA_CurveElementLocation_DownCast(thing)
Handle_StepFEA_CurveElementLocation_DownCast = _StepFEA.Handle_StepFEA_CurveElementLocation_DownCast

class StepFEA_ArbitraryVolume3dElementCoordinateSystem(StepFEA_FeaRepresentationItem):
    """Representation of STEP entity ArbitraryVolume3dElementCoordinateSystem"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_ArbitraryVolume3dElementCoordinateSystem self) -> StepFEA_ArbitraryVolume3dElementCoordinateSystem

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_ArbitraryVolume3dElementCoordinateSystem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_ArbitraryVolume3dElementCoordinateSystem self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Handle_StepFEA_FeaAxis2Placement3d aCoordinateSystem)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aCoordinateSystem: OCC.wrapper.StepFEA.Handle_StepFEA_FeaAxis2Placement3d

        """
        return _StepFEA.StepFEA_ArbitraryVolume3dElementCoordinateSystem_Init(self, *args)


    def CoordinateSystem(self, *args):
        """
        CoordinateSystem(StepFEA_ArbitraryVolume3dElementCoordinateSystem self) -> Handle_StepFEA_FeaAxis2Placement3d

        Returns field CoordinateSystem

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_FeaAxis2Placement3d

        """
        return _StepFEA.StepFEA_ArbitraryVolume3dElementCoordinateSystem_CoordinateSystem(self, *args)


    def SetCoordinateSystem(self, *args):
        """
        SetCoordinateSystem(StepFEA_ArbitraryVolume3dElementCoordinateSystem self, Handle_StepFEA_FeaAxis2Placement3d CoordinateSystem)

        Set field CoordinateSystem

        :type CoordinateSystem: OCC.wrapper.StepFEA.Handle_StepFEA_FeaAxis2Placement3d

        """
        return _StepFEA.StepFEA_ArbitraryVolume3dElementCoordinateSystem_SetCoordinateSystem(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_ArbitraryVolume3dElementCoordinateSystem_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_ArbitraryVolume3dElementCoordinateSystem_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_ArbitraryVolume3dElementCoordinateSystem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_ArbitraryVolume3dElementCoordinateSystem
StepFEA_ArbitraryVolume3dElementCoordinateSystem_swigregister = _StepFEA.StepFEA_ArbitraryVolume3dElementCoordinateSystem_swigregister
StepFEA_ArbitraryVolume3dElementCoordinateSystem_swigregister(StepFEA_ArbitraryVolume3dElementCoordinateSystem)

def StepFEA_ArbitraryVolume3dElementCoordinateSystem_get_type_name(*args):
    """
    StepFEA_ArbitraryVolume3dElementCoordinateSystem_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_ArbitraryVolume3dElementCoordinateSystem_get_type_name(*args)

def StepFEA_ArbitraryVolume3dElementCoordinateSystem_get_type_descriptor(*args):
    """
    StepFEA_ArbitraryVolume3dElementCoordinateSystem_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_ArbitraryVolume3dElementCoordinateSystem_get_type_descriptor(*args)

class StepFEA_Surface3dElementRepresentation(StepFEA_ElementRepresentation):
    """Representation of STEP entity Surface3dElementRepresentation"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_Surface3dElementRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_Surface3dElementRepresentation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_Surface3dElementRepresentation self) -> StepFEA_Surface3dElementRepresentation

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_Surface3dElementRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_Surface3dElementRepresentation self, Handle_TCollection_HAsciiString aRepresentation_Name, Handle_StepRepr_HArray1OfRepresentationItem aRepresentation_Items, Handle_StepRepr_RepresentationContext aRepresentation_ContextOfItems, Handle_StepFEA_HArray1OfNodeRepresentation aElementRepresentation_NodeList, Handle_StepFEA_FeaModel3d aModelRef, Handle_StepElement_Surface3dElementDescriptor aElementDescriptor, Handle_StepElement_SurfaceElementProperty aProperty, Handle_StepElement_ElementMaterial aMaterial)

        Initialize all fields (own and inherited)

        :type aRepresentation_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRepresentation_Items: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aRepresentation_ContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext
        :type aElementRepresentation_NodeList: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation
        :type aModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel3d
        :type aElementDescriptor: OCC.wrapper.StepElement.Handle_StepElement_Surface3dElementDescriptor
        :type aProperty: OCC.wrapper.StepElement.Handle_StepElement_SurfaceElementProperty
        :type aMaterial: OCC.wrapper.StepElement.Handle_StepElement_ElementMaterial

        """
        return _StepFEA.StepFEA_Surface3dElementRepresentation_Init(self, *args)


    def ModelRef(self, *args):
        """
        ModelRef(StepFEA_Surface3dElementRepresentation self) -> Handle_StepFEA_FeaModel3d

        Returns field ModelRef

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel3d

        """
        return _StepFEA.StepFEA_Surface3dElementRepresentation_ModelRef(self, *args)


    def SetModelRef(self, *args):
        """
        SetModelRef(StepFEA_Surface3dElementRepresentation self, Handle_StepFEA_FeaModel3d ModelRef)

        Set field ModelRef

        :type ModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel3d

        """
        return _StepFEA.StepFEA_Surface3dElementRepresentation_SetModelRef(self, *args)


    def ElementDescriptor(self, *args):
        """
        ElementDescriptor(StepFEA_Surface3dElementRepresentation self) -> Handle_StepElement_Surface3dElementDescriptor

        Returns field ElementDescriptor

        :rtype: OCC.wrapper.StepElement.Handle_StepElement_Surface3dElementDescriptor

        """
        return _StepFEA.StepFEA_Surface3dElementRepresentation_ElementDescriptor(self, *args)


    def SetElementDescriptor(self, *args):
        """
        SetElementDescriptor(StepFEA_Surface3dElementRepresentation self, Handle_StepElement_Surface3dElementDescriptor ElementDescriptor)

        Set field ElementDescriptor

        :type ElementDescriptor: OCC.wrapper.StepElement.Handle_StepElement_Surface3dElementDescriptor

        """
        return _StepFEA.StepFEA_Surface3dElementRepresentation_SetElementDescriptor(self, *args)


    def Property(self, *args):
        """
        Property(StepFEA_Surface3dElementRepresentation self) -> Handle_StepElement_SurfaceElementProperty

        Returns field Property

        :rtype: OCC.wrapper.StepElement.Handle_StepElement_SurfaceElementProperty

        """
        return _StepFEA.StepFEA_Surface3dElementRepresentation_Property(self, *args)


    def SetProperty(self, *args):
        """
        SetProperty(StepFEA_Surface3dElementRepresentation self, Handle_StepElement_SurfaceElementProperty Property)

        Set field Property

        :type Property: OCC.wrapper.StepElement.Handle_StepElement_SurfaceElementProperty

        """
        return _StepFEA.StepFEA_Surface3dElementRepresentation_SetProperty(self, *args)


    def Material(self, *args):
        """
        Material(StepFEA_Surface3dElementRepresentation self) -> Handle_StepElement_ElementMaterial

        Returns field Material

        :rtype: OCC.wrapper.StepElement.Handle_StepElement_ElementMaterial

        """
        return _StepFEA.StepFEA_Surface3dElementRepresentation_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(StepFEA_Surface3dElementRepresentation self, Handle_StepElement_ElementMaterial Material)

        Set field Material

        :type Material: OCC.wrapper.StepElement.Handle_StepElement_ElementMaterial

        """
        return _StepFEA.StepFEA_Surface3dElementRepresentation_SetMaterial(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_Surface3dElementRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_Surface3dElementRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_Surface3dElementRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_Surface3dElementRepresentation
StepFEA_Surface3dElementRepresentation_swigregister = _StepFEA.StepFEA_Surface3dElementRepresentation_swigregister
StepFEA_Surface3dElementRepresentation_swigregister(StepFEA_Surface3dElementRepresentation)

def StepFEA_Surface3dElementRepresentation_get_type_name(*args):
    """
    StepFEA_Surface3dElementRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_Surface3dElementRepresentation_get_type_name(*args)

def StepFEA_Surface3dElementRepresentation_get_type_descriptor(*args):
    """
    StepFEA_Surface3dElementRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_Surface3dElementRepresentation_get_type_descriptor(*args)

class Handle_StepFEA_Node(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_Node self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_Node_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_Node self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_Node_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_Node self, StepFEA_Node thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_Node_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_Node self, Handle_StepFEA_Node theHandle) -> Handle_StepFEA_Node
        assign(Handle_StepFEA_Node self, StepFEA_Node thePtr) -> Handle_StepFEA_Node
        assign(Handle_StepFEA_Node self, Handle_StepFEA_Node theHandle) -> Handle_StepFEA_Node

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_Node_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_Node self) -> StepFEA_Node

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_Node_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_Node self) -> StepFEA_Node

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_Node___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_Node self) -> StepFEA_Node

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_Node___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_Node___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_Node___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_Node(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_Node_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_Node

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_Node self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_Node_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_Node_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_Node_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepFEA_Node self, Handle_TCollection_HAsciiString aRepresentation_Name, Handle_StepRepr_HArray1OfRepresentationItem aRepresentation_Items, Handle_StepRepr_RepresentationContext aRepresentation_ContextOfItems, Handle_StepFEA_FeaModel aModelRef)

        Initialize all fields (own and inherited)

        :type aRepresentation_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRepresentation_Items: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aRepresentation_ContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext
        :type aModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel

        """
        return _StepFEA.Handle_StepFEA_Node_Init(self, *args)


    def ModelRef(self, *args):
        """
        ModelRef(Handle_StepFEA_Node self) -> Handle_StepFEA_FeaModel

        Returns field ModelRef

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel

        """
        return _StepFEA.Handle_StepFEA_Node_ModelRef(self, *args)


    def SetModelRef(self, *args):
        """
        SetModelRef(Handle_StepFEA_Node self, Handle_StepFEA_FeaModel ModelRef)

        Set field ModelRef

        :type ModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel

        """
        return _StepFEA.Handle_StepFEA_Node_SetModelRef(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_Node self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_Node_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_Node self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_Node_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepFEA_Node self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepFEA.Handle_StepFEA_Node_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepFEA_Node self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepFEA.Handle_StepFEA_Node_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepFEA_Node self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepFEA.Handle_StepFEA_Node_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepFEA_Node self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_Node_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepFEA_Node self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepFEA.Handle_StepFEA_Node_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepFEA_Node self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepFEA.Handle_StepFEA_Node_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_Node self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_Node_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_Node self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_Node self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_Node_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_Node self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_Node self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_Node_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_Node self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_Node_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_Node self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_Node_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_Node self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_Node_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_Node self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_Node_DecrementRefCounter(self, *args)

Handle_StepFEA_Node_swigregister = _StepFEA.Handle_StepFEA_Node_swigregister
Handle_StepFEA_Node_swigregister(Handle_StepFEA_Node)

def Handle_StepFEA_Node_DownCast(thing):
    return _StepFEA.Handle_StepFEA_Node_DownCast(thing)
Handle_StepFEA_Node_DownCast = _StepFEA.Handle_StepFEA_Node_DownCast

class Handle_StepFEA_Curve3dElementProperty(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_Curve3dElementProperty self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_Curve3dElementProperty_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_Curve3dElementProperty self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementProperty_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_Curve3dElementProperty self, StepFEA_Curve3dElementProperty thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementProperty_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_Curve3dElementProperty self, Handle_StepFEA_Curve3dElementProperty theHandle) -> Handle_StepFEA_Curve3dElementProperty
        assign(Handle_StepFEA_Curve3dElementProperty self, StepFEA_Curve3dElementProperty thePtr) -> Handle_StepFEA_Curve3dElementProperty
        assign(Handle_StepFEA_Curve3dElementProperty self, Handle_StepFEA_Curve3dElementProperty theHandle) -> Handle_StepFEA_Curve3dElementProperty

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementProperty_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_Curve3dElementProperty self) -> StepFEA_Curve3dElementProperty

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementProperty_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_Curve3dElementProperty self) -> StepFEA_Curve3dElementProperty

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementProperty___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_Curve3dElementProperty self) -> StepFEA_Curve3dElementProperty

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementProperty___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_Curve3dElementProperty___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_Curve3dElementProperty___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_Curve3dElementProperty(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_Curve3dElementProperty_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_Curve3dElementProperty

    def Init(self, *args):
        """
        Init(Handle_StepFEA_Curve3dElementProperty self, Handle_TCollection_HAsciiString aPropertyId, Handle_TCollection_HAsciiString aDescription, Handle_StepFEA_HArray1OfCurveElementInterval aIntervalDefinitions, Handle_StepFEA_HArray1OfCurveElementEndOffset aEndOffsets, Handle_StepFEA_HArray1OfCurveElementEndRelease aEndReleases)

        Initialize all fields (own and inherited)

        :type aPropertyId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aIntervalDefinitions: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfCurveElementInterval
        :type aEndOffsets: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfCurveElementEndOffset
        :type aEndReleases: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfCurveElementEndRelease

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementProperty_Init(self, *args)


    def PropertyId(self, *args):
        """
        PropertyId(Handle_StepFEA_Curve3dElementProperty self) -> Handle_TCollection_HAsciiString

        Returns field PropertyId

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementProperty_PropertyId(self, *args)


    def SetPropertyId(self, *args):
        """
        SetPropertyId(Handle_StepFEA_Curve3dElementProperty self, Handle_TCollection_HAsciiString PropertyId)

        Set field PropertyId

        :type PropertyId: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementProperty_SetPropertyId(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepFEA_Curve3dElementProperty self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementProperty_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepFEA_Curve3dElementProperty self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementProperty_SetDescription(self, *args)


    def IntervalDefinitions(self, *args):
        """
        IntervalDefinitions(Handle_StepFEA_Curve3dElementProperty self) -> Handle_StepFEA_HArray1OfCurveElementInterval

        Returns field IntervalDefinitions

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfCurveElementInterval

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementProperty_IntervalDefinitions(self, *args)


    def SetIntervalDefinitions(self, *args):
        """
        SetIntervalDefinitions(Handle_StepFEA_Curve3dElementProperty self, Handle_StepFEA_HArray1OfCurveElementInterval IntervalDefinitions)

        Set field IntervalDefinitions

        :type IntervalDefinitions: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfCurveElementInterval

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementProperty_SetIntervalDefinitions(self, *args)


    def EndOffsets(self, *args):
        """
        EndOffsets(Handle_StepFEA_Curve3dElementProperty self) -> Handle_StepFEA_HArray1OfCurveElementEndOffset

        Returns field EndOffsets

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfCurveElementEndOffset

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementProperty_EndOffsets(self, *args)


    def SetEndOffsets(self, *args):
        """
        SetEndOffsets(Handle_StepFEA_Curve3dElementProperty self, Handle_StepFEA_HArray1OfCurveElementEndOffset EndOffsets)

        Set field EndOffsets

        :type EndOffsets: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfCurveElementEndOffset

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementProperty_SetEndOffsets(self, *args)


    def EndReleases(self, *args):
        """
        EndReleases(Handle_StepFEA_Curve3dElementProperty self) -> Handle_StepFEA_HArray1OfCurveElementEndRelease

        Returns field EndReleases

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfCurveElementEndRelease

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementProperty_EndReleases(self, *args)


    def SetEndReleases(self, *args):
        """
        SetEndReleases(Handle_StepFEA_Curve3dElementProperty self, Handle_StepFEA_HArray1OfCurveElementEndRelease EndReleases)

        Set field EndReleases

        :type EndReleases: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfCurveElementEndRelease

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementProperty_SetEndReleases(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_Curve3dElementProperty self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementProperty_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_Curve3dElementProperty_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_Curve3dElementProperty_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_Curve3dElementProperty self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_Curve3dElementProperty_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_Curve3dElementProperty self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_Curve3dElementProperty self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementProperty_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_Curve3dElementProperty self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_Curve3dElementProperty self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementProperty_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_Curve3dElementProperty self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementProperty_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_Curve3dElementProperty self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementProperty_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_Curve3dElementProperty self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_Curve3dElementProperty_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_Curve3dElementProperty self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementProperty_DecrementRefCounter(self, *args)

Handle_StepFEA_Curve3dElementProperty_swigregister = _StepFEA.Handle_StepFEA_Curve3dElementProperty_swigregister
Handle_StepFEA_Curve3dElementProperty_swigregister(Handle_StepFEA_Curve3dElementProperty)

def Handle_StepFEA_Curve3dElementProperty_DownCast(thing):
    return _StepFEA.Handle_StepFEA_Curve3dElementProperty_DownCast(thing)
Handle_StepFEA_Curve3dElementProperty_DownCast = _StepFEA.Handle_StepFEA_Curve3dElementProperty_DownCast

class Handle_StepFEA_DummyNode(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_DummyNode self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_DummyNode_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_DummyNode self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_DummyNode_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_DummyNode self, StepFEA_DummyNode thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_DummyNode_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_DummyNode self, Handle_StepFEA_DummyNode theHandle) -> Handle_StepFEA_DummyNode
        assign(Handle_StepFEA_DummyNode self, StepFEA_DummyNode thePtr) -> Handle_StepFEA_DummyNode
        assign(Handle_StepFEA_DummyNode self, Handle_StepFEA_DummyNode theHandle) -> Handle_StepFEA_DummyNode

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_DummyNode_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_DummyNode self) -> StepFEA_DummyNode

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_DummyNode_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_DummyNode self) -> StepFEA_DummyNode

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_DummyNode___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_DummyNode self) -> StepFEA_DummyNode

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_DummyNode___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_DummyNode___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_DummyNode___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_DummyNode(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_DummyNode_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_DummyNode

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_DummyNode self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_DummyNode_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_DummyNode_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_DummyNode_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepFEA_DummyNode self, Handle_TCollection_HAsciiString aRepresentation_Name, Handle_StepRepr_HArray1OfRepresentationItem aRepresentation_Items, Handle_StepRepr_RepresentationContext aRepresentation_ContextOfItems, Handle_StepFEA_FeaModel aModelRef)

        Initialize all fields (own and inherited)

        :type aRepresentation_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRepresentation_Items: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aRepresentation_ContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext
        :type aModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel

        """
        return _StepFEA.Handle_StepFEA_DummyNode_Init(self, *args)


    def ModelRef(self, *args):
        """
        ModelRef(Handle_StepFEA_DummyNode self) -> Handle_StepFEA_FeaModel

        Returns field ModelRef

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel

        """
        return _StepFEA.Handle_StepFEA_DummyNode_ModelRef(self, *args)


    def SetModelRef(self, *args):
        """
        SetModelRef(Handle_StepFEA_DummyNode self, Handle_StepFEA_FeaModel ModelRef)

        Set field ModelRef

        :type ModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel

        """
        return _StepFEA.Handle_StepFEA_DummyNode_SetModelRef(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_DummyNode self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_DummyNode_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_DummyNode self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_DummyNode_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepFEA_DummyNode self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepFEA.Handle_StepFEA_DummyNode_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepFEA_DummyNode self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepFEA.Handle_StepFEA_DummyNode_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepFEA_DummyNode self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepFEA.Handle_StepFEA_DummyNode_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepFEA_DummyNode self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_DummyNode_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepFEA_DummyNode self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepFEA.Handle_StepFEA_DummyNode_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepFEA_DummyNode self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepFEA.Handle_StepFEA_DummyNode_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_DummyNode self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_DummyNode_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_DummyNode self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_DummyNode self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_DummyNode_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_DummyNode self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_DummyNode self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_DummyNode_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_DummyNode self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_DummyNode_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_DummyNode self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_DummyNode_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_DummyNode self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_DummyNode_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_DummyNode self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_DummyNode_DecrementRefCounter(self, *args)

Handle_StepFEA_DummyNode_swigregister = _StepFEA.Handle_StepFEA_DummyNode_swigregister
Handle_StepFEA_DummyNode_swigregister(Handle_StepFEA_DummyNode)

def Handle_StepFEA_DummyNode_DownCast(thing):
    return _StepFEA.Handle_StepFEA_DummyNode_DownCast(thing)
Handle_StepFEA_DummyNode_DownCast = _StepFEA.Handle_StepFEA_DummyNode_DownCast

class StepFEA_HSequenceOfElementGeometricRelationship(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_HSequenceOfElementGeometricRelationship
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_HSequenceOfElementGeometricRelationship(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_HSequenceOfElementGeometricRelationship self) -> StepFEA_HSequenceOfElementGeometricRelationship
        __init__(StepFEA_HSequenceOfElementGeometricRelationship self, NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship theOther) -> StepFEA_HSequenceOfElementGeometricRelationship

        :type theOther: OCC.wrapper.StepFEA.StepFEA_SequenceOfElementGeometricRelationship

        """
        this = _StepFEA.new_StepFEA_HSequenceOfElementGeometricRelationship(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.StepFEA.StepFEA_SequenceOfElementGeometricRelationship

        """
        res = _StepFEA.StepFEA_HSequenceOfElementGeometricRelationship_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(StepFEA_HSequenceOfElementGeometricRelationship self, Handle_StepFEA_ElementGeometricRelationship theItem)
        Append(StepFEA_HSequenceOfElementGeometricRelationship self, NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship theSequence)

        :type theSequence: OCC.wrapper.StepFEA.StepFEA_SequenceOfElementGeometricRelationship

        """
        return _StepFEA.StepFEA_HSequenceOfElementGeometricRelationship_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(StepFEA_HSequenceOfElementGeometricRelationship self) -> NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship

        :rtype: OCC.wrapper.StepFEA.StepFEA_SequenceOfElementGeometricRelationship

        """
        return _StepFEA.StepFEA_HSequenceOfElementGeometricRelationship_ChangeSequence(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_HSequenceOfElementGeometricRelationship_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_HSequenceOfElementGeometricRelationship_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_HSequenceOfElementGeometricRelationship_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_HSequenceOfElementGeometricRelationship
StepFEA_HSequenceOfElementGeometricRelationship_swigregister = _StepFEA.StepFEA_HSequenceOfElementGeometricRelationship_swigregister
StepFEA_HSequenceOfElementGeometricRelationship_swigregister(StepFEA_HSequenceOfElementGeometricRelationship)

def StepFEA_HSequenceOfElementGeometricRelationship_get_type_name(*args):
    """
    StepFEA_HSequenceOfElementGeometricRelationship_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_HSequenceOfElementGeometricRelationship_get_type_name(*args)

def StepFEA_HSequenceOfElementGeometricRelationship_get_type_descriptor(*args):
    """
    StepFEA_HSequenceOfElementGeometricRelationship_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_HSequenceOfElementGeometricRelationship_get_type_descriptor(*args)

class Handle_StepFEA_Curve3dElementRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_Curve3dElementRepresentation self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_Curve3dElementRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_Curve3dElementRepresentation self, StepFEA_Curve3dElementRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_Curve3dElementRepresentation self, Handle_StepFEA_Curve3dElementRepresentation theHandle) -> Handle_StepFEA_Curve3dElementRepresentation
        assign(Handle_StepFEA_Curve3dElementRepresentation self, StepFEA_Curve3dElementRepresentation thePtr) -> Handle_StepFEA_Curve3dElementRepresentation
        assign(Handle_StepFEA_Curve3dElementRepresentation self, Handle_StepFEA_Curve3dElementRepresentation theHandle) -> Handle_StepFEA_Curve3dElementRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_Curve3dElementRepresentation self) -> StepFEA_Curve3dElementRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_Curve3dElementRepresentation self) -> StepFEA_Curve3dElementRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_Curve3dElementRepresentation self) -> StepFEA_Curve3dElementRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_Curve3dElementRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_Curve3dElementRepresentation_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_Curve3dElementRepresentation

    def Init(self, *args):
        """
        Init(Handle_StepFEA_Curve3dElementRepresentation self, Handle_TCollection_HAsciiString aRepresentation_Name, Handle_StepRepr_HArray1OfRepresentationItem aRepresentation_Items, Handle_StepRepr_RepresentationContext aRepresentation_ContextOfItems, Handle_StepFEA_HArray1OfNodeRepresentation aElementRepresentation_NodeList, Handle_StepFEA_FeaModel3d aModelRef, Handle_StepElement_Curve3dElementDescriptor aElementDescriptor, Handle_StepFEA_Curve3dElementProperty aProperty, Handle_StepElement_ElementMaterial aMaterial)

        Initialize all fields (own and inherited)

        :type aRepresentation_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRepresentation_Items: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aRepresentation_ContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext
        :type aElementRepresentation_NodeList: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation
        :type aModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel3d
        :type aElementDescriptor: OCC.wrapper.StepElement.Handle_StepElement_Curve3dElementDescriptor
        :type aProperty: OCC.wrapper.StepFEA.Handle_StepFEA_Curve3dElementProperty
        :type aMaterial: OCC.wrapper.StepElement.Handle_StepElement_ElementMaterial

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_Init(self, *args)


    def ModelRef(self, *args):
        """
        ModelRef(Handle_StepFEA_Curve3dElementRepresentation self) -> Handle_StepFEA_FeaModel3d

        Returns field ModelRef

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel3d

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_ModelRef(self, *args)


    def SetModelRef(self, *args):
        """
        SetModelRef(Handle_StepFEA_Curve3dElementRepresentation self, Handle_StepFEA_FeaModel3d ModelRef)

        Set field ModelRef

        :type ModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel3d

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_SetModelRef(self, *args)


    def ElementDescriptor(self, *args):
        """
        ElementDescriptor(Handle_StepFEA_Curve3dElementRepresentation self) -> Handle_StepElement_Curve3dElementDescriptor

        Returns field ElementDescriptor

        :rtype: OCC.wrapper.StepElement.Handle_StepElement_Curve3dElementDescriptor

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_ElementDescriptor(self, *args)


    def SetElementDescriptor(self, *args):
        """
        SetElementDescriptor(Handle_StepFEA_Curve3dElementRepresentation self, Handle_StepElement_Curve3dElementDescriptor ElementDescriptor)

        Set field ElementDescriptor

        :type ElementDescriptor: OCC.wrapper.StepElement.Handle_StepElement_Curve3dElementDescriptor

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_SetElementDescriptor(self, *args)


    def Property(self, *args):
        """
        Property(Handle_StepFEA_Curve3dElementRepresentation self) -> Handle_StepFEA_Curve3dElementProperty

        Returns field Property

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_Curve3dElementProperty

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_Property(self, *args)


    def SetProperty(self, *args):
        """
        SetProperty(Handle_StepFEA_Curve3dElementRepresentation self, Handle_StepFEA_Curve3dElementProperty Property)

        Set field Property

        :type Property: OCC.wrapper.StepFEA.Handle_StepFEA_Curve3dElementProperty

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_SetProperty(self, *args)


    def Material(self, *args):
        """
        Material(Handle_StepFEA_Curve3dElementRepresentation self) -> Handle_StepElement_ElementMaterial

        Returns field Material

        :rtype: OCC.wrapper.StepElement.Handle_StepElement_ElementMaterial

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_StepFEA_Curve3dElementRepresentation self, Handle_StepElement_ElementMaterial Material)

        Set field Material

        :type Material: OCC.wrapper.StepElement.Handle_StepElement_ElementMaterial

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_SetMaterial(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_Curve3dElementRepresentation self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NodeList(self, *args):
        """
        NodeList(Handle_StepFEA_Curve3dElementRepresentation self) -> Handle_StepFEA_HArray1OfNodeRepresentation

        Returns field NodeList

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_NodeList(self, *args)


    def SetNodeList(self, *args):
        """
        SetNodeList(Handle_StepFEA_Curve3dElementRepresentation self, Handle_StepFEA_HArray1OfNodeRepresentation NodeList)

        Set field NodeList

        :type NodeList: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_SetNodeList(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_Curve3dElementRepresentation self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_Curve3dElementRepresentation self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepFEA_Curve3dElementRepresentation self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepFEA_Curve3dElementRepresentation self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepFEA_Curve3dElementRepresentation self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepFEA_Curve3dElementRepresentation self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepFEA_Curve3dElementRepresentation self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepFEA_Curve3dElementRepresentation self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_Curve3dElementRepresentation self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_Curve3dElementRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_Curve3dElementRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_Curve3dElementRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_Curve3dElementRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_Curve3dElementRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_Curve3dElementRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_Curve3dElementRepresentation self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_Curve3dElementRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_DecrementRefCounter(self, *args)

Handle_StepFEA_Curve3dElementRepresentation_swigregister = _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_swigregister
Handle_StepFEA_Curve3dElementRepresentation_swigregister(Handle_StepFEA_Curve3dElementRepresentation)

def Handle_StepFEA_Curve3dElementRepresentation_DownCast(thing):
    return _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_DownCast(thing)
Handle_StepFEA_Curve3dElementRepresentation_DownCast = _StepFEA.Handle_StepFEA_Curve3dElementRepresentation_DownCast

class StepFEA_HArray1OfCurveElementEndRelease(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_HArray1OfCurveElementEndRelease
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_HArray1OfCurveElementEndRelease(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_HArray1OfCurveElementEndRelease self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepFEA_HArray1OfCurveElementEndRelease
        __init__(StepFEA_HArray1OfCurveElementEndRelease self, Standard_Integer const theLower, Standard_Integer const theUpper, Handle_StepFEA_CurveElementEndRelease theValue) -> StepFEA_HArray1OfCurveElementEndRelease
        __init__(StepFEA_HArray1OfCurveElementEndRelease self, NCollection_Array1_Handle_StepFEA_CurveElementEndRelease theOther) -> StepFEA_HArray1OfCurveElementEndRelease

        :type theOther: OCC.wrapper.StepFEA.StepFEA_Array1OfCurveElementEndRelease

        """
        this = _StepFEA.new_StepFEA_HArray1OfCurveElementEndRelease(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepFEA.StepFEA_Array1OfCurveElementEndRelease

        """
        res = _StepFEA.StepFEA_HArray1OfCurveElementEndRelease_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepFEA_HArray1OfCurveElementEndRelease self) -> NCollection_Array1_Handle_StepFEA_CurveElementEndRelease

        :rtype: OCC.wrapper.StepFEA.StepFEA_Array1OfCurveElementEndRelease

        """
        return _StepFEA.StepFEA_HArray1OfCurveElementEndRelease_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_HArray1OfCurveElementEndRelease_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_HArray1OfCurveElementEndRelease_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_HArray1OfCurveElementEndRelease_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_HArray1OfCurveElementEndRelease
StepFEA_HArray1OfCurveElementEndRelease_swigregister = _StepFEA.StepFEA_HArray1OfCurveElementEndRelease_swigregister
StepFEA_HArray1OfCurveElementEndRelease_swigregister(StepFEA_HArray1OfCurveElementEndRelease)

def StepFEA_HArray1OfCurveElementEndRelease_get_type_name(*args):
    """
    StepFEA_HArray1OfCurveElementEndRelease_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_HArray1OfCurveElementEndRelease_get_type_name(*args)

def StepFEA_HArray1OfCurveElementEndRelease_get_type_descriptor(*args):
    """
    StepFEA_HArray1OfCurveElementEndRelease_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_HArray1OfCurveElementEndRelease_get_type_descriptor(*args)

class Handle_StepFEA_NodeGroup(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_NodeGroup self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_NodeGroup_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_NodeGroup self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_NodeGroup_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_NodeGroup self, StepFEA_NodeGroup thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_NodeGroup_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_NodeGroup self, Handle_StepFEA_NodeGroup theHandle) -> Handle_StepFEA_NodeGroup
        assign(Handle_StepFEA_NodeGroup self, StepFEA_NodeGroup thePtr) -> Handle_StepFEA_NodeGroup
        assign(Handle_StepFEA_NodeGroup self, Handle_StepFEA_NodeGroup theHandle) -> Handle_StepFEA_NodeGroup

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_NodeGroup_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_NodeGroup self) -> StepFEA_NodeGroup

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_NodeGroup_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_NodeGroup self) -> StepFEA_NodeGroup

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_NodeGroup___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_NodeGroup self) -> StepFEA_NodeGroup

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_NodeGroup___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_NodeGroup___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_NodeGroup___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_NodeGroup(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_NodeGroup_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_NodeGroup

    def Init(self, *args):
        """
        Init(Handle_StepFEA_NodeGroup self, Handle_TCollection_HAsciiString aGroup_Name, Handle_TCollection_HAsciiString aGroup_Description, Handle_StepFEA_FeaModel aFeaGroup_ModelRef, Handle_StepFEA_HArray1OfNodeRepresentation aNodes)

        Initialize all fields (own and inherited)

        :type aGroup_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aGroup_Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFeaGroup_ModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel
        :type aNodes: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation

        """
        return _StepFEA.Handle_StepFEA_NodeGroup_Init(self, *args)


    def Nodes(self, *args):
        """
        Nodes(Handle_StepFEA_NodeGroup self) -> Handle_StepFEA_HArray1OfNodeRepresentation

        Returns field Nodes

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation

        """
        return _StepFEA.Handle_StepFEA_NodeGroup_Nodes(self, *args)


    def SetNodes(self, *args):
        """
        SetNodes(Handle_StepFEA_NodeGroup self, Handle_StepFEA_HArray1OfNodeRepresentation Nodes)

        Set field Nodes

        :type Nodes: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation

        """
        return _StepFEA.Handle_StepFEA_NodeGroup_SetNodes(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_NodeGroup self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_NodeGroup_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_NodeGroup_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_NodeGroup_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ModelRef(self, *args):
        """
        ModelRef(Handle_StepFEA_NodeGroup self) -> Handle_StepFEA_FeaModel

        Returns field ModelRef

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel

        """
        return _StepFEA.Handle_StepFEA_NodeGroup_ModelRef(self, *args)


    def SetModelRef(self, *args):
        """
        SetModelRef(Handle_StepFEA_NodeGroup self, Handle_StepFEA_FeaModel ModelRef)

        Set field ModelRef

        :type ModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel

        """
        return _StepFEA.Handle_StepFEA_NodeGroup_SetModelRef(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_NodeGroup self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_NodeGroup_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_NodeGroup self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_NodeGroup_SetName(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepFEA_NodeGroup self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_NodeGroup_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepFEA_NodeGroup self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_NodeGroup_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(Handle_StepFEA_NodeGroup self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_NodeGroup_HasDescription(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_NodeGroup self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_NodeGroup_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_NodeGroup self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_NodeGroup self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_NodeGroup_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_NodeGroup self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_NodeGroup self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_NodeGroup_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_NodeGroup self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_NodeGroup_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_NodeGroup self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_NodeGroup_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_NodeGroup self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_NodeGroup_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_NodeGroup self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_NodeGroup_DecrementRefCounter(self, *args)

Handle_StepFEA_NodeGroup_swigregister = _StepFEA.Handle_StepFEA_NodeGroup_swigregister
Handle_StepFEA_NodeGroup_swigregister(Handle_StepFEA_NodeGroup)

def Handle_StepFEA_NodeGroup_DownCast(thing):
    return _StepFEA.Handle_StepFEA_NodeGroup_DownCast(thing)
Handle_StepFEA_NodeGroup_DownCast = _StepFEA.Handle_StepFEA_NodeGroup_DownCast

class Handle_StepFEA_HArray1OfCurveElementEndRelease(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_HArray1OfCurveElementEndRelease self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndRelease_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_HArray1OfCurveElementEndRelease self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndRelease_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_HArray1OfCurveElementEndRelease self, StepFEA_HArray1OfCurveElementEndRelease thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndRelease_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_HArray1OfCurveElementEndRelease self, Handle_StepFEA_HArray1OfCurveElementEndRelease theHandle) -> Handle_StepFEA_HArray1OfCurveElementEndRelease
        assign(Handle_StepFEA_HArray1OfCurveElementEndRelease self, StepFEA_HArray1OfCurveElementEndRelease thePtr) -> Handle_StepFEA_HArray1OfCurveElementEndRelease
        assign(Handle_StepFEA_HArray1OfCurveElementEndRelease self, Handle_StepFEA_HArray1OfCurveElementEndRelease theHandle) -> Handle_StepFEA_HArray1OfCurveElementEndRelease

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndRelease_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_HArray1OfCurveElementEndRelease self) -> StepFEA_HArray1OfCurveElementEndRelease

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndRelease_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_HArray1OfCurveElementEndRelease self) -> StepFEA_HArray1OfCurveElementEndRelease

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndRelease___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_HArray1OfCurveElementEndRelease self) -> StepFEA_HArray1OfCurveElementEndRelease

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndRelease___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndRelease___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndRelease___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_HArray1OfCurveElementEndRelease(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_HArray1OfCurveElementEndRelease_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_HArray1OfCurveElementEndRelease

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepFEA.StepFEA_Array1OfCurveElementEndRelease

        """
        res = _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndRelease_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepFEA_HArray1OfCurveElementEndRelease self) -> NCollection_Array1_Handle_StepFEA_CurveElementEndRelease

        :rtype: OCC.wrapper.StepFEA.StepFEA_Array1OfCurveElementEndRelease

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndRelease_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_HArray1OfCurveElementEndRelease self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndRelease_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndRelease_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndRelease_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_HArray1OfCurveElementEndRelease self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndRelease_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_HArray1OfCurveElementEndRelease self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_HArray1OfCurveElementEndRelease self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndRelease_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_HArray1OfCurveElementEndRelease self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_HArray1OfCurveElementEndRelease self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndRelease_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_HArray1OfCurveElementEndRelease self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndRelease_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_HArray1OfCurveElementEndRelease self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndRelease_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_HArray1OfCurveElementEndRelease self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndRelease_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_HArray1OfCurveElementEndRelease self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndRelease_DecrementRefCounter(self, *args)

Handle_StepFEA_HArray1OfCurveElementEndRelease_swigregister = _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndRelease_swigregister
Handle_StepFEA_HArray1OfCurveElementEndRelease_swigregister(Handle_StepFEA_HArray1OfCurveElementEndRelease)

def Handle_StepFEA_HArray1OfCurveElementEndRelease_DownCast(thing):
    return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndRelease_DownCast(thing)
Handle_StepFEA_HArray1OfCurveElementEndRelease_DownCast = _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndRelease_DownCast

class StepFEA_HArray1OfElementRepresentation(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_HArray1OfElementRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_HArray1OfElementRepresentation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_HArray1OfElementRepresentation self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepFEA_HArray1OfElementRepresentation
        __init__(StepFEA_HArray1OfElementRepresentation self, Standard_Integer const theLower, Standard_Integer const theUpper, Handle_StepFEA_ElementRepresentation theValue) -> StepFEA_HArray1OfElementRepresentation
        __init__(StepFEA_HArray1OfElementRepresentation self, NCollection_Array1_Handle_StepFEA_ElementRepresentation theOther) -> StepFEA_HArray1OfElementRepresentation

        :type theOther: OCC.wrapper.StepFEA.StepFEA_Array1OfElementRepresentation

        """
        this = _StepFEA.new_StepFEA_HArray1OfElementRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepFEA.StepFEA_Array1OfElementRepresentation

        """
        res = _StepFEA.StepFEA_HArray1OfElementRepresentation_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepFEA_HArray1OfElementRepresentation self) -> NCollection_Array1_Handle_StepFEA_ElementRepresentation

        :rtype: OCC.wrapper.StepFEA.StepFEA_Array1OfElementRepresentation

        """
        return _StepFEA.StepFEA_HArray1OfElementRepresentation_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_HArray1OfElementRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_HArray1OfElementRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_HArray1OfElementRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_HArray1OfElementRepresentation
StepFEA_HArray1OfElementRepresentation_swigregister = _StepFEA.StepFEA_HArray1OfElementRepresentation_swigregister
StepFEA_HArray1OfElementRepresentation_swigregister(StepFEA_HArray1OfElementRepresentation)

def StepFEA_HArray1OfElementRepresentation_get_type_name(*args):
    """
    StepFEA_HArray1OfElementRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_HArray1OfElementRepresentation_get_type_name(*args)

def StepFEA_HArray1OfElementRepresentation_get_type_descriptor(*args):
    """
    StepFEA_HArray1OfElementRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_HArray1OfElementRepresentation_get_type_descriptor(*args)

class Handle_StepFEA_ParametricSurface3dElementCoordinateSystem(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_ParametricSurface3dElementCoordinateSystem self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_ParametricSurface3dElementCoordinateSystem_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_ParametricSurface3dElementCoordinateSystem self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_ParametricSurface3dElementCoordinateSystem_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_ParametricSurface3dElementCoordinateSystem self, StepFEA_ParametricSurface3dElementCoordinateSystem thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_ParametricSurface3dElementCoordinateSystem_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_ParametricSurface3dElementCoordinateSystem self, Handle_StepFEA_ParametricSurface3dElementCoordinateSystem theHandle) -> Handle_StepFEA_ParametricSurface3dElementCoordinateSystem
        assign(Handle_StepFEA_ParametricSurface3dElementCoordinateSystem self, StepFEA_ParametricSurface3dElementCoordinateSystem thePtr) -> Handle_StepFEA_ParametricSurface3dElementCoordinateSystem
        assign(Handle_StepFEA_ParametricSurface3dElementCoordinateSystem self, Handle_StepFEA_ParametricSurface3dElementCoordinateSystem theHandle) -> Handle_StepFEA_ParametricSurface3dElementCoordinateSystem

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_ParametricSurface3dElementCoordinateSystem_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_ParametricSurface3dElementCoordinateSystem self) -> StepFEA_ParametricSurface3dElementCoordinateSystem

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_ParametricSurface3dElementCoordinateSystem_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_ParametricSurface3dElementCoordinateSystem self) -> StepFEA_ParametricSurface3dElementCoordinateSystem

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_ParametricSurface3dElementCoordinateSystem___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_ParametricSurface3dElementCoordinateSystem self) -> StepFEA_ParametricSurface3dElementCoordinateSystem

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_ParametricSurface3dElementCoordinateSystem___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_ParametricSurface3dElementCoordinateSystem___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_ParametricSurface3dElementCoordinateSystem___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_ParametricSurface3dElementCoordinateSystem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_ParametricSurface3dElementCoordinateSystem_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_ParametricSurface3dElementCoordinateSystem

    def Init(self, *args):
        """
        Init(Handle_StepFEA_ParametricSurface3dElementCoordinateSystem self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Standard_Integer const aAxis, Standard_Real const aAngle)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aAxis: int
        :type aAngle: float

        """
        return _StepFEA.Handle_StepFEA_ParametricSurface3dElementCoordinateSystem_Init(self, *args)


    def Axis(self, *args):
        """
        Axis(Handle_StepFEA_ParametricSurface3dElementCoordinateSystem self) -> Standard_Integer

        Returns field Axis

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_ParametricSurface3dElementCoordinateSystem_Axis(self, *args)


    def SetAxis(self, *args):
        """
        SetAxis(Handle_StepFEA_ParametricSurface3dElementCoordinateSystem self, Standard_Integer const Axis)

        Set field Axis

        :type Axis: int

        """
        return _StepFEA.Handle_StepFEA_ParametricSurface3dElementCoordinateSystem_SetAxis(self, *args)


    def Angle(self, *args):
        """
        Angle(Handle_StepFEA_ParametricSurface3dElementCoordinateSystem self) -> Standard_Real

        Returns field Angle

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepFEA.Handle_StepFEA_ParametricSurface3dElementCoordinateSystem_Angle(self, *args)


    def SetAngle(self, *args):
        """
        SetAngle(Handle_StepFEA_ParametricSurface3dElementCoordinateSystem self, Standard_Real const Angle)

        Set field Angle

        :type Angle: float

        """
        return _StepFEA.Handle_StepFEA_ParametricSurface3dElementCoordinateSystem_SetAngle(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_ParametricSurface3dElementCoordinateSystem self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_ParametricSurface3dElementCoordinateSystem_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_ParametricSurface3dElementCoordinateSystem_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_ParametricSurface3dElementCoordinateSystem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_ParametricSurface3dElementCoordinateSystem self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_ParametricSurface3dElementCoordinateSystem_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_ParametricSurface3dElementCoordinateSystem self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_ParametricSurface3dElementCoordinateSystem_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_ParametricSurface3dElementCoordinateSystem self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_ParametricSurface3dElementCoordinateSystem_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_ParametricSurface3dElementCoordinateSystem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_ParametricSurface3dElementCoordinateSystem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_ParametricSurface3dElementCoordinateSystem_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_ParametricSurface3dElementCoordinateSystem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_ParametricSurface3dElementCoordinateSystem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_ParametricSurface3dElementCoordinateSystem_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_ParametricSurface3dElementCoordinateSystem self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_ParametricSurface3dElementCoordinateSystem_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_ParametricSurface3dElementCoordinateSystem self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_ParametricSurface3dElementCoordinateSystem_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_ParametricSurface3dElementCoordinateSystem self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_ParametricSurface3dElementCoordinateSystem_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_ParametricSurface3dElementCoordinateSystem self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_ParametricSurface3dElementCoordinateSystem_DecrementRefCounter(self, *args)

Handle_StepFEA_ParametricSurface3dElementCoordinateSystem_swigregister = _StepFEA.Handle_StepFEA_ParametricSurface3dElementCoordinateSystem_swigregister
Handle_StepFEA_ParametricSurface3dElementCoordinateSystem_swigregister(Handle_StepFEA_ParametricSurface3dElementCoordinateSystem)

def Handle_StepFEA_ParametricSurface3dElementCoordinateSystem_DownCast(thing):
    return _StepFEA.Handle_StepFEA_ParametricSurface3dElementCoordinateSystem_DownCast(thing)
Handle_StepFEA_ParametricSurface3dElementCoordinateSystem_DownCast = _StepFEA.Handle_StepFEA_ParametricSurface3dElementCoordinateSystem_DownCast

class Handle_StepFEA_FeaMoistureAbsorption(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_FeaMoistureAbsorption self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_FeaMoistureAbsorption_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_FeaMoistureAbsorption self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_FeaMoistureAbsorption_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_FeaMoistureAbsorption self, StepFEA_FeaMoistureAbsorption thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_FeaMoistureAbsorption_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_FeaMoistureAbsorption self, Handle_StepFEA_FeaMoistureAbsorption theHandle) -> Handle_StepFEA_FeaMoistureAbsorption
        assign(Handle_StepFEA_FeaMoistureAbsorption self, StepFEA_FeaMoistureAbsorption thePtr) -> Handle_StepFEA_FeaMoistureAbsorption
        assign(Handle_StepFEA_FeaMoistureAbsorption self, Handle_StepFEA_FeaMoistureAbsorption theHandle) -> Handle_StepFEA_FeaMoistureAbsorption

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_FeaMoistureAbsorption_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_FeaMoistureAbsorption self) -> StepFEA_FeaMoistureAbsorption

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaMoistureAbsorption_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_FeaMoistureAbsorption self) -> StepFEA_FeaMoistureAbsorption

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaMoistureAbsorption___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_FeaMoistureAbsorption self) -> StepFEA_FeaMoistureAbsorption

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_FeaMoistureAbsorption___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_FeaMoistureAbsorption___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_FeaMoistureAbsorption___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_FeaMoistureAbsorption(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_FeaMoistureAbsorption_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_FeaMoistureAbsorption

    def Init(self, *args):
        """
        Init(Handle_StepFEA_FeaMoistureAbsorption self, Handle_TCollection_HAsciiString aRepresentationItem_Name, StepFEA_SymmetricTensor23d aFeaConstants)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFeaConstants: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor23d

        """
        return _StepFEA.Handle_StepFEA_FeaMoistureAbsorption_Init(self, *args)


    def FeaConstants(self, *args):
        """
        FeaConstants(Handle_StepFEA_FeaMoistureAbsorption self) -> StepFEA_SymmetricTensor23d

        Returns field FeaConstants

        :rtype: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor23d

        """
        return _StepFEA.Handle_StepFEA_FeaMoistureAbsorption_FeaConstants(self, *args)


    def SetFeaConstants(self, *args):
        """
        SetFeaConstants(Handle_StepFEA_FeaMoistureAbsorption self, StepFEA_SymmetricTensor23d FeaConstants)

        Set field FeaConstants

        :type FeaConstants: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor23d

        """
        return _StepFEA.Handle_StepFEA_FeaMoistureAbsorption_SetFeaConstants(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_FeaMoistureAbsorption self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_FeaMoistureAbsorption_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaMoistureAbsorption_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaMoistureAbsorption_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_FeaMoistureAbsorption self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaMoistureAbsorption_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_FeaMoistureAbsorption self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaMoistureAbsorption_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_FeaMoistureAbsorption self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_FeaMoistureAbsorption_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_FeaMoistureAbsorption self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_FeaMoistureAbsorption self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaMoistureAbsorption_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_FeaMoistureAbsorption self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_FeaMoistureAbsorption self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaMoistureAbsorption_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_FeaMoistureAbsorption self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_FeaMoistureAbsorption_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_FeaMoistureAbsorption self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaMoistureAbsorption_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_FeaMoistureAbsorption self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_FeaMoistureAbsorption_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_FeaMoistureAbsorption self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaMoistureAbsorption_DecrementRefCounter(self, *args)

Handle_StepFEA_FeaMoistureAbsorption_swigregister = _StepFEA.Handle_StepFEA_FeaMoistureAbsorption_swigregister
Handle_StepFEA_FeaMoistureAbsorption_swigregister(Handle_StepFEA_FeaMoistureAbsorption)

def Handle_StepFEA_FeaMoistureAbsorption_DownCast(thing):
    return _StepFEA.Handle_StepFEA_FeaMoistureAbsorption_DownCast(thing)
Handle_StepFEA_FeaMoistureAbsorption_DownCast = _StepFEA.Handle_StepFEA_FeaMoistureAbsorption_DownCast

class StepFEA_FreedomsList(Standard.Standard_Transient):
    """Representation of STEP entity FreedomsList"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_FreedomsList
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_FreedomsList(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_FreedomsList self) -> StepFEA_FreedomsList

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_FreedomsList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_FreedomsList self, Handle_StepFEA_HArray1OfDegreeOfFreedom aFreedoms)

        Initialize all fields (own and inherited)

        :type aFreedoms: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfDegreeOfFreedom

        """
        return _StepFEA.StepFEA_FreedomsList_Init(self, *args)


    def Freedoms(self, *args):
        """
        Freedoms(StepFEA_FreedomsList self) -> Handle_StepFEA_HArray1OfDegreeOfFreedom

        Returns field Freedoms

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfDegreeOfFreedom

        """
        return _StepFEA.StepFEA_FreedomsList_Freedoms(self, *args)


    def SetFreedoms(self, *args):
        """
        SetFreedoms(StepFEA_FreedomsList self, Handle_StepFEA_HArray1OfDegreeOfFreedom Freedoms)

        Set field Freedoms

        :type Freedoms: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfDegreeOfFreedom

        """
        return _StepFEA.StepFEA_FreedomsList_SetFreedoms(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_FreedomsList_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_FreedomsList_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_FreedomsList_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_FreedomsList
StepFEA_FreedomsList_swigregister = _StepFEA.StepFEA_FreedomsList_swigregister
StepFEA_FreedomsList_swigregister(StepFEA_FreedomsList)

def StepFEA_FreedomsList_get_type_name(*args):
    """
    StepFEA_FreedomsList_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_FreedomsList_get_type_name(*args)

def StepFEA_FreedomsList_get_type_descriptor(*args):
    """
    StepFEA_FreedomsList_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_FreedomsList_get_type_descriptor(*args)

class NCollection_Array1_StepFEA_DegreeOfFreedom(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_StepFEA_DegreeOfFreedom self) -> NCollection_Array1< StepFEA_DegreeOfFreedom >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepFEA.NCollection_Array1_StepFEA_DegreeOfFreedom_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_StepFEA_DegreeOfFreedom self) -> NCollection_Array1< StepFEA_DegreeOfFreedom >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepFEA.NCollection_Array1_StepFEA_DegreeOfFreedom_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_StepFEA_DegreeOfFreedom self) -> NCollection_Array1< StepFEA_DegreeOfFreedom >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepFEA.NCollection_Array1_StepFEA_DegreeOfFreedom_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_StepFEA_DegreeOfFreedom self) -> NCollection_Array1< StepFEA_DegreeOfFreedom >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepFEA.NCollection_Array1_StepFEA_DegreeOfFreedom_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepFEA.new_NCollection_Array1_StepFEA_DegreeOfFreedom(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_StepFEA_DegreeOfFreedom self, StepFEA_DegreeOfFreedom theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepFEA.NCollection_Array1_StepFEA_DegreeOfFreedom_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_StepFEA_DegreeOfFreedom self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Array1_StepFEA_DegreeOfFreedom_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_StepFEA_DegreeOfFreedom self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Array1_StepFEA_DegreeOfFreedom_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_StepFEA_DegreeOfFreedom self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.NCollection_Array1_StepFEA_DegreeOfFreedom_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_StepFEA_DegreeOfFreedom self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Array1_StepFEA_DegreeOfFreedom_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_StepFEA_DegreeOfFreedom self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Array1_StepFEA_DegreeOfFreedom_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_StepFEA_DegreeOfFreedom self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.NCollection_Array1_StepFEA_DegreeOfFreedom_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_StepFEA_DegreeOfFreedom self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.NCollection_Array1_StepFEA_DegreeOfFreedom_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_StepFEA_DegreeOfFreedom self, NCollection_Array1_StepFEA_DegreeOfFreedom theOther) -> NCollection_Array1_StepFEA_DegreeOfFreedom

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepFEA.NCollection_Array1_StepFEA_DegreeOfFreedom_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_StepFEA_DegreeOfFreedom self, NCollection_Array1_StepFEA_DegreeOfFreedom theOther) -> NCollection_Array1_StepFEA_DegreeOfFreedom

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepFEA.NCollection_Array1_StepFEA_DegreeOfFreedom_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_StepFEA_DegreeOfFreedom self, NCollection_Array1_StepFEA_DegreeOfFreedom theOther) -> NCollection_Array1_StepFEA_DegreeOfFreedom
        assign(NCollection_Array1_StepFEA_DegreeOfFreedom self, NCollection_Array1_StepFEA_DegreeOfFreedom theOther) -> NCollection_Array1_StepFEA_DegreeOfFreedom

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepFEA.NCollection_Array1_StepFEA_DegreeOfFreedom_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Array1_StepFEA_DegreeOfFreedom_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_StepFEA_DegreeOfFreedom self) -> StepFEA_DegreeOfFreedom

        @return first element

        :rtype: TheItemType &

        """
        return _StepFEA.NCollection_Array1_StepFEA_DegreeOfFreedom_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Array1_StepFEA_DegreeOfFreedom_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_StepFEA_DegreeOfFreedom self) -> StepFEA_DegreeOfFreedom

        @return last element

        :rtype: TheItemType &

        """
        return _StepFEA.NCollection_Array1_StepFEA_DegreeOfFreedom_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Array1_StepFEA_DegreeOfFreedom_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_StepFEA_DegreeOfFreedom self, Standard_Integer const theIndex) -> StepFEA_DegreeOfFreedom

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepFEA.NCollection_Array1_StepFEA_DegreeOfFreedom_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Array1_StepFEA_DegreeOfFreedom___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Array1_StepFEA_DegreeOfFreedom_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_StepFEA_DegreeOfFreedom self, Standard_Integer const theIndex, StepFEA_DegreeOfFreedom theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepFEA.NCollection_Array1_StepFEA_DegreeOfFreedom_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_StepFEA_DegreeOfFreedom self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepFEA.NCollection_Array1_StepFEA_DegreeOfFreedom_Resize(self, *args)

    __swig_destroy__ = _StepFEA.delete_NCollection_Array1_StepFEA_DegreeOfFreedom
NCollection_Array1_StepFEA_DegreeOfFreedom_swigregister = _StepFEA.NCollection_Array1_StepFEA_DegreeOfFreedom_swigregister
NCollection_Array1_StepFEA_DegreeOfFreedom_swigregister(NCollection_Array1_StepFEA_DegreeOfFreedom)


try:
	StepFEA_Array1OfDegreeOfFreedom = NCollection_Array1_StepFEA_DegreeOfFreedom
except NameError:
	pass # does not exist, probably ignored

class StepFEA_ElementOrElementGroup(StepData.StepData_SelectType):
    """Representation of STEP SELECT type ElementOrElementGroup"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepFEA_ElementOrElementGroup self) -> StepFEA_ElementOrElementGroup

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_ElementOrElementGroup(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepFEA_ElementOrElementGroup self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a kind of ElementOrElementGroup select type
        1 -> ElementRepresentation from StepFEA
        2 -> ElementGroup from StepFEA
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.StepFEA_ElementOrElementGroup_CaseNum(self, *args)


    def ElementRepresentation(self, *args):
        """
        ElementRepresentation(StepFEA_ElementOrElementGroup self) -> Handle_StepFEA_ElementRepresentation

        Returns Value as ElementRepresentation (or Null if another type)

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_ElementRepresentation

        """
        return _StepFEA.StepFEA_ElementOrElementGroup_ElementRepresentation(self, *args)


    def ElementGroup(self, *args):
        """
        ElementGroup(StepFEA_ElementOrElementGroup self) -> Handle_StepFEA_ElementGroup

        Returns Value as ElementGroup (or Null if another type)

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_ElementGroup

        """
        return _StepFEA.StepFEA_ElementOrElementGroup_ElementGroup(self, *args)

    __swig_destroy__ = _StepFEA.delete_StepFEA_ElementOrElementGroup
StepFEA_ElementOrElementGroup_swigregister = _StepFEA.StepFEA_ElementOrElementGroup_swigregister
StepFEA_ElementOrElementGroup_swigregister(StepFEA_ElementOrElementGroup)

class StepFEA_FeaSecantCoefficientOfLinearThermalExpansion(StepFEA_FeaMaterialPropertyRepresentationItem):
    """Representation of STEP entity FeaSecantCoefficientOfLinearThermalExpansion"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_FeaSecantCoefficientOfLinearThermalExpansion self) -> StepFEA_FeaSecantCoefficientOfLinearThermalExpansion

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_FeaSecantCoefficientOfLinearThermalExpansion self, Handle_TCollection_HAsciiString aRepresentationItem_Name, StepFEA_SymmetricTensor23d aFeaConstants, Standard_Real const aReferenceTemperature)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFeaConstants: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor23d
        :type aReferenceTemperature: float

        """
        return _StepFEA.StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_Init(self, *args)


    def FeaConstants(self, *args):
        """
        FeaConstants(StepFEA_FeaSecantCoefficientOfLinearThermalExpansion self) -> StepFEA_SymmetricTensor23d

        Returns field FeaConstants

        :rtype: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor23d

        """
        return _StepFEA.StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_FeaConstants(self, *args)


    def SetFeaConstants(self, *args):
        """
        SetFeaConstants(StepFEA_FeaSecantCoefficientOfLinearThermalExpansion self, StepFEA_SymmetricTensor23d FeaConstants)

        Set field FeaConstants

        :type FeaConstants: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor23d

        """
        return _StepFEA.StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_SetFeaConstants(self, *args)


    def ReferenceTemperature(self, *args):
        """
        ReferenceTemperature(StepFEA_FeaSecantCoefficientOfLinearThermalExpansion self) -> Standard_Real

        Returns field ReferenceTemperature

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepFEA.StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_ReferenceTemperature(self, *args)


    def SetReferenceTemperature(self, *args):
        """
        SetReferenceTemperature(StepFEA_FeaSecantCoefficientOfLinearThermalExpansion self, Standard_Real const ReferenceTemperature)

        Set field ReferenceTemperature

        :type ReferenceTemperature: float

        """
        return _StepFEA.StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_SetReferenceTemperature(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion
StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_swigregister = _StepFEA.StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_swigregister
StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_swigregister(StepFEA_FeaSecantCoefficientOfLinearThermalExpansion)

def StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_get_type_name(*args):
    """
    StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_get_type_name(*args)

def StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_get_type_descriptor(*args):
    """
    StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_get_type_descriptor(*args)

class StepFEA_ParametricCurve3dElementCoordinateSystem(StepFEA_FeaRepresentationItem):
    """Representation of STEP entity ParametricCurve3dElementCoordinateSystem"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_ParametricCurve3dElementCoordinateSystem
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_ParametricCurve3dElementCoordinateSystem(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_ParametricCurve3dElementCoordinateSystem self) -> StepFEA_ParametricCurve3dElementCoordinateSystem

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_ParametricCurve3dElementCoordinateSystem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_ParametricCurve3dElementCoordinateSystem self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Handle_StepFEA_ParametricCurve3dElementCoordinateDirection aDirection)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aDirection: OCC.wrapper.StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateDirection

        """
        return _StepFEA.StepFEA_ParametricCurve3dElementCoordinateSystem_Init(self, *args)


    def Direction(self, *args):
        """
        Direction(StepFEA_ParametricCurve3dElementCoordinateSystem self) -> Handle_StepFEA_ParametricCurve3dElementCoordinateDirection

        Returns field Direction

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateDirection

        """
        return _StepFEA.StepFEA_ParametricCurve3dElementCoordinateSystem_Direction(self, *args)


    def SetDirection(self, *args):
        """
        SetDirection(StepFEA_ParametricCurve3dElementCoordinateSystem self, Handle_StepFEA_ParametricCurve3dElementCoordinateDirection Direction)

        Set field Direction

        :type Direction: OCC.wrapper.StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateDirection

        """
        return _StepFEA.StepFEA_ParametricCurve3dElementCoordinateSystem_SetDirection(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_ParametricCurve3dElementCoordinateSystem_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_ParametricCurve3dElementCoordinateSystem_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_ParametricCurve3dElementCoordinateSystem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_ParametricCurve3dElementCoordinateSystem
StepFEA_ParametricCurve3dElementCoordinateSystem_swigregister = _StepFEA.StepFEA_ParametricCurve3dElementCoordinateSystem_swigregister
StepFEA_ParametricCurve3dElementCoordinateSystem_swigregister(StepFEA_ParametricCurve3dElementCoordinateSystem)

def StepFEA_ParametricCurve3dElementCoordinateSystem_get_type_name(*args):
    """
    StepFEA_ParametricCurve3dElementCoordinateSystem_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_ParametricCurve3dElementCoordinateSystem_get_type_name(*args)

def StepFEA_ParametricCurve3dElementCoordinateSystem_get_type_descriptor(*args):
    """
    StepFEA_ParametricCurve3dElementCoordinateSystem_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_ParametricCurve3dElementCoordinateSystem_get_type_descriptor(*args)

class StepFEA_FeaSurfaceSectionGeometricRelationship(Standard.Standard_Transient):
    """Representation of STEP entity FeaSurfaceSectionGeometricRelationship"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_FeaSurfaceSectionGeometricRelationship
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_FeaSurfaceSectionGeometricRelationship(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_FeaSurfaceSectionGeometricRelationship self) -> StepFEA_FeaSurfaceSectionGeometricRelationship

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_FeaSurfaceSectionGeometricRelationship(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_FeaSurfaceSectionGeometricRelationship self, Handle_StepElement_SurfaceSection aSectionRef, Handle_StepElement_AnalysisItemWithinRepresentation aItem)

        Initialize all fields (own and inherited)

        :type aSectionRef: OCC.wrapper.StepElement.Handle_StepElement_SurfaceSection
        :type aItem: OCC.wrapper.StepElement.Handle_StepElement_AnalysisItemWithinRepresentation

        """
        return _StepFEA.StepFEA_FeaSurfaceSectionGeometricRelationship_Init(self, *args)


    def SectionRef(self, *args):
        """
        SectionRef(StepFEA_FeaSurfaceSectionGeometricRelationship self) -> Handle_StepElement_SurfaceSection

        Returns field SectionRef

        :rtype: OCC.wrapper.StepElement.Handle_StepElement_SurfaceSection

        """
        return _StepFEA.StepFEA_FeaSurfaceSectionGeometricRelationship_SectionRef(self, *args)


    def SetSectionRef(self, *args):
        """
        SetSectionRef(StepFEA_FeaSurfaceSectionGeometricRelationship self, Handle_StepElement_SurfaceSection SectionRef)

        Set field SectionRef

        :type SectionRef: OCC.wrapper.StepElement.Handle_StepElement_SurfaceSection

        """
        return _StepFEA.StepFEA_FeaSurfaceSectionGeometricRelationship_SetSectionRef(self, *args)


    def Item(self, *args):
        """
        Item(StepFEA_FeaSurfaceSectionGeometricRelationship self) -> Handle_StepElement_AnalysisItemWithinRepresentation

        Returns field Item

        :rtype: OCC.wrapper.StepElement.Handle_StepElement_AnalysisItemWithinRepresentation

        """
        return _StepFEA.StepFEA_FeaSurfaceSectionGeometricRelationship_Item(self, *args)


    def SetItem(self, *args):
        """
        SetItem(StepFEA_FeaSurfaceSectionGeometricRelationship self, Handle_StepElement_AnalysisItemWithinRepresentation Item)

        Set field Item

        :type Item: OCC.wrapper.StepElement.Handle_StepElement_AnalysisItemWithinRepresentation

        """
        return _StepFEA.StepFEA_FeaSurfaceSectionGeometricRelationship_SetItem(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_FeaSurfaceSectionGeometricRelationship_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_FeaSurfaceSectionGeometricRelationship_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_FeaSurfaceSectionGeometricRelationship_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_FeaSurfaceSectionGeometricRelationship
StepFEA_FeaSurfaceSectionGeometricRelationship_swigregister = _StepFEA.StepFEA_FeaSurfaceSectionGeometricRelationship_swigregister
StepFEA_FeaSurfaceSectionGeometricRelationship_swigregister(StepFEA_FeaSurfaceSectionGeometricRelationship)

def StepFEA_FeaSurfaceSectionGeometricRelationship_get_type_name(*args):
    """
    StepFEA_FeaSurfaceSectionGeometricRelationship_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_FeaSurfaceSectionGeometricRelationship_get_type_name(*args)

def StepFEA_FeaSurfaceSectionGeometricRelationship_get_type_descriptor(*args):
    """
    StepFEA_FeaSurfaceSectionGeometricRelationship_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_FeaSurfaceSectionGeometricRelationship_get_type_descriptor(*args)

class StepFEA_HArray1OfCurveElementEndOffset(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_HArray1OfCurveElementEndOffset
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_HArray1OfCurveElementEndOffset(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_HArray1OfCurveElementEndOffset self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepFEA_HArray1OfCurveElementEndOffset
        __init__(StepFEA_HArray1OfCurveElementEndOffset self, Standard_Integer const theLower, Standard_Integer const theUpper, Handle_StepFEA_CurveElementEndOffset theValue) -> StepFEA_HArray1OfCurveElementEndOffset
        __init__(StepFEA_HArray1OfCurveElementEndOffset self, NCollection_Array1_Handle_StepFEA_CurveElementEndOffset theOther) -> StepFEA_HArray1OfCurveElementEndOffset

        :type theOther: OCC.wrapper.StepFEA.StepFEA_Array1OfCurveElementEndOffset

        """
        this = _StepFEA.new_StepFEA_HArray1OfCurveElementEndOffset(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepFEA.StepFEA_Array1OfCurveElementEndOffset

        """
        res = _StepFEA.StepFEA_HArray1OfCurveElementEndOffset_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepFEA_HArray1OfCurveElementEndOffset self) -> NCollection_Array1_Handle_StepFEA_CurveElementEndOffset

        :rtype: OCC.wrapper.StepFEA.StepFEA_Array1OfCurveElementEndOffset

        """
        return _StepFEA.StepFEA_HArray1OfCurveElementEndOffset_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_HArray1OfCurveElementEndOffset_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_HArray1OfCurveElementEndOffset_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_HArray1OfCurveElementEndOffset_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_HArray1OfCurveElementEndOffset
StepFEA_HArray1OfCurveElementEndOffset_swigregister = _StepFEA.StepFEA_HArray1OfCurveElementEndOffset_swigregister
StepFEA_HArray1OfCurveElementEndOffset_swigregister(StepFEA_HArray1OfCurveElementEndOffset)

def StepFEA_HArray1OfCurveElementEndOffset_get_type_name(*args):
    """
    StepFEA_HArray1OfCurveElementEndOffset_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_HArray1OfCurveElementEndOffset_get_type_name(*args)

def StepFEA_HArray1OfCurveElementEndOffset_get_type_descriptor(*args):
    """
    StepFEA_HArray1OfCurveElementEndOffset_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_HArray1OfCurveElementEndOffset_get_type_descriptor(*args)

class StepFEA_SymmetricTensor23d(StepData.StepData_SelectType):
    """Representation of STEP SELECT type SymmetricTensor23d"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepFEA_SymmetricTensor23d self) -> StepFEA_SymmetricTensor23d

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_SymmetricTensor23d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepFEA_SymmetricTensor23d self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a kind of SymmetricTensor23d select type
        return 0

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.StepFEA_SymmetricTensor23d_CaseNum(self, *args)


    def CaseMem(self, *args):
        """
        CaseMem(StepFEA_SymmetricTensor23d self, Handle_StepData_SelectMember ent) -> Standard_Integer

        Recognizes a items of select member SymmetricTensor23dMember
        1 -> IsotropicSymmetricTensor23d
        2 -> OrthotropicSymmetricTensor23d
        3 -> AnisotropicSymmetricTensor23d
        0 else

        :type ent: OCC.wrapper.StepData.Handle_StepData_SelectMember
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.StepFEA_SymmetricTensor23d_CaseMem(self, *args)


    def NewMember(self, *args):
        """
        NewMember(StepFEA_SymmetricTensor23d self) -> Handle_StepData_SelectMember

        Returns a new select member the type SymmetricTensor23dMember

        :rtype: OCC.wrapper.StepData.Handle_StepData_SelectMember

        """
        return _StepFEA.StepFEA_SymmetricTensor23d_NewMember(self, *args)


    def SetIsotropicSymmetricTensor23d(self, *args):
        """
        SetIsotropicSymmetricTensor23d(StepFEA_SymmetricTensor23d self, Standard_Real const aVal)

        Set Value for IsotropicSymmetricTensor23d

        :type aVal: float

        """
        return _StepFEA.StepFEA_SymmetricTensor23d_SetIsotropicSymmetricTensor23d(self, *args)


    def IsotropicSymmetricTensor23d(self, *args):
        """
        IsotropicSymmetricTensor23d(StepFEA_SymmetricTensor23d self) -> Standard_Real

        Returns Value as IsotropicSymmetricTensor23d (or Null if another type)

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepFEA.StepFEA_SymmetricTensor23d_IsotropicSymmetricTensor23d(self, *args)


    def SetOrthotropicSymmetricTensor23d(self, *args):
        """
        SetOrthotropicSymmetricTensor23d(StepFEA_SymmetricTensor23d self, Handle_TColStd_HArray1OfReal aVal)

        Set Value for OrthotropicSymmetricTensor23d

        :type aVal: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepFEA.StepFEA_SymmetricTensor23d_SetOrthotropicSymmetricTensor23d(self, *args)


    def OrthotropicSymmetricTensor23d(self, *args):
        """
        OrthotropicSymmetricTensor23d(StepFEA_SymmetricTensor23d self) -> Handle_TColStd_HArray1OfReal

        Returns Value as OrthotropicSymmetricTensor23d (or Null if another type)

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepFEA.StepFEA_SymmetricTensor23d_OrthotropicSymmetricTensor23d(self, *args)


    def SetAnisotropicSymmetricTensor23d(self, *args):
        """
        SetAnisotropicSymmetricTensor23d(StepFEA_SymmetricTensor23d self, Handle_TColStd_HArray1OfReal aVal)

        Set Value for AnisotropicSymmetricTensor23d

        :type aVal: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepFEA.StepFEA_SymmetricTensor23d_SetAnisotropicSymmetricTensor23d(self, *args)


    def AnisotropicSymmetricTensor23d(self, *args):
        """
        AnisotropicSymmetricTensor23d(StepFEA_SymmetricTensor23d self) -> Handle_TColStd_HArray1OfReal

        Returns Value as AnisotropicSymmetricTensor23d (or Null if another type)

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepFEA.StepFEA_SymmetricTensor23d_AnisotropicSymmetricTensor23d(self, *args)

    __swig_destroy__ = _StepFEA.delete_StepFEA_SymmetricTensor23d
StepFEA_SymmetricTensor23d_swigregister = _StepFEA.StepFEA_SymmetricTensor23d_swigregister
StepFEA_SymmetricTensor23d_swigregister(StepFEA_SymmetricTensor23d)

class Handle_StepFEA_ElementGroup(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_ElementGroup self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_ElementGroup_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_ElementGroup self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_ElementGroup_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_ElementGroup self, StepFEA_ElementGroup thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_ElementGroup_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_ElementGroup self, Handle_StepFEA_ElementGroup theHandle) -> Handle_StepFEA_ElementGroup
        assign(Handle_StepFEA_ElementGroup self, StepFEA_ElementGroup thePtr) -> Handle_StepFEA_ElementGroup
        assign(Handle_StepFEA_ElementGroup self, Handle_StepFEA_ElementGroup theHandle) -> Handle_StepFEA_ElementGroup

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_ElementGroup_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_ElementGroup self) -> StepFEA_ElementGroup

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_ElementGroup_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_ElementGroup self) -> StepFEA_ElementGroup

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_ElementGroup___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_ElementGroup self) -> StepFEA_ElementGroup

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_ElementGroup___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_ElementGroup___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_ElementGroup___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_ElementGroup(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_ElementGroup_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_ElementGroup

    def Init(self, *args):
        """
        Init(Handle_StepFEA_ElementGroup self, Handle_TCollection_HAsciiString aGroup_Name, Handle_TCollection_HAsciiString aGroup_Description, Handle_StepFEA_FeaModel aFeaGroup_ModelRef, Handle_StepFEA_HArray1OfElementRepresentation aElements)

        Initialize all fields (own and inherited)

        :type aGroup_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aGroup_Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFeaGroup_ModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel
        :type aElements: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfElementRepresentation

        """
        return _StepFEA.Handle_StepFEA_ElementGroup_Init(self, *args)


    def Elements(self, *args):
        """
        Elements(Handle_StepFEA_ElementGroup self) -> Handle_StepFEA_HArray1OfElementRepresentation

        Returns field Elements

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfElementRepresentation

        """
        return _StepFEA.Handle_StepFEA_ElementGroup_Elements(self, *args)


    def SetElements(self, *args):
        """
        SetElements(Handle_StepFEA_ElementGroup self, Handle_StepFEA_HArray1OfElementRepresentation Elements)

        Set field Elements

        :type Elements: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfElementRepresentation

        """
        return _StepFEA.Handle_StepFEA_ElementGroup_SetElements(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_ElementGroup self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_ElementGroup_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_ElementGroup_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_ElementGroup_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ModelRef(self, *args):
        """
        ModelRef(Handle_StepFEA_ElementGroup self) -> Handle_StepFEA_FeaModel

        Returns field ModelRef

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel

        """
        return _StepFEA.Handle_StepFEA_ElementGroup_ModelRef(self, *args)


    def SetModelRef(self, *args):
        """
        SetModelRef(Handle_StepFEA_ElementGroup self, Handle_StepFEA_FeaModel ModelRef)

        Set field ModelRef

        :type ModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel

        """
        return _StepFEA.Handle_StepFEA_ElementGroup_SetModelRef(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_ElementGroup self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_ElementGroup_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_ElementGroup self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_ElementGroup_SetName(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepFEA_ElementGroup self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_ElementGroup_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepFEA_ElementGroup self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_ElementGroup_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(Handle_StepFEA_ElementGroup self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_ElementGroup_HasDescription(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_ElementGroup self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_ElementGroup_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_ElementGroup self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_ElementGroup self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_ElementGroup_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_ElementGroup self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_ElementGroup self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_ElementGroup_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_ElementGroup self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_ElementGroup_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_ElementGroup self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_ElementGroup_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_ElementGroup self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_ElementGroup_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_ElementGroup self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_ElementGroup_DecrementRefCounter(self, *args)

Handle_StepFEA_ElementGroup_swigregister = _StepFEA.Handle_StepFEA_ElementGroup_swigregister
Handle_StepFEA_ElementGroup_swigregister(Handle_StepFEA_ElementGroup)

def Handle_StepFEA_ElementGroup_DownCast(thing):
    return _StepFEA.Handle_StepFEA_ElementGroup_DownCast(thing)
Handle_StepFEA_ElementGroup_DownCast = _StepFEA.Handle_StepFEA_ElementGroup_DownCast

class Handle_StepFEA_FeaCurveSectionGeometricRelationship(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_FeaCurveSectionGeometricRelationship self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_FeaCurveSectionGeometricRelationship_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_FeaCurveSectionGeometricRelationship self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_FeaCurveSectionGeometricRelationship_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_FeaCurveSectionGeometricRelationship self, StepFEA_FeaCurveSectionGeometricRelationship thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_FeaCurveSectionGeometricRelationship_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_FeaCurveSectionGeometricRelationship self, Handle_StepFEA_FeaCurveSectionGeometricRelationship theHandle) -> Handle_StepFEA_FeaCurveSectionGeometricRelationship
        assign(Handle_StepFEA_FeaCurveSectionGeometricRelationship self, StepFEA_FeaCurveSectionGeometricRelationship thePtr) -> Handle_StepFEA_FeaCurveSectionGeometricRelationship
        assign(Handle_StepFEA_FeaCurveSectionGeometricRelationship self, Handle_StepFEA_FeaCurveSectionGeometricRelationship theHandle) -> Handle_StepFEA_FeaCurveSectionGeometricRelationship

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_FeaCurveSectionGeometricRelationship_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_FeaCurveSectionGeometricRelationship self) -> StepFEA_FeaCurveSectionGeometricRelationship

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaCurveSectionGeometricRelationship_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_FeaCurveSectionGeometricRelationship self) -> StepFEA_FeaCurveSectionGeometricRelationship

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaCurveSectionGeometricRelationship___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_FeaCurveSectionGeometricRelationship self) -> StepFEA_FeaCurveSectionGeometricRelationship

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_FeaCurveSectionGeometricRelationship___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_FeaCurveSectionGeometricRelationship___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_FeaCurveSectionGeometricRelationship___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_FeaCurveSectionGeometricRelationship(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_FeaCurveSectionGeometricRelationship_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_FeaCurveSectionGeometricRelationship

    def Init(self, *args):
        """
        Init(Handle_StepFEA_FeaCurveSectionGeometricRelationship self, Handle_StepElement_CurveElementSectionDefinition aSectionRef, Handle_StepElement_AnalysisItemWithinRepresentation aItem)

        Initialize all fields (own and inherited)

        :type aSectionRef: OCC.wrapper.StepElement.Handle_StepElement_CurveElementSectionDefinition
        :type aItem: OCC.wrapper.StepElement.Handle_StepElement_AnalysisItemWithinRepresentation

        """
        return _StepFEA.Handle_StepFEA_FeaCurveSectionGeometricRelationship_Init(self, *args)


    def SectionRef(self, *args):
        """
        SectionRef(Handle_StepFEA_FeaCurveSectionGeometricRelationship self) -> Handle_StepElement_CurveElementSectionDefinition

        Returns field SectionRef

        :rtype: OCC.wrapper.StepElement.Handle_StepElement_CurveElementSectionDefinition

        """
        return _StepFEA.Handle_StepFEA_FeaCurveSectionGeometricRelationship_SectionRef(self, *args)


    def SetSectionRef(self, *args):
        """
        SetSectionRef(Handle_StepFEA_FeaCurveSectionGeometricRelationship self, Handle_StepElement_CurveElementSectionDefinition SectionRef)

        Set field SectionRef

        :type SectionRef: OCC.wrapper.StepElement.Handle_StepElement_CurveElementSectionDefinition

        """
        return _StepFEA.Handle_StepFEA_FeaCurveSectionGeometricRelationship_SetSectionRef(self, *args)


    def Item(self, *args):
        """
        Item(Handle_StepFEA_FeaCurveSectionGeometricRelationship self) -> Handle_StepElement_AnalysisItemWithinRepresentation

        Returns field Item

        :rtype: OCC.wrapper.StepElement.Handle_StepElement_AnalysisItemWithinRepresentation

        """
        return _StepFEA.Handle_StepFEA_FeaCurveSectionGeometricRelationship_Item(self, *args)


    def SetItem(self, *args):
        """
        SetItem(Handle_StepFEA_FeaCurveSectionGeometricRelationship self, Handle_StepElement_AnalysisItemWithinRepresentation Item)

        Set field Item

        :type Item: OCC.wrapper.StepElement.Handle_StepElement_AnalysisItemWithinRepresentation

        """
        return _StepFEA.Handle_StepFEA_FeaCurveSectionGeometricRelationship_SetItem(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_FeaCurveSectionGeometricRelationship self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_FeaCurveSectionGeometricRelationship_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaCurveSectionGeometricRelationship_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaCurveSectionGeometricRelationship_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_FeaCurveSectionGeometricRelationship self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_FeaCurveSectionGeometricRelationship_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_FeaCurveSectionGeometricRelationship self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_FeaCurveSectionGeometricRelationship self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaCurveSectionGeometricRelationship_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_FeaCurveSectionGeometricRelationship self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_FeaCurveSectionGeometricRelationship self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaCurveSectionGeometricRelationship_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_FeaCurveSectionGeometricRelationship self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_FeaCurveSectionGeometricRelationship_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_FeaCurveSectionGeometricRelationship self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaCurveSectionGeometricRelationship_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_FeaCurveSectionGeometricRelationship self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_FeaCurveSectionGeometricRelationship_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_FeaCurveSectionGeometricRelationship self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaCurveSectionGeometricRelationship_DecrementRefCounter(self, *args)

Handle_StepFEA_FeaCurveSectionGeometricRelationship_swigregister = _StepFEA.Handle_StepFEA_FeaCurveSectionGeometricRelationship_swigregister
Handle_StepFEA_FeaCurveSectionGeometricRelationship_swigregister(Handle_StepFEA_FeaCurveSectionGeometricRelationship)

def Handle_StepFEA_FeaCurveSectionGeometricRelationship_DownCast(thing):
    return _StepFEA.Handle_StepFEA_FeaCurveSectionGeometricRelationship_DownCast(thing)
Handle_StepFEA_FeaCurveSectionGeometricRelationship_DownCast = _StepFEA.Handle_StepFEA_FeaCurveSectionGeometricRelationship_DownCast

class Handle_StepFEA_Surface3dElementRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_Surface3dElementRepresentation self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_Surface3dElementRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_Surface3dElementRepresentation self, StepFEA_Surface3dElementRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_Surface3dElementRepresentation self, Handle_StepFEA_Surface3dElementRepresentation theHandle) -> Handle_StepFEA_Surface3dElementRepresentation
        assign(Handle_StepFEA_Surface3dElementRepresentation self, StepFEA_Surface3dElementRepresentation thePtr) -> Handle_StepFEA_Surface3dElementRepresentation
        assign(Handle_StepFEA_Surface3dElementRepresentation self, Handle_StepFEA_Surface3dElementRepresentation theHandle) -> Handle_StepFEA_Surface3dElementRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_Surface3dElementRepresentation self) -> StepFEA_Surface3dElementRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_Surface3dElementRepresentation self) -> StepFEA_Surface3dElementRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_Surface3dElementRepresentation self) -> StepFEA_Surface3dElementRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_Surface3dElementRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_Surface3dElementRepresentation_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_Surface3dElementRepresentation

    def Init(self, *args):
        """
        Init(Handle_StepFEA_Surface3dElementRepresentation self, Handle_TCollection_HAsciiString aRepresentation_Name, Handle_StepRepr_HArray1OfRepresentationItem aRepresentation_Items, Handle_StepRepr_RepresentationContext aRepresentation_ContextOfItems, Handle_StepFEA_HArray1OfNodeRepresentation aElementRepresentation_NodeList, Handle_StepFEA_FeaModel3d aModelRef, Handle_StepElement_Surface3dElementDescriptor aElementDescriptor, Handle_StepElement_SurfaceElementProperty aProperty, Handle_StepElement_ElementMaterial aMaterial)

        Initialize all fields (own and inherited)

        :type aRepresentation_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRepresentation_Items: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aRepresentation_ContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext
        :type aElementRepresentation_NodeList: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation
        :type aModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel3d
        :type aElementDescriptor: OCC.wrapper.StepElement.Handle_StepElement_Surface3dElementDescriptor
        :type aProperty: OCC.wrapper.StepElement.Handle_StepElement_SurfaceElementProperty
        :type aMaterial: OCC.wrapper.StepElement.Handle_StepElement_ElementMaterial

        """
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_Init(self, *args)


    def ModelRef(self, *args):
        """
        ModelRef(Handle_StepFEA_Surface3dElementRepresentation self) -> Handle_StepFEA_FeaModel3d

        Returns field ModelRef

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel3d

        """
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_ModelRef(self, *args)


    def SetModelRef(self, *args):
        """
        SetModelRef(Handle_StepFEA_Surface3dElementRepresentation self, Handle_StepFEA_FeaModel3d ModelRef)

        Set field ModelRef

        :type ModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel3d

        """
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_SetModelRef(self, *args)


    def ElementDescriptor(self, *args):
        """
        ElementDescriptor(Handle_StepFEA_Surface3dElementRepresentation self) -> Handle_StepElement_Surface3dElementDescriptor

        Returns field ElementDescriptor

        :rtype: OCC.wrapper.StepElement.Handle_StepElement_Surface3dElementDescriptor

        """
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_ElementDescriptor(self, *args)


    def SetElementDescriptor(self, *args):
        """
        SetElementDescriptor(Handle_StepFEA_Surface3dElementRepresentation self, Handle_StepElement_Surface3dElementDescriptor ElementDescriptor)

        Set field ElementDescriptor

        :type ElementDescriptor: OCC.wrapper.StepElement.Handle_StepElement_Surface3dElementDescriptor

        """
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_SetElementDescriptor(self, *args)


    def Property(self, *args):
        """
        Property(Handle_StepFEA_Surface3dElementRepresentation self) -> Handle_StepElement_SurfaceElementProperty

        Returns field Property

        :rtype: OCC.wrapper.StepElement.Handle_StepElement_SurfaceElementProperty

        """
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_Property(self, *args)


    def SetProperty(self, *args):
        """
        SetProperty(Handle_StepFEA_Surface3dElementRepresentation self, Handle_StepElement_SurfaceElementProperty Property)

        Set field Property

        :type Property: OCC.wrapper.StepElement.Handle_StepElement_SurfaceElementProperty

        """
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_SetProperty(self, *args)


    def Material(self, *args):
        """
        Material(Handle_StepFEA_Surface3dElementRepresentation self) -> Handle_StepElement_ElementMaterial

        Returns field Material

        :rtype: OCC.wrapper.StepElement.Handle_StepElement_ElementMaterial

        """
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_StepFEA_Surface3dElementRepresentation self, Handle_StepElement_ElementMaterial Material)

        Set field Material

        :type Material: OCC.wrapper.StepElement.Handle_StepElement_ElementMaterial

        """
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_SetMaterial(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_Surface3dElementRepresentation self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NodeList(self, *args):
        """
        NodeList(Handle_StepFEA_Surface3dElementRepresentation self) -> Handle_StepFEA_HArray1OfNodeRepresentation

        Returns field NodeList

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation

        """
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_NodeList(self, *args)


    def SetNodeList(self, *args):
        """
        SetNodeList(Handle_StepFEA_Surface3dElementRepresentation self, Handle_StepFEA_HArray1OfNodeRepresentation NodeList)

        Set field NodeList

        :type NodeList: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation

        """
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_SetNodeList(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_Surface3dElementRepresentation self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_Surface3dElementRepresentation self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepFEA_Surface3dElementRepresentation self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepFEA_Surface3dElementRepresentation self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepFEA_Surface3dElementRepresentation self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepFEA_Surface3dElementRepresentation self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepFEA_Surface3dElementRepresentation self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepFEA_Surface3dElementRepresentation self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_Surface3dElementRepresentation self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_Surface3dElementRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_Surface3dElementRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_Surface3dElementRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_Surface3dElementRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_Surface3dElementRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_Surface3dElementRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_Surface3dElementRepresentation self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_Surface3dElementRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_DecrementRefCounter(self, *args)

Handle_StepFEA_Surface3dElementRepresentation_swigregister = _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_swigregister
Handle_StepFEA_Surface3dElementRepresentation_swigregister(Handle_StepFEA_Surface3dElementRepresentation)

def Handle_StepFEA_Surface3dElementRepresentation_DownCast(thing):
    return _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_DownCast(thing)
Handle_StepFEA_Surface3dElementRepresentation_DownCast = _StepFEA.Handle_StepFEA_Surface3dElementRepresentation_DownCast

class Handle_StepFEA_HSequenceOfElementRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_HSequenceOfElementRepresentation self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_HSequenceOfElementRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_HSequenceOfElementRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfElementRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_HSequenceOfElementRepresentation self, StepFEA_HSequenceOfElementRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfElementRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_HSequenceOfElementRepresentation self, Handle_StepFEA_HSequenceOfElementRepresentation theHandle) -> Handle_StepFEA_HSequenceOfElementRepresentation
        assign(Handle_StepFEA_HSequenceOfElementRepresentation self, StepFEA_HSequenceOfElementRepresentation thePtr) -> Handle_StepFEA_HSequenceOfElementRepresentation
        assign(Handle_StepFEA_HSequenceOfElementRepresentation self, Handle_StepFEA_HSequenceOfElementRepresentation theHandle) -> Handle_StepFEA_HSequenceOfElementRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfElementRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_HSequenceOfElementRepresentation self) -> StepFEA_HSequenceOfElementRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfElementRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_HSequenceOfElementRepresentation self) -> StepFEA_HSequenceOfElementRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfElementRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_HSequenceOfElementRepresentation self) -> StepFEA_HSequenceOfElementRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfElementRepresentation___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_HSequenceOfElementRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_HSequenceOfElementRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_HSequenceOfElementRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_HSequenceOfElementRepresentation_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_HSequenceOfElementRepresentation

    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.StepFEA.StepFEA_SequenceOfElementRepresentation

        """
        res = _StepFEA.Handle_StepFEA_HSequenceOfElementRepresentation_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Handle_StepFEA_HSequenceOfElementRepresentation self, Handle_StepFEA_ElementRepresentation theItem)
        Append(Handle_StepFEA_HSequenceOfElementRepresentation self, NCollection_Sequence_Handle_StepFEA_ElementRepresentation theSequence)

        :type theSequence: OCC.wrapper.StepFEA.StepFEA_SequenceOfElementRepresentation

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfElementRepresentation_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Handle_StepFEA_HSequenceOfElementRepresentation self) -> NCollection_Sequence_Handle_StepFEA_ElementRepresentation

        :rtype: OCC.wrapper.StepFEA.StepFEA_SequenceOfElementRepresentation

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfElementRepresentation_ChangeSequence(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_HSequenceOfElementRepresentation self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfElementRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_HSequenceOfElementRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_HSequenceOfElementRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_HSequenceOfElementRepresentation self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_HSequenceOfElementRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_HSequenceOfElementRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_HSequenceOfElementRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfElementRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_HSequenceOfElementRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_HSequenceOfElementRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfElementRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_HSequenceOfElementRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfElementRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_HSequenceOfElementRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfElementRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_HSequenceOfElementRepresentation self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_HSequenceOfElementRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_HSequenceOfElementRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfElementRepresentation_DecrementRefCounter(self, *args)

Handle_StepFEA_HSequenceOfElementRepresentation_swigregister = _StepFEA.Handle_StepFEA_HSequenceOfElementRepresentation_swigregister
Handle_StepFEA_HSequenceOfElementRepresentation_swigregister(Handle_StepFEA_HSequenceOfElementRepresentation)

def Handle_StepFEA_HSequenceOfElementRepresentation_DownCast(thing):
    return _StepFEA.Handle_StepFEA_HSequenceOfElementRepresentation_DownCast(thing)
Handle_StepFEA_HSequenceOfElementRepresentation_DownCast = _StepFEA.Handle_StepFEA_HSequenceOfElementRepresentation_DownCast

class StepFEA_HSequenceOfNodeRepresentation(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_HSequenceOfNodeRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_HSequenceOfNodeRepresentation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_HSequenceOfNodeRepresentation self) -> StepFEA_HSequenceOfNodeRepresentation
        __init__(StepFEA_HSequenceOfNodeRepresentation self, NCollection_Sequence_Handle_StepFEA_NodeRepresentation theOther) -> StepFEA_HSequenceOfNodeRepresentation

        :type theOther: OCC.wrapper.StepFEA.StepFEA_SequenceOfNodeRepresentation

        """
        this = _StepFEA.new_StepFEA_HSequenceOfNodeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.StepFEA.StepFEA_SequenceOfNodeRepresentation

        """
        res = _StepFEA.StepFEA_HSequenceOfNodeRepresentation_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(StepFEA_HSequenceOfNodeRepresentation self, Handle_StepFEA_NodeRepresentation theItem)
        Append(StepFEA_HSequenceOfNodeRepresentation self, NCollection_Sequence_Handle_StepFEA_NodeRepresentation theSequence)

        :type theSequence: OCC.wrapper.StepFEA.StepFEA_SequenceOfNodeRepresentation

        """
        return _StepFEA.StepFEA_HSequenceOfNodeRepresentation_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(StepFEA_HSequenceOfNodeRepresentation self) -> NCollection_Sequence_Handle_StepFEA_NodeRepresentation

        :rtype: OCC.wrapper.StepFEA.StepFEA_SequenceOfNodeRepresentation

        """
        return _StepFEA.StepFEA_HSequenceOfNodeRepresentation_ChangeSequence(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_HSequenceOfNodeRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_HSequenceOfNodeRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_HSequenceOfNodeRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_HSequenceOfNodeRepresentation
StepFEA_HSequenceOfNodeRepresentation_swigregister = _StepFEA.StepFEA_HSequenceOfNodeRepresentation_swigregister
StepFEA_HSequenceOfNodeRepresentation_swigregister(StepFEA_HSequenceOfNodeRepresentation)

def StepFEA_HSequenceOfNodeRepresentation_get_type_name(*args):
    """
    StepFEA_HSequenceOfNodeRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_HSequenceOfNodeRepresentation_get_type_name(*args)

def StepFEA_HSequenceOfNodeRepresentation_get_type_descriptor(*args):
    """
    StepFEA_HSequenceOfNodeRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_HSequenceOfNodeRepresentation_get_type_descriptor(*args)

class StepFEA_CurveElementEndOffset(Standard.Standard_Transient):
    """Representation of STEP entity CurveElementEndOffset"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_CurveElementEndOffset
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_CurveElementEndOffset(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_CurveElementEndOffset self) -> StepFEA_CurveElementEndOffset

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_CurveElementEndOffset(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_CurveElementEndOffset self, StepFEA_CurveElementEndCoordinateSystem aCoordinateSystem, Handle_TColStd_HArray1OfReal aOffsetVector)

        Initialize all fields (own and inherited)

        :type aCoordinateSystem: OCC.wrapper.StepFEA.StepFEA_CurveElementEndCoordinateSystem
        :type aOffsetVector: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepFEA.StepFEA_CurveElementEndOffset_Init(self, *args)


    def CoordinateSystem(self, *args):
        """
        CoordinateSystem(StepFEA_CurveElementEndOffset self) -> StepFEA_CurveElementEndCoordinateSystem

        Returns field CoordinateSystem

        :rtype: OCC.wrapper.StepFEA.StepFEA_CurveElementEndCoordinateSystem

        """
        return _StepFEA.StepFEA_CurveElementEndOffset_CoordinateSystem(self, *args)


    def SetCoordinateSystem(self, *args):
        """
        SetCoordinateSystem(StepFEA_CurveElementEndOffset self, StepFEA_CurveElementEndCoordinateSystem CoordinateSystem)

        Set field CoordinateSystem

        :type CoordinateSystem: OCC.wrapper.StepFEA.StepFEA_CurveElementEndCoordinateSystem

        """
        return _StepFEA.StepFEA_CurveElementEndOffset_SetCoordinateSystem(self, *args)


    def OffsetVector(self, *args):
        """
        OffsetVector(StepFEA_CurveElementEndOffset self) -> Handle_TColStd_HArray1OfReal

        Returns field OffsetVector

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepFEA.StepFEA_CurveElementEndOffset_OffsetVector(self, *args)


    def SetOffsetVector(self, *args):
        """
        SetOffsetVector(StepFEA_CurveElementEndOffset self, Handle_TColStd_HArray1OfReal OffsetVector)

        Set field OffsetVector

        :type OffsetVector: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepFEA.StepFEA_CurveElementEndOffset_SetOffsetVector(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_CurveElementEndOffset_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_CurveElementEndOffset_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_CurveElementEndOffset_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_CurveElementEndOffset
StepFEA_CurveElementEndOffset_swigregister = _StepFEA.StepFEA_CurveElementEndOffset_swigregister
StepFEA_CurveElementEndOffset_swigregister(StepFEA_CurveElementEndOffset)

def StepFEA_CurveElementEndOffset_get_type_name(*args):
    """
    StepFEA_CurveElementEndOffset_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_CurveElementEndOffset_get_type_name(*args)

def StepFEA_CurveElementEndOffset_get_type_descriptor(*args):
    """
    StepFEA_CurveElementEndOffset_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_CurveElementEndOffset_get_type_descriptor(*args)

class StepFEA_HArray1OfNodeRepresentation(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_HArray1OfNodeRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_HArray1OfNodeRepresentation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_HArray1OfNodeRepresentation self, Standard_Integer const theLower, Standard_Integer const theUpper) -> StepFEA_HArray1OfNodeRepresentation
        __init__(StepFEA_HArray1OfNodeRepresentation self, Standard_Integer const theLower, Standard_Integer const theUpper, Handle_StepFEA_NodeRepresentation theValue) -> StepFEA_HArray1OfNodeRepresentation
        __init__(StepFEA_HArray1OfNodeRepresentation self, NCollection_Array1_Handle_StepFEA_NodeRepresentation theOther) -> StepFEA_HArray1OfNodeRepresentation

        :type theOther: OCC.wrapper.StepFEA.StepFEA_Array1OfNodeRepresentation

        """
        this = _StepFEA.new_StepFEA_HArray1OfNodeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepFEA.StepFEA_Array1OfNodeRepresentation

        """
        res = _StepFEA.StepFEA_HArray1OfNodeRepresentation_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(StepFEA_HArray1OfNodeRepresentation self) -> NCollection_Array1_Handle_StepFEA_NodeRepresentation

        :rtype: OCC.wrapper.StepFEA.StepFEA_Array1OfNodeRepresentation

        """
        return _StepFEA.StepFEA_HArray1OfNodeRepresentation_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_HArray1OfNodeRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_HArray1OfNodeRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_HArray1OfNodeRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_HArray1OfNodeRepresentation
StepFEA_HArray1OfNodeRepresentation_swigregister = _StepFEA.StepFEA_HArray1OfNodeRepresentation_swigregister
StepFEA_HArray1OfNodeRepresentation_swigregister(StepFEA_HArray1OfNodeRepresentation)

def StepFEA_HArray1OfNodeRepresentation_get_type_name(*args):
    """
    StepFEA_HArray1OfNodeRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_HArray1OfNodeRepresentation_get_type_name(*args)

def StepFEA_HArray1OfNodeRepresentation_get_type_descriptor(*args):
    """
    StepFEA_HArray1OfNodeRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_HArray1OfNodeRepresentation_get_type_descriptor(*args)

class NCollection_Array1_Handle_StepFEA_CurveElementInterval(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_StepFEA_CurveElementInterval self) -> NCollection_Array1< opencascade::handle< StepFEA_CurveElementInterval > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementInterval_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_StepFEA_CurveElementInterval self) -> NCollection_Array1< opencascade::handle< StepFEA_CurveElementInterval > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementInterval_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_StepFEA_CurveElementInterval self) -> NCollection_Array1< opencascade::handle< StepFEA_CurveElementInterval > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementInterval_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_StepFEA_CurveElementInterval self) -> NCollection_Array1< opencascade::handle< StepFEA_CurveElementInterval > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementInterval_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepFEA.new_NCollection_Array1_Handle_StepFEA_CurveElementInterval(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_StepFEA_CurveElementInterval self, Handle_StepFEA_CurveElementInterval theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementInterval_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_StepFEA_CurveElementInterval self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementInterval_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_StepFEA_CurveElementInterval self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementInterval_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_StepFEA_CurveElementInterval self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementInterval_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_StepFEA_CurveElementInterval self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementInterval_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_StepFEA_CurveElementInterval self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementInterval_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_StepFEA_CurveElementInterval self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementInterval_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_StepFEA_CurveElementInterval self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementInterval_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_StepFEA_CurveElementInterval self, NCollection_Array1_Handle_StepFEA_CurveElementInterval theOther) -> NCollection_Array1_Handle_StepFEA_CurveElementInterval

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementInterval_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_StepFEA_CurveElementInterval self, NCollection_Array1_Handle_StepFEA_CurveElementInterval theOther) -> NCollection_Array1_Handle_StepFEA_CurveElementInterval

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementInterval_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_StepFEA_CurveElementInterval self, NCollection_Array1_Handle_StepFEA_CurveElementInterval theOther) -> NCollection_Array1_Handle_StepFEA_CurveElementInterval
        assign(NCollection_Array1_Handle_StepFEA_CurveElementInterval self, NCollection_Array1_Handle_StepFEA_CurveElementInterval theOther) -> NCollection_Array1_Handle_StepFEA_CurveElementInterval

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementInterval_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementInterval_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_StepFEA_CurveElementInterval self) -> Handle_StepFEA_CurveElementInterval

        @return first element

        :rtype: TheItemType &

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementInterval_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementInterval_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_StepFEA_CurveElementInterval self) -> Handle_StepFEA_CurveElementInterval

        @return last element

        :rtype: TheItemType &

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementInterval_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementInterval_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_StepFEA_CurveElementInterval self, Standard_Integer const theIndex) -> Handle_StepFEA_CurveElementInterval

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementInterval_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementInterval___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementInterval_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_StepFEA_CurveElementInterval self, Standard_Integer const theIndex, Handle_StepFEA_CurveElementInterval theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementInterval_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_StepFEA_CurveElementInterval self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementInterval_Resize(self, *args)

    __swig_destroy__ = _StepFEA.delete_NCollection_Array1_Handle_StepFEA_CurveElementInterval
NCollection_Array1_Handle_StepFEA_CurveElementInterval_swigregister = _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementInterval_swigregister
NCollection_Array1_Handle_StepFEA_CurveElementInterval_swigregister(NCollection_Array1_Handle_StepFEA_CurveElementInterval)


try:
	StepFEA_Array1OfCurveElementInterval = NCollection_Array1_Handle_StepFEA_CurveElementInterval
except NameError:
	pass # does not exist, probably ignored

class Handle_StepFEA_FeaModelDefinition(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_FeaModelDefinition self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_FeaModelDefinition_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_FeaModelDefinition self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_FeaModelDefinition_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_FeaModelDefinition self, StepFEA_FeaModelDefinition thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_FeaModelDefinition_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_FeaModelDefinition self, Handle_StepFEA_FeaModelDefinition theHandle) -> Handle_StepFEA_FeaModelDefinition
        assign(Handle_StepFEA_FeaModelDefinition self, StepFEA_FeaModelDefinition thePtr) -> Handle_StepFEA_FeaModelDefinition
        assign(Handle_StepFEA_FeaModelDefinition self, Handle_StepFEA_FeaModelDefinition theHandle) -> Handle_StepFEA_FeaModelDefinition

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_FeaModelDefinition_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_FeaModelDefinition self) -> StepFEA_FeaModelDefinition

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaModelDefinition_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_FeaModelDefinition self) -> StepFEA_FeaModelDefinition

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaModelDefinition___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_FeaModelDefinition self) -> StepFEA_FeaModelDefinition

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_FeaModelDefinition___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_FeaModelDefinition___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_FeaModelDefinition___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_FeaModelDefinition(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_FeaModelDefinition_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_FeaModelDefinition

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_FeaModelDefinition self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_FeaModelDefinition_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaModelDefinition_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaModelDefinition_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepFEA_FeaModelDefinition self, Handle_TCollection_HAsciiString aName, Handle_TCollection_HAsciiString aDescription, Handle_StepRepr_ProductDefinitionShape aOfShape, StepData_Logical const aProductDefinitional)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aOfShape: OCC.wrapper.StepRepr.Handle_StepRepr_ProductDefinitionShape
        :type aProductDefinitional: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepFEA.Handle_StepFEA_FeaModelDefinition_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_FeaModelDefinition self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaModelDefinition_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_FeaModelDefinition self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaModelDefinition_Name(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepFEA_FeaModelDefinition self, Handle_TCollection_HAsciiString aDescription)

        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaModelDefinition_SetDescription(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepFEA_FeaModelDefinition self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaModelDefinition_Description(self, *args)


    def SetOfShape(self, *args):
        """
        SetOfShape(Handle_StepFEA_FeaModelDefinition self, Handle_StepRepr_ProductDefinitionShape aOfShape)

        :type aOfShape: OCC.wrapper.StepRepr.Handle_StepRepr_ProductDefinitionShape

        """
        return _StepFEA.Handle_StepFEA_FeaModelDefinition_SetOfShape(self, *args)


    def OfShape(self, *args):
        """
        OfShape(Handle_StepFEA_FeaModelDefinition self) -> Handle_StepRepr_ProductDefinitionShape

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_ProductDefinitionShape

        """
        return _StepFEA.Handle_StepFEA_FeaModelDefinition_OfShape(self, *args)


    def SetProductDefinitional(self, *args):
        """
        SetProductDefinitional(Handle_StepFEA_FeaModelDefinition self, StepData_Logical const aProductDefinitional)

        :type aProductDefinitional: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepFEA.Handle_StepFEA_FeaModelDefinition_SetProductDefinitional(self, *args)


    def ProductDefinitional(self, *args):
        """
        ProductDefinitional(Handle_StepFEA_FeaModelDefinition self) -> StepData_Logical

        :rtype: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepFEA.Handle_StepFEA_FeaModelDefinition_ProductDefinitional(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_FeaModelDefinition self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_FeaModelDefinition_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_FeaModelDefinition self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_FeaModelDefinition self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaModelDefinition_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_FeaModelDefinition self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_FeaModelDefinition self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaModelDefinition_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_FeaModelDefinition self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_FeaModelDefinition_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_FeaModelDefinition self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaModelDefinition_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_FeaModelDefinition self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_FeaModelDefinition_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_FeaModelDefinition self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaModelDefinition_DecrementRefCounter(self, *args)

Handle_StepFEA_FeaModelDefinition_swigregister = _StepFEA.Handle_StepFEA_FeaModelDefinition_swigregister
Handle_StepFEA_FeaModelDefinition_swigregister(Handle_StepFEA_FeaModelDefinition)

def Handle_StepFEA_FeaModelDefinition_DownCast(thing):
    return _StepFEA.Handle_StepFEA_FeaModelDefinition_DownCast(thing)
Handle_StepFEA_FeaModelDefinition_DownCast = _StepFEA.Handle_StepFEA_FeaModelDefinition_DownCast

class StepFEA_SymmetricTensor42d(StepData.StepData_SelectType):
    """Representation of STEP SELECT type SymmetricTensor42d"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepFEA_SymmetricTensor42d self) -> StepFEA_SymmetricTensor42d

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_SymmetricTensor42d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepFEA_SymmetricTensor42d self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a kind of SymmetricTensor42d select type
        1 -> HArray1OfReal from TColStd
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.StepFEA_SymmetricTensor42d_CaseNum(self, *args)


    def AnisotropicSymmetricTensor42d(self, *args):
        """
        AnisotropicSymmetricTensor42d(StepFEA_SymmetricTensor42d self) -> Handle_TColStd_HArray1OfReal

        Returns Value as AnisotropicSymmetricTensor42d (or Null if another type)

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepFEA.StepFEA_SymmetricTensor42d_AnisotropicSymmetricTensor42d(self, *args)

    __swig_destroy__ = _StepFEA.delete_StepFEA_SymmetricTensor42d
StepFEA_SymmetricTensor42d_swigregister = _StepFEA.StepFEA_SymmetricTensor42d_swigregister
StepFEA_SymmetricTensor42d_swigregister(StepFEA_SymmetricTensor42d)

class Handle_StepFEA_HArray1OfCurveElementInterval(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_HArray1OfCurveElementInterval self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementInterval_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_HArray1OfCurveElementInterval self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementInterval_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_HArray1OfCurveElementInterval self, StepFEA_HArray1OfCurveElementInterval thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementInterval_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_HArray1OfCurveElementInterval self, Handle_StepFEA_HArray1OfCurveElementInterval theHandle) -> Handle_StepFEA_HArray1OfCurveElementInterval
        assign(Handle_StepFEA_HArray1OfCurveElementInterval self, StepFEA_HArray1OfCurveElementInterval thePtr) -> Handle_StepFEA_HArray1OfCurveElementInterval
        assign(Handle_StepFEA_HArray1OfCurveElementInterval self, Handle_StepFEA_HArray1OfCurveElementInterval theHandle) -> Handle_StepFEA_HArray1OfCurveElementInterval

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementInterval_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_HArray1OfCurveElementInterval self) -> StepFEA_HArray1OfCurveElementInterval

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementInterval_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_HArray1OfCurveElementInterval self) -> StepFEA_HArray1OfCurveElementInterval

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementInterval___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_HArray1OfCurveElementInterval self) -> StepFEA_HArray1OfCurveElementInterval

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementInterval___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementInterval___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_HArray1OfCurveElementInterval___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_HArray1OfCurveElementInterval(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_HArray1OfCurveElementInterval_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_HArray1OfCurveElementInterval

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepFEA.StepFEA_Array1OfCurveElementInterval

        """
        res = _StepFEA.Handle_StepFEA_HArray1OfCurveElementInterval_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepFEA_HArray1OfCurveElementInterval self) -> NCollection_Array1_Handle_StepFEA_CurveElementInterval

        :rtype: OCC.wrapper.StepFEA.StepFEA_Array1OfCurveElementInterval

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementInterval_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_HArray1OfCurveElementInterval self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementInterval_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_HArray1OfCurveElementInterval_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_HArray1OfCurveElementInterval_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_HArray1OfCurveElementInterval self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementInterval_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_HArray1OfCurveElementInterval self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_HArray1OfCurveElementInterval self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementInterval_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_HArray1OfCurveElementInterval self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_HArray1OfCurveElementInterval self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementInterval_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_HArray1OfCurveElementInterval self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementInterval_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_HArray1OfCurveElementInterval self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementInterval_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_HArray1OfCurveElementInterval self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementInterval_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_HArray1OfCurveElementInterval self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementInterval_DecrementRefCounter(self, *args)

Handle_StepFEA_HArray1OfCurveElementInterval_swigregister = _StepFEA.Handle_StepFEA_HArray1OfCurveElementInterval_swigregister
Handle_StepFEA_HArray1OfCurveElementInterval_swigregister(Handle_StepFEA_HArray1OfCurveElementInterval)

def Handle_StepFEA_HArray1OfCurveElementInterval_DownCast(thing):
    return _StepFEA.Handle_StepFEA_HArray1OfCurveElementInterval_DownCast(thing)
Handle_StepFEA_HArray1OfCurveElementInterval_DownCast = _StepFEA.Handle_StepFEA_HArray1OfCurveElementInterval_DownCast

class NCollection_Array1_Handle_StepFEA_CurveElementEndRelease(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_StepFEA_CurveElementEndRelease self) -> NCollection_Array1< opencascade::handle< StepFEA_CurveElementEndRelease > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndRelease_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_StepFEA_CurveElementEndRelease self) -> NCollection_Array1< opencascade::handle< StepFEA_CurveElementEndRelease > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndRelease_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_StepFEA_CurveElementEndRelease self) -> NCollection_Array1< opencascade::handle< StepFEA_CurveElementEndRelease > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndRelease_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_StepFEA_CurveElementEndRelease self) -> NCollection_Array1< opencascade::handle< StepFEA_CurveElementEndRelease > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndRelease_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepFEA.new_NCollection_Array1_Handle_StepFEA_CurveElementEndRelease(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_StepFEA_CurveElementEndRelease self, Handle_StepFEA_CurveElementEndRelease theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndRelease_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_StepFEA_CurveElementEndRelease self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndRelease_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_StepFEA_CurveElementEndRelease self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndRelease_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_StepFEA_CurveElementEndRelease self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndRelease_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_StepFEA_CurveElementEndRelease self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndRelease_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_StepFEA_CurveElementEndRelease self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndRelease_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_StepFEA_CurveElementEndRelease self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndRelease_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_StepFEA_CurveElementEndRelease self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndRelease_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_StepFEA_CurveElementEndRelease self, NCollection_Array1_Handle_StepFEA_CurveElementEndRelease theOther) -> NCollection_Array1_Handle_StepFEA_CurveElementEndRelease

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndRelease_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_StepFEA_CurveElementEndRelease self, NCollection_Array1_Handle_StepFEA_CurveElementEndRelease theOther) -> NCollection_Array1_Handle_StepFEA_CurveElementEndRelease

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndRelease_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_StepFEA_CurveElementEndRelease self, NCollection_Array1_Handle_StepFEA_CurveElementEndRelease theOther) -> NCollection_Array1_Handle_StepFEA_CurveElementEndRelease
        assign(NCollection_Array1_Handle_StepFEA_CurveElementEndRelease self, NCollection_Array1_Handle_StepFEA_CurveElementEndRelease theOther) -> NCollection_Array1_Handle_StepFEA_CurveElementEndRelease

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndRelease_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndRelease_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_StepFEA_CurveElementEndRelease self) -> Handle_StepFEA_CurveElementEndRelease

        @return first element

        :rtype: TheItemType &

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndRelease_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndRelease_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_StepFEA_CurveElementEndRelease self) -> Handle_StepFEA_CurveElementEndRelease

        @return last element

        :rtype: TheItemType &

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndRelease_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndRelease_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_StepFEA_CurveElementEndRelease self, Standard_Integer const theIndex) -> Handle_StepFEA_CurveElementEndRelease

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndRelease_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndRelease___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndRelease_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_StepFEA_CurveElementEndRelease self, Standard_Integer const theIndex, Handle_StepFEA_CurveElementEndRelease theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndRelease_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_StepFEA_CurveElementEndRelease self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndRelease_Resize(self, *args)

    __swig_destroy__ = _StepFEA.delete_NCollection_Array1_Handle_StepFEA_CurveElementEndRelease
NCollection_Array1_Handle_StepFEA_CurveElementEndRelease_swigregister = _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndRelease_swigregister
NCollection_Array1_Handle_StepFEA_CurveElementEndRelease_swigregister(NCollection_Array1_Handle_StepFEA_CurveElementEndRelease)


try:
	StepFEA_Array1OfCurveElementEndRelease = NCollection_Array1_Handle_StepFEA_CurveElementEndRelease
except NameError:
	pass # does not exist, probably ignored

class Handle_StepFEA_FeaShellMembraneStiffness(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_FeaShellMembraneStiffness self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneStiffness_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_FeaShellMembraneStiffness self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneStiffness_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_FeaShellMembraneStiffness self, StepFEA_FeaShellMembraneStiffness thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneStiffness_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_FeaShellMembraneStiffness self, Handle_StepFEA_FeaShellMembraneStiffness theHandle) -> Handle_StepFEA_FeaShellMembraneStiffness
        assign(Handle_StepFEA_FeaShellMembraneStiffness self, StepFEA_FeaShellMembraneStiffness thePtr) -> Handle_StepFEA_FeaShellMembraneStiffness
        assign(Handle_StepFEA_FeaShellMembraneStiffness self, Handle_StepFEA_FeaShellMembraneStiffness theHandle) -> Handle_StepFEA_FeaShellMembraneStiffness

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneStiffness_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_FeaShellMembraneStiffness self) -> StepFEA_FeaShellMembraneStiffness

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneStiffness_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_FeaShellMembraneStiffness self) -> StepFEA_FeaShellMembraneStiffness

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneStiffness___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_FeaShellMembraneStiffness self) -> StepFEA_FeaShellMembraneStiffness

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneStiffness___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_FeaShellMembraneStiffness___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_FeaShellMembraneStiffness___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_FeaShellMembraneStiffness(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_FeaShellMembraneStiffness_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_FeaShellMembraneStiffness

    def Init(self, *args):
        """
        Init(Handle_StepFEA_FeaShellMembraneStiffness self, Handle_TCollection_HAsciiString aRepresentationItem_Name, StepFEA_SymmetricTensor42d aFeaConstants)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFeaConstants: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor42d

        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneStiffness_Init(self, *args)


    def FeaConstants(self, *args):
        """
        FeaConstants(Handle_StepFEA_FeaShellMembraneStiffness self) -> StepFEA_SymmetricTensor42d

        Returns field FeaConstants

        :rtype: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor42d

        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneStiffness_FeaConstants(self, *args)


    def SetFeaConstants(self, *args):
        """
        SetFeaConstants(Handle_StepFEA_FeaShellMembraneStiffness self, StepFEA_SymmetricTensor42d FeaConstants)

        Set field FeaConstants

        :type FeaConstants: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor42d

        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneStiffness_SetFeaConstants(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_FeaShellMembraneStiffness self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneStiffness_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaShellMembraneStiffness_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaShellMembraneStiffness_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_FeaShellMembraneStiffness self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneStiffness_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_FeaShellMembraneStiffness self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneStiffness_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_FeaShellMembraneStiffness self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneStiffness_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_FeaShellMembraneStiffness self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_FeaShellMembraneStiffness self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneStiffness_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_FeaShellMembraneStiffness self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_FeaShellMembraneStiffness self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneStiffness_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_FeaShellMembraneStiffness self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneStiffness_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_FeaShellMembraneStiffness self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneStiffness_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_FeaShellMembraneStiffness self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneStiffness_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_FeaShellMembraneStiffness self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneStiffness_DecrementRefCounter(self, *args)

Handle_StepFEA_FeaShellMembraneStiffness_swigregister = _StepFEA.Handle_StepFEA_FeaShellMembraneStiffness_swigregister
Handle_StepFEA_FeaShellMembraneStiffness_swigregister(Handle_StepFEA_FeaShellMembraneStiffness)

def Handle_StepFEA_FeaShellMembraneStiffness_DownCast(thing):
    return _StepFEA.Handle_StepFEA_FeaShellMembraneStiffness_DownCast(thing)
Handle_StepFEA_FeaShellMembraneStiffness_DownCast = _StepFEA.Handle_StepFEA_FeaShellMembraneStiffness_DownCast

class StepFEA_FeaShellMembraneBendingCouplingStiffness(StepFEA_FeaMaterialPropertyRepresentationItem):
    """Representation of STEP entity FeaShellMembraneBendingCouplingStiffness"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_FeaShellMembraneBendingCouplingStiffness self) -> StepFEA_FeaShellMembraneBendingCouplingStiffness

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_FeaShellMembraneBendingCouplingStiffness(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_FeaShellMembraneBendingCouplingStiffness self, Handle_TCollection_HAsciiString aRepresentationItem_Name, StepFEA_SymmetricTensor42d aFeaConstants)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFeaConstants: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor42d

        """
        return _StepFEA.StepFEA_FeaShellMembraneBendingCouplingStiffness_Init(self, *args)


    def FeaConstants(self, *args):
        """
        FeaConstants(StepFEA_FeaShellMembraneBendingCouplingStiffness self) -> StepFEA_SymmetricTensor42d

        Returns field FeaConstants

        :rtype: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor42d

        """
        return _StepFEA.StepFEA_FeaShellMembraneBendingCouplingStiffness_FeaConstants(self, *args)


    def SetFeaConstants(self, *args):
        """
        SetFeaConstants(StepFEA_FeaShellMembraneBendingCouplingStiffness self, StepFEA_SymmetricTensor42d FeaConstants)

        Set field FeaConstants

        :type FeaConstants: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor42d

        """
        return _StepFEA.StepFEA_FeaShellMembraneBendingCouplingStiffness_SetFeaConstants(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_FeaShellMembraneBendingCouplingStiffness_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_FeaShellMembraneBendingCouplingStiffness_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_FeaShellMembraneBendingCouplingStiffness_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_FeaShellMembraneBendingCouplingStiffness
StepFEA_FeaShellMembraneBendingCouplingStiffness_swigregister = _StepFEA.StepFEA_FeaShellMembraneBendingCouplingStiffness_swigregister
StepFEA_FeaShellMembraneBendingCouplingStiffness_swigregister(StepFEA_FeaShellMembraneBendingCouplingStiffness)

def StepFEA_FeaShellMembraneBendingCouplingStiffness_get_type_name(*args):
    """
    StepFEA_FeaShellMembraneBendingCouplingStiffness_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_FeaShellMembraneBendingCouplingStiffness_get_type_name(*args)

def StepFEA_FeaShellMembraneBendingCouplingStiffness_get_type_descriptor(*args):
    """
    StepFEA_FeaShellMembraneBendingCouplingStiffness_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_FeaShellMembraneBendingCouplingStiffness_get_type_descriptor(*args)

class Handle_StepFEA_FeaGroup(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_FeaGroup self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_FeaGroup_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_FeaGroup self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_FeaGroup_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_FeaGroup self, StepFEA_FeaGroup thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_FeaGroup_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_FeaGroup self, Handle_StepFEA_FeaGroup theHandle) -> Handle_StepFEA_FeaGroup
        assign(Handle_StepFEA_FeaGroup self, StepFEA_FeaGroup thePtr) -> Handle_StepFEA_FeaGroup
        assign(Handle_StepFEA_FeaGroup self, Handle_StepFEA_FeaGroup theHandle) -> Handle_StepFEA_FeaGroup

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_FeaGroup_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_FeaGroup self) -> StepFEA_FeaGroup

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaGroup_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_FeaGroup self) -> StepFEA_FeaGroup

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaGroup___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_FeaGroup self) -> StepFEA_FeaGroup

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_FeaGroup___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_FeaGroup___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_FeaGroup___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_FeaGroup(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_FeaGroup_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_FeaGroup

    def Init(self, *args):
        """
        Init(Handle_StepFEA_FeaGroup self, Handle_TCollection_HAsciiString aGroup_Name, Handle_TCollection_HAsciiString aGroup_Description, Handle_StepFEA_FeaModel aModelRef)

        Initialize all fields (own and inherited)

        :type aGroup_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aGroup_Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel

        """
        return _StepFEA.Handle_StepFEA_FeaGroup_Init(self, *args)


    def ModelRef(self, *args):
        """
        ModelRef(Handle_StepFEA_FeaGroup self) -> Handle_StepFEA_FeaModel

        Returns field ModelRef

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel

        """
        return _StepFEA.Handle_StepFEA_FeaGroup_ModelRef(self, *args)


    def SetModelRef(self, *args):
        """
        SetModelRef(Handle_StepFEA_FeaGroup self, Handle_StepFEA_FeaModel ModelRef)

        Set field ModelRef

        :type ModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel

        """
        return _StepFEA.Handle_StepFEA_FeaGroup_SetModelRef(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_FeaGroup self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_FeaGroup_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaGroup_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaGroup_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Name(self, *args):
        """
        Name(Handle_StepFEA_FeaGroup self) -> Handle_TCollection_HAsciiString

        Returns field Name

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaGroup_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_FeaGroup self, Handle_TCollection_HAsciiString Name)

        Set field Name

        :type Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaGroup_SetName(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepFEA_FeaGroup self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaGroup_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepFEA_FeaGroup self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaGroup_SetDescription(self, *args)


    def HasDescription(self, *args):
        """
        HasDescription(Handle_StepFEA_FeaGroup self) -> Standard_Boolean

        Returns True if optional field Description is defined

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaGroup_HasDescription(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_FeaGroup self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_FeaGroup_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_FeaGroup self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_FeaGroup self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaGroup_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_FeaGroup self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_FeaGroup self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaGroup_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_FeaGroup self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_FeaGroup_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_FeaGroup self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaGroup_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_FeaGroup self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_FeaGroup_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_FeaGroup self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaGroup_DecrementRefCounter(self, *args)

Handle_StepFEA_FeaGroup_swigregister = _StepFEA.Handle_StepFEA_FeaGroup_swigregister
Handle_StepFEA_FeaGroup_swigregister(Handle_StepFEA_FeaGroup)

def Handle_StepFEA_FeaGroup_DownCast(thing):
    return _StepFEA.Handle_StepFEA_FeaGroup_DownCast(thing)
Handle_StepFEA_FeaGroup_DownCast = _StepFEA.Handle_StepFEA_FeaGroup_DownCast

class Handle_StepFEA_CurveElementEndRelease(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_CurveElementEndRelease self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_CurveElementEndRelease_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_CurveElementEndRelease self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_CurveElementEndRelease_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_CurveElementEndRelease self, StepFEA_CurveElementEndRelease thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_CurveElementEndRelease_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_CurveElementEndRelease self, Handle_StepFEA_CurveElementEndRelease theHandle) -> Handle_StepFEA_CurveElementEndRelease
        assign(Handle_StepFEA_CurveElementEndRelease self, StepFEA_CurveElementEndRelease thePtr) -> Handle_StepFEA_CurveElementEndRelease
        assign(Handle_StepFEA_CurveElementEndRelease self, Handle_StepFEA_CurveElementEndRelease theHandle) -> Handle_StepFEA_CurveElementEndRelease

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_CurveElementEndRelease_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_CurveElementEndRelease self) -> StepFEA_CurveElementEndRelease

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_CurveElementEndRelease_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_CurveElementEndRelease self) -> StepFEA_CurveElementEndRelease

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_CurveElementEndRelease___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_CurveElementEndRelease self) -> StepFEA_CurveElementEndRelease

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_CurveElementEndRelease___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_CurveElementEndRelease___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_CurveElementEndRelease___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_CurveElementEndRelease(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_CurveElementEndRelease_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_CurveElementEndRelease

    def Init(self, *args):
        """
        Init(Handle_StepFEA_CurveElementEndRelease self, StepFEA_CurveElementEndCoordinateSystem aCoordinateSystem, Handle_StepElement_HArray1OfCurveElementEndReleasePacket aReleases)

        Initialize all fields (own and inherited)

        :type aCoordinateSystem: OCC.wrapper.StepFEA.StepFEA_CurveElementEndCoordinateSystem
        :type aReleases: OCC.wrapper.StepElement.Handle_StepElement_HArray1OfCurveElementEndReleasePacket

        """
        return _StepFEA.Handle_StepFEA_CurveElementEndRelease_Init(self, *args)


    def CoordinateSystem(self, *args):
        """
        CoordinateSystem(Handle_StepFEA_CurveElementEndRelease self) -> StepFEA_CurveElementEndCoordinateSystem

        Returns field CoordinateSystem

        :rtype: OCC.wrapper.StepFEA.StepFEA_CurveElementEndCoordinateSystem

        """
        return _StepFEA.Handle_StepFEA_CurveElementEndRelease_CoordinateSystem(self, *args)


    def SetCoordinateSystem(self, *args):
        """
        SetCoordinateSystem(Handle_StepFEA_CurveElementEndRelease self, StepFEA_CurveElementEndCoordinateSystem CoordinateSystem)

        Set field CoordinateSystem

        :type CoordinateSystem: OCC.wrapper.StepFEA.StepFEA_CurveElementEndCoordinateSystem

        """
        return _StepFEA.Handle_StepFEA_CurveElementEndRelease_SetCoordinateSystem(self, *args)


    def Releases(self, *args):
        """
        Releases(Handle_StepFEA_CurveElementEndRelease self) -> Handle_StepElement_HArray1OfCurveElementEndReleasePacket

        Returns field Releases

        :rtype: OCC.wrapper.StepElement.Handle_StepElement_HArray1OfCurveElementEndReleasePacket

        """
        return _StepFEA.Handle_StepFEA_CurveElementEndRelease_Releases(self, *args)


    def SetReleases(self, *args):
        """
        SetReleases(Handle_StepFEA_CurveElementEndRelease self, Handle_StepElement_HArray1OfCurveElementEndReleasePacket Releases)

        Set field Releases

        :type Releases: OCC.wrapper.StepElement.Handle_StepElement_HArray1OfCurveElementEndReleasePacket

        """
        return _StepFEA.Handle_StepFEA_CurveElementEndRelease_SetReleases(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_CurveElementEndRelease self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_CurveElementEndRelease_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_CurveElementEndRelease_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_CurveElementEndRelease_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_CurveElementEndRelease self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_CurveElementEndRelease_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_CurveElementEndRelease self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_CurveElementEndRelease self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_CurveElementEndRelease_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_CurveElementEndRelease self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_CurveElementEndRelease self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_CurveElementEndRelease_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_CurveElementEndRelease self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_CurveElementEndRelease_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_CurveElementEndRelease self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_CurveElementEndRelease_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_CurveElementEndRelease self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_CurveElementEndRelease_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_CurveElementEndRelease self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_CurveElementEndRelease_DecrementRefCounter(self, *args)

Handle_StepFEA_CurveElementEndRelease_swigregister = _StepFEA.Handle_StepFEA_CurveElementEndRelease_swigregister
Handle_StepFEA_CurveElementEndRelease_swigregister(Handle_StepFEA_CurveElementEndRelease)

def Handle_StepFEA_CurveElementEndRelease_DownCast(thing):
    return _StepFEA.Handle_StepFEA_CurveElementEndRelease_DownCast(thing)
Handle_StepFEA_CurveElementEndRelease_DownCast = _StepFEA.Handle_StepFEA_CurveElementEndRelease_DownCast

class StepFEA_ElementGeometricRelationship(Standard.Standard_Transient):
    """Representation of STEP entity ElementGeometricRelationship"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_ElementGeometricRelationship
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_ElementGeometricRelationship(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_ElementGeometricRelationship self) -> StepFEA_ElementGeometricRelationship

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_ElementGeometricRelationship(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_ElementGeometricRelationship self, StepFEA_ElementOrElementGroup aElementRef, Handle_StepElement_AnalysisItemWithinRepresentation aItem, StepElement_ElementAspect aAspect)

        Initialize all fields (own and inherited)

        :type aElementRef: OCC.wrapper.StepFEA.StepFEA_ElementOrElementGroup
        :type aItem: OCC.wrapper.StepElement.Handle_StepElement_AnalysisItemWithinRepresentation
        :type aAspect: OCC.wrapper.StepElement.StepElement_ElementAspect

        """
        return _StepFEA.StepFEA_ElementGeometricRelationship_Init(self, *args)


    def ElementRef(self, *args):
        """
        ElementRef(StepFEA_ElementGeometricRelationship self) -> StepFEA_ElementOrElementGroup

        Returns field ElementRef

        :rtype: OCC.wrapper.StepFEA.StepFEA_ElementOrElementGroup

        """
        return _StepFEA.StepFEA_ElementGeometricRelationship_ElementRef(self, *args)


    def SetElementRef(self, *args):
        """
        SetElementRef(StepFEA_ElementGeometricRelationship self, StepFEA_ElementOrElementGroup ElementRef)

        Set field ElementRef

        :type ElementRef: OCC.wrapper.StepFEA.StepFEA_ElementOrElementGroup

        """
        return _StepFEA.StepFEA_ElementGeometricRelationship_SetElementRef(self, *args)


    def Item(self, *args):
        """
        Item(StepFEA_ElementGeometricRelationship self) -> Handle_StepElement_AnalysisItemWithinRepresentation

        Returns field Item

        :rtype: OCC.wrapper.StepElement.Handle_StepElement_AnalysisItemWithinRepresentation

        """
        return _StepFEA.StepFEA_ElementGeometricRelationship_Item(self, *args)


    def SetItem(self, *args):
        """
        SetItem(StepFEA_ElementGeometricRelationship self, Handle_StepElement_AnalysisItemWithinRepresentation Item)

        Set field Item

        :type Item: OCC.wrapper.StepElement.Handle_StepElement_AnalysisItemWithinRepresentation

        """
        return _StepFEA.StepFEA_ElementGeometricRelationship_SetItem(self, *args)


    def Aspect(self, *args):
        """
        Aspect(StepFEA_ElementGeometricRelationship self) -> StepElement_ElementAspect

        Returns field Aspect

        :rtype: OCC.wrapper.StepElement.StepElement_ElementAspect

        """
        return _StepFEA.StepFEA_ElementGeometricRelationship_Aspect(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(StepFEA_ElementGeometricRelationship self, StepElement_ElementAspect Aspect)

        Set field Aspect

        :type Aspect: OCC.wrapper.StepElement.StepElement_ElementAspect

        """
        return _StepFEA.StepFEA_ElementGeometricRelationship_SetAspect(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_ElementGeometricRelationship_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_ElementGeometricRelationship_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_ElementGeometricRelationship_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_ElementGeometricRelationship
StepFEA_ElementGeometricRelationship_swigregister = _StepFEA.StepFEA_ElementGeometricRelationship_swigregister
StepFEA_ElementGeometricRelationship_swigregister(StepFEA_ElementGeometricRelationship)

def StepFEA_ElementGeometricRelationship_get_type_name(*args):
    """
    StepFEA_ElementGeometricRelationship_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_ElementGeometricRelationship_get_type_name(*args)

def StepFEA_ElementGeometricRelationship_get_type_descriptor(*args):
    """
    StepFEA_ElementGeometricRelationship_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_ElementGeometricRelationship_get_type_descriptor(*args)

class StepFEA_NodeWithSolutionCoordinateSystem(StepFEA_Node):
    """Representation of STEP entity NodeWithSolutionCoordinateSystem"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_NodeWithSolutionCoordinateSystem
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_NodeWithSolutionCoordinateSystem(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_NodeWithSolutionCoordinateSystem self) -> StepFEA_NodeWithSolutionCoordinateSystem

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_NodeWithSolutionCoordinateSystem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_NodeWithSolutionCoordinateSystem_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_NodeWithSolutionCoordinateSystem_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_NodeWithSolutionCoordinateSystem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_NodeWithSolutionCoordinateSystem
StepFEA_NodeWithSolutionCoordinateSystem_swigregister = _StepFEA.StepFEA_NodeWithSolutionCoordinateSystem_swigregister
StepFEA_NodeWithSolutionCoordinateSystem_swigregister(StepFEA_NodeWithSolutionCoordinateSystem)

def StepFEA_NodeWithSolutionCoordinateSystem_get_type_name(*args):
    """
    StepFEA_NodeWithSolutionCoordinateSystem_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_NodeWithSolutionCoordinateSystem_get_type_name(*args)

def StepFEA_NodeWithSolutionCoordinateSystem_get_type_descriptor(*args):
    """
    StepFEA_NodeWithSolutionCoordinateSystem_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_NodeWithSolutionCoordinateSystem_get_type_descriptor(*args)

class Handle_StepFEA_FeaMaterialPropertyRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_FeaMaterialPropertyRepresentation self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_FeaMaterialPropertyRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_FeaMaterialPropertyRepresentation self, StepFEA_FeaMaterialPropertyRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_FeaMaterialPropertyRepresentation self, Handle_StepFEA_FeaMaterialPropertyRepresentation theHandle) -> Handle_StepFEA_FeaMaterialPropertyRepresentation
        assign(Handle_StepFEA_FeaMaterialPropertyRepresentation self, StepFEA_FeaMaterialPropertyRepresentation thePtr) -> Handle_StepFEA_FeaMaterialPropertyRepresentation
        assign(Handle_StepFEA_FeaMaterialPropertyRepresentation self, Handle_StepFEA_FeaMaterialPropertyRepresentation theHandle) -> Handle_StepFEA_FeaMaterialPropertyRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_FeaMaterialPropertyRepresentation self) -> StepFEA_FeaMaterialPropertyRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_FeaMaterialPropertyRepresentation self) -> StepFEA_FeaMaterialPropertyRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_FeaMaterialPropertyRepresentation self) -> StepFEA_FeaMaterialPropertyRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentation___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_FeaMaterialPropertyRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentation_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_FeaMaterialPropertyRepresentation

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_FeaMaterialPropertyRepresentation self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepFEA_FeaMaterialPropertyRepresentation self, StepRepr_RepresentedDefinition aPropertyDefinitionRepresentation_Definition, Handle_StepRepr_Representation aPropertyDefinitionRepresentation_UsedRepresentation, Handle_StepRepr_DataEnvironment aDependentEnvironment)

        Initialize all fields (own and inherited)

        :type aPropertyDefinitionRepresentation_Definition: OCC.wrapper.StepRepr.StepRepr_RepresentedDefinition
        :type aPropertyDefinitionRepresentation_UsedRepresentation: OCC.wrapper.StepRepr.Handle_StepRepr_Representation
        :type aDependentEnvironment: OCC.wrapper.StepRepr.Handle_StepRepr_DataEnvironment

        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentation_Init(self, *args)


    def DependentEnvironment(self, *args):
        """
        DependentEnvironment(Handle_StepFEA_FeaMaterialPropertyRepresentation self) -> Handle_StepRepr_DataEnvironment

        Returns field DependentEnvironment

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_DataEnvironment

        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentation_DependentEnvironment(self, *args)


    def SetDependentEnvironment(self, *args):
        """
        SetDependentEnvironment(Handle_StepFEA_FeaMaterialPropertyRepresentation self, Handle_StepRepr_DataEnvironment DependentEnvironment)

        Set field DependentEnvironment

        :type DependentEnvironment: OCC.wrapper.StepRepr.Handle_StepRepr_DataEnvironment

        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentation_SetDependentEnvironment(self, *args)


    def Definition(self, *args):
        """
        Definition(Handle_StepFEA_FeaMaterialPropertyRepresentation self) -> StepRepr_RepresentedDefinition

        Returns field Definition

        :rtype: OCC.wrapper.StepRepr.StepRepr_RepresentedDefinition

        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentation_Definition(self, *args)


    def SetDefinition(self, *args):
        """
        SetDefinition(Handle_StepFEA_FeaMaterialPropertyRepresentation self, StepRepr_RepresentedDefinition Definition)

        Set field Definition

        :type Definition: OCC.wrapper.StepRepr.StepRepr_RepresentedDefinition

        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentation_SetDefinition(self, *args)


    def UsedRepresentation(self, *args):
        """
        UsedRepresentation(Handle_StepFEA_FeaMaterialPropertyRepresentation self) -> Handle_StepRepr_Representation

        Returns field UsedRepresentation

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_Representation

        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentation_UsedRepresentation(self, *args)


    def SetUsedRepresentation(self, *args):
        """
        SetUsedRepresentation(Handle_StepFEA_FeaMaterialPropertyRepresentation self, Handle_StepRepr_Representation UsedRepresentation)

        Set field UsedRepresentation

        :type UsedRepresentation: OCC.wrapper.StepRepr.Handle_StepRepr_Representation

        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentation_SetUsedRepresentation(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_FeaMaterialPropertyRepresentation self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_FeaMaterialPropertyRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_FeaMaterialPropertyRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_FeaMaterialPropertyRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_FeaMaterialPropertyRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_FeaMaterialPropertyRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_FeaMaterialPropertyRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_FeaMaterialPropertyRepresentation self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_FeaMaterialPropertyRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentation_DecrementRefCounter(self, *args)

Handle_StepFEA_FeaMaterialPropertyRepresentation_swigregister = _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentation_swigregister
Handle_StepFEA_FeaMaterialPropertyRepresentation_swigregister(Handle_StepFEA_FeaMaterialPropertyRepresentation)

def Handle_StepFEA_FeaMaterialPropertyRepresentation_DownCast(thing):
    return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentation_DownCast(thing)
Handle_StepFEA_FeaMaterialPropertyRepresentation_DownCast = _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentation_DownCast

class Handle_StepFEA_FeaRepresentationItem(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_FeaRepresentationItem self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_FeaRepresentationItem_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_FeaRepresentationItem self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_FeaRepresentationItem_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_FeaRepresentationItem self, StepFEA_FeaRepresentationItem thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_FeaRepresentationItem_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_FeaRepresentationItem self, Handle_StepFEA_FeaRepresentationItem theHandle) -> Handle_StepFEA_FeaRepresentationItem
        assign(Handle_StepFEA_FeaRepresentationItem self, StepFEA_FeaRepresentationItem thePtr) -> Handle_StepFEA_FeaRepresentationItem
        assign(Handle_StepFEA_FeaRepresentationItem self, Handle_StepFEA_FeaRepresentationItem theHandle) -> Handle_StepFEA_FeaRepresentationItem

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_FeaRepresentationItem_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_FeaRepresentationItem self) -> StepFEA_FeaRepresentationItem

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaRepresentationItem_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_FeaRepresentationItem self) -> StepFEA_FeaRepresentationItem

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaRepresentationItem___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_FeaRepresentationItem self) -> StepFEA_FeaRepresentationItem

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_FeaRepresentationItem___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_FeaRepresentationItem___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_FeaRepresentationItem___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_FeaRepresentationItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_FeaRepresentationItem_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_FeaRepresentationItem

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_FeaRepresentationItem self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_FeaRepresentationItem_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaRepresentationItem_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaRepresentationItem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepFEA_FeaRepresentationItem self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaRepresentationItem_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_FeaRepresentationItem self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaRepresentationItem_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_FeaRepresentationItem self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaRepresentationItem_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_FeaRepresentationItem self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_FeaRepresentationItem_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_FeaRepresentationItem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_FeaRepresentationItem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaRepresentationItem_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_FeaRepresentationItem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_FeaRepresentationItem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaRepresentationItem_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_FeaRepresentationItem self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_FeaRepresentationItem_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_FeaRepresentationItem self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaRepresentationItem_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_FeaRepresentationItem self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_FeaRepresentationItem_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_FeaRepresentationItem self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaRepresentationItem_DecrementRefCounter(self, *args)

Handle_StepFEA_FeaRepresentationItem_swigregister = _StepFEA.Handle_StepFEA_FeaRepresentationItem_swigregister
Handle_StepFEA_FeaRepresentationItem_swigregister(Handle_StepFEA_FeaRepresentationItem)

def Handle_StepFEA_FeaRepresentationItem_DownCast(thing):
    return _StepFEA.Handle_StepFEA_FeaRepresentationItem_DownCast(thing)
Handle_StepFEA_FeaRepresentationItem_DownCast = _StepFEA.Handle_StepFEA_FeaRepresentationItem_DownCast

class Handle_StepFEA_ConstantSurface3dElementCoordinateSystem(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_ConstantSurface3dElementCoordinateSystem self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_ConstantSurface3dElementCoordinateSystem_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_ConstantSurface3dElementCoordinateSystem self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_ConstantSurface3dElementCoordinateSystem_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_ConstantSurface3dElementCoordinateSystem self, StepFEA_ConstantSurface3dElementCoordinateSystem thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_ConstantSurface3dElementCoordinateSystem_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_ConstantSurface3dElementCoordinateSystem self, Handle_StepFEA_ConstantSurface3dElementCoordinateSystem theHandle) -> Handle_StepFEA_ConstantSurface3dElementCoordinateSystem
        assign(Handle_StepFEA_ConstantSurface3dElementCoordinateSystem self, StepFEA_ConstantSurface3dElementCoordinateSystem thePtr) -> Handle_StepFEA_ConstantSurface3dElementCoordinateSystem
        assign(Handle_StepFEA_ConstantSurface3dElementCoordinateSystem self, Handle_StepFEA_ConstantSurface3dElementCoordinateSystem theHandle) -> Handle_StepFEA_ConstantSurface3dElementCoordinateSystem

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_ConstantSurface3dElementCoordinateSystem_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_ConstantSurface3dElementCoordinateSystem self) -> StepFEA_ConstantSurface3dElementCoordinateSystem

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_ConstantSurface3dElementCoordinateSystem_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_ConstantSurface3dElementCoordinateSystem self) -> StepFEA_ConstantSurface3dElementCoordinateSystem

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_ConstantSurface3dElementCoordinateSystem___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_ConstantSurface3dElementCoordinateSystem self) -> StepFEA_ConstantSurface3dElementCoordinateSystem

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_ConstantSurface3dElementCoordinateSystem___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_ConstantSurface3dElementCoordinateSystem___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_ConstantSurface3dElementCoordinateSystem___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_ConstantSurface3dElementCoordinateSystem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_ConstantSurface3dElementCoordinateSystem_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_ConstantSurface3dElementCoordinateSystem

    def Init(self, *args):
        """
        Init(Handle_StepFEA_ConstantSurface3dElementCoordinateSystem self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Standard_Integer const aAxis, Standard_Real const aAngle)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aAxis: int
        :type aAngle: float

        """
        return _StepFEA.Handle_StepFEA_ConstantSurface3dElementCoordinateSystem_Init(self, *args)


    def Axis(self, *args):
        """
        Axis(Handle_StepFEA_ConstantSurface3dElementCoordinateSystem self) -> Standard_Integer

        Returns field Axis

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_ConstantSurface3dElementCoordinateSystem_Axis(self, *args)


    def SetAxis(self, *args):
        """
        SetAxis(Handle_StepFEA_ConstantSurface3dElementCoordinateSystem self, Standard_Integer const Axis)

        Set field Axis

        :type Axis: int

        """
        return _StepFEA.Handle_StepFEA_ConstantSurface3dElementCoordinateSystem_SetAxis(self, *args)


    def Angle(self, *args):
        """
        Angle(Handle_StepFEA_ConstantSurface3dElementCoordinateSystem self) -> Standard_Real

        Returns field Angle

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepFEA.Handle_StepFEA_ConstantSurface3dElementCoordinateSystem_Angle(self, *args)


    def SetAngle(self, *args):
        """
        SetAngle(Handle_StepFEA_ConstantSurface3dElementCoordinateSystem self, Standard_Real const Angle)

        Set field Angle

        :type Angle: float

        """
        return _StepFEA.Handle_StepFEA_ConstantSurface3dElementCoordinateSystem_SetAngle(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_ConstantSurface3dElementCoordinateSystem self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_ConstantSurface3dElementCoordinateSystem_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_ConstantSurface3dElementCoordinateSystem_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_ConstantSurface3dElementCoordinateSystem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_ConstantSurface3dElementCoordinateSystem self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_ConstantSurface3dElementCoordinateSystem_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_ConstantSurface3dElementCoordinateSystem self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_ConstantSurface3dElementCoordinateSystem_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_ConstantSurface3dElementCoordinateSystem self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_ConstantSurface3dElementCoordinateSystem_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_ConstantSurface3dElementCoordinateSystem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_ConstantSurface3dElementCoordinateSystem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_ConstantSurface3dElementCoordinateSystem_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_ConstantSurface3dElementCoordinateSystem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_ConstantSurface3dElementCoordinateSystem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_ConstantSurface3dElementCoordinateSystem_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_ConstantSurface3dElementCoordinateSystem self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_ConstantSurface3dElementCoordinateSystem_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_ConstantSurface3dElementCoordinateSystem self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_ConstantSurface3dElementCoordinateSystem_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_ConstantSurface3dElementCoordinateSystem self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_ConstantSurface3dElementCoordinateSystem_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_ConstantSurface3dElementCoordinateSystem self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_ConstantSurface3dElementCoordinateSystem_DecrementRefCounter(self, *args)

Handle_StepFEA_ConstantSurface3dElementCoordinateSystem_swigregister = _StepFEA.Handle_StepFEA_ConstantSurface3dElementCoordinateSystem_swigregister
Handle_StepFEA_ConstantSurface3dElementCoordinateSystem_swigregister(Handle_StepFEA_ConstantSurface3dElementCoordinateSystem)

def Handle_StepFEA_ConstantSurface3dElementCoordinateSystem_DownCast(thing):
    return _StepFEA.Handle_StepFEA_ConstantSurface3dElementCoordinateSystem_DownCast(thing)
Handle_StepFEA_ConstantSurface3dElementCoordinateSystem_DownCast = _StepFEA.Handle_StepFEA_ConstantSurface3dElementCoordinateSystem_DownCast

class Handle_StepFEA_AlignedSurface3dElementCoordinateSystem(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_AlignedSurface3dElementCoordinateSystem self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_AlignedSurface3dElementCoordinateSystem_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_AlignedSurface3dElementCoordinateSystem self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_AlignedSurface3dElementCoordinateSystem_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_AlignedSurface3dElementCoordinateSystem self, StepFEA_AlignedSurface3dElementCoordinateSystem thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_AlignedSurface3dElementCoordinateSystem_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_AlignedSurface3dElementCoordinateSystem self, Handle_StepFEA_AlignedSurface3dElementCoordinateSystem theHandle) -> Handle_StepFEA_AlignedSurface3dElementCoordinateSystem
        assign(Handle_StepFEA_AlignedSurface3dElementCoordinateSystem self, StepFEA_AlignedSurface3dElementCoordinateSystem thePtr) -> Handle_StepFEA_AlignedSurface3dElementCoordinateSystem
        assign(Handle_StepFEA_AlignedSurface3dElementCoordinateSystem self, Handle_StepFEA_AlignedSurface3dElementCoordinateSystem theHandle) -> Handle_StepFEA_AlignedSurface3dElementCoordinateSystem

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_AlignedSurface3dElementCoordinateSystem_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_AlignedSurface3dElementCoordinateSystem self) -> StepFEA_AlignedSurface3dElementCoordinateSystem

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_AlignedSurface3dElementCoordinateSystem_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_AlignedSurface3dElementCoordinateSystem self) -> StepFEA_AlignedSurface3dElementCoordinateSystem

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_AlignedSurface3dElementCoordinateSystem___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_AlignedSurface3dElementCoordinateSystem self) -> StepFEA_AlignedSurface3dElementCoordinateSystem

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_AlignedSurface3dElementCoordinateSystem___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_AlignedSurface3dElementCoordinateSystem___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_AlignedSurface3dElementCoordinateSystem___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_AlignedSurface3dElementCoordinateSystem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_AlignedSurface3dElementCoordinateSystem_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_AlignedSurface3dElementCoordinateSystem

    def Init(self, *args):
        """
        Init(Handle_StepFEA_AlignedSurface3dElementCoordinateSystem self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Handle_StepFEA_FeaAxis2Placement3d aCoordinateSystem)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aCoordinateSystem: OCC.wrapper.StepFEA.Handle_StepFEA_FeaAxis2Placement3d

        """
        return _StepFEA.Handle_StepFEA_AlignedSurface3dElementCoordinateSystem_Init(self, *args)


    def CoordinateSystem(self, *args):
        """
        CoordinateSystem(Handle_StepFEA_AlignedSurface3dElementCoordinateSystem self) -> Handle_StepFEA_FeaAxis2Placement3d

        Returns field CoordinateSystem

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_FeaAxis2Placement3d

        """
        return _StepFEA.Handle_StepFEA_AlignedSurface3dElementCoordinateSystem_CoordinateSystem(self, *args)


    def SetCoordinateSystem(self, *args):
        """
        SetCoordinateSystem(Handle_StepFEA_AlignedSurface3dElementCoordinateSystem self, Handle_StepFEA_FeaAxis2Placement3d CoordinateSystem)

        Set field CoordinateSystem

        :type CoordinateSystem: OCC.wrapper.StepFEA.Handle_StepFEA_FeaAxis2Placement3d

        """
        return _StepFEA.Handle_StepFEA_AlignedSurface3dElementCoordinateSystem_SetCoordinateSystem(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_AlignedSurface3dElementCoordinateSystem self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_AlignedSurface3dElementCoordinateSystem_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_AlignedSurface3dElementCoordinateSystem_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_AlignedSurface3dElementCoordinateSystem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_AlignedSurface3dElementCoordinateSystem self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_AlignedSurface3dElementCoordinateSystem_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_AlignedSurface3dElementCoordinateSystem self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_AlignedSurface3dElementCoordinateSystem_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_AlignedSurface3dElementCoordinateSystem self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_AlignedSurface3dElementCoordinateSystem_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_AlignedSurface3dElementCoordinateSystem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_AlignedSurface3dElementCoordinateSystem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_AlignedSurface3dElementCoordinateSystem_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_AlignedSurface3dElementCoordinateSystem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_AlignedSurface3dElementCoordinateSystem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_AlignedSurface3dElementCoordinateSystem_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_AlignedSurface3dElementCoordinateSystem self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_AlignedSurface3dElementCoordinateSystem_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_AlignedSurface3dElementCoordinateSystem self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_AlignedSurface3dElementCoordinateSystem_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_AlignedSurface3dElementCoordinateSystem self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_AlignedSurface3dElementCoordinateSystem_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_AlignedSurface3dElementCoordinateSystem self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_AlignedSurface3dElementCoordinateSystem_DecrementRefCounter(self, *args)

Handle_StepFEA_AlignedSurface3dElementCoordinateSystem_swigregister = _StepFEA.Handle_StepFEA_AlignedSurface3dElementCoordinateSystem_swigregister
Handle_StepFEA_AlignedSurface3dElementCoordinateSystem_swigregister(Handle_StepFEA_AlignedSurface3dElementCoordinateSystem)

def Handle_StepFEA_AlignedSurface3dElementCoordinateSystem_DownCast(thing):
    return _StepFEA.Handle_StepFEA_AlignedSurface3dElementCoordinateSystem_DownCast(thing)
Handle_StepFEA_AlignedSurface3dElementCoordinateSystem_DownCast = _StepFEA.Handle_StepFEA_AlignedSurface3dElementCoordinateSystem_DownCast

class StepFEA_SymmetricTensor43d(StepData.StepData_SelectType):
    """Representation of STEP SELECT type SymmetricTensor43d"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepFEA_SymmetricTensor43d self) -> StepFEA_SymmetricTensor43d

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_SymmetricTensor43d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepFEA_SymmetricTensor43d self, Handle_Standard_Transient ent) -> Standard_Integer

        return 0

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.StepFEA_SymmetricTensor43d_CaseNum(self, *args)


    def CaseMem(self, *args):
        """
        CaseMem(StepFEA_SymmetricTensor43d self, Handle_StepData_SelectMember ent) -> Standard_Integer

        Recognizes a items of select member CurveElementFreedomMember
        1 -> AnisotropicSymmetricTensor43d
        2 -> FeaIsotropicSymmetricTensor43d
        3 -> FeaIsoOrthotropicSymmetricTensor43d
        4 -> FeaTransverseIsotropicSymmetricTensor43d
        5 -> FeaColumnNormalisedOrthotropicSymmetricTensor43d
        6 -> FeaColumnNormalisedMonoclinicSymmetricTensor43d
        0 else

        :type ent: OCC.wrapper.StepData.Handle_StepData_SelectMember
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.StepFEA_SymmetricTensor43d_CaseMem(self, *args)


    def NewMember(self, *args):
        """
        NewMember(StepFEA_SymmetricTensor43d self) -> Handle_StepData_SelectMember

        :rtype: OCC.wrapper.StepData.Handle_StepData_SelectMember

        """
        return _StepFEA.StepFEA_SymmetricTensor43d_NewMember(self, *args)


    def AnisotropicSymmetricTensor43d(self, *args):
        """
        AnisotropicSymmetricTensor43d(StepFEA_SymmetricTensor43d self) -> Handle_TColStd_HArray1OfReal

        Returns Value as AnisotropicSymmetricTensor43d (or Null if another type)

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepFEA.StepFEA_SymmetricTensor43d_AnisotropicSymmetricTensor43d(self, *args)


    def FeaIsotropicSymmetricTensor43d(self, *args):
        """
        FeaIsotropicSymmetricTensor43d(StepFEA_SymmetricTensor43d self) -> Handle_TColStd_HArray1OfReal

        Returns Value as FeaIsotropicSymmetricTensor43d (or Null if another type)

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepFEA.StepFEA_SymmetricTensor43d_FeaIsotropicSymmetricTensor43d(self, *args)


    def FeaIsoOrthotropicSymmetricTensor43d(self, *args):
        """
        FeaIsoOrthotropicSymmetricTensor43d(StepFEA_SymmetricTensor43d self) -> Handle_TColStd_HArray1OfReal

        Returns Value as FeaIsoOrthotropicSymmetricTensor43d (or Null if another type)

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepFEA.StepFEA_SymmetricTensor43d_FeaIsoOrthotropicSymmetricTensor43d(self, *args)


    def FeaTransverseIsotropicSymmetricTensor43d(self, *args):
        """
        FeaTransverseIsotropicSymmetricTensor43d(StepFEA_SymmetricTensor43d self) -> Handle_TColStd_HArray1OfReal

        Returns Value as FeaTransverseIsotropicSymmetricTensor43d (or Null if another type)

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepFEA.StepFEA_SymmetricTensor43d_FeaTransverseIsotropicSymmetricTensor43d(self, *args)


    def FeaColumnNormalisedOrthotropicSymmetricTensor43d(self, *args):
        """
        FeaColumnNormalisedOrthotropicSymmetricTensor43d(StepFEA_SymmetricTensor43d self) -> Handle_TColStd_HArray1OfReal

        Returns Value as FeaColumnNormalisedOrthotropicSymmetricTensor43d (or Null if another type)

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepFEA.StepFEA_SymmetricTensor43d_FeaColumnNormalisedOrthotropicSymmetricTensor43d(self, *args)


    def FeaColumnNormalisedMonoclinicSymmetricTensor43d(self, *args):
        """
        FeaColumnNormalisedMonoclinicSymmetricTensor43d(StepFEA_SymmetricTensor43d self) -> Handle_TColStd_HArray1OfReal

        Returns Value as FeaColumnNormalisedMonoclinicSymmetricTensor43d (or Null if another type)

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepFEA.StepFEA_SymmetricTensor43d_FeaColumnNormalisedMonoclinicSymmetricTensor43d(self, *args)

    __swig_destroy__ = _StepFEA.delete_StepFEA_SymmetricTensor43d
StepFEA_SymmetricTensor43d_swigregister = _StepFEA.StepFEA_SymmetricTensor43d_swigregister
StepFEA_SymmetricTensor43d_swigregister(StepFEA_SymmetricTensor43d)

class Handle_StepFEA_ElementRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_ElementRepresentation self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_ElementRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_ElementRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_ElementRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_ElementRepresentation self, StepFEA_ElementRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_ElementRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_ElementRepresentation self, Handle_StepFEA_ElementRepresentation theHandle) -> Handle_StepFEA_ElementRepresentation
        assign(Handle_StepFEA_ElementRepresentation self, StepFEA_ElementRepresentation thePtr) -> Handle_StepFEA_ElementRepresentation
        assign(Handle_StepFEA_ElementRepresentation self, Handle_StepFEA_ElementRepresentation theHandle) -> Handle_StepFEA_ElementRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_ElementRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_ElementRepresentation self) -> StepFEA_ElementRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_ElementRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_ElementRepresentation self) -> StepFEA_ElementRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_ElementRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_ElementRepresentation self) -> StepFEA_ElementRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_ElementRepresentation___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_ElementRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_ElementRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_ElementRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_ElementRepresentation_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_ElementRepresentation

    def Init(self, *args):
        """
        Init(Handle_StepFEA_ElementRepresentation self, Handle_TCollection_HAsciiString aRepresentation_Name, Handle_StepRepr_HArray1OfRepresentationItem aRepresentation_Items, Handle_StepRepr_RepresentationContext aRepresentation_ContextOfItems, Handle_StepFEA_HArray1OfNodeRepresentation aNodeList)

        Initialize all fields (own and inherited)

        :type aRepresentation_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRepresentation_Items: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aRepresentation_ContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext
        :type aNodeList: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation

        """
        return _StepFEA.Handle_StepFEA_ElementRepresentation_Init(self, *args)


    def NodeList(self, *args):
        """
        NodeList(Handle_StepFEA_ElementRepresentation self) -> Handle_StepFEA_HArray1OfNodeRepresentation

        Returns field NodeList

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation

        """
        return _StepFEA.Handle_StepFEA_ElementRepresentation_NodeList(self, *args)


    def SetNodeList(self, *args):
        """
        SetNodeList(Handle_StepFEA_ElementRepresentation self, Handle_StepFEA_HArray1OfNodeRepresentation NodeList)

        Set field NodeList

        :type NodeList: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation

        """
        return _StepFEA.Handle_StepFEA_ElementRepresentation_SetNodeList(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_ElementRepresentation self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_ElementRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_ElementRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_ElementRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_ElementRepresentation self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_ElementRepresentation_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_ElementRepresentation self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_ElementRepresentation_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepFEA_ElementRepresentation self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepFEA.Handle_StepFEA_ElementRepresentation_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepFEA_ElementRepresentation self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepFEA.Handle_StepFEA_ElementRepresentation_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepFEA_ElementRepresentation self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepFEA.Handle_StepFEA_ElementRepresentation_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepFEA_ElementRepresentation self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_ElementRepresentation_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepFEA_ElementRepresentation self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepFEA.Handle_StepFEA_ElementRepresentation_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepFEA_ElementRepresentation self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepFEA.Handle_StepFEA_ElementRepresentation_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_ElementRepresentation self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_ElementRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_ElementRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_ElementRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_ElementRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_ElementRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_ElementRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_ElementRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_ElementRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_ElementRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_ElementRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_ElementRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_ElementRepresentation self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_ElementRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_ElementRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_ElementRepresentation_DecrementRefCounter(self, *args)

Handle_StepFEA_ElementRepresentation_swigregister = _StepFEA.Handle_StepFEA_ElementRepresentation_swigregister
Handle_StepFEA_ElementRepresentation_swigregister(Handle_StepFEA_ElementRepresentation)

def Handle_StepFEA_ElementRepresentation_DownCast(thing):
    return _StepFEA.Handle_StepFEA_ElementRepresentation_DownCast(thing)
Handle_StepFEA_ElementRepresentation_DownCast = _StepFEA.Handle_StepFEA_ElementRepresentation_DownCast

class StepFEA_SymmetricTensor23dMember(StepData.StepData_SelectArrReal):
    """Representation of member for  STEP SELECT type SymmetricTensor23d"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_SymmetricTensor23dMember
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_SymmetricTensor23dMember(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_SymmetricTensor23dMember self) -> StepFEA_SymmetricTensor23dMember

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_SymmetricTensor23dMember(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def HasName(self, *args):
        """
        HasName(StepFEA_SymmetricTensor23dMember self) -> Standard_Boolean

        Returns True if has name

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.StepFEA_SymmetricTensor23dMember_HasName(self, *args)


    def Name(self, *args):
        """
        Name(StepFEA_SymmetricTensor23dMember self) -> Standard_CString

        Returns set name

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepFEA.StepFEA_SymmetricTensor23dMember_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(StepFEA_SymmetricTensor23dMember self, Standard_CString const name) -> Standard_Boolean

        Set name

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.StepFEA_SymmetricTensor23dMember_SetName(self, *args)


    def Matches(self, *args):
        """
        Matches(StepFEA_SymmetricTensor23dMember self, Standard_CString const name) -> Standard_Boolean

        Tells if the name of a SelectMember matches a given one;

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.StepFEA_SymmetricTensor23dMember_Matches(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_SymmetricTensor23dMember_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_SymmetricTensor23dMember_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_SymmetricTensor23dMember_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_SymmetricTensor23dMember
StepFEA_SymmetricTensor23dMember_swigregister = _StepFEA.StepFEA_SymmetricTensor23dMember_swigregister
StepFEA_SymmetricTensor23dMember_swigregister(StepFEA_SymmetricTensor23dMember)

def StepFEA_SymmetricTensor23dMember_get_type_name(*args):
    """
    StepFEA_SymmetricTensor23dMember_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_SymmetricTensor23dMember_get_type_name(*args)

def StepFEA_SymmetricTensor23dMember_get_type_descriptor(*args):
    """
    StepFEA_SymmetricTensor23dMember_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_SymmetricTensor23dMember_get_type_descriptor(*args)

class Handle_StepFEA_ParametricCurve3dElementCoordinateSystem(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_ParametricCurve3dElementCoordinateSystem self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateSystem_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_ParametricCurve3dElementCoordinateSystem self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateSystem_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_ParametricCurve3dElementCoordinateSystem self, StepFEA_ParametricCurve3dElementCoordinateSystem thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateSystem_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_ParametricCurve3dElementCoordinateSystem self, Handle_StepFEA_ParametricCurve3dElementCoordinateSystem theHandle) -> Handle_StepFEA_ParametricCurve3dElementCoordinateSystem
        assign(Handle_StepFEA_ParametricCurve3dElementCoordinateSystem self, StepFEA_ParametricCurve3dElementCoordinateSystem thePtr) -> Handle_StepFEA_ParametricCurve3dElementCoordinateSystem
        assign(Handle_StepFEA_ParametricCurve3dElementCoordinateSystem self, Handle_StepFEA_ParametricCurve3dElementCoordinateSystem theHandle) -> Handle_StepFEA_ParametricCurve3dElementCoordinateSystem

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateSystem_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_ParametricCurve3dElementCoordinateSystem self) -> StepFEA_ParametricCurve3dElementCoordinateSystem

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateSystem_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_ParametricCurve3dElementCoordinateSystem self) -> StepFEA_ParametricCurve3dElementCoordinateSystem

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateSystem___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_ParametricCurve3dElementCoordinateSystem self) -> StepFEA_ParametricCurve3dElementCoordinateSystem

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateSystem___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateSystem___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateSystem___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_ParametricCurve3dElementCoordinateSystem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateSystem_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_ParametricCurve3dElementCoordinateSystem

    def Init(self, *args):
        """
        Init(Handle_StepFEA_ParametricCurve3dElementCoordinateSystem self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Handle_StepFEA_ParametricCurve3dElementCoordinateDirection aDirection)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aDirection: OCC.wrapper.StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateDirection

        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateSystem_Init(self, *args)


    def Direction(self, *args):
        """
        Direction(Handle_StepFEA_ParametricCurve3dElementCoordinateSystem self) -> Handle_StepFEA_ParametricCurve3dElementCoordinateDirection

        Returns field Direction

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateDirection

        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateSystem_Direction(self, *args)


    def SetDirection(self, *args):
        """
        SetDirection(Handle_StepFEA_ParametricCurve3dElementCoordinateSystem self, Handle_StepFEA_ParametricCurve3dElementCoordinateDirection Direction)

        Set field Direction

        :type Direction: OCC.wrapper.StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateDirection

        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateSystem_SetDirection(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_ParametricCurve3dElementCoordinateSystem self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateSystem_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateSystem_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateSystem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_ParametricCurve3dElementCoordinateSystem self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateSystem_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_ParametricCurve3dElementCoordinateSystem self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateSystem_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_ParametricCurve3dElementCoordinateSystem self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateSystem_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_ParametricCurve3dElementCoordinateSystem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_ParametricCurve3dElementCoordinateSystem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateSystem_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_ParametricCurve3dElementCoordinateSystem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_ParametricCurve3dElementCoordinateSystem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateSystem_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_ParametricCurve3dElementCoordinateSystem self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateSystem_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_ParametricCurve3dElementCoordinateSystem self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateSystem_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_ParametricCurve3dElementCoordinateSystem self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateSystem_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_ParametricCurve3dElementCoordinateSystem self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateSystem_DecrementRefCounter(self, *args)

Handle_StepFEA_ParametricCurve3dElementCoordinateSystem_swigregister = _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateSystem_swigregister
Handle_StepFEA_ParametricCurve3dElementCoordinateSystem_swigregister(Handle_StepFEA_ParametricCurve3dElementCoordinateSystem)

def Handle_StepFEA_ParametricCurve3dElementCoordinateSystem_DownCast(thing):
    return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateSystem_DownCast(thing)
Handle_StepFEA_ParametricCurve3dElementCoordinateSystem_DownCast = _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateSystem_DownCast

class Handle_StepFEA_HArray1OfNodeRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_HArray1OfNodeRepresentation self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_HArray1OfNodeRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_HArray1OfNodeRepresentation self, StepFEA_HArray1OfNodeRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_HArray1OfNodeRepresentation self, Handle_StepFEA_HArray1OfNodeRepresentation theHandle) -> Handle_StepFEA_HArray1OfNodeRepresentation
        assign(Handle_StepFEA_HArray1OfNodeRepresentation self, StepFEA_HArray1OfNodeRepresentation thePtr) -> Handle_StepFEA_HArray1OfNodeRepresentation
        assign(Handle_StepFEA_HArray1OfNodeRepresentation self, Handle_StepFEA_HArray1OfNodeRepresentation theHandle) -> Handle_StepFEA_HArray1OfNodeRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_HArray1OfNodeRepresentation self) -> StepFEA_HArray1OfNodeRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_HArray1OfNodeRepresentation self) -> StepFEA_HArray1OfNodeRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_HArray1OfNodeRepresentation self) -> StepFEA_HArray1OfNodeRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_HArray1OfNodeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_HArray1OfNodeRepresentation

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepFEA.StepFEA_Array1OfNodeRepresentation

        """
        res = _StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepFEA_HArray1OfNodeRepresentation self) -> NCollection_Array1_Handle_StepFEA_NodeRepresentation

        :rtype: OCC.wrapper.StepFEA.StepFEA_Array1OfNodeRepresentation

        """
        return _StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_HArray1OfNodeRepresentation self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_HArray1OfNodeRepresentation self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_HArray1OfNodeRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_HArray1OfNodeRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_HArray1OfNodeRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_HArray1OfNodeRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_HArray1OfNodeRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_HArray1OfNodeRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_HArray1OfNodeRepresentation self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_HArray1OfNodeRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation_DecrementRefCounter(self, *args)

Handle_StepFEA_HArray1OfNodeRepresentation_swigregister = _StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation_swigregister
Handle_StepFEA_HArray1OfNodeRepresentation_swigregister(Handle_StepFEA_HArray1OfNodeRepresentation)

def Handle_StepFEA_HArray1OfNodeRepresentation_DownCast(thing):
    return _StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation_DownCast(thing)
Handle_StepFEA_HArray1OfNodeRepresentation_DownCast = _StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation_DownCast

class StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion(StepFEA_FeaMaterialPropertyRepresentationItem):
    """Representation of STEP entity FeaTangentialCoefficientOfLinearThermalExpansion"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion self) -> StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion self, Handle_TCollection_HAsciiString aRepresentationItem_Name, StepFEA_SymmetricTensor23d aFeaConstants)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFeaConstants: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor23d

        """
        return _StepFEA.StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_Init(self, *args)


    def FeaConstants(self, *args):
        """
        FeaConstants(StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion self) -> StepFEA_SymmetricTensor23d

        Returns field FeaConstants

        :rtype: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor23d

        """
        return _StepFEA.StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_FeaConstants(self, *args)


    def SetFeaConstants(self, *args):
        """
        SetFeaConstants(StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion self, StepFEA_SymmetricTensor23d FeaConstants)

        Set field FeaConstants

        :type FeaConstants: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor23d

        """
        return _StepFEA.StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_SetFeaConstants(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion
StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_swigregister = _StepFEA.StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_swigregister
StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_swigregister(StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion)

def StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_get_type_name(*args):
    """
    StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_get_type_name(*args)

def StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_get_type_descriptor(*args):
    """
    StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_get_type_descriptor(*args)

class Handle_StepFEA_NodeSet(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_NodeSet self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_NodeSet_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_NodeSet self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_NodeSet_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_NodeSet self, StepFEA_NodeSet thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_NodeSet_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_NodeSet self, Handle_StepFEA_NodeSet theHandle) -> Handle_StepFEA_NodeSet
        assign(Handle_StepFEA_NodeSet self, StepFEA_NodeSet thePtr) -> Handle_StepFEA_NodeSet
        assign(Handle_StepFEA_NodeSet self, Handle_StepFEA_NodeSet theHandle) -> Handle_StepFEA_NodeSet

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_NodeSet_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_NodeSet self) -> StepFEA_NodeSet

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_NodeSet_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_NodeSet self) -> StepFEA_NodeSet

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_NodeSet___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_NodeSet self) -> StepFEA_NodeSet

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_NodeSet___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_NodeSet___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_NodeSet___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_NodeSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_NodeSet_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_NodeSet

    def Init(self, *args):
        """
        Init(Handle_StepFEA_NodeSet self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Handle_StepFEA_HArray1OfNodeRepresentation aNodes)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aNodes: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation

        """
        return _StepFEA.Handle_StepFEA_NodeSet_Init(self, *args)


    def Nodes(self, *args):
        """
        Nodes(Handle_StepFEA_NodeSet self) -> Handle_StepFEA_HArray1OfNodeRepresentation

        Returns field Nodes

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation

        """
        return _StepFEA.Handle_StepFEA_NodeSet_Nodes(self, *args)


    def SetNodes(self, *args):
        """
        SetNodes(Handle_StepFEA_NodeSet self, Handle_StepFEA_HArray1OfNodeRepresentation Nodes)

        Set field Nodes

        :type Nodes: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation

        """
        return _StepFEA.Handle_StepFEA_NodeSet_SetNodes(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_NodeSet self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_NodeSet_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_NodeSet_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_NodeSet_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_NodeSet self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_NodeSet_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_NodeSet self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_NodeSet_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_NodeSet self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_NodeSet_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_NodeSet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_NodeSet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_NodeSet_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_NodeSet self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_NodeSet self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_NodeSet_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_NodeSet self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_NodeSet_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_NodeSet self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_NodeSet_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_NodeSet self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_NodeSet_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_NodeSet self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_NodeSet_DecrementRefCounter(self, *args)

Handle_StepFEA_NodeSet_swigregister = _StepFEA.Handle_StepFEA_NodeSet_swigregister
Handle_StepFEA_NodeSet_swigregister(Handle_StepFEA_NodeSet)

def Handle_StepFEA_NodeSet_DownCast(thing):
    return _StepFEA.Handle_StepFEA_NodeSet_DownCast(thing)
Handle_StepFEA_NodeSet_DownCast = _StepFEA.Handle_StepFEA_NodeSet_DownCast

class StepFEA_SymmetricTensor22d(StepData.StepData_SelectType):
    """Representation of STEP SELECT type SymmetricTensor22d"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepFEA_SymmetricTensor22d self) -> StepFEA_SymmetricTensor22d

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_SymmetricTensor22d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepFEA_SymmetricTensor22d self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a kind of SymmetricTensor22d select type
        1 -> HArray1OfReal from TColStd
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.StepFEA_SymmetricTensor22d_CaseNum(self, *args)


    def AnisotropicSymmetricTensor22d(self, *args):
        """
        AnisotropicSymmetricTensor22d(StepFEA_SymmetricTensor22d self) -> Handle_TColStd_HArray1OfReal

        Returns Value as AnisotropicSymmetricTensor22d (or Null if another type)

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepFEA.StepFEA_SymmetricTensor22d_AnisotropicSymmetricTensor22d(self, *args)

    __swig_destroy__ = _StepFEA.delete_StepFEA_SymmetricTensor22d
StepFEA_SymmetricTensor22d_swigregister = _StepFEA.StepFEA_SymmetricTensor22d_swigregister
StepFEA_SymmetricTensor22d_swigregister(StepFEA_SymmetricTensor22d)

class NCollection_Sequence_Handle_StepFEA_NodeRepresentation(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_StepFEA_NodeRepresentation self) -> NCollection_Sequence< opencascade::handle< StepFEA_NodeRepresentation > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_NodeRepresentation_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_StepFEA_NodeRepresentation self) -> NCollection_Sequence< opencascade::handle< StepFEA_NodeRepresentation > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_NodeRepresentation_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_StepFEA_NodeRepresentation self) -> NCollection_Sequence< opencascade::handle< StepFEA_NodeRepresentation > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_NodeRepresentation_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_StepFEA_NodeRepresentation self) -> NCollection_Sequence< opencascade::handle< StepFEA_NodeRepresentation > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_NodeRepresentation_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _StepFEA.new_NCollection_Sequence_Handle_StepFEA_NodeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_StepFEA_NodeRepresentation self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_NodeRepresentation_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_StepFEA_NodeRepresentation self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_NodeRepresentation_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_StepFEA_NodeRepresentation self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_NodeRepresentation_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_StepFEA_NodeRepresentation self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_NodeRepresentation_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_StepFEA_NodeRepresentation self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_NodeRepresentation_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_StepFEA_NodeRepresentation self)

        Reverse sequence


        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_NodeRepresentation_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_StepFEA_NodeRepresentation self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_NodeRepresentation_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_NodeRepresentation_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_StepFEA_NodeRepresentation self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_NodeRepresentation_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_StepFEA_NodeRepresentation self, NCollection_Sequence_Handle_StepFEA_NodeRepresentation theOther) -> NCollection_Sequence_Handle_StepFEA_NodeRepresentation

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_NodeRepresentation_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_StepFEA_NodeRepresentation self, NCollection_Sequence_Handle_StepFEA_NodeRepresentation theOther) -> NCollection_Sequence_Handle_StepFEA_NodeRepresentation

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_NodeRepresentation_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_StepFEA_NodeRepresentation self, NCollection_Sequence< opencascade::handle< StepFEA_NodeRepresentation > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_StepFEA_NodeRepresentation self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_StepFEA_NodeRepresentation self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_NodeRepresentation_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_StepFEA_NodeRepresentation self, Handle_StepFEA_NodeRepresentation theItem)
        Append(NCollection_Sequence_Handle_StepFEA_NodeRepresentation self, NCollection_Sequence_Handle_StepFEA_NodeRepresentation theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_NodeRepresentation_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_StepFEA_NodeRepresentation self, Handle_StepFEA_NodeRepresentation theItem)
        Prepend(NCollection_Sequence_Handle_StepFEA_NodeRepresentation self, NCollection_Sequence_Handle_StepFEA_NodeRepresentation theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_NodeRepresentation_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_StepFEA_NodeRepresentation self, Standard_Integer const theIndex, Handle_StepFEA_NodeRepresentation theItem)
        InsertBefore(NCollection_Sequence_Handle_StepFEA_NodeRepresentation self, Standard_Integer const theIndex, NCollection_Sequence_Handle_StepFEA_NodeRepresentation theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_NodeRepresentation_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_StepFEA_NodeRepresentation self, NCollection_Sequence< opencascade::handle< StepFEA_NodeRepresentation > >::Iterator & thePosition, Handle_StepFEA_NodeRepresentation theItem)
        InsertAfter(NCollection_Sequence_Handle_StepFEA_NodeRepresentation self, Standard_Integer const theIndex, NCollection_Sequence_Handle_StepFEA_NodeRepresentation theSeq)
        InsertAfter(NCollection_Sequence_Handle_StepFEA_NodeRepresentation self, Standard_Integer const theIndex, Handle_StepFEA_NodeRepresentation theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_NodeRepresentation_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_StepFEA_NodeRepresentation self, Standard_Integer const theIndex, NCollection_Sequence_Handle_StepFEA_NodeRepresentation theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_NodeRepresentation_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Sequence_Handle_StepFEA_NodeRepresentation_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_StepFEA_NodeRepresentation self) -> Handle_StepFEA_NodeRepresentation

        First item access

        :rtype: TheItemType &

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_NodeRepresentation_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Sequence_Handle_StepFEA_NodeRepresentation_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_StepFEA_NodeRepresentation self) -> Handle_StepFEA_NodeRepresentation

        Last item access

        :rtype: TheItemType &

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_NodeRepresentation_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Sequence_Handle_StepFEA_NodeRepresentation_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_StepFEA_NodeRepresentation self, Standard_Integer const theIndex) -> Handle_StepFEA_NodeRepresentation

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_NodeRepresentation_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Sequence_Handle_StepFEA_NodeRepresentation___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_StepFEA_NodeRepresentation self, Standard_Integer const theIndex, Handle_StepFEA_NodeRepresentation theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_NodeRepresentation_SetValue(self, *args)


    def __iter__(self):
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_NodeRepresentation___iter__(self)
    __swig_destroy__ = _StepFEA.delete_NCollection_Sequence_Handle_StepFEA_NodeRepresentation
NCollection_Sequence_Handle_StepFEA_NodeRepresentation_swigregister = _StepFEA.NCollection_Sequence_Handle_StepFEA_NodeRepresentation_swigregister
NCollection_Sequence_Handle_StepFEA_NodeRepresentation_swigregister(NCollection_Sequence_Handle_StepFEA_NodeRepresentation)

def NCollection_Sequence_Handle_StepFEA_NodeRepresentation_delNode(*args):
    """
    NCollection_Sequence_Handle_StepFEA_NodeRepresentation_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _StepFEA.NCollection_Sequence_Handle_StepFEA_NodeRepresentation_delNode(*args)

class NCollection_Sequence_Handle_StepFEA_NodeRepresentation_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _StepFEA.new_NCollection_Sequence_Handle_StepFEA_NodeRepresentation_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StepFEA.delete_NCollection_Sequence_Handle_StepFEA_NodeRepresentation_IteratorHelper

    def __next__(self):
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_NodeRepresentation_IteratorHelper___next__(self)
NCollection_Sequence_Handle_StepFEA_NodeRepresentation_IteratorHelper_swigregister = _StepFEA.NCollection_Sequence_Handle_StepFEA_NodeRepresentation_IteratorHelper_swigregister
NCollection_Sequence_Handle_StepFEA_NodeRepresentation_IteratorHelper_swigregister(NCollection_Sequence_Handle_StepFEA_NodeRepresentation_IteratorHelper)


try:
	StepFEA_SequenceOfNodeRepresentation = NCollection_Sequence_Handle_StepFEA_NodeRepresentation
except NameError:
	pass # does not exist, probably ignored

class Handle_StepFEA_FreedomsList(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_FreedomsList self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_FreedomsList_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_FreedomsList self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_FreedomsList_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_FreedomsList self, StepFEA_FreedomsList thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_FreedomsList_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_FreedomsList self, Handle_StepFEA_FreedomsList theHandle) -> Handle_StepFEA_FreedomsList
        assign(Handle_StepFEA_FreedomsList self, StepFEA_FreedomsList thePtr) -> Handle_StepFEA_FreedomsList
        assign(Handle_StepFEA_FreedomsList self, Handle_StepFEA_FreedomsList theHandle) -> Handle_StepFEA_FreedomsList

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_FreedomsList_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_FreedomsList self) -> StepFEA_FreedomsList

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FreedomsList_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_FreedomsList self) -> StepFEA_FreedomsList

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FreedomsList___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_FreedomsList self) -> StepFEA_FreedomsList

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_FreedomsList___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_FreedomsList___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_FreedomsList___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_FreedomsList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_FreedomsList_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_FreedomsList

    def Init(self, *args):
        """
        Init(Handle_StepFEA_FreedomsList self, Handle_StepFEA_HArray1OfDegreeOfFreedom aFreedoms)

        Initialize all fields (own and inherited)

        :type aFreedoms: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfDegreeOfFreedom

        """
        return _StepFEA.Handle_StepFEA_FreedomsList_Init(self, *args)


    def Freedoms(self, *args):
        """
        Freedoms(Handle_StepFEA_FreedomsList self) -> Handle_StepFEA_HArray1OfDegreeOfFreedom

        Returns field Freedoms

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfDegreeOfFreedom

        """
        return _StepFEA.Handle_StepFEA_FreedomsList_Freedoms(self, *args)


    def SetFreedoms(self, *args):
        """
        SetFreedoms(Handle_StepFEA_FreedomsList self, Handle_StepFEA_HArray1OfDegreeOfFreedom Freedoms)

        Set field Freedoms

        :type Freedoms: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfDegreeOfFreedom

        """
        return _StepFEA.Handle_StepFEA_FreedomsList_SetFreedoms(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_FreedomsList self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_FreedomsList_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FreedomsList_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FreedomsList_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_FreedomsList self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_FreedomsList_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_FreedomsList self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_FreedomsList self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FreedomsList_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_FreedomsList self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_FreedomsList self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FreedomsList_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_FreedomsList self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_FreedomsList_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_FreedomsList self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FreedomsList_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_FreedomsList self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_FreedomsList_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_FreedomsList self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FreedomsList_DecrementRefCounter(self, *args)

Handle_StepFEA_FreedomsList_swigregister = _StepFEA.Handle_StepFEA_FreedomsList_swigregister
Handle_StepFEA_FreedomsList_swigregister(Handle_StepFEA_FreedomsList)

def Handle_StepFEA_FreedomsList_DownCast(thing):
    return _StepFEA.Handle_StepFEA_FreedomsList_DownCast(thing)
Handle_StepFEA_FreedomsList_DownCast = _StepFEA.Handle_StepFEA_FreedomsList_DownCast

class Handle_StepFEA_FeaAreaDensity(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_FeaAreaDensity self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_FeaAreaDensity_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_FeaAreaDensity self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_FeaAreaDensity_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_FeaAreaDensity self, StepFEA_FeaAreaDensity thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_FeaAreaDensity_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_FeaAreaDensity self, Handle_StepFEA_FeaAreaDensity theHandle) -> Handle_StepFEA_FeaAreaDensity
        assign(Handle_StepFEA_FeaAreaDensity self, StepFEA_FeaAreaDensity thePtr) -> Handle_StepFEA_FeaAreaDensity
        assign(Handle_StepFEA_FeaAreaDensity self, Handle_StepFEA_FeaAreaDensity theHandle) -> Handle_StepFEA_FeaAreaDensity

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_FeaAreaDensity_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_FeaAreaDensity self) -> StepFEA_FeaAreaDensity

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaAreaDensity_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_FeaAreaDensity self) -> StepFEA_FeaAreaDensity

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaAreaDensity___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_FeaAreaDensity self) -> StepFEA_FeaAreaDensity

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_FeaAreaDensity___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_FeaAreaDensity___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_FeaAreaDensity___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_FeaAreaDensity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_FeaAreaDensity_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_FeaAreaDensity

    def Init(self, *args):
        """
        Init(Handle_StepFEA_FeaAreaDensity self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Standard_Real const aFeaConstant)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFeaConstant: float

        """
        return _StepFEA.Handle_StepFEA_FeaAreaDensity_Init(self, *args)


    def FeaConstant(self, *args):
        """
        FeaConstant(Handle_StepFEA_FeaAreaDensity self) -> Standard_Real

        Returns field FeaConstant

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepFEA.Handle_StepFEA_FeaAreaDensity_FeaConstant(self, *args)


    def SetFeaConstant(self, *args):
        """
        SetFeaConstant(Handle_StepFEA_FeaAreaDensity self, Standard_Real const FeaConstant)

        Set field FeaConstant

        :type FeaConstant: float

        """
        return _StepFEA.Handle_StepFEA_FeaAreaDensity_SetFeaConstant(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_FeaAreaDensity self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_FeaAreaDensity_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaAreaDensity_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaAreaDensity_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_FeaAreaDensity self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaAreaDensity_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_FeaAreaDensity self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaAreaDensity_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_FeaAreaDensity self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_FeaAreaDensity_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_FeaAreaDensity self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_FeaAreaDensity self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaAreaDensity_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_FeaAreaDensity self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_FeaAreaDensity self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaAreaDensity_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_FeaAreaDensity self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_FeaAreaDensity_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_FeaAreaDensity self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaAreaDensity_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_FeaAreaDensity self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_FeaAreaDensity_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_FeaAreaDensity self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaAreaDensity_DecrementRefCounter(self, *args)

Handle_StepFEA_FeaAreaDensity_swigregister = _StepFEA.Handle_StepFEA_FeaAreaDensity_swigregister
Handle_StepFEA_FeaAreaDensity_swigregister(Handle_StepFEA_FeaAreaDensity)

def Handle_StepFEA_FeaAreaDensity_DownCast(thing):
    return _StepFEA.Handle_StepFEA_FeaAreaDensity_DownCast(thing)
Handle_StepFEA_FeaAreaDensity_DownCast = _StepFEA.Handle_StepFEA_FeaAreaDensity_DownCast

class Handle_StepFEA_HSequenceOfElementGeometricRelationship(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_HSequenceOfElementGeometricRelationship self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_HSequenceOfElementGeometricRelationship_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_HSequenceOfElementGeometricRelationship self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfElementGeometricRelationship_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_HSequenceOfElementGeometricRelationship self, StepFEA_HSequenceOfElementGeometricRelationship thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfElementGeometricRelationship_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_HSequenceOfElementGeometricRelationship self, Handle_StepFEA_HSequenceOfElementGeometricRelationship theHandle) -> Handle_StepFEA_HSequenceOfElementGeometricRelationship
        assign(Handle_StepFEA_HSequenceOfElementGeometricRelationship self, StepFEA_HSequenceOfElementGeometricRelationship thePtr) -> Handle_StepFEA_HSequenceOfElementGeometricRelationship
        assign(Handle_StepFEA_HSequenceOfElementGeometricRelationship self, Handle_StepFEA_HSequenceOfElementGeometricRelationship theHandle) -> Handle_StepFEA_HSequenceOfElementGeometricRelationship

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfElementGeometricRelationship_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_HSequenceOfElementGeometricRelationship self) -> StepFEA_HSequenceOfElementGeometricRelationship

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfElementGeometricRelationship_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_HSequenceOfElementGeometricRelationship self) -> StepFEA_HSequenceOfElementGeometricRelationship

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfElementGeometricRelationship___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_HSequenceOfElementGeometricRelationship self) -> StepFEA_HSequenceOfElementGeometricRelationship

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfElementGeometricRelationship___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_HSequenceOfElementGeometricRelationship___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_HSequenceOfElementGeometricRelationship___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_HSequenceOfElementGeometricRelationship(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_HSequenceOfElementGeometricRelationship_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_HSequenceOfElementGeometricRelationship

    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.StepFEA.StepFEA_SequenceOfElementGeometricRelationship

        """
        res = _StepFEA.Handle_StepFEA_HSequenceOfElementGeometricRelationship_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Handle_StepFEA_HSequenceOfElementGeometricRelationship self, Handle_StepFEA_ElementGeometricRelationship theItem)
        Append(Handle_StepFEA_HSequenceOfElementGeometricRelationship self, NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship theSequence)

        :type theSequence: OCC.wrapper.StepFEA.StepFEA_SequenceOfElementGeometricRelationship

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfElementGeometricRelationship_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Handle_StepFEA_HSequenceOfElementGeometricRelationship self) -> NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship

        :rtype: OCC.wrapper.StepFEA.StepFEA_SequenceOfElementGeometricRelationship

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfElementGeometricRelationship_ChangeSequence(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_HSequenceOfElementGeometricRelationship self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfElementGeometricRelationship_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_HSequenceOfElementGeometricRelationship_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_HSequenceOfElementGeometricRelationship_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_HSequenceOfElementGeometricRelationship self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_HSequenceOfElementGeometricRelationship_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_HSequenceOfElementGeometricRelationship self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_HSequenceOfElementGeometricRelationship self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfElementGeometricRelationship_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_HSequenceOfElementGeometricRelationship self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_HSequenceOfElementGeometricRelationship self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfElementGeometricRelationship_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_HSequenceOfElementGeometricRelationship self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfElementGeometricRelationship_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_HSequenceOfElementGeometricRelationship self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfElementGeometricRelationship_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_HSequenceOfElementGeometricRelationship self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_HSequenceOfElementGeometricRelationship_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_HSequenceOfElementGeometricRelationship self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfElementGeometricRelationship_DecrementRefCounter(self, *args)

Handle_StepFEA_HSequenceOfElementGeometricRelationship_swigregister = _StepFEA.Handle_StepFEA_HSequenceOfElementGeometricRelationship_swigregister
Handle_StepFEA_HSequenceOfElementGeometricRelationship_swigregister(Handle_StepFEA_HSequenceOfElementGeometricRelationship)

def Handle_StepFEA_HSequenceOfElementGeometricRelationship_DownCast(thing):
    return _StepFEA.Handle_StepFEA_HSequenceOfElementGeometricRelationship_DownCast(thing)
Handle_StepFEA_HSequenceOfElementGeometricRelationship_DownCast = _StepFEA.Handle_StepFEA_HSequenceOfElementGeometricRelationship_DownCast

class Handle_StepFEA_FeaMaterialPropertyRepresentationItem(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_FeaMaterialPropertyRepresentationItem self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentationItem_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_FeaMaterialPropertyRepresentationItem self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentationItem_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_FeaMaterialPropertyRepresentationItem self, StepFEA_FeaMaterialPropertyRepresentationItem thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentationItem_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_FeaMaterialPropertyRepresentationItem self, Handle_StepFEA_FeaMaterialPropertyRepresentationItem theHandle) -> Handle_StepFEA_FeaMaterialPropertyRepresentationItem
        assign(Handle_StepFEA_FeaMaterialPropertyRepresentationItem self, StepFEA_FeaMaterialPropertyRepresentationItem thePtr) -> Handle_StepFEA_FeaMaterialPropertyRepresentationItem
        assign(Handle_StepFEA_FeaMaterialPropertyRepresentationItem self, Handle_StepFEA_FeaMaterialPropertyRepresentationItem theHandle) -> Handle_StepFEA_FeaMaterialPropertyRepresentationItem

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentationItem_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_FeaMaterialPropertyRepresentationItem self) -> StepFEA_FeaMaterialPropertyRepresentationItem

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentationItem_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_FeaMaterialPropertyRepresentationItem self) -> StepFEA_FeaMaterialPropertyRepresentationItem

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentationItem___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_FeaMaterialPropertyRepresentationItem self) -> StepFEA_FeaMaterialPropertyRepresentationItem

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentationItem___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentationItem___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentationItem___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_FeaMaterialPropertyRepresentationItem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentationItem_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_FeaMaterialPropertyRepresentationItem

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_FeaMaterialPropertyRepresentationItem self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentationItem_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentationItem_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentationItem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepFEA_FeaMaterialPropertyRepresentationItem self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentationItem_Init(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_FeaMaterialPropertyRepresentationItem self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentationItem_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_FeaMaterialPropertyRepresentationItem self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentationItem_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_FeaMaterialPropertyRepresentationItem self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentationItem_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_FeaMaterialPropertyRepresentationItem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_FeaMaterialPropertyRepresentationItem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentationItem_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_FeaMaterialPropertyRepresentationItem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_FeaMaterialPropertyRepresentationItem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentationItem_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_FeaMaterialPropertyRepresentationItem self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentationItem_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_FeaMaterialPropertyRepresentationItem self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentationItem_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_FeaMaterialPropertyRepresentationItem self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentationItem_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_FeaMaterialPropertyRepresentationItem self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentationItem_DecrementRefCounter(self, *args)

Handle_StepFEA_FeaMaterialPropertyRepresentationItem_swigregister = _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentationItem_swigregister
Handle_StepFEA_FeaMaterialPropertyRepresentationItem_swigregister(Handle_StepFEA_FeaMaterialPropertyRepresentationItem)

def Handle_StepFEA_FeaMaterialPropertyRepresentationItem_DownCast(thing):
    return _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentationItem_DownCast(thing)
Handle_StepFEA_FeaMaterialPropertyRepresentationItem_DownCast = _StepFEA.Handle_StepFEA_FeaMaterialPropertyRepresentationItem_DownCast

class Handle_StepFEA_CurveElementIntervalConstant(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_CurveElementIntervalConstant self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalConstant_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_CurveElementIntervalConstant self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalConstant_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_CurveElementIntervalConstant self, StepFEA_CurveElementIntervalConstant thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalConstant_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_CurveElementIntervalConstant self, Handle_StepFEA_CurveElementIntervalConstant theHandle) -> Handle_StepFEA_CurveElementIntervalConstant
        assign(Handle_StepFEA_CurveElementIntervalConstant self, StepFEA_CurveElementIntervalConstant thePtr) -> Handle_StepFEA_CurveElementIntervalConstant
        assign(Handle_StepFEA_CurveElementIntervalConstant self, Handle_StepFEA_CurveElementIntervalConstant theHandle) -> Handle_StepFEA_CurveElementIntervalConstant

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalConstant_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_CurveElementIntervalConstant self) -> StepFEA_CurveElementIntervalConstant

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalConstant_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_CurveElementIntervalConstant self) -> StepFEA_CurveElementIntervalConstant

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalConstant___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_CurveElementIntervalConstant self) -> StepFEA_CurveElementIntervalConstant

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalConstant___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_CurveElementIntervalConstant___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_CurveElementIntervalConstant___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_CurveElementIntervalConstant(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_CurveElementIntervalConstant_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_CurveElementIntervalConstant

    def Init(self, *args):
        """
        Init(Handle_StepFEA_CurveElementIntervalConstant self, Handle_StepFEA_CurveElementLocation aCurveElementInterval_FinishPosition, Handle_StepBasic_EulerAngles aCurveElementInterval_EuAngles, Handle_StepElement_CurveElementSectionDefinition aSection)

        Initialize all fields (own and inherited)

        :type aCurveElementInterval_FinishPosition: OCC.wrapper.StepFEA.Handle_StepFEA_CurveElementLocation
        :type aCurveElementInterval_EuAngles: OCC.wrapper.StepBasic.Handle_StepBasic_EulerAngles
        :type aSection: OCC.wrapper.StepElement.Handle_StepElement_CurveElementSectionDefinition

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalConstant_Init(self, *args)


    def Section(self, *args):
        """
        Section(Handle_StepFEA_CurveElementIntervalConstant self) -> Handle_StepElement_CurveElementSectionDefinition

        Returns field Section

        :rtype: OCC.wrapper.StepElement.Handle_StepElement_CurveElementSectionDefinition

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalConstant_Section(self, *args)


    def SetSection(self, *args):
        """
        SetSection(Handle_StepFEA_CurveElementIntervalConstant self, Handle_StepElement_CurveElementSectionDefinition Section)

        Set field Section

        :type Section: OCC.wrapper.StepElement.Handle_StepElement_CurveElementSectionDefinition

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalConstant_SetSection(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_CurveElementIntervalConstant self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalConstant_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_CurveElementIntervalConstant_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_CurveElementIntervalConstant_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FinishPosition(self, *args):
        """
        FinishPosition(Handle_StepFEA_CurveElementIntervalConstant self) -> Handle_StepFEA_CurveElementLocation

        Returns field FinishPosition

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_CurveElementLocation

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalConstant_FinishPosition(self, *args)


    def SetFinishPosition(self, *args):
        """
        SetFinishPosition(Handle_StepFEA_CurveElementIntervalConstant self, Handle_StepFEA_CurveElementLocation FinishPosition)

        Set field FinishPosition

        :type FinishPosition: OCC.wrapper.StepFEA.Handle_StepFEA_CurveElementLocation

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalConstant_SetFinishPosition(self, *args)


    def EuAngles(self, *args):
        """
        EuAngles(Handle_StepFEA_CurveElementIntervalConstant self) -> Handle_StepBasic_EulerAngles

        Returns field EuAngles

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_EulerAngles

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalConstant_EuAngles(self, *args)


    def SetEuAngles(self, *args):
        """
        SetEuAngles(Handle_StepFEA_CurveElementIntervalConstant self, Handle_StepBasic_EulerAngles EuAngles)

        Set field EuAngles

        :type EuAngles: OCC.wrapper.StepBasic.Handle_StepBasic_EulerAngles

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalConstant_SetEuAngles(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_CurveElementIntervalConstant self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalConstant_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_CurveElementIntervalConstant self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_CurveElementIntervalConstant self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalConstant_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_CurveElementIntervalConstant self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_CurveElementIntervalConstant self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalConstant_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_CurveElementIntervalConstant self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalConstant_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_CurveElementIntervalConstant self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalConstant_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_CurveElementIntervalConstant self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalConstant_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_CurveElementIntervalConstant self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalConstant_DecrementRefCounter(self, *args)

Handle_StepFEA_CurveElementIntervalConstant_swigregister = _StepFEA.Handle_StepFEA_CurveElementIntervalConstant_swigregister
Handle_StepFEA_CurveElementIntervalConstant_swigregister(Handle_StepFEA_CurveElementIntervalConstant)

def Handle_StepFEA_CurveElementIntervalConstant_DownCast(thing):
    return _StepFEA.Handle_StepFEA_CurveElementIntervalConstant_DownCast(thing)
Handle_StepFEA_CurveElementIntervalConstant_DownCast = _StepFEA.Handle_StepFEA_CurveElementIntervalConstant_DownCast

class Handle_StepFEA_CurveElementIntervalLinearlyVarying(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_CurveElementIntervalLinearlyVarying self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalLinearlyVarying_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_CurveElementIntervalLinearlyVarying self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalLinearlyVarying_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_CurveElementIntervalLinearlyVarying self, StepFEA_CurveElementIntervalLinearlyVarying thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalLinearlyVarying_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_CurveElementIntervalLinearlyVarying self, Handle_StepFEA_CurveElementIntervalLinearlyVarying theHandle) -> Handle_StepFEA_CurveElementIntervalLinearlyVarying
        assign(Handle_StepFEA_CurveElementIntervalLinearlyVarying self, StepFEA_CurveElementIntervalLinearlyVarying thePtr) -> Handle_StepFEA_CurveElementIntervalLinearlyVarying
        assign(Handle_StepFEA_CurveElementIntervalLinearlyVarying self, Handle_StepFEA_CurveElementIntervalLinearlyVarying theHandle) -> Handle_StepFEA_CurveElementIntervalLinearlyVarying

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalLinearlyVarying_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_CurveElementIntervalLinearlyVarying self) -> StepFEA_CurveElementIntervalLinearlyVarying

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalLinearlyVarying_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_CurveElementIntervalLinearlyVarying self) -> StepFEA_CurveElementIntervalLinearlyVarying

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalLinearlyVarying___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_CurveElementIntervalLinearlyVarying self) -> StepFEA_CurveElementIntervalLinearlyVarying

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalLinearlyVarying___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_CurveElementIntervalLinearlyVarying___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_CurveElementIntervalLinearlyVarying___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_CurveElementIntervalLinearlyVarying(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_CurveElementIntervalLinearlyVarying_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_CurveElementIntervalLinearlyVarying

    def Init(self, *args):
        """
        Init(Handle_StepFEA_CurveElementIntervalLinearlyVarying self, Handle_StepFEA_CurveElementLocation aCurveElementInterval_FinishPosition, Handle_StepBasic_EulerAngles aCurveElementInterval_EuAngles, Handle_StepElement_HArray1OfCurveElementSectionDefinition aSections)

        Initialize all fields (own and inherited)

        :type aCurveElementInterval_FinishPosition: OCC.wrapper.StepFEA.Handle_StepFEA_CurveElementLocation
        :type aCurveElementInterval_EuAngles: OCC.wrapper.StepBasic.Handle_StepBasic_EulerAngles
        :type aSections: OCC.wrapper.StepElement.Handle_StepElement_HArray1OfCurveElementSectionDefinition

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalLinearlyVarying_Init(self, *args)


    def Sections(self, *args):
        """
        Sections(Handle_StepFEA_CurveElementIntervalLinearlyVarying self) -> Handle_StepElement_HArray1OfCurveElementSectionDefinition

        Returns field Sections

        :rtype: OCC.wrapper.StepElement.Handle_StepElement_HArray1OfCurveElementSectionDefinition

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalLinearlyVarying_Sections(self, *args)


    def SetSections(self, *args):
        """
        SetSections(Handle_StepFEA_CurveElementIntervalLinearlyVarying self, Handle_StepElement_HArray1OfCurveElementSectionDefinition Sections)

        Set field Sections

        :type Sections: OCC.wrapper.StepElement.Handle_StepElement_HArray1OfCurveElementSectionDefinition

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalLinearlyVarying_SetSections(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_CurveElementIntervalLinearlyVarying self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalLinearlyVarying_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_CurveElementIntervalLinearlyVarying_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_CurveElementIntervalLinearlyVarying_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FinishPosition(self, *args):
        """
        FinishPosition(Handle_StepFEA_CurveElementIntervalLinearlyVarying self) -> Handle_StepFEA_CurveElementLocation

        Returns field FinishPosition

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_CurveElementLocation

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalLinearlyVarying_FinishPosition(self, *args)


    def SetFinishPosition(self, *args):
        """
        SetFinishPosition(Handle_StepFEA_CurveElementIntervalLinearlyVarying self, Handle_StepFEA_CurveElementLocation FinishPosition)

        Set field FinishPosition

        :type FinishPosition: OCC.wrapper.StepFEA.Handle_StepFEA_CurveElementLocation

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalLinearlyVarying_SetFinishPosition(self, *args)


    def EuAngles(self, *args):
        """
        EuAngles(Handle_StepFEA_CurveElementIntervalLinearlyVarying self) -> Handle_StepBasic_EulerAngles

        Returns field EuAngles

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_EulerAngles

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalLinearlyVarying_EuAngles(self, *args)


    def SetEuAngles(self, *args):
        """
        SetEuAngles(Handle_StepFEA_CurveElementIntervalLinearlyVarying self, Handle_StepBasic_EulerAngles EuAngles)

        Set field EuAngles

        :type EuAngles: OCC.wrapper.StepBasic.Handle_StepBasic_EulerAngles

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalLinearlyVarying_SetEuAngles(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_CurveElementIntervalLinearlyVarying self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalLinearlyVarying_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_CurveElementIntervalLinearlyVarying self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_CurveElementIntervalLinearlyVarying self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalLinearlyVarying_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_CurveElementIntervalLinearlyVarying self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_CurveElementIntervalLinearlyVarying self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalLinearlyVarying_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_CurveElementIntervalLinearlyVarying self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalLinearlyVarying_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_CurveElementIntervalLinearlyVarying self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalLinearlyVarying_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_CurveElementIntervalLinearlyVarying self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalLinearlyVarying_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_CurveElementIntervalLinearlyVarying self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_CurveElementIntervalLinearlyVarying_DecrementRefCounter(self, *args)

Handle_StepFEA_CurveElementIntervalLinearlyVarying_swigregister = _StepFEA.Handle_StepFEA_CurveElementIntervalLinearlyVarying_swigregister
Handle_StepFEA_CurveElementIntervalLinearlyVarying_swigregister(Handle_StepFEA_CurveElementIntervalLinearlyVarying)

def Handle_StepFEA_CurveElementIntervalLinearlyVarying_DownCast(thing):
    return _StepFEA.Handle_StepFEA_CurveElementIntervalLinearlyVarying_DownCast(thing)
Handle_StepFEA_CurveElementIntervalLinearlyVarying_DownCast = _StepFEA.Handle_StepFEA_CurveElementIntervalLinearlyVarying_DownCast

class Handle_StepFEA_SymmetricTensor23dMember(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_SymmetricTensor23dMember self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_SymmetricTensor23dMember self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_SymmetricTensor23dMember self, StepFEA_SymmetricTensor23dMember thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_SymmetricTensor23dMember self, Handle_StepFEA_SymmetricTensor23dMember theHandle) -> Handle_StepFEA_SymmetricTensor23dMember
        assign(Handle_StepFEA_SymmetricTensor23dMember self, StepFEA_SymmetricTensor23dMember thePtr) -> Handle_StepFEA_SymmetricTensor23dMember
        assign(Handle_StepFEA_SymmetricTensor23dMember self, Handle_StepFEA_SymmetricTensor23dMember theHandle) -> Handle_StepFEA_SymmetricTensor23dMember

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_SymmetricTensor23dMember self) -> StepFEA_SymmetricTensor23dMember

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_SymmetricTensor23dMember self) -> StepFEA_SymmetricTensor23dMember

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_SymmetricTensor23dMember self) -> StepFEA_SymmetricTensor23dMember

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_SymmetricTensor23dMember(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_SymmetricTensor23dMember_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_SymmetricTensor23dMember

    def HasName(self, *args):
        """
        HasName(Handle_StepFEA_SymmetricTensor23dMember self) -> Standard_Boolean

        Returns True if has name

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_HasName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_SymmetricTensor23dMember self) -> Standard_CString

        Returns set name

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_Name(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_SymmetricTensor23dMember self, Standard_CString const name) -> Standard_Boolean

        Set name

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_SetName(self, *args)


    def Matches(self, *args):
        """
        Matches(Handle_StepFEA_SymmetricTensor23dMember self, Standard_CString const name) -> Standard_Boolean

        Tells if the name of a SelectMember matches a given one;

        :type name: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_Matches(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_SymmetricTensor23dMember self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Kind(self, *args):
        """
        Kind(Handle_StepFEA_SymmetricTensor23dMember self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_Kind(self, *args)


    def ArrReal(self, *args):
        """
        ArrReal(Handle_StepFEA_SymmetricTensor23dMember self) -> Handle_TColStd_HArray1OfReal

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_ArrReal(self, *args)


    def SetArrReal(self, *args):
        """
        SetArrReal(Handle_StepFEA_SymmetricTensor23dMember self, Handle_TColStd_HArray1OfReal arr)

        :type arr: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_SetArrReal(self, *args)


    def Field(self, *args):
        """
        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        res = _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_Field(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def CField(self, *args):
        """
        CField(Handle_StepFEA_SymmetricTensor23dMember self) -> StepData_Field

        :rtype: OCC.wrapper.StepData.StepData_Field

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_CField(self, *args)


    def SetKind(self, *args):
        """
        SetKind(Handle_StepFEA_SymmetricTensor23dMember self, Standard_Integer const kind)

        :type kind: int

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_SetKind(self, *args)


    def Int(self, *args):
        """
        Int(Handle_StepFEA_SymmetricTensor23dMember self) -> Standard_Integer

        This internal method gives access to a value implemented by an
        Integer (to read it)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_Int(self, *args)


    def SetInt(self, *args):
        """
        SetInt(Handle_StepFEA_SymmetricTensor23dMember self, Standard_Integer const val)

        This internal method gives access to a value implemented by an
        Integer (to set it)

        :type val: int

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_SetInt(self, *args)


    def Real(self, *args):
        """
        Real(Handle_StepFEA_SymmetricTensor23dMember self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_Real(self, *args)


    def SetReal(self, *args):
        """
        SetReal(Handle_StepFEA_SymmetricTensor23dMember self, Standard_Real const val)

        :type val: float

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_SetReal(self, *args)


    def String(self, *args):
        """
        String(Handle_StepFEA_SymmetricTensor23dMember self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_String(self, *args)


    def SetString(self, *args):
        """
        SetString(Handle_StepFEA_SymmetricTensor23dMember self, Standard_CString const val)

        :type val: OCC.wrapper.Standard.Standard_CString

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_SetString(self, *args)


    def ParamType(self, *args):
        """
        ParamType(Handle_StepFEA_SymmetricTensor23dMember self) -> Interface_ParamType

        Returns the Kind of the SelectMember, under the form of an
        enum ParamType

        :rtype: OCC.wrapper.Interface.Interface_ParamType

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_ParamType(self, *args)


    def Integer(self, *args):
        """
        Integer(Handle_StepFEA_SymmetricTensor23dMember self) -> Standard_Integer

        Gets the value as an Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_Integer(self, *args)


    def SetInteger(self, *args):
        """
        SetInteger(Handle_StepFEA_SymmetricTensor23dMember self, Standard_Integer const val)

        :type val: int

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_SetInteger(self, *args)


    def Boolean(self, *args):
        """
        Boolean(Handle_StepFEA_SymmetricTensor23dMember self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_Boolean(self, *args)


    def SetBoolean(self, *args):
        """
        SetBoolean(Handle_StepFEA_SymmetricTensor23dMember self, Standard_Boolean const val)

        :type val: bool

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_SetBoolean(self, *args)


    def Logical(self, *args):
        """
        Logical(Handle_StepFEA_SymmetricTensor23dMember self) -> StepData_Logical

        :rtype: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_Logical(self, *args)


    def SetLogical(self, *args):
        """
        SetLogical(Handle_StepFEA_SymmetricTensor23dMember self, StepData_Logical const val)

        :type val: OCC.wrapper.StepData.StepData_Logical

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_SetLogical(self, *args)


    def Enum(self, *args):
        """
        Enum(Handle_StepFEA_SymmetricTensor23dMember self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_Enum(self, *args)


    def EnumText(self, *args):
        """
        EnumText(Handle_StepFEA_SymmetricTensor23dMember self) -> Standard_CString

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_EnumText(self, *args)


    def SetEnum(self, *args):
        """
        SetEnum(Handle_StepFEA_SymmetricTensor23dMember self, Standard_Integer const val, Standard_CString const text)

        :type val: int
        :type text: OCC.wrapper.Standard.Standard_CString

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_SetEnum(self, *args)


    def SetEnumText(self, *args):
        """
        SetEnumText(Handle_StepFEA_SymmetricTensor23dMember self, Standard_Integer const val, Standard_CString const text)

        :type val: int
        :type text: OCC.wrapper.Standard.Standard_CString

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_SetEnumText(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_SymmetricTensor23dMember self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_SymmetricTensor23dMember self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_SymmetricTensor23dMember self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_SymmetricTensor23dMember self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_SymmetricTensor23dMember self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_SymmetricTensor23dMember self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_SymmetricTensor23dMember self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_SymmetricTensor23dMember self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_SymmetricTensor23dMember self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_DecrementRefCounter(self, *args)

Handle_StepFEA_SymmetricTensor23dMember_swigregister = _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_swigregister
Handle_StepFEA_SymmetricTensor23dMember_swigregister(Handle_StepFEA_SymmetricTensor23dMember)

def Handle_StepFEA_SymmetricTensor23dMember_DownCast(thing):
    return _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_DownCast(thing)
Handle_StepFEA_SymmetricTensor23dMember_DownCast = _StepFEA.Handle_StepFEA_SymmetricTensor23dMember_DownCast

class StepFEA_GeometricNode(StepFEA_NodeRepresentation):
    """Representation of STEP entity GeometricNode"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_GeometricNode
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_GeometricNode(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_GeometricNode self) -> StepFEA_GeometricNode

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_GeometricNode(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_GeometricNode_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_GeometricNode_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_GeometricNode_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_GeometricNode
StepFEA_GeometricNode_swigregister = _StepFEA.StepFEA_GeometricNode_swigregister
StepFEA_GeometricNode_swigregister(StepFEA_GeometricNode)

def StepFEA_GeometricNode_get_type_name(*args):
    """
    StepFEA_GeometricNode_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_GeometricNode_get_type_name(*args)

def StepFEA_GeometricNode_get_type_descriptor(*args):
    """
    StepFEA_GeometricNode_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_GeometricNode_get_type_descriptor(*args)

class StepFEA_CurveElementEndCoordinateSystem(StepData.StepData_SelectType):
    """Representation of STEP SELECT type CurveElementEndCoordinateSystem"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StepFEA_CurveElementEndCoordinateSystem self) -> StepFEA_CurveElementEndCoordinateSystem

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_CurveElementEndCoordinateSystem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CaseNum(self, *args):
        """
        CaseNum(StepFEA_CurveElementEndCoordinateSystem self, Handle_Standard_Transient ent) -> Standard_Integer

        Recognizes a kind of CurveElementEndCoordinateSystem select type
        1 -> FeaAxis2Placement3d from StepFEA
        2 -> AlignedCurve3dElementCoordinateSystem from StepFEA
        3 -> ParametricCurve3dElementCoordinateSystem from StepFEA
        0 else

        :type ent: OCC.wrapper.Standard.Handle_Standard_Transient
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.StepFEA_CurveElementEndCoordinateSystem_CaseNum(self, *args)


    def FeaAxis2Placement3d(self, *args):
        """
        FeaAxis2Placement3d(StepFEA_CurveElementEndCoordinateSystem self) -> Handle_StepFEA_FeaAxis2Placement3d

        Returns Value as FeaAxis2Placement3d (or Null if another type)

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_FeaAxis2Placement3d

        """
        return _StepFEA.StepFEA_CurveElementEndCoordinateSystem_FeaAxis2Placement3d(self, *args)


    def AlignedCurve3dElementCoordinateSystem(self, *args):
        """
        AlignedCurve3dElementCoordinateSystem(StepFEA_CurveElementEndCoordinateSystem self) -> Handle_StepFEA_AlignedCurve3dElementCoordinateSystem

        Returns Value as AlignedCurve3dElementCoordinateSystem (or Null if another type)

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_AlignedCurve3dElementCoordinateSystem

        """
        return _StepFEA.StepFEA_CurveElementEndCoordinateSystem_AlignedCurve3dElementCoordinateSystem(self, *args)


    def ParametricCurve3dElementCoordinateSystem(self, *args):
        """
        ParametricCurve3dElementCoordinateSystem(StepFEA_CurveElementEndCoordinateSystem self) -> Handle_StepFEA_ParametricCurve3dElementCoordinateSystem

        Returns Value as ParametricCurve3dElementCoordinateSystem (or Null if another type)

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateSystem

        """
        return _StepFEA.StepFEA_CurveElementEndCoordinateSystem_ParametricCurve3dElementCoordinateSystem(self, *args)

    __swig_destroy__ = _StepFEA.delete_StepFEA_CurveElementEndCoordinateSystem
StepFEA_CurveElementEndCoordinateSystem_swigregister = _StepFEA.StepFEA_CurveElementEndCoordinateSystem_swigregister
StepFEA_CurveElementEndCoordinateSystem_swigregister(StepFEA_CurveElementEndCoordinateSystem)

class Handle_StepFEA_FreedomAndCoefficient(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_FreedomAndCoefficient self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_FreedomAndCoefficient_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_FreedomAndCoefficient self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_FreedomAndCoefficient_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_FreedomAndCoefficient self, StepFEA_FreedomAndCoefficient thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_FreedomAndCoefficient_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_FreedomAndCoefficient self, Handle_StepFEA_FreedomAndCoefficient theHandle) -> Handle_StepFEA_FreedomAndCoefficient
        assign(Handle_StepFEA_FreedomAndCoefficient self, StepFEA_FreedomAndCoefficient thePtr) -> Handle_StepFEA_FreedomAndCoefficient
        assign(Handle_StepFEA_FreedomAndCoefficient self, Handle_StepFEA_FreedomAndCoefficient theHandle) -> Handle_StepFEA_FreedomAndCoefficient

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_FreedomAndCoefficient_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_FreedomAndCoefficient self) -> StepFEA_FreedomAndCoefficient

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FreedomAndCoefficient_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_FreedomAndCoefficient self) -> StepFEA_FreedomAndCoefficient

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FreedomAndCoefficient___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_FreedomAndCoefficient self) -> StepFEA_FreedomAndCoefficient

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_FreedomAndCoefficient___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_FreedomAndCoefficient___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_FreedomAndCoefficient___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_FreedomAndCoefficient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_FreedomAndCoefficient_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_FreedomAndCoefficient

    def Init(self, *args):
        """
        Init(Handle_StepFEA_FreedomAndCoefficient self, StepFEA_DegreeOfFreedom aFreedom, StepElement_MeasureOrUnspecifiedValue aA)

        Initialize all fields (own and inherited)

        :type aFreedom: OCC.wrapper.StepFEA.StepFEA_DegreeOfFreedom
        :type aA: OCC.wrapper.StepElement.StepElement_MeasureOrUnspecifiedValue

        """
        return _StepFEA.Handle_StepFEA_FreedomAndCoefficient_Init(self, *args)


    def Freedom(self, *args):
        """
        Freedom(Handle_StepFEA_FreedomAndCoefficient self) -> StepFEA_DegreeOfFreedom

        Returns field Freedom

        :rtype: OCC.wrapper.StepFEA.StepFEA_DegreeOfFreedom

        """
        return _StepFEA.Handle_StepFEA_FreedomAndCoefficient_Freedom(self, *args)


    def SetFreedom(self, *args):
        """
        SetFreedom(Handle_StepFEA_FreedomAndCoefficient self, StepFEA_DegreeOfFreedom Freedom)

        Set field Freedom

        :type Freedom: OCC.wrapper.StepFEA.StepFEA_DegreeOfFreedom

        """
        return _StepFEA.Handle_StepFEA_FreedomAndCoefficient_SetFreedom(self, *args)


    def A(self, *args):
        """
        A(Handle_StepFEA_FreedomAndCoefficient self) -> StepElement_MeasureOrUnspecifiedValue

        Returns field A

        :rtype: OCC.wrapper.StepElement.StepElement_MeasureOrUnspecifiedValue

        """
        return _StepFEA.Handle_StepFEA_FreedomAndCoefficient_A(self, *args)


    def SetA(self, *args):
        """
        SetA(Handle_StepFEA_FreedomAndCoefficient self, StepElement_MeasureOrUnspecifiedValue A)

        Set field A

        :type A: OCC.wrapper.StepElement.StepElement_MeasureOrUnspecifiedValue

        """
        return _StepFEA.Handle_StepFEA_FreedomAndCoefficient_SetA(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_FreedomAndCoefficient self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_FreedomAndCoefficient_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FreedomAndCoefficient_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FreedomAndCoefficient_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_FreedomAndCoefficient self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_FreedomAndCoefficient_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_FreedomAndCoefficient self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_FreedomAndCoefficient self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FreedomAndCoefficient_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_FreedomAndCoefficient self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_FreedomAndCoefficient self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FreedomAndCoefficient_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_FreedomAndCoefficient self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_FreedomAndCoefficient_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_FreedomAndCoefficient self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FreedomAndCoefficient_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_FreedomAndCoefficient self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_FreedomAndCoefficient_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_FreedomAndCoefficient self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FreedomAndCoefficient_DecrementRefCounter(self, *args)

Handle_StepFEA_FreedomAndCoefficient_swigregister = _StepFEA.Handle_StepFEA_FreedomAndCoefficient_swigregister
Handle_StepFEA_FreedomAndCoefficient_swigregister(Handle_StepFEA_FreedomAndCoefficient)

def Handle_StepFEA_FreedomAndCoefficient_DownCast(thing):
    return _StepFEA.Handle_StepFEA_FreedomAndCoefficient_DownCast(thing)
Handle_StepFEA_FreedomAndCoefficient_DownCast = _StepFEA.Handle_StepFEA_FreedomAndCoefficient_DownCast

class Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem self, StepFEA_ArbitraryVolume3dElementCoordinateSystem thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem self, Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem theHandle) -> Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem
        assign(Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem self, StepFEA_ArbitraryVolume3dElementCoordinateSystem thePtr) -> Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem
        assign(Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem self, Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem theHandle) -> Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem self) -> StepFEA_ArbitraryVolume3dElementCoordinateSystem

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem self) -> StepFEA_ArbitraryVolume3dElementCoordinateSystem

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem self) -> StepFEA_ArbitraryVolume3dElementCoordinateSystem

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem

    def Init(self, *args):
        """
        Init(Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Handle_StepFEA_FeaAxis2Placement3d aCoordinateSystem)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aCoordinateSystem: OCC.wrapper.StepFEA.Handle_StepFEA_FeaAxis2Placement3d

        """
        return _StepFEA.Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem_Init(self, *args)


    def CoordinateSystem(self, *args):
        """
        CoordinateSystem(Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem self) -> Handle_StepFEA_FeaAxis2Placement3d

        Returns field CoordinateSystem

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_FeaAxis2Placement3d

        """
        return _StepFEA.Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem_CoordinateSystem(self, *args)


    def SetCoordinateSystem(self, *args):
        """
        SetCoordinateSystem(Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem self, Handle_StepFEA_FeaAxis2Placement3d CoordinateSystem)

        Set field CoordinateSystem

        :type CoordinateSystem: OCC.wrapper.StepFEA.Handle_StepFEA_FeaAxis2Placement3d

        """
        return _StepFEA.Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem_SetCoordinateSystem(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem_DecrementRefCounter(self, *args)

Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem_swigregister = _StepFEA.Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem_swigregister
Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem_swigregister(Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem)

def Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem_DownCast(thing):
    return _StepFEA.Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem_DownCast(thing)
Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem_DownCast = _StepFEA.Handle_StepFEA_ArbitraryVolume3dElementCoordinateSystem_DownCast

class Handle_StepFEA_FeaModel(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_FeaModel self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_FeaModel_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_FeaModel self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_FeaModel_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_FeaModel self, StepFEA_FeaModel thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_FeaModel_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_FeaModel self, Handle_StepFEA_FeaModel theHandle) -> Handle_StepFEA_FeaModel
        assign(Handle_StepFEA_FeaModel self, StepFEA_FeaModel thePtr) -> Handle_StepFEA_FeaModel
        assign(Handle_StepFEA_FeaModel self, Handle_StepFEA_FeaModel theHandle) -> Handle_StepFEA_FeaModel

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_FeaModel_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_FeaModel self) -> StepFEA_FeaModel

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaModel_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_FeaModel self) -> StepFEA_FeaModel

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaModel___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_FeaModel self) -> StepFEA_FeaModel

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_FeaModel___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_FeaModel___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_FeaModel___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_FeaModel(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_FeaModel_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_FeaModel

    def Init(self, *args):
        """
        Init(Handle_StepFEA_FeaModel self, Handle_TCollection_HAsciiString aRepresentation_Name, Handle_StepRepr_HArray1OfRepresentationItem aRepresentation_Items, Handle_StepRepr_RepresentationContext aRepresentation_ContextOfItems, Handle_TCollection_HAsciiString aCreatingSoftware, Handle_TColStd_HArray1OfAsciiString aIntendedAnalysisCode, Handle_TCollection_HAsciiString aDescription, Handle_TCollection_HAsciiString aAnalysisType)

        Initialize all fields (own and inherited)

        :type aRepresentation_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRepresentation_Items: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aRepresentation_ContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext
        :type aCreatingSoftware: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aIntendedAnalysisCode: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfAsciiString
        :type aDescription: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aAnalysisType: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaModel_Init(self, *args)


    def CreatingSoftware(self, *args):
        """
        CreatingSoftware(Handle_StepFEA_FeaModel self) -> Handle_TCollection_HAsciiString

        Returns field CreatingSoftware

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaModel_CreatingSoftware(self, *args)


    def SetCreatingSoftware(self, *args):
        """
        SetCreatingSoftware(Handle_StepFEA_FeaModel self, Handle_TCollection_HAsciiString CreatingSoftware)

        Set field CreatingSoftware

        :type CreatingSoftware: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaModel_SetCreatingSoftware(self, *args)


    def IntendedAnalysisCode(self, *args):
        """
        IntendedAnalysisCode(Handle_StepFEA_FeaModel self) -> Handle_TColStd_HArray1OfAsciiString

        Returns field IntendedAnalysisCode

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaModel_IntendedAnalysisCode(self, *args)


    def SetIntendedAnalysisCode(self, *args):
        """
        SetIntendedAnalysisCode(Handle_StepFEA_FeaModel self, Handle_TColStd_HArray1OfAsciiString IntendedAnalysisCode)

        Set field IntendedAnalysisCode

        :type IntendedAnalysisCode: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaModel_SetIntendedAnalysisCode(self, *args)


    def Description(self, *args):
        """
        Description(Handle_StepFEA_FeaModel self) -> Handle_TCollection_HAsciiString

        Returns field Description

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaModel_Description(self, *args)


    def SetDescription(self, *args):
        """
        SetDescription(Handle_StepFEA_FeaModel self, Handle_TCollection_HAsciiString Description)

        Set field Description

        :type Description: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaModel_SetDescription(self, *args)


    def AnalysisType(self, *args):
        """
        AnalysisType(Handle_StepFEA_FeaModel self) -> Handle_TCollection_HAsciiString

        Returns field AnalysisType

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaModel_AnalysisType(self, *args)


    def SetAnalysisType(self, *args):
        """
        SetAnalysisType(Handle_StepFEA_FeaModel self, Handle_TCollection_HAsciiString AnalysisType)

        Set field AnalysisType

        :type AnalysisType: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaModel_SetAnalysisType(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_FeaModel self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_FeaModel_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaModel_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaModel_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_FeaModel self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaModel_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_FeaModel self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaModel_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepFEA_FeaModel self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepFEA.Handle_StepFEA_FeaModel_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepFEA_FeaModel self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepFEA.Handle_StepFEA_FeaModel_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepFEA_FeaModel self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepFEA.Handle_StepFEA_FeaModel_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepFEA_FeaModel self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaModel_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepFEA_FeaModel self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepFEA.Handle_StepFEA_FeaModel_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepFEA_FeaModel self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepFEA.Handle_StepFEA_FeaModel_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_FeaModel self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_FeaModel_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_FeaModel self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_FeaModel self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaModel_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_FeaModel self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_FeaModel self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaModel_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_FeaModel self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_FeaModel_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_FeaModel self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaModel_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_FeaModel self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_FeaModel_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_FeaModel self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaModel_DecrementRefCounter(self, *args)

Handle_StepFEA_FeaModel_swigregister = _StepFEA.Handle_StepFEA_FeaModel_swigregister
Handle_StepFEA_FeaModel_swigregister(Handle_StepFEA_FeaModel)

def Handle_StepFEA_FeaModel_DownCast(thing):
    return _StepFEA.Handle_StepFEA_FeaModel_DownCast(thing)
Handle_StepFEA_FeaModel_DownCast = _StepFEA.Handle_StepFEA_FeaModel_DownCast

class NCollection_Sequence_Handle_StepFEA_ElementRepresentation(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_StepFEA_ElementRepresentation self) -> NCollection_Sequence< opencascade::handle< StepFEA_ElementRepresentation > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementRepresentation_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_StepFEA_ElementRepresentation self) -> NCollection_Sequence< opencascade::handle< StepFEA_ElementRepresentation > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementRepresentation_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_StepFEA_ElementRepresentation self) -> NCollection_Sequence< opencascade::handle< StepFEA_ElementRepresentation > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementRepresentation_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_StepFEA_ElementRepresentation self) -> NCollection_Sequence< opencascade::handle< StepFEA_ElementRepresentation > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementRepresentation_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _StepFEA.new_NCollection_Sequence_Handle_StepFEA_ElementRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_StepFEA_ElementRepresentation self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementRepresentation_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_StepFEA_ElementRepresentation self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementRepresentation_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_StepFEA_ElementRepresentation self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementRepresentation_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_StepFEA_ElementRepresentation self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementRepresentation_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_StepFEA_ElementRepresentation self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementRepresentation_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_StepFEA_ElementRepresentation self)

        Reverse sequence


        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementRepresentation_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_StepFEA_ElementRepresentation self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementRepresentation_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementRepresentation_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_StepFEA_ElementRepresentation self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementRepresentation_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_StepFEA_ElementRepresentation self, NCollection_Sequence_Handle_StepFEA_ElementRepresentation theOther) -> NCollection_Sequence_Handle_StepFEA_ElementRepresentation

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementRepresentation_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_StepFEA_ElementRepresentation self, NCollection_Sequence_Handle_StepFEA_ElementRepresentation theOther) -> NCollection_Sequence_Handle_StepFEA_ElementRepresentation

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementRepresentation_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_StepFEA_ElementRepresentation self, NCollection_Sequence< opencascade::handle< StepFEA_ElementRepresentation > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_StepFEA_ElementRepresentation self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_StepFEA_ElementRepresentation self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementRepresentation_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_StepFEA_ElementRepresentation self, Handle_StepFEA_ElementRepresentation theItem)
        Append(NCollection_Sequence_Handle_StepFEA_ElementRepresentation self, NCollection_Sequence_Handle_StepFEA_ElementRepresentation theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementRepresentation_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_StepFEA_ElementRepresentation self, Handle_StepFEA_ElementRepresentation theItem)
        Prepend(NCollection_Sequence_Handle_StepFEA_ElementRepresentation self, NCollection_Sequence_Handle_StepFEA_ElementRepresentation theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementRepresentation_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_StepFEA_ElementRepresentation self, Standard_Integer const theIndex, Handle_StepFEA_ElementRepresentation theItem)
        InsertBefore(NCollection_Sequence_Handle_StepFEA_ElementRepresentation self, Standard_Integer const theIndex, NCollection_Sequence_Handle_StepFEA_ElementRepresentation theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementRepresentation_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_StepFEA_ElementRepresentation self, NCollection_Sequence< opencascade::handle< StepFEA_ElementRepresentation > >::Iterator & thePosition, Handle_StepFEA_ElementRepresentation theItem)
        InsertAfter(NCollection_Sequence_Handle_StepFEA_ElementRepresentation self, Standard_Integer const theIndex, NCollection_Sequence_Handle_StepFEA_ElementRepresentation theSeq)
        InsertAfter(NCollection_Sequence_Handle_StepFEA_ElementRepresentation self, Standard_Integer const theIndex, Handle_StepFEA_ElementRepresentation theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementRepresentation_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_StepFEA_ElementRepresentation self, Standard_Integer const theIndex, NCollection_Sequence_Handle_StepFEA_ElementRepresentation theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementRepresentation_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementRepresentation_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_StepFEA_ElementRepresentation self) -> Handle_StepFEA_ElementRepresentation

        First item access

        :rtype: TheItemType &

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementRepresentation_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementRepresentation_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_StepFEA_ElementRepresentation self) -> Handle_StepFEA_ElementRepresentation

        Last item access

        :rtype: TheItemType &

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementRepresentation_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementRepresentation_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_StepFEA_ElementRepresentation self, Standard_Integer const theIndex) -> Handle_StepFEA_ElementRepresentation

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementRepresentation_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementRepresentation___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_StepFEA_ElementRepresentation self, Standard_Integer const theIndex, Handle_StepFEA_ElementRepresentation theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementRepresentation_SetValue(self, *args)


    def __iter__(self):
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementRepresentation___iter__(self)
    __swig_destroy__ = _StepFEA.delete_NCollection_Sequence_Handle_StepFEA_ElementRepresentation
NCollection_Sequence_Handle_StepFEA_ElementRepresentation_swigregister = _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementRepresentation_swigregister
NCollection_Sequence_Handle_StepFEA_ElementRepresentation_swigregister(NCollection_Sequence_Handle_StepFEA_ElementRepresentation)

def NCollection_Sequence_Handle_StepFEA_ElementRepresentation_delNode(*args):
    """
    NCollection_Sequence_Handle_StepFEA_ElementRepresentation_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementRepresentation_delNode(*args)

class NCollection_Sequence_Handle_StepFEA_ElementRepresentation_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _StepFEA.new_NCollection_Sequence_Handle_StepFEA_ElementRepresentation_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StepFEA.delete_NCollection_Sequence_Handle_StepFEA_ElementRepresentation_IteratorHelper

    def __next__(self):
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementRepresentation_IteratorHelper___next__(self)
NCollection_Sequence_Handle_StepFEA_ElementRepresentation_IteratorHelper_swigregister = _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementRepresentation_IteratorHelper_swigregister
NCollection_Sequence_Handle_StepFEA_ElementRepresentation_IteratorHelper_swigregister(NCollection_Sequence_Handle_StepFEA_ElementRepresentation_IteratorHelper)


try:
	StepFEA_SequenceOfElementRepresentation = NCollection_Sequence_Handle_StepFEA_ElementRepresentation
except NameError:
	pass # does not exist, probably ignored

class Handle_StepFEA_GeometricNode(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_GeometricNode self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_GeometricNode_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_GeometricNode self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_GeometricNode_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_GeometricNode self, StepFEA_GeometricNode thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_GeometricNode_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_GeometricNode self, Handle_StepFEA_GeometricNode theHandle) -> Handle_StepFEA_GeometricNode
        assign(Handle_StepFEA_GeometricNode self, StepFEA_GeometricNode thePtr) -> Handle_StepFEA_GeometricNode
        assign(Handle_StepFEA_GeometricNode self, Handle_StepFEA_GeometricNode theHandle) -> Handle_StepFEA_GeometricNode

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_GeometricNode_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_GeometricNode self) -> StepFEA_GeometricNode

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_GeometricNode_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_GeometricNode self) -> StepFEA_GeometricNode

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_GeometricNode___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_GeometricNode self) -> StepFEA_GeometricNode

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_GeometricNode___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_GeometricNode___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_GeometricNode___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_GeometricNode(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_GeometricNode_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_GeometricNode

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_GeometricNode self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_GeometricNode_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_GeometricNode_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_GeometricNode_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepFEA_GeometricNode self, Handle_TCollection_HAsciiString aRepresentation_Name, Handle_StepRepr_HArray1OfRepresentationItem aRepresentation_Items, Handle_StepRepr_RepresentationContext aRepresentation_ContextOfItems, Handle_StepFEA_FeaModel aModelRef)

        Initialize all fields (own and inherited)

        :type aRepresentation_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRepresentation_Items: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aRepresentation_ContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext
        :type aModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel

        """
        return _StepFEA.Handle_StepFEA_GeometricNode_Init(self, *args)


    def ModelRef(self, *args):
        """
        ModelRef(Handle_StepFEA_GeometricNode self) -> Handle_StepFEA_FeaModel

        Returns field ModelRef

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel

        """
        return _StepFEA.Handle_StepFEA_GeometricNode_ModelRef(self, *args)


    def SetModelRef(self, *args):
        """
        SetModelRef(Handle_StepFEA_GeometricNode self, Handle_StepFEA_FeaModel ModelRef)

        Set field ModelRef

        :type ModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel

        """
        return _StepFEA.Handle_StepFEA_GeometricNode_SetModelRef(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_GeometricNode self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_GeometricNode_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_GeometricNode self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_GeometricNode_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepFEA_GeometricNode self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepFEA.Handle_StepFEA_GeometricNode_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepFEA_GeometricNode self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepFEA.Handle_StepFEA_GeometricNode_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepFEA_GeometricNode self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepFEA.Handle_StepFEA_GeometricNode_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepFEA_GeometricNode self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_GeometricNode_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepFEA_GeometricNode self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepFEA.Handle_StepFEA_GeometricNode_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepFEA_GeometricNode self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepFEA.Handle_StepFEA_GeometricNode_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_GeometricNode self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_GeometricNode_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_GeometricNode self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_GeometricNode self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_GeometricNode_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_GeometricNode self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_GeometricNode self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_GeometricNode_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_GeometricNode self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_GeometricNode_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_GeometricNode self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_GeometricNode_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_GeometricNode self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_GeometricNode_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_GeometricNode self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_GeometricNode_DecrementRefCounter(self, *args)

Handle_StepFEA_GeometricNode_swigregister = _StepFEA.Handle_StepFEA_GeometricNode_swigregister
Handle_StepFEA_GeometricNode_swigregister(Handle_StepFEA_GeometricNode)

def Handle_StepFEA_GeometricNode_DownCast(thing):
    return _StepFEA.Handle_StepFEA_GeometricNode_DownCast(thing)
Handle_StepFEA_GeometricNode_DownCast = _StepFEA.Handle_StepFEA_GeometricNode_DownCast

class Handle_StepFEA_CurveElementInterval(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_CurveElementInterval self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_CurveElementInterval_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_CurveElementInterval self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_CurveElementInterval_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_CurveElementInterval self, StepFEA_CurveElementInterval thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_CurveElementInterval_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_CurveElementInterval self, Handle_StepFEA_CurveElementInterval theHandle) -> Handle_StepFEA_CurveElementInterval
        assign(Handle_StepFEA_CurveElementInterval self, StepFEA_CurveElementInterval thePtr) -> Handle_StepFEA_CurveElementInterval
        assign(Handle_StepFEA_CurveElementInterval self, Handle_StepFEA_CurveElementInterval theHandle) -> Handle_StepFEA_CurveElementInterval

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_CurveElementInterval_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_CurveElementInterval self) -> StepFEA_CurveElementInterval

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_CurveElementInterval_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_CurveElementInterval self) -> StepFEA_CurveElementInterval

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_CurveElementInterval___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_CurveElementInterval self) -> StepFEA_CurveElementInterval

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_CurveElementInterval___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_CurveElementInterval___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_CurveElementInterval___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_CurveElementInterval(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_CurveElementInterval_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_CurveElementInterval

    def Init(self, *args):
        """
        Init(Handle_StepFEA_CurveElementInterval self, Handle_StepFEA_CurveElementLocation aFinishPosition, Handle_StepBasic_EulerAngles aEuAngles)

        Initialize all fields (own and inherited)

        :type aFinishPosition: OCC.wrapper.StepFEA.Handle_StepFEA_CurveElementLocation
        :type aEuAngles: OCC.wrapper.StepBasic.Handle_StepBasic_EulerAngles

        """
        return _StepFEA.Handle_StepFEA_CurveElementInterval_Init(self, *args)


    def FinishPosition(self, *args):
        """
        FinishPosition(Handle_StepFEA_CurveElementInterval self) -> Handle_StepFEA_CurveElementLocation

        Returns field FinishPosition

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_CurveElementLocation

        """
        return _StepFEA.Handle_StepFEA_CurveElementInterval_FinishPosition(self, *args)


    def SetFinishPosition(self, *args):
        """
        SetFinishPosition(Handle_StepFEA_CurveElementInterval self, Handle_StepFEA_CurveElementLocation FinishPosition)

        Set field FinishPosition

        :type FinishPosition: OCC.wrapper.StepFEA.Handle_StepFEA_CurveElementLocation

        """
        return _StepFEA.Handle_StepFEA_CurveElementInterval_SetFinishPosition(self, *args)


    def EuAngles(self, *args):
        """
        EuAngles(Handle_StepFEA_CurveElementInterval self) -> Handle_StepBasic_EulerAngles

        Returns field EuAngles

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_EulerAngles

        """
        return _StepFEA.Handle_StepFEA_CurveElementInterval_EuAngles(self, *args)


    def SetEuAngles(self, *args):
        """
        SetEuAngles(Handle_StepFEA_CurveElementInterval self, Handle_StepBasic_EulerAngles EuAngles)

        Set field EuAngles

        :type EuAngles: OCC.wrapper.StepBasic.Handle_StepBasic_EulerAngles

        """
        return _StepFEA.Handle_StepFEA_CurveElementInterval_SetEuAngles(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_CurveElementInterval self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_CurveElementInterval_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_CurveElementInterval_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_CurveElementInterval_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_CurveElementInterval self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_CurveElementInterval_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_CurveElementInterval self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_CurveElementInterval self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_CurveElementInterval_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_CurveElementInterval self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_CurveElementInterval self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_CurveElementInterval_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_CurveElementInterval self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_CurveElementInterval_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_CurveElementInterval self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_CurveElementInterval_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_CurveElementInterval self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_CurveElementInterval_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_CurveElementInterval self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_CurveElementInterval_DecrementRefCounter(self, *args)

Handle_StepFEA_CurveElementInterval_swigregister = _StepFEA.Handle_StepFEA_CurveElementInterval_swigregister
Handle_StepFEA_CurveElementInterval_swigregister(Handle_StepFEA_CurveElementInterval)

def Handle_StepFEA_CurveElementInterval_DownCast(thing):
    return _StepFEA.Handle_StepFEA_CurveElementInterval_DownCast(thing)
Handle_StepFEA_CurveElementInterval_DownCast = _StepFEA.Handle_StepFEA_CurveElementInterval_DownCast

class Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion self, StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion self, Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion theHandle) -> Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion
        assign(Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion self, StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion thePtr) -> Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion
        assign(Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion self, Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion theHandle) -> Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion self) -> StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion self) -> StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion self) -> StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion

    def Init(self, *args):
        """
        Init(Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion self, Handle_TCollection_HAsciiString aRepresentationItem_Name, StepFEA_SymmetricTensor23d aFeaConstants)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFeaConstants: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor23d

        """
        return _StepFEA.Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_Init(self, *args)


    def FeaConstants(self, *args):
        """
        FeaConstants(Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion self) -> StepFEA_SymmetricTensor23d

        Returns field FeaConstants

        :rtype: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor23d

        """
        return _StepFEA.Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_FeaConstants(self, *args)


    def SetFeaConstants(self, *args):
        """
        SetFeaConstants(Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion self, StepFEA_SymmetricTensor23d FeaConstants)

        Set field FeaConstants

        :type FeaConstants: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor23d

        """
        return _StepFEA.Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_SetFeaConstants(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_DecrementRefCounter(self, *args)

Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_swigregister = _StepFEA.Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_swigregister
Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_swigregister(Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion)

def Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_DownCast(thing):
    return _StepFEA.Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_DownCast(thing)
Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_DownCast = _StepFEA.Handle_StepFEA_FeaTangentialCoefficientOfLinearThermalExpansion_DownCast

class Handle_StepFEA_NodeWithSolutionCoordinateSystem(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_NodeWithSolutionCoordinateSystem self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_NodeWithSolutionCoordinateSystem_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_NodeWithSolutionCoordinateSystem self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_NodeWithSolutionCoordinateSystem_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_NodeWithSolutionCoordinateSystem self, StepFEA_NodeWithSolutionCoordinateSystem thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_NodeWithSolutionCoordinateSystem_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_NodeWithSolutionCoordinateSystem self, Handle_StepFEA_NodeWithSolutionCoordinateSystem theHandle) -> Handle_StepFEA_NodeWithSolutionCoordinateSystem
        assign(Handle_StepFEA_NodeWithSolutionCoordinateSystem self, StepFEA_NodeWithSolutionCoordinateSystem thePtr) -> Handle_StepFEA_NodeWithSolutionCoordinateSystem
        assign(Handle_StepFEA_NodeWithSolutionCoordinateSystem self, Handle_StepFEA_NodeWithSolutionCoordinateSystem theHandle) -> Handle_StepFEA_NodeWithSolutionCoordinateSystem

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_NodeWithSolutionCoordinateSystem_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_NodeWithSolutionCoordinateSystem self) -> StepFEA_NodeWithSolutionCoordinateSystem

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_NodeWithSolutionCoordinateSystem_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_NodeWithSolutionCoordinateSystem self) -> StepFEA_NodeWithSolutionCoordinateSystem

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_NodeWithSolutionCoordinateSystem___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_NodeWithSolutionCoordinateSystem self) -> StepFEA_NodeWithSolutionCoordinateSystem

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_NodeWithSolutionCoordinateSystem___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_NodeWithSolutionCoordinateSystem___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_NodeWithSolutionCoordinateSystem___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_NodeWithSolutionCoordinateSystem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_NodeWithSolutionCoordinateSystem_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_NodeWithSolutionCoordinateSystem

    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_NodeWithSolutionCoordinateSystem self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_NodeWithSolutionCoordinateSystem_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_NodeWithSolutionCoordinateSystem_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_NodeWithSolutionCoordinateSystem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_StepFEA_NodeWithSolutionCoordinateSystem self, Handle_TCollection_HAsciiString aRepresentation_Name, Handle_StepRepr_HArray1OfRepresentationItem aRepresentation_Items, Handle_StepRepr_RepresentationContext aRepresentation_ContextOfItems, Handle_StepFEA_FeaModel aModelRef)

        Initialize all fields (own and inherited)

        :type aRepresentation_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRepresentation_Items: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aRepresentation_ContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext
        :type aModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel

        """
        return _StepFEA.Handle_StepFEA_NodeWithSolutionCoordinateSystem_Init(self, *args)


    def ModelRef(self, *args):
        """
        ModelRef(Handle_StepFEA_NodeWithSolutionCoordinateSystem self) -> Handle_StepFEA_FeaModel

        Returns field ModelRef

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel

        """
        return _StepFEA.Handle_StepFEA_NodeWithSolutionCoordinateSystem_ModelRef(self, *args)


    def SetModelRef(self, *args):
        """
        SetModelRef(Handle_StepFEA_NodeWithSolutionCoordinateSystem self, Handle_StepFEA_FeaModel ModelRef)

        Set field ModelRef

        :type ModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel

        """
        return _StepFEA.Handle_StepFEA_NodeWithSolutionCoordinateSystem_SetModelRef(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_NodeWithSolutionCoordinateSystem self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_NodeWithSolutionCoordinateSystem_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_NodeWithSolutionCoordinateSystem self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_NodeWithSolutionCoordinateSystem_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepFEA_NodeWithSolutionCoordinateSystem self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepFEA.Handle_StepFEA_NodeWithSolutionCoordinateSystem_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepFEA_NodeWithSolutionCoordinateSystem self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepFEA.Handle_StepFEA_NodeWithSolutionCoordinateSystem_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepFEA_NodeWithSolutionCoordinateSystem self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepFEA.Handle_StepFEA_NodeWithSolutionCoordinateSystem_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepFEA_NodeWithSolutionCoordinateSystem self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_NodeWithSolutionCoordinateSystem_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepFEA_NodeWithSolutionCoordinateSystem self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepFEA.Handle_StepFEA_NodeWithSolutionCoordinateSystem_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepFEA_NodeWithSolutionCoordinateSystem self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepFEA.Handle_StepFEA_NodeWithSolutionCoordinateSystem_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_NodeWithSolutionCoordinateSystem self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_NodeWithSolutionCoordinateSystem_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_NodeWithSolutionCoordinateSystem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_NodeWithSolutionCoordinateSystem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_NodeWithSolutionCoordinateSystem_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_NodeWithSolutionCoordinateSystem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_NodeWithSolutionCoordinateSystem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_NodeWithSolutionCoordinateSystem_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_NodeWithSolutionCoordinateSystem self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_NodeWithSolutionCoordinateSystem_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_NodeWithSolutionCoordinateSystem self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_NodeWithSolutionCoordinateSystem_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_NodeWithSolutionCoordinateSystem self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_NodeWithSolutionCoordinateSystem_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_NodeWithSolutionCoordinateSystem self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_NodeWithSolutionCoordinateSystem_DecrementRefCounter(self, *args)

Handle_StepFEA_NodeWithSolutionCoordinateSystem_swigregister = _StepFEA.Handle_StepFEA_NodeWithSolutionCoordinateSystem_swigregister
Handle_StepFEA_NodeWithSolutionCoordinateSystem_swigregister(Handle_StepFEA_NodeWithSolutionCoordinateSystem)

def Handle_StepFEA_NodeWithSolutionCoordinateSystem_DownCast(thing):
    return _StepFEA.Handle_StepFEA_NodeWithSolutionCoordinateSystem_DownCast(thing)
Handle_StepFEA_NodeWithSolutionCoordinateSystem_DownCast = _StepFEA.Handle_StepFEA_NodeWithSolutionCoordinateSystem_DownCast

class Handle_StepFEA_HArray1OfCurveElementEndOffset(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_HArray1OfCurveElementEndOffset self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndOffset_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_HArray1OfCurveElementEndOffset self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndOffset_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_HArray1OfCurveElementEndOffset self, StepFEA_HArray1OfCurveElementEndOffset thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndOffset_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_HArray1OfCurveElementEndOffset self, Handle_StepFEA_HArray1OfCurveElementEndOffset theHandle) -> Handle_StepFEA_HArray1OfCurveElementEndOffset
        assign(Handle_StepFEA_HArray1OfCurveElementEndOffset self, StepFEA_HArray1OfCurveElementEndOffset thePtr) -> Handle_StepFEA_HArray1OfCurveElementEndOffset
        assign(Handle_StepFEA_HArray1OfCurveElementEndOffset self, Handle_StepFEA_HArray1OfCurveElementEndOffset theHandle) -> Handle_StepFEA_HArray1OfCurveElementEndOffset

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndOffset_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_HArray1OfCurveElementEndOffset self) -> StepFEA_HArray1OfCurveElementEndOffset

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndOffset_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_HArray1OfCurveElementEndOffset self) -> StepFEA_HArray1OfCurveElementEndOffset

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndOffset___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_HArray1OfCurveElementEndOffset self) -> StepFEA_HArray1OfCurveElementEndOffset

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndOffset___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndOffset___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndOffset___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_HArray1OfCurveElementEndOffset(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_HArray1OfCurveElementEndOffset_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_HArray1OfCurveElementEndOffset

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepFEA.StepFEA_Array1OfCurveElementEndOffset

        """
        res = _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndOffset_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepFEA_HArray1OfCurveElementEndOffset self) -> NCollection_Array1_Handle_StepFEA_CurveElementEndOffset

        :rtype: OCC.wrapper.StepFEA.StepFEA_Array1OfCurveElementEndOffset

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndOffset_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_HArray1OfCurveElementEndOffset self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndOffset_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndOffset_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndOffset_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_HArray1OfCurveElementEndOffset self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndOffset_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_HArray1OfCurveElementEndOffset self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_HArray1OfCurveElementEndOffset self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndOffset_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_HArray1OfCurveElementEndOffset self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_HArray1OfCurveElementEndOffset self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndOffset_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_HArray1OfCurveElementEndOffset self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndOffset_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_HArray1OfCurveElementEndOffset self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndOffset_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_HArray1OfCurveElementEndOffset self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndOffset_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_HArray1OfCurveElementEndOffset self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndOffset_DecrementRefCounter(self, *args)

Handle_StepFEA_HArray1OfCurveElementEndOffset_swigregister = _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndOffset_swigregister
Handle_StepFEA_HArray1OfCurveElementEndOffset_swigregister(Handle_StepFEA_HArray1OfCurveElementEndOffset)

def Handle_StepFEA_HArray1OfCurveElementEndOffset_DownCast(thing):
    return _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndOffset_DownCast(thing)
Handle_StepFEA_HArray1OfCurveElementEndOffset_DownCast = _StepFEA.Handle_StepFEA_HArray1OfCurveElementEndOffset_DownCast

class NCollection_Array1_Handle_StepFEA_NodeRepresentation(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_StepFEA_NodeRepresentation self) -> NCollection_Array1< opencascade::handle< StepFEA_NodeRepresentation > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_NodeRepresentation_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_StepFEA_NodeRepresentation self) -> NCollection_Array1< opencascade::handle< StepFEA_NodeRepresentation > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_NodeRepresentation_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_StepFEA_NodeRepresentation self) -> NCollection_Array1< opencascade::handle< StepFEA_NodeRepresentation > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_NodeRepresentation_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_StepFEA_NodeRepresentation self) -> NCollection_Array1< opencascade::handle< StepFEA_NodeRepresentation > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_NodeRepresentation_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepFEA.new_NCollection_Array1_Handle_StepFEA_NodeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_StepFEA_NodeRepresentation self, Handle_StepFEA_NodeRepresentation theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_NodeRepresentation_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_StepFEA_NodeRepresentation self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_NodeRepresentation_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_StepFEA_NodeRepresentation self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_NodeRepresentation_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_StepFEA_NodeRepresentation self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_NodeRepresentation_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_StepFEA_NodeRepresentation self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_NodeRepresentation_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_StepFEA_NodeRepresentation self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_NodeRepresentation_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_StepFEA_NodeRepresentation self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_NodeRepresentation_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_StepFEA_NodeRepresentation self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_NodeRepresentation_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_StepFEA_NodeRepresentation self, NCollection_Array1_Handle_StepFEA_NodeRepresentation theOther) -> NCollection_Array1_Handle_StepFEA_NodeRepresentation

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_NodeRepresentation_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_StepFEA_NodeRepresentation self, NCollection_Array1_Handle_StepFEA_NodeRepresentation theOther) -> NCollection_Array1_Handle_StepFEA_NodeRepresentation

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_NodeRepresentation_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_StepFEA_NodeRepresentation self, NCollection_Array1_Handle_StepFEA_NodeRepresentation theOther) -> NCollection_Array1_Handle_StepFEA_NodeRepresentation
        assign(NCollection_Array1_Handle_StepFEA_NodeRepresentation self, NCollection_Array1_Handle_StepFEA_NodeRepresentation theOther) -> NCollection_Array1_Handle_StepFEA_NodeRepresentation

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_NodeRepresentation_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Array1_Handle_StepFEA_NodeRepresentation_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_StepFEA_NodeRepresentation self) -> Handle_StepFEA_NodeRepresentation

        @return first element

        :rtype: TheItemType &

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_NodeRepresentation_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Array1_Handle_StepFEA_NodeRepresentation_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_StepFEA_NodeRepresentation self) -> Handle_StepFEA_NodeRepresentation

        @return last element

        :rtype: TheItemType &

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_NodeRepresentation_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Array1_Handle_StepFEA_NodeRepresentation_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_StepFEA_NodeRepresentation self, Standard_Integer const theIndex) -> Handle_StepFEA_NodeRepresentation

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_NodeRepresentation_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Array1_Handle_StepFEA_NodeRepresentation___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Array1_Handle_StepFEA_NodeRepresentation_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_StepFEA_NodeRepresentation self, Standard_Integer const theIndex, Handle_StepFEA_NodeRepresentation theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_NodeRepresentation_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_StepFEA_NodeRepresentation self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_NodeRepresentation_Resize(self, *args)

    __swig_destroy__ = _StepFEA.delete_NCollection_Array1_Handle_StepFEA_NodeRepresentation
NCollection_Array1_Handle_StepFEA_NodeRepresentation_swigregister = _StepFEA.NCollection_Array1_Handle_StepFEA_NodeRepresentation_swigregister
NCollection_Array1_Handle_StepFEA_NodeRepresentation_swigregister(NCollection_Array1_Handle_StepFEA_NodeRepresentation)


try:
	StepFEA_Array1OfNodeRepresentation = NCollection_Array1_Handle_StepFEA_NodeRepresentation
except NameError:
	pass # does not exist, probably ignored

class NCollection_Array1_Handle_StepFEA_CurveElementEndOffset(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_StepFEA_CurveElementEndOffset self) -> NCollection_Array1< opencascade::handle< StepFEA_CurveElementEndOffset > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndOffset_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_StepFEA_CurveElementEndOffset self) -> NCollection_Array1< opencascade::handle< StepFEA_CurveElementEndOffset > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndOffset_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_StepFEA_CurveElementEndOffset self) -> NCollection_Array1< opencascade::handle< StepFEA_CurveElementEndOffset > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndOffset_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_StepFEA_CurveElementEndOffset self) -> NCollection_Array1< opencascade::handle< StepFEA_CurveElementEndOffset > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndOffset_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepFEA.new_NCollection_Array1_Handle_StepFEA_CurveElementEndOffset(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_StepFEA_CurveElementEndOffset self, Handle_StepFEA_CurveElementEndOffset theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndOffset_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_StepFEA_CurveElementEndOffset self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndOffset_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_StepFEA_CurveElementEndOffset self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndOffset_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_StepFEA_CurveElementEndOffset self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndOffset_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_StepFEA_CurveElementEndOffset self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndOffset_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_StepFEA_CurveElementEndOffset self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndOffset_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_StepFEA_CurveElementEndOffset self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndOffset_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_StepFEA_CurveElementEndOffset self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndOffset_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_StepFEA_CurveElementEndOffset self, NCollection_Array1_Handle_StepFEA_CurveElementEndOffset theOther) -> NCollection_Array1_Handle_StepFEA_CurveElementEndOffset

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndOffset_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_StepFEA_CurveElementEndOffset self, NCollection_Array1_Handle_StepFEA_CurveElementEndOffset theOther) -> NCollection_Array1_Handle_StepFEA_CurveElementEndOffset

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndOffset_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_StepFEA_CurveElementEndOffset self, NCollection_Array1_Handle_StepFEA_CurveElementEndOffset theOther) -> NCollection_Array1_Handle_StepFEA_CurveElementEndOffset
        assign(NCollection_Array1_Handle_StepFEA_CurveElementEndOffset self, NCollection_Array1_Handle_StepFEA_CurveElementEndOffset theOther) -> NCollection_Array1_Handle_StepFEA_CurveElementEndOffset

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndOffset_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndOffset_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_StepFEA_CurveElementEndOffset self) -> Handle_StepFEA_CurveElementEndOffset

        @return first element

        :rtype: TheItemType &

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndOffset_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndOffset_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_StepFEA_CurveElementEndOffset self) -> Handle_StepFEA_CurveElementEndOffset

        @return last element

        :rtype: TheItemType &

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndOffset_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndOffset_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_StepFEA_CurveElementEndOffset self, Standard_Integer const theIndex) -> Handle_StepFEA_CurveElementEndOffset

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndOffset_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndOffset___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndOffset_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_StepFEA_CurveElementEndOffset self, Standard_Integer const theIndex, Handle_StepFEA_CurveElementEndOffset theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndOffset_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_StepFEA_CurveElementEndOffset self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndOffset_Resize(self, *args)

    __swig_destroy__ = _StepFEA.delete_NCollection_Array1_Handle_StepFEA_CurveElementEndOffset
NCollection_Array1_Handle_StepFEA_CurveElementEndOffset_swigregister = _StepFEA.NCollection_Array1_Handle_StepFEA_CurveElementEndOffset_swigregister
NCollection_Array1_Handle_StepFEA_CurveElementEndOffset_swigregister(NCollection_Array1_Handle_StepFEA_CurveElementEndOffset)


try:
	StepFEA_Array1OfCurveElementEndOffset = NCollection_Array1_Handle_StepFEA_CurveElementEndOffset
except NameError:
	pass # does not exist, probably ignored

class Handle_StepFEA_CurveElementEndOffset(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_CurveElementEndOffset self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_CurveElementEndOffset_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_CurveElementEndOffset self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_CurveElementEndOffset_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_CurveElementEndOffset self, StepFEA_CurveElementEndOffset thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_CurveElementEndOffset_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_CurveElementEndOffset self, Handle_StepFEA_CurveElementEndOffset theHandle) -> Handle_StepFEA_CurveElementEndOffset
        assign(Handle_StepFEA_CurveElementEndOffset self, StepFEA_CurveElementEndOffset thePtr) -> Handle_StepFEA_CurveElementEndOffset
        assign(Handle_StepFEA_CurveElementEndOffset self, Handle_StepFEA_CurveElementEndOffset theHandle) -> Handle_StepFEA_CurveElementEndOffset

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_CurveElementEndOffset_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_CurveElementEndOffset self) -> StepFEA_CurveElementEndOffset

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_CurveElementEndOffset_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_CurveElementEndOffset self) -> StepFEA_CurveElementEndOffset

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_CurveElementEndOffset___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_CurveElementEndOffset self) -> StepFEA_CurveElementEndOffset

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_CurveElementEndOffset___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_CurveElementEndOffset___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_CurveElementEndOffset___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_CurveElementEndOffset(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_CurveElementEndOffset_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_CurveElementEndOffset

    def Init(self, *args):
        """
        Init(Handle_StepFEA_CurveElementEndOffset self, StepFEA_CurveElementEndCoordinateSystem aCoordinateSystem, Handle_TColStd_HArray1OfReal aOffsetVector)

        Initialize all fields (own and inherited)

        :type aCoordinateSystem: OCC.wrapper.StepFEA.StepFEA_CurveElementEndCoordinateSystem
        :type aOffsetVector: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepFEA.Handle_StepFEA_CurveElementEndOffset_Init(self, *args)


    def CoordinateSystem(self, *args):
        """
        CoordinateSystem(Handle_StepFEA_CurveElementEndOffset self) -> StepFEA_CurveElementEndCoordinateSystem

        Returns field CoordinateSystem

        :rtype: OCC.wrapper.StepFEA.StepFEA_CurveElementEndCoordinateSystem

        """
        return _StepFEA.Handle_StepFEA_CurveElementEndOffset_CoordinateSystem(self, *args)


    def SetCoordinateSystem(self, *args):
        """
        SetCoordinateSystem(Handle_StepFEA_CurveElementEndOffset self, StepFEA_CurveElementEndCoordinateSystem CoordinateSystem)

        Set field CoordinateSystem

        :type CoordinateSystem: OCC.wrapper.StepFEA.StepFEA_CurveElementEndCoordinateSystem

        """
        return _StepFEA.Handle_StepFEA_CurveElementEndOffset_SetCoordinateSystem(self, *args)


    def OffsetVector(self, *args):
        """
        OffsetVector(Handle_StepFEA_CurveElementEndOffset self) -> Handle_TColStd_HArray1OfReal

        Returns field OffsetVector

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepFEA.Handle_StepFEA_CurveElementEndOffset_OffsetVector(self, *args)


    def SetOffsetVector(self, *args):
        """
        SetOffsetVector(Handle_StepFEA_CurveElementEndOffset self, Handle_TColStd_HArray1OfReal OffsetVector)

        Set field OffsetVector

        :type OffsetVector: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _StepFEA.Handle_StepFEA_CurveElementEndOffset_SetOffsetVector(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_CurveElementEndOffset self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_CurveElementEndOffset_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_CurveElementEndOffset_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_CurveElementEndOffset_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_CurveElementEndOffset self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_CurveElementEndOffset_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_CurveElementEndOffset self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_CurveElementEndOffset self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_CurveElementEndOffset_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_CurveElementEndOffset self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_CurveElementEndOffset self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_CurveElementEndOffset_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_CurveElementEndOffset self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_CurveElementEndOffset_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_CurveElementEndOffset self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_CurveElementEndOffset_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_CurveElementEndOffset self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_CurveElementEndOffset_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_CurveElementEndOffset self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_CurveElementEndOffset_DecrementRefCounter(self, *args)

Handle_StepFEA_CurveElementEndOffset_swigregister = _StepFEA.Handle_StepFEA_CurveElementEndOffset_swigregister
Handle_StepFEA_CurveElementEndOffset_swigregister(Handle_StepFEA_CurveElementEndOffset)

def Handle_StepFEA_CurveElementEndOffset_DownCast(thing):
    return _StepFEA.Handle_StepFEA_CurveElementEndOffset_DownCast(thing)
Handle_StepFEA_CurveElementEndOffset_DownCast = _StepFEA.Handle_StepFEA_CurveElementEndOffset_DownCast

class Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness self, StepFEA_FeaShellMembraneBendingCouplingStiffness thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness self, Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness theHandle) -> Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness
        assign(Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness self, StepFEA_FeaShellMembraneBendingCouplingStiffness thePtr) -> Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness
        assign(Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness self, Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness theHandle) -> Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness self) -> StepFEA_FeaShellMembraneBendingCouplingStiffness

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness self) -> StepFEA_FeaShellMembraneBendingCouplingStiffness

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness self) -> StepFEA_FeaShellMembraneBendingCouplingStiffness

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness

    def Init(self, *args):
        """
        Init(Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness self, Handle_TCollection_HAsciiString aRepresentationItem_Name, StepFEA_SymmetricTensor42d aFeaConstants)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFeaConstants: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor42d

        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness_Init(self, *args)


    def FeaConstants(self, *args):
        """
        FeaConstants(Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness self) -> StepFEA_SymmetricTensor42d

        Returns field FeaConstants

        :rtype: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor42d

        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness_FeaConstants(self, *args)


    def SetFeaConstants(self, *args):
        """
        SetFeaConstants(Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness self, StepFEA_SymmetricTensor42d FeaConstants)

        Set field FeaConstants

        :type FeaConstants: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor42d

        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness_SetFeaConstants(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness_DecrementRefCounter(self, *args)

Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness_swigregister = _StepFEA.Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness_swigregister
Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness_swigregister(Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness)

def Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness_DownCast(thing):
    return _StepFEA.Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness_DownCast(thing)
Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness_DownCast = _StepFEA.Handle_StepFEA_FeaShellMembraneBendingCouplingStiffness_DownCast

class NCollection_Array1_Handle_StepFEA_ElementRepresentation(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_StepFEA_ElementRepresentation self) -> NCollection_Array1< opencascade::handle< StepFEA_ElementRepresentation > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_ElementRepresentation_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_StepFEA_ElementRepresentation self) -> NCollection_Array1< opencascade::handle< StepFEA_ElementRepresentation > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_ElementRepresentation_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_StepFEA_ElementRepresentation self) -> NCollection_Array1< opencascade::handle< StepFEA_ElementRepresentation > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_ElementRepresentation_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_StepFEA_ElementRepresentation self) -> NCollection_Array1< opencascade::handle< StepFEA_ElementRepresentation > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_ElementRepresentation_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _StepFEA.new_NCollection_Array1_Handle_StepFEA_ElementRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_StepFEA_ElementRepresentation self, Handle_StepFEA_ElementRepresentation theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_ElementRepresentation_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_StepFEA_ElementRepresentation self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_ElementRepresentation_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_StepFEA_ElementRepresentation self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_ElementRepresentation_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_StepFEA_ElementRepresentation self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_ElementRepresentation_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_StepFEA_ElementRepresentation self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_ElementRepresentation_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_StepFEA_ElementRepresentation self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_ElementRepresentation_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_StepFEA_ElementRepresentation self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_ElementRepresentation_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_StepFEA_ElementRepresentation self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_ElementRepresentation_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_StepFEA_ElementRepresentation self, NCollection_Array1_Handle_StepFEA_ElementRepresentation theOther) -> NCollection_Array1_Handle_StepFEA_ElementRepresentation

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_ElementRepresentation_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_StepFEA_ElementRepresentation self, NCollection_Array1_Handle_StepFEA_ElementRepresentation theOther) -> NCollection_Array1_Handle_StepFEA_ElementRepresentation

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_ElementRepresentation_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_StepFEA_ElementRepresentation self, NCollection_Array1_Handle_StepFEA_ElementRepresentation theOther) -> NCollection_Array1_Handle_StepFEA_ElementRepresentation
        assign(NCollection_Array1_Handle_StepFEA_ElementRepresentation self, NCollection_Array1_Handle_StepFEA_ElementRepresentation theOther) -> NCollection_Array1_Handle_StepFEA_ElementRepresentation

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_ElementRepresentation_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Array1_Handle_StepFEA_ElementRepresentation_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_StepFEA_ElementRepresentation self) -> Handle_StepFEA_ElementRepresentation

        @return first element

        :rtype: TheItemType &

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_ElementRepresentation_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Array1_Handle_StepFEA_ElementRepresentation_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_StepFEA_ElementRepresentation self) -> Handle_StepFEA_ElementRepresentation

        @return last element

        :rtype: TheItemType &

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_ElementRepresentation_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Array1_Handle_StepFEA_ElementRepresentation_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_StepFEA_ElementRepresentation self, Standard_Integer const theIndex) -> Handle_StepFEA_ElementRepresentation

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_ElementRepresentation_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Array1_Handle_StepFEA_ElementRepresentation___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Array1_Handle_StepFEA_ElementRepresentation_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_StepFEA_ElementRepresentation self, Standard_Integer const theIndex, Handle_StepFEA_ElementRepresentation theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_ElementRepresentation_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_StepFEA_ElementRepresentation self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _StepFEA.NCollection_Array1_Handle_StepFEA_ElementRepresentation_Resize(self, *args)

    __swig_destroy__ = _StepFEA.delete_NCollection_Array1_Handle_StepFEA_ElementRepresentation
NCollection_Array1_Handle_StepFEA_ElementRepresentation_swigregister = _StepFEA.NCollection_Array1_Handle_StepFEA_ElementRepresentation_swigregister
NCollection_Array1_Handle_StepFEA_ElementRepresentation_swigregister(NCollection_Array1_Handle_StepFEA_ElementRepresentation)


try:
	StepFEA_Array1OfElementRepresentation = NCollection_Array1_Handle_StepFEA_ElementRepresentation
except NameError:
	pass # does not exist, probably ignored

class NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty self) -> NCollection_Sequence< opencascade::handle< StepFEA_Curve3dElementProperty > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty self) -> NCollection_Sequence< opencascade::handle< StepFEA_Curve3dElementProperty > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty self) -> NCollection_Sequence< opencascade::handle< StepFEA_Curve3dElementProperty > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty self) -> NCollection_Sequence< opencascade::handle< StepFEA_Curve3dElementProperty > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _StepFEA.new_NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty self)

        Reverse sequence


        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty self, NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty theOther) -> NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty self, NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty theOther) -> NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty self, NCollection_Sequence< opencascade::handle< StepFEA_Curve3dElementProperty > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty self, Handle_StepFEA_Curve3dElementProperty theItem)
        Append(NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty self, NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty self, Handle_StepFEA_Curve3dElementProperty theItem)
        Prepend(NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty self, NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty self, Standard_Integer const theIndex, Handle_StepFEA_Curve3dElementProperty theItem)
        InsertBefore(NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty self, Standard_Integer const theIndex, NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty self, NCollection_Sequence< opencascade::handle< StepFEA_Curve3dElementProperty > >::Iterator & thePosition, Handle_StepFEA_Curve3dElementProperty theItem)
        InsertAfter(NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty self, Standard_Integer const theIndex, NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty theSeq)
        InsertAfter(NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty self, Standard_Integer const theIndex, Handle_StepFEA_Curve3dElementProperty theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty self, Standard_Integer const theIndex, NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty self) -> Handle_StepFEA_Curve3dElementProperty

        First item access

        :rtype: TheItemType &

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty self) -> Handle_StepFEA_Curve3dElementProperty

        Last item access

        :rtype: TheItemType &

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty self, Standard_Integer const theIndex) -> Handle_StepFEA_Curve3dElementProperty

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty self, Standard_Integer const theIndex, Handle_StepFEA_Curve3dElementProperty theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_SetValue(self, *args)


    def __iter__(self):
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty___iter__(self)
    __swig_destroy__ = _StepFEA.delete_NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty
NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_swigregister = _StepFEA.NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_swigregister
NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_swigregister(NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty)

def NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_delNode(*args):
    """
    NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _StepFEA.NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_delNode(*args)

class NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _StepFEA.new_NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StepFEA.delete_NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_IteratorHelper

    def __next__(self):
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_IteratorHelper___next__(self)
NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_IteratorHelper_swigregister = _StepFEA.NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_IteratorHelper_swigregister
NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_IteratorHelper_swigregister(NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty_IteratorHelper)


try:
	StepFEA_SequenceOfCurve3dElementProperty = NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty
except NameError:
	pass # does not exist, probably ignored

class Handle_StepFEA_HArray1OfElementRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_HArray1OfElementRepresentation self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_HArray1OfElementRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_HArray1OfElementRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_HArray1OfElementRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_HArray1OfElementRepresentation self, StepFEA_HArray1OfElementRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_HArray1OfElementRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_HArray1OfElementRepresentation self, Handle_StepFEA_HArray1OfElementRepresentation theHandle) -> Handle_StepFEA_HArray1OfElementRepresentation
        assign(Handle_StepFEA_HArray1OfElementRepresentation self, StepFEA_HArray1OfElementRepresentation thePtr) -> Handle_StepFEA_HArray1OfElementRepresentation
        assign(Handle_StepFEA_HArray1OfElementRepresentation self, Handle_StepFEA_HArray1OfElementRepresentation theHandle) -> Handle_StepFEA_HArray1OfElementRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_HArray1OfElementRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_HArray1OfElementRepresentation self) -> StepFEA_HArray1OfElementRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_HArray1OfElementRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_HArray1OfElementRepresentation self) -> StepFEA_HArray1OfElementRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_HArray1OfElementRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_HArray1OfElementRepresentation self) -> StepFEA_HArray1OfElementRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_HArray1OfElementRepresentation___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_HArray1OfElementRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_HArray1OfElementRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_HArray1OfElementRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_HArray1OfElementRepresentation_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_HArray1OfElementRepresentation

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepFEA.StepFEA_Array1OfElementRepresentation

        """
        res = _StepFEA.Handle_StepFEA_HArray1OfElementRepresentation_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepFEA_HArray1OfElementRepresentation self) -> NCollection_Array1_Handle_StepFEA_ElementRepresentation

        :rtype: OCC.wrapper.StepFEA.StepFEA_Array1OfElementRepresentation

        """
        return _StepFEA.Handle_StepFEA_HArray1OfElementRepresentation_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_HArray1OfElementRepresentation self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_HArray1OfElementRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_HArray1OfElementRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_HArray1OfElementRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_HArray1OfElementRepresentation self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_HArray1OfElementRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_HArray1OfElementRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_HArray1OfElementRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_HArray1OfElementRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_HArray1OfElementRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_HArray1OfElementRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_HArray1OfElementRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_HArray1OfElementRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_HArray1OfElementRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_HArray1OfElementRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_HArray1OfElementRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_HArray1OfElementRepresentation self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_HArray1OfElementRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_HArray1OfElementRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_HArray1OfElementRepresentation_DecrementRefCounter(self, *args)

Handle_StepFEA_HArray1OfElementRepresentation_swigregister = _StepFEA.Handle_StepFEA_HArray1OfElementRepresentation_swigregister
Handle_StepFEA_HArray1OfElementRepresentation_swigregister(Handle_StepFEA_HArray1OfElementRepresentation)

def Handle_StepFEA_HArray1OfElementRepresentation_DownCast(thing):
    return _StepFEA.Handle_StepFEA_HArray1OfElementRepresentation_DownCast(thing)
Handle_StepFEA_HArray1OfElementRepresentation_DownCast = _StepFEA.Handle_StepFEA_HArray1OfElementRepresentation_DownCast

class Handle_StepFEA_HArray1OfDegreeOfFreedom(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_HArray1OfDegreeOfFreedom self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_HArray1OfDegreeOfFreedom_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_HArray1OfDegreeOfFreedom self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_HArray1OfDegreeOfFreedom_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_HArray1OfDegreeOfFreedom self, StepFEA_HArray1OfDegreeOfFreedom thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_HArray1OfDegreeOfFreedom_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_HArray1OfDegreeOfFreedom self, Handle_StepFEA_HArray1OfDegreeOfFreedom theHandle) -> Handle_StepFEA_HArray1OfDegreeOfFreedom
        assign(Handle_StepFEA_HArray1OfDegreeOfFreedom self, StepFEA_HArray1OfDegreeOfFreedom thePtr) -> Handle_StepFEA_HArray1OfDegreeOfFreedom
        assign(Handle_StepFEA_HArray1OfDegreeOfFreedom self, Handle_StepFEA_HArray1OfDegreeOfFreedom theHandle) -> Handle_StepFEA_HArray1OfDegreeOfFreedom

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_HArray1OfDegreeOfFreedom_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_HArray1OfDegreeOfFreedom self) -> StepFEA_HArray1OfDegreeOfFreedom

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_HArray1OfDegreeOfFreedom_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_HArray1OfDegreeOfFreedom self) -> StepFEA_HArray1OfDegreeOfFreedom

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_HArray1OfDegreeOfFreedom___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_HArray1OfDegreeOfFreedom self) -> StepFEA_HArray1OfDegreeOfFreedom

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_HArray1OfDegreeOfFreedom___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_HArray1OfDegreeOfFreedom___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_HArray1OfDegreeOfFreedom___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_HArray1OfDegreeOfFreedom(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_HArray1OfDegreeOfFreedom_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_HArray1OfDegreeOfFreedom

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.StepFEA.StepFEA_Array1OfDegreeOfFreedom

        """
        res = _StepFEA.Handle_StepFEA_HArray1OfDegreeOfFreedom_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_StepFEA_HArray1OfDegreeOfFreedom self) -> NCollection_Array1_StepFEA_DegreeOfFreedom

        :rtype: OCC.wrapper.StepFEA.StepFEA_Array1OfDegreeOfFreedom

        """
        return _StepFEA.Handle_StepFEA_HArray1OfDegreeOfFreedom_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_HArray1OfDegreeOfFreedom self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_HArray1OfDegreeOfFreedom_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_HArray1OfDegreeOfFreedom_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_HArray1OfDegreeOfFreedom_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_HArray1OfDegreeOfFreedom self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_HArray1OfDegreeOfFreedom_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_HArray1OfDegreeOfFreedom self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_HArray1OfDegreeOfFreedom self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_HArray1OfDegreeOfFreedom_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_HArray1OfDegreeOfFreedom self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_HArray1OfDegreeOfFreedom self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_HArray1OfDegreeOfFreedom_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_HArray1OfDegreeOfFreedom self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_HArray1OfDegreeOfFreedom_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_HArray1OfDegreeOfFreedom self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_HArray1OfDegreeOfFreedom_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_HArray1OfDegreeOfFreedom self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_HArray1OfDegreeOfFreedom_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_HArray1OfDegreeOfFreedom self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_HArray1OfDegreeOfFreedom_DecrementRefCounter(self, *args)

Handle_StepFEA_HArray1OfDegreeOfFreedom_swigregister = _StepFEA.Handle_StepFEA_HArray1OfDegreeOfFreedom_swigregister
Handle_StepFEA_HArray1OfDegreeOfFreedom_swigregister(Handle_StepFEA_HArray1OfDegreeOfFreedom)

def Handle_StepFEA_HArray1OfDegreeOfFreedom_DownCast(thing):
    return _StepFEA.Handle_StepFEA_HArray1OfDegreeOfFreedom_DownCast(thing)
Handle_StepFEA_HArray1OfDegreeOfFreedom_DownCast = _StepFEA.Handle_StepFEA_HArray1OfDegreeOfFreedom_DownCast

class Handle_StepFEA_ParametricCurve3dElementCoordinateDirection(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_ParametricCurve3dElementCoordinateDirection self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateDirection_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_ParametricCurve3dElementCoordinateDirection self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateDirection_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_ParametricCurve3dElementCoordinateDirection self, StepFEA_ParametricCurve3dElementCoordinateDirection thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateDirection_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_ParametricCurve3dElementCoordinateDirection self, Handle_StepFEA_ParametricCurve3dElementCoordinateDirection theHandle) -> Handle_StepFEA_ParametricCurve3dElementCoordinateDirection
        assign(Handle_StepFEA_ParametricCurve3dElementCoordinateDirection self, StepFEA_ParametricCurve3dElementCoordinateDirection thePtr) -> Handle_StepFEA_ParametricCurve3dElementCoordinateDirection
        assign(Handle_StepFEA_ParametricCurve3dElementCoordinateDirection self, Handle_StepFEA_ParametricCurve3dElementCoordinateDirection theHandle) -> Handle_StepFEA_ParametricCurve3dElementCoordinateDirection

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateDirection_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_ParametricCurve3dElementCoordinateDirection self) -> StepFEA_ParametricCurve3dElementCoordinateDirection

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateDirection_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_ParametricCurve3dElementCoordinateDirection self) -> StepFEA_ParametricCurve3dElementCoordinateDirection

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateDirection___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_ParametricCurve3dElementCoordinateDirection self) -> StepFEA_ParametricCurve3dElementCoordinateDirection

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateDirection___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateDirection___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateDirection___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_ParametricCurve3dElementCoordinateDirection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateDirection_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_ParametricCurve3dElementCoordinateDirection

    def Init(self, *args):
        """
        Init(Handle_StepFEA_ParametricCurve3dElementCoordinateDirection self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Handle_StepGeom_Direction aOrientation)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aOrientation: OCC.wrapper.StepFEA.Handle_StepGeom_Direction

        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateDirection_Init(self, *args)


    def Orientation(self, *args):
        """
        Orientation(Handle_StepFEA_ParametricCurve3dElementCoordinateDirection self) -> Handle_StepGeom_Direction

        Returns field Orientation

        :rtype: OCC.wrapper.StepFEA.Handle_StepGeom_Direction

        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateDirection_Orientation(self, *args)


    def SetOrientation(self, *args):
        """
        SetOrientation(Handle_StepFEA_ParametricCurve3dElementCoordinateDirection self, Handle_StepGeom_Direction Orientation)

        Set field Orientation

        :type Orientation: OCC.wrapper.StepFEA.Handle_StepGeom_Direction

        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateDirection_SetOrientation(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_ParametricCurve3dElementCoordinateDirection self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateDirection_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateDirection_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateDirection_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_ParametricCurve3dElementCoordinateDirection self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateDirection_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_ParametricCurve3dElementCoordinateDirection self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateDirection_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_ParametricCurve3dElementCoordinateDirection self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateDirection_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_ParametricCurve3dElementCoordinateDirection self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_ParametricCurve3dElementCoordinateDirection self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateDirection_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_ParametricCurve3dElementCoordinateDirection self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_ParametricCurve3dElementCoordinateDirection self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateDirection_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_ParametricCurve3dElementCoordinateDirection self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateDirection_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_ParametricCurve3dElementCoordinateDirection self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateDirection_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_ParametricCurve3dElementCoordinateDirection self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateDirection_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_ParametricCurve3dElementCoordinateDirection self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateDirection_DecrementRefCounter(self, *args)

Handle_StepFEA_ParametricCurve3dElementCoordinateDirection_swigregister = _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateDirection_swigregister
Handle_StepFEA_ParametricCurve3dElementCoordinateDirection_swigregister(Handle_StepFEA_ParametricCurve3dElementCoordinateDirection)

def Handle_StepFEA_ParametricCurve3dElementCoordinateDirection_DownCast(thing):
    return _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateDirection_DownCast(thing)
Handle_StepFEA_ParametricCurve3dElementCoordinateDirection_DownCast = _StepFEA.Handle_StepFEA_ParametricCurve3dElementCoordinateDirection_DownCast

class StepFEA_Volume3dElementRepresentation(StepFEA_ElementRepresentation):
    """Representation of STEP entity Volume3dElementRepresentation"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_StepFEA_Volume3dElementRepresentation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_StepFEA_Volume3dElementRepresentation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(StepFEA_Volume3dElementRepresentation self) -> StepFEA_Volume3dElementRepresentation

        Empty constructor


        """
        this = _StepFEA.new_StepFEA_Volume3dElementRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(StepFEA_Volume3dElementRepresentation self, Handle_TCollection_HAsciiString aRepresentation_Name, Handle_StepRepr_HArray1OfRepresentationItem aRepresentation_Items, Handle_StepRepr_RepresentationContext aRepresentation_ContextOfItems, Handle_StepFEA_HArray1OfNodeRepresentation aElementRepresentation_NodeList, Handle_StepFEA_FeaModel3d aModelRef, Handle_StepElement_Volume3dElementDescriptor aElementDescriptor, Handle_StepElement_ElementMaterial aMaterial)

        Initialize all fields (own and inherited)

        :type aRepresentation_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRepresentation_Items: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aRepresentation_ContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext
        :type aElementRepresentation_NodeList: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation
        :type aModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel3d
        :type aElementDescriptor: OCC.wrapper.StepElement.Handle_StepElement_Volume3dElementDescriptor
        :type aMaterial: OCC.wrapper.StepElement.Handle_StepElement_ElementMaterial

        """
        return _StepFEA.StepFEA_Volume3dElementRepresentation_Init(self, *args)


    def ModelRef(self, *args):
        """
        ModelRef(StepFEA_Volume3dElementRepresentation self) -> Handle_StepFEA_FeaModel3d

        Returns field ModelRef

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel3d

        """
        return _StepFEA.StepFEA_Volume3dElementRepresentation_ModelRef(self, *args)


    def SetModelRef(self, *args):
        """
        SetModelRef(StepFEA_Volume3dElementRepresentation self, Handle_StepFEA_FeaModel3d ModelRef)

        Set field ModelRef

        :type ModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel3d

        """
        return _StepFEA.StepFEA_Volume3dElementRepresentation_SetModelRef(self, *args)


    def ElementDescriptor(self, *args):
        """
        ElementDescriptor(StepFEA_Volume3dElementRepresentation self) -> Handle_StepElement_Volume3dElementDescriptor

        Returns field ElementDescriptor

        :rtype: OCC.wrapper.StepElement.Handle_StepElement_Volume3dElementDescriptor

        """
        return _StepFEA.StepFEA_Volume3dElementRepresentation_ElementDescriptor(self, *args)


    def SetElementDescriptor(self, *args):
        """
        SetElementDescriptor(StepFEA_Volume3dElementRepresentation self, Handle_StepElement_Volume3dElementDescriptor ElementDescriptor)

        Set field ElementDescriptor

        :type ElementDescriptor: OCC.wrapper.StepElement.Handle_StepElement_Volume3dElementDescriptor

        """
        return _StepFEA.StepFEA_Volume3dElementRepresentation_SetElementDescriptor(self, *args)


    def Material(self, *args):
        """
        Material(StepFEA_Volume3dElementRepresentation self) -> Handle_StepElement_ElementMaterial

        Returns field Material

        :rtype: OCC.wrapper.StepElement.Handle_StepElement_ElementMaterial

        """
        return _StepFEA.StepFEA_Volume3dElementRepresentation_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(StepFEA_Volume3dElementRepresentation self, Handle_StepElement_ElementMaterial Material)

        Set field Material

        :type Material: OCC.wrapper.StepElement.Handle_StepElement_ElementMaterial

        """
        return _StepFEA.StepFEA_Volume3dElementRepresentation_SetMaterial(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _StepFEA.StepFEA_Volume3dElementRepresentation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _StepFEA.StepFEA_Volume3dElementRepresentation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.StepFEA_Volume3dElementRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _StepFEA.delete_StepFEA_Volume3dElementRepresentation
StepFEA_Volume3dElementRepresentation_swigregister = _StepFEA.StepFEA_Volume3dElementRepresentation_swigregister
StepFEA_Volume3dElementRepresentation_swigregister(StepFEA_Volume3dElementRepresentation)

def StepFEA_Volume3dElementRepresentation_get_type_name(*args):
    """
    StepFEA_Volume3dElementRepresentation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _StepFEA.StepFEA_Volume3dElementRepresentation_get_type_name(*args)

def StepFEA_Volume3dElementRepresentation_get_type_descriptor(*args):
    """
    StepFEA_Volume3dElementRepresentation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _StepFEA.StepFEA_Volume3dElementRepresentation_get_type_descriptor(*args)

class Handle_StepFEA_FeaSurfaceSectionGeometricRelationship(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_FeaSurfaceSectionGeometricRelationship self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_FeaSurfaceSectionGeometricRelationship_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_FeaSurfaceSectionGeometricRelationship self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_FeaSurfaceSectionGeometricRelationship_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_FeaSurfaceSectionGeometricRelationship self, StepFEA_FeaSurfaceSectionGeometricRelationship thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_FeaSurfaceSectionGeometricRelationship_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_FeaSurfaceSectionGeometricRelationship self, Handle_StepFEA_FeaSurfaceSectionGeometricRelationship theHandle) -> Handle_StepFEA_FeaSurfaceSectionGeometricRelationship
        assign(Handle_StepFEA_FeaSurfaceSectionGeometricRelationship self, StepFEA_FeaSurfaceSectionGeometricRelationship thePtr) -> Handle_StepFEA_FeaSurfaceSectionGeometricRelationship
        assign(Handle_StepFEA_FeaSurfaceSectionGeometricRelationship self, Handle_StepFEA_FeaSurfaceSectionGeometricRelationship theHandle) -> Handle_StepFEA_FeaSurfaceSectionGeometricRelationship

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_FeaSurfaceSectionGeometricRelationship_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_FeaSurfaceSectionGeometricRelationship self) -> StepFEA_FeaSurfaceSectionGeometricRelationship

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaSurfaceSectionGeometricRelationship_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_FeaSurfaceSectionGeometricRelationship self) -> StepFEA_FeaSurfaceSectionGeometricRelationship

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaSurfaceSectionGeometricRelationship___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_FeaSurfaceSectionGeometricRelationship self) -> StepFEA_FeaSurfaceSectionGeometricRelationship

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_FeaSurfaceSectionGeometricRelationship___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_FeaSurfaceSectionGeometricRelationship___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_FeaSurfaceSectionGeometricRelationship___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_FeaSurfaceSectionGeometricRelationship(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_FeaSurfaceSectionGeometricRelationship_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_FeaSurfaceSectionGeometricRelationship

    def Init(self, *args):
        """
        Init(Handle_StepFEA_FeaSurfaceSectionGeometricRelationship self, Handle_StepElement_SurfaceSection aSectionRef, Handle_StepElement_AnalysisItemWithinRepresentation aItem)

        Initialize all fields (own and inherited)

        :type aSectionRef: OCC.wrapper.StepElement.Handle_StepElement_SurfaceSection
        :type aItem: OCC.wrapper.StepElement.Handle_StepElement_AnalysisItemWithinRepresentation

        """
        return _StepFEA.Handle_StepFEA_FeaSurfaceSectionGeometricRelationship_Init(self, *args)


    def SectionRef(self, *args):
        """
        SectionRef(Handle_StepFEA_FeaSurfaceSectionGeometricRelationship self) -> Handle_StepElement_SurfaceSection

        Returns field SectionRef

        :rtype: OCC.wrapper.StepElement.Handle_StepElement_SurfaceSection

        """
        return _StepFEA.Handle_StepFEA_FeaSurfaceSectionGeometricRelationship_SectionRef(self, *args)


    def SetSectionRef(self, *args):
        """
        SetSectionRef(Handle_StepFEA_FeaSurfaceSectionGeometricRelationship self, Handle_StepElement_SurfaceSection SectionRef)

        Set field SectionRef

        :type SectionRef: OCC.wrapper.StepElement.Handle_StepElement_SurfaceSection

        """
        return _StepFEA.Handle_StepFEA_FeaSurfaceSectionGeometricRelationship_SetSectionRef(self, *args)


    def Item(self, *args):
        """
        Item(Handle_StepFEA_FeaSurfaceSectionGeometricRelationship self) -> Handle_StepElement_AnalysisItemWithinRepresentation

        Returns field Item

        :rtype: OCC.wrapper.StepElement.Handle_StepElement_AnalysisItemWithinRepresentation

        """
        return _StepFEA.Handle_StepFEA_FeaSurfaceSectionGeometricRelationship_Item(self, *args)


    def SetItem(self, *args):
        """
        SetItem(Handle_StepFEA_FeaSurfaceSectionGeometricRelationship self, Handle_StepElement_AnalysisItemWithinRepresentation Item)

        Set field Item

        :type Item: OCC.wrapper.StepElement.Handle_StepElement_AnalysisItemWithinRepresentation

        """
        return _StepFEA.Handle_StepFEA_FeaSurfaceSectionGeometricRelationship_SetItem(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_FeaSurfaceSectionGeometricRelationship self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_FeaSurfaceSectionGeometricRelationship_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaSurfaceSectionGeometricRelationship_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaSurfaceSectionGeometricRelationship_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_FeaSurfaceSectionGeometricRelationship self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_FeaSurfaceSectionGeometricRelationship_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_FeaSurfaceSectionGeometricRelationship self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_FeaSurfaceSectionGeometricRelationship self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaSurfaceSectionGeometricRelationship_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_FeaSurfaceSectionGeometricRelationship self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_FeaSurfaceSectionGeometricRelationship self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaSurfaceSectionGeometricRelationship_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_FeaSurfaceSectionGeometricRelationship self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_FeaSurfaceSectionGeometricRelationship_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_FeaSurfaceSectionGeometricRelationship self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaSurfaceSectionGeometricRelationship_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_FeaSurfaceSectionGeometricRelationship self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_FeaSurfaceSectionGeometricRelationship_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_FeaSurfaceSectionGeometricRelationship self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaSurfaceSectionGeometricRelationship_DecrementRefCounter(self, *args)

Handle_StepFEA_FeaSurfaceSectionGeometricRelationship_swigregister = _StepFEA.Handle_StepFEA_FeaSurfaceSectionGeometricRelationship_swigregister
Handle_StepFEA_FeaSurfaceSectionGeometricRelationship_swigregister(Handle_StepFEA_FeaSurfaceSectionGeometricRelationship)

def Handle_StepFEA_FeaSurfaceSectionGeometricRelationship_DownCast(thing):
    return _StepFEA.Handle_StepFEA_FeaSurfaceSectionGeometricRelationship_DownCast(thing)
Handle_StepFEA_FeaSurfaceSectionGeometricRelationship_DownCast = _StepFEA.Handle_StepFEA_FeaSurfaceSectionGeometricRelationship_DownCast

class Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion self, StepFEA_FeaSecantCoefficientOfLinearThermalExpansion thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion self, Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion theHandle) -> Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion
        assign(Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion self, StepFEA_FeaSecantCoefficientOfLinearThermalExpansion thePtr) -> Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion
        assign(Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion self, Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion theHandle) -> Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion self) -> StepFEA_FeaSecantCoefficientOfLinearThermalExpansion

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion self) -> StepFEA_FeaSecantCoefficientOfLinearThermalExpansion

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion self) -> StepFEA_FeaSecantCoefficientOfLinearThermalExpansion

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion

    def Init(self, *args):
        """
        Init(Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion self, Handle_TCollection_HAsciiString aRepresentationItem_Name, StepFEA_SymmetricTensor23d aFeaConstants, Standard_Real const aReferenceTemperature)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aFeaConstants: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor23d
        :type aReferenceTemperature: float

        """
        return _StepFEA.Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_Init(self, *args)


    def FeaConstants(self, *args):
        """
        FeaConstants(Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion self) -> StepFEA_SymmetricTensor23d

        Returns field FeaConstants

        :rtype: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor23d

        """
        return _StepFEA.Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_FeaConstants(self, *args)


    def SetFeaConstants(self, *args):
        """
        SetFeaConstants(Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion self, StepFEA_SymmetricTensor23d FeaConstants)

        Set field FeaConstants

        :type FeaConstants: OCC.wrapper.StepFEA.StepFEA_SymmetricTensor23d

        """
        return _StepFEA.Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_SetFeaConstants(self, *args)


    def ReferenceTemperature(self, *args):
        """
        ReferenceTemperature(Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion self) -> Standard_Real

        Returns field ReferenceTemperature

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _StepFEA.Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_ReferenceTemperature(self, *args)


    def SetReferenceTemperature(self, *args):
        """
        SetReferenceTemperature(Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion self, Standard_Real const ReferenceTemperature)

        Set field ReferenceTemperature

        :type ReferenceTemperature: float

        """
        return _StepFEA.Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_SetReferenceTemperature(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_DecrementRefCounter(self, *args)

Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_swigregister = _StepFEA.Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_swigregister
Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_swigregister(Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion)

def Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_DownCast(thing):
    return _StepFEA.Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_DownCast(thing)
Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_DownCast = _StepFEA.Handle_StepFEA_FeaSecantCoefficientOfLinearThermalExpansion_DownCast

class Handle_StepFEA_HSequenceOfNodeRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_HSequenceOfNodeRepresentation self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_HSequenceOfNodeRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_HSequenceOfNodeRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfNodeRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_HSequenceOfNodeRepresentation self, StepFEA_HSequenceOfNodeRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfNodeRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_HSequenceOfNodeRepresentation self, Handle_StepFEA_HSequenceOfNodeRepresentation theHandle) -> Handle_StepFEA_HSequenceOfNodeRepresentation
        assign(Handle_StepFEA_HSequenceOfNodeRepresentation self, StepFEA_HSequenceOfNodeRepresentation thePtr) -> Handle_StepFEA_HSequenceOfNodeRepresentation
        assign(Handle_StepFEA_HSequenceOfNodeRepresentation self, Handle_StepFEA_HSequenceOfNodeRepresentation theHandle) -> Handle_StepFEA_HSequenceOfNodeRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfNodeRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_HSequenceOfNodeRepresentation self) -> StepFEA_HSequenceOfNodeRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfNodeRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_HSequenceOfNodeRepresentation self) -> StepFEA_HSequenceOfNodeRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfNodeRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_HSequenceOfNodeRepresentation self) -> StepFEA_HSequenceOfNodeRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfNodeRepresentation___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_HSequenceOfNodeRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_HSequenceOfNodeRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_HSequenceOfNodeRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_HSequenceOfNodeRepresentation_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_HSequenceOfNodeRepresentation

    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.StepFEA.StepFEA_SequenceOfNodeRepresentation

        """
        res = _StepFEA.Handle_StepFEA_HSequenceOfNodeRepresentation_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Handle_StepFEA_HSequenceOfNodeRepresentation self, Handle_StepFEA_NodeRepresentation theItem)
        Append(Handle_StepFEA_HSequenceOfNodeRepresentation self, NCollection_Sequence_Handle_StepFEA_NodeRepresentation theSequence)

        :type theSequence: OCC.wrapper.StepFEA.StepFEA_SequenceOfNodeRepresentation

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfNodeRepresentation_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Handle_StepFEA_HSequenceOfNodeRepresentation self) -> NCollection_Sequence_Handle_StepFEA_NodeRepresentation

        :rtype: OCC.wrapper.StepFEA.StepFEA_SequenceOfNodeRepresentation

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfNodeRepresentation_ChangeSequence(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_HSequenceOfNodeRepresentation self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfNodeRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_HSequenceOfNodeRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_HSequenceOfNodeRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_HSequenceOfNodeRepresentation self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_HSequenceOfNodeRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_HSequenceOfNodeRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_HSequenceOfNodeRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfNodeRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_HSequenceOfNodeRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_HSequenceOfNodeRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfNodeRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_HSequenceOfNodeRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfNodeRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_HSequenceOfNodeRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfNodeRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_HSequenceOfNodeRepresentation self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_HSequenceOfNodeRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_HSequenceOfNodeRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfNodeRepresentation_DecrementRefCounter(self, *args)

Handle_StepFEA_HSequenceOfNodeRepresentation_swigregister = _StepFEA.Handle_StepFEA_HSequenceOfNodeRepresentation_swigregister
Handle_StepFEA_HSequenceOfNodeRepresentation_swigregister(Handle_StepFEA_HSequenceOfNodeRepresentation)

def Handle_StepFEA_HSequenceOfNodeRepresentation_DownCast(thing):
    return _StepFEA.Handle_StepFEA_HSequenceOfNodeRepresentation_DownCast(thing)
Handle_StepFEA_HSequenceOfNodeRepresentation_DownCast = _StepFEA.Handle_StepFEA_HSequenceOfNodeRepresentation_DownCast

class Handle_StepFEA_ElementGeometricRelationship(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_ElementGeometricRelationship self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_ElementGeometricRelationship_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_ElementGeometricRelationship self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_ElementGeometricRelationship_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_ElementGeometricRelationship self, StepFEA_ElementGeometricRelationship thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_ElementGeometricRelationship_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_ElementGeometricRelationship self, Handle_StepFEA_ElementGeometricRelationship theHandle) -> Handle_StepFEA_ElementGeometricRelationship
        assign(Handle_StepFEA_ElementGeometricRelationship self, StepFEA_ElementGeometricRelationship thePtr) -> Handle_StepFEA_ElementGeometricRelationship
        assign(Handle_StepFEA_ElementGeometricRelationship self, Handle_StepFEA_ElementGeometricRelationship theHandle) -> Handle_StepFEA_ElementGeometricRelationship

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_ElementGeometricRelationship_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_ElementGeometricRelationship self) -> StepFEA_ElementGeometricRelationship

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_ElementGeometricRelationship_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_ElementGeometricRelationship self) -> StepFEA_ElementGeometricRelationship

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_ElementGeometricRelationship___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_ElementGeometricRelationship self) -> StepFEA_ElementGeometricRelationship

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_ElementGeometricRelationship___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_ElementGeometricRelationship___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_ElementGeometricRelationship___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_ElementGeometricRelationship(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_ElementGeometricRelationship_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_ElementGeometricRelationship

    def Init(self, *args):
        """
        Init(Handle_StepFEA_ElementGeometricRelationship self, StepFEA_ElementOrElementGroup aElementRef, Handle_StepElement_AnalysisItemWithinRepresentation aItem, StepElement_ElementAspect aAspect)

        Initialize all fields (own and inherited)

        :type aElementRef: OCC.wrapper.StepFEA.StepFEA_ElementOrElementGroup
        :type aItem: OCC.wrapper.StepElement.Handle_StepElement_AnalysisItemWithinRepresentation
        :type aAspect: OCC.wrapper.StepElement.StepElement_ElementAspect

        """
        return _StepFEA.Handle_StepFEA_ElementGeometricRelationship_Init(self, *args)


    def ElementRef(self, *args):
        """
        ElementRef(Handle_StepFEA_ElementGeometricRelationship self) -> StepFEA_ElementOrElementGroup

        Returns field ElementRef

        :rtype: OCC.wrapper.StepFEA.StepFEA_ElementOrElementGroup

        """
        return _StepFEA.Handle_StepFEA_ElementGeometricRelationship_ElementRef(self, *args)


    def SetElementRef(self, *args):
        """
        SetElementRef(Handle_StepFEA_ElementGeometricRelationship self, StepFEA_ElementOrElementGroup ElementRef)

        Set field ElementRef

        :type ElementRef: OCC.wrapper.StepFEA.StepFEA_ElementOrElementGroup

        """
        return _StepFEA.Handle_StepFEA_ElementGeometricRelationship_SetElementRef(self, *args)


    def Item(self, *args):
        """
        Item(Handle_StepFEA_ElementGeometricRelationship self) -> Handle_StepElement_AnalysisItemWithinRepresentation

        Returns field Item

        :rtype: OCC.wrapper.StepElement.Handle_StepElement_AnalysisItemWithinRepresentation

        """
        return _StepFEA.Handle_StepFEA_ElementGeometricRelationship_Item(self, *args)


    def SetItem(self, *args):
        """
        SetItem(Handle_StepFEA_ElementGeometricRelationship self, Handle_StepElement_AnalysisItemWithinRepresentation Item)

        Set field Item

        :type Item: OCC.wrapper.StepElement.Handle_StepElement_AnalysisItemWithinRepresentation

        """
        return _StepFEA.Handle_StepFEA_ElementGeometricRelationship_SetItem(self, *args)


    def Aspect(self, *args):
        """
        Aspect(Handle_StepFEA_ElementGeometricRelationship self) -> StepElement_ElementAspect

        Returns field Aspect

        :rtype: OCC.wrapper.StepElement.StepElement_ElementAspect

        """
        return _StepFEA.Handle_StepFEA_ElementGeometricRelationship_Aspect(self, *args)


    def SetAspect(self, *args):
        """
        SetAspect(Handle_StepFEA_ElementGeometricRelationship self, StepElement_ElementAspect Aspect)

        Set field Aspect

        :type Aspect: OCC.wrapper.StepElement.StepElement_ElementAspect

        """
        return _StepFEA.Handle_StepFEA_ElementGeometricRelationship_SetAspect(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_ElementGeometricRelationship self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_ElementGeometricRelationship_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_ElementGeometricRelationship_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_ElementGeometricRelationship_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_ElementGeometricRelationship self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_ElementGeometricRelationship_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_ElementGeometricRelationship self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_ElementGeometricRelationship self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_ElementGeometricRelationship_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_ElementGeometricRelationship self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_ElementGeometricRelationship self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_ElementGeometricRelationship_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_ElementGeometricRelationship self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_ElementGeometricRelationship_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_ElementGeometricRelationship self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_ElementGeometricRelationship_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_ElementGeometricRelationship self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_ElementGeometricRelationship_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_ElementGeometricRelationship self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_ElementGeometricRelationship_DecrementRefCounter(self, *args)

Handle_StepFEA_ElementGeometricRelationship_swigregister = _StepFEA.Handle_StepFEA_ElementGeometricRelationship_swigregister
Handle_StepFEA_ElementGeometricRelationship_swigregister(Handle_StepFEA_ElementGeometricRelationship)

def Handle_StepFEA_ElementGeometricRelationship_DownCast(thing):
    return _StepFEA.Handle_StepFEA_ElementGeometricRelationship_DownCast(thing)
Handle_StepFEA_ElementGeometricRelationship_DownCast = _StepFEA.Handle_StepFEA_ElementGeometricRelationship_DownCast

class NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship self) -> NCollection_Sequence< opencascade::handle< StepFEA_ElementGeometricRelationship > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship self) -> NCollection_Sequence< opencascade::handle< StepFEA_ElementGeometricRelationship > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship self) -> NCollection_Sequence< opencascade::handle< StepFEA_ElementGeometricRelationship > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship self) -> NCollection_Sequence< opencascade::handle< StepFEA_ElementGeometricRelationship > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _StepFEA.new_NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship self)

        Reverse sequence


        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship self, NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship theOther) -> NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship self, NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship theOther) -> NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship self, NCollection_Sequence< opencascade::handle< StepFEA_ElementGeometricRelationship > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship self, Handle_StepFEA_ElementGeometricRelationship theItem)
        Append(NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship self, NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship self, Handle_StepFEA_ElementGeometricRelationship theItem)
        Prepend(NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship self, NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship self, Standard_Integer const theIndex, Handle_StepFEA_ElementGeometricRelationship theItem)
        InsertBefore(NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship self, Standard_Integer const theIndex, NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship self, NCollection_Sequence< opencascade::handle< StepFEA_ElementGeometricRelationship > >::Iterator & thePosition, Handle_StepFEA_ElementGeometricRelationship theItem)
        InsertAfter(NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship self, Standard_Integer const theIndex, NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship theSeq)
        InsertAfter(NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship self, Standard_Integer const theIndex, Handle_StepFEA_ElementGeometricRelationship theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship self, Standard_Integer const theIndex, NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship self) -> Handle_StepFEA_ElementGeometricRelationship

        First item access

        :rtype: TheItemType &

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship self) -> Handle_StepFEA_ElementGeometricRelationship

        Last item access

        :rtype: TheItemType &

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship self, Standard_Integer const theIndex) -> Handle_StepFEA_ElementGeometricRelationship

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship self, Standard_Integer const theIndex, Handle_StepFEA_ElementGeometricRelationship theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_SetValue(self, *args)


    def __iter__(self):
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship___iter__(self)
    __swig_destroy__ = _StepFEA.delete_NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship
NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_swigregister = _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_swigregister
NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_swigregister(NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship)

def NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_delNode(*args):
    """
    NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_delNode(*args)

class NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _StepFEA.new_NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StepFEA.delete_NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_IteratorHelper

    def __next__(self):
        return _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_IteratorHelper___next__(self)
NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_IteratorHelper_swigregister = _StepFEA.NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_IteratorHelper_swigregister
NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_IteratorHelper_swigregister(NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship_IteratorHelper)


try:
	StepFEA_SequenceOfElementGeometricRelationship = NCollection_Sequence_Handle_StepFEA_ElementGeometricRelationship
except NameError:
	pass # does not exist, probably ignored

class Handle_StepFEA_HSequenceOfCurve3dElementProperty(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_HSequenceOfCurve3dElementProperty self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_HSequenceOfCurve3dElementProperty_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_HSequenceOfCurve3dElementProperty self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfCurve3dElementProperty_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_HSequenceOfCurve3dElementProperty self, StepFEA_HSequenceOfCurve3dElementProperty thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfCurve3dElementProperty_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_HSequenceOfCurve3dElementProperty self, Handle_StepFEA_HSequenceOfCurve3dElementProperty theHandle) -> Handle_StepFEA_HSequenceOfCurve3dElementProperty
        assign(Handle_StepFEA_HSequenceOfCurve3dElementProperty self, StepFEA_HSequenceOfCurve3dElementProperty thePtr) -> Handle_StepFEA_HSequenceOfCurve3dElementProperty
        assign(Handle_StepFEA_HSequenceOfCurve3dElementProperty self, Handle_StepFEA_HSequenceOfCurve3dElementProperty theHandle) -> Handle_StepFEA_HSequenceOfCurve3dElementProperty

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfCurve3dElementProperty_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_HSequenceOfCurve3dElementProperty self) -> StepFEA_HSequenceOfCurve3dElementProperty

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfCurve3dElementProperty_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_HSequenceOfCurve3dElementProperty self) -> StepFEA_HSequenceOfCurve3dElementProperty

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfCurve3dElementProperty___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_HSequenceOfCurve3dElementProperty self) -> StepFEA_HSequenceOfCurve3dElementProperty

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfCurve3dElementProperty___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_HSequenceOfCurve3dElementProperty___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_HSequenceOfCurve3dElementProperty___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_HSequenceOfCurve3dElementProperty(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_HSequenceOfCurve3dElementProperty_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_HSequenceOfCurve3dElementProperty

    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.StepFEA.StepFEA_SequenceOfCurve3dElementProperty

        """
        res = _StepFEA.Handle_StepFEA_HSequenceOfCurve3dElementProperty_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Handle_StepFEA_HSequenceOfCurve3dElementProperty self, Handle_StepFEA_Curve3dElementProperty theItem)
        Append(Handle_StepFEA_HSequenceOfCurve3dElementProperty self, NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty theSequence)

        :type theSequence: OCC.wrapper.StepFEA.StepFEA_SequenceOfCurve3dElementProperty

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfCurve3dElementProperty_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Handle_StepFEA_HSequenceOfCurve3dElementProperty self) -> NCollection_Sequence_Handle_StepFEA_Curve3dElementProperty

        :rtype: OCC.wrapper.StepFEA.StepFEA_SequenceOfCurve3dElementProperty

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfCurve3dElementProperty_ChangeSequence(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_HSequenceOfCurve3dElementProperty self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfCurve3dElementProperty_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_HSequenceOfCurve3dElementProperty_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_HSequenceOfCurve3dElementProperty_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_HSequenceOfCurve3dElementProperty self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_HSequenceOfCurve3dElementProperty_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_HSequenceOfCurve3dElementProperty self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_HSequenceOfCurve3dElementProperty self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfCurve3dElementProperty_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_HSequenceOfCurve3dElementProperty self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_HSequenceOfCurve3dElementProperty self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfCurve3dElementProperty_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_HSequenceOfCurve3dElementProperty self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfCurve3dElementProperty_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_HSequenceOfCurve3dElementProperty self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfCurve3dElementProperty_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_HSequenceOfCurve3dElementProperty self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_HSequenceOfCurve3dElementProperty_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_HSequenceOfCurve3dElementProperty self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_HSequenceOfCurve3dElementProperty_DecrementRefCounter(self, *args)

Handle_StepFEA_HSequenceOfCurve3dElementProperty_swigregister = _StepFEA.Handle_StepFEA_HSequenceOfCurve3dElementProperty_swigregister
Handle_StepFEA_HSequenceOfCurve3dElementProperty_swigregister(Handle_StepFEA_HSequenceOfCurve3dElementProperty)

def Handle_StepFEA_HSequenceOfCurve3dElementProperty_DownCast(thing):
    return _StepFEA.Handle_StepFEA_HSequenceOfCurve3dElementProperty_DownCast(thing)
Handle_StepFEA_HSequenceOfCurve3dElementProperty_DownCast = _StepFEA.Handle_StepFEA_HSequenceOfCurve3dElementProperty_DownCast

class Handle_StepFEA_Volume3dElementRepresentation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_Volume3dElementRepresentation self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_Volume3dElementRepresentation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_Volume3dElementRepresentation self, StepFEA_Volume3dElementRepresentation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_Volume3dElementRepresentation self, Handle_StepFEA_Volume3dElementRepresentation theHandle) -> Handle_StepFEA_Volume3dElementRepresentation
        assign(Handle_StepFEA_Volume3dElementRepresentation self, StepFEA_Volume3dElementRepresentation thePtr) -> Handle_StepFEA_Volume3dElementRepresentation
        assign(Handle_StepFEA_Volume3dElementRepresentation self, Handle_StepFEA_Volume3dElementRepresentation theHandle) -> Handle_StepFEA_Volume3dElementRepresentation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_Volume3dElementRepresentation self) -> StepFEA_Volume3dElementRepresentation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_Volume3dElementRepresentation self) -> StepFEA_Volume3dElementRepresentation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_Volume3dElementRepresentation self) -> StepFEA_Volume3dElementRepresentation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_Volume3dElementRepresentation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_Volume3dElementRepresentation_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_Volume3dElementRepresentation

    def Init(self, *args):
        """
        Init(Handle_StepFEA_Volume3dElementRepresentation self, Handle_TCollection_HAsciiString aRepresentation_Name, Handle_StepRepr_HArray1OfRepresentationItem aRepresentation_Items, Handle_StepRepr_RepresentationContext aRepresentation_ContextOfItems, Handle_StepFEA_HArray1OfNodeRepresentation aElementRepresentation_NodeList, Handle_StepFEA_FeaModel3d aModelRef, Handle_StepElement_Volume3dElementDescriptor aElementDescriptor, Handle_StepElement_ElementMaterial aMaterial)

        Initialize all fields (own and inherited)

        :type aRepresentation_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aRepresentation_Items: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem
        :type aRepresentation_ContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext
        :type aElementRepresentation_NodeList: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation
        :type aModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel3d
        :type aElementDescriptor: OCC.wrapper.StepElement.Handle_StepElement_Volume3dElementDescriptor
        :type aMaterial: OCC.wrapper.StepElement.Handle_StepElement_ElementMaterial

        """
        return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_Init(self, *args)


    def ModelRef(self, *args):
        """
        ModelRef(Handle_StepFEA_Volume3dElementRepresentation self) -> Handle_StepFEA_FeaModel3d

        Returns field ModelRef

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel3d

        """
        return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_ModelRef(self, *args)


    def SetModelRef(self, *args):
        """
        SetModelRef(Handle_StepFEA_Volume3dElementRepresentation self, Handle_StepFEA_FeaModel3d ModelRef)

        Set field ModelRef

        :type ModelRef: OCC.wrapper.StepFEA.Handle_StepFEA_FeaModel3d

        """
        return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_SetModelRef(self, *args)


    def ElementDescriptor(self, *args):
        """
        ElementDescriptor(Handle_StepFEA_Volume3dElementRepresentation self) -> Handle_StepElement_Volume3dElementDescriptor

        Returns field ElementDescriptor

        :rtype: OCC.wrapper.StepElement.Handle_StepElement_Volume3dElementDescriptor

        """
        return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_ElementDescriptor(self, *args)


    def SetElementDescriptor(self, *args):
        """
        SetElementDescriptor(Handle_StepFEA_Volume3dElementRepresentation self, Handle_StepElement_Volume3dElementDescriptor ElementDescriptor)

        Set field ElementDescriptor

        :type ElementDescriptor: OCC.wrapper.StepElement.Handle_StepElement_Volume3dElementDescriptor

        """
        return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_SetElementDescriptor(self, *args)


    def Material(self, *args):
        """
        Material(Handle_StepFEA_Volume3dElementRepresentation self) -> Handle_StepElement_ElementMaterial

        Returns field Material

        :rtype: OCC.wrapper.StepElement.Handle_StepElement_ElementMaterial

        """
        return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_Material(self, *args)


    def SetMaterial(self, *args):
        """
        SetMaterial(Handle_StepFEA_Volume3dElementRepresentation self, Handle_StepElement_ElementMaterial Material)

        Set field Material

        :type Material: OCC.wrapper.StepElement.Handle_StepElement_ElementMaterial

        """
        return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_SetMaterial(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_Volume3dElementRepresentation self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NodeList(self, *args):
        """
        NodeList(Handle_StepFEA_Volume3dElementRepresentation self) -> Handle_StepFEA_HArray1OfNodeRepresentation

        Returns field NodeList

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation

        """
        return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_NodeList(self, *args)


    def SetNodeList(self, *args):
        """
        SetNodeList(Handle_StepFEA_Volume3dElementRepresentation self, Handle_StepFEA_HArray1OfNodeRepresentation NodeList)

        Set field NodeList

        :type NodeList: OCC.wrapper.StepFEA.Handle_StepFEA_HArray1OfNodeRepresentation

        """
        return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_SetNodeList(self, *args)


    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_Volume3dElementRepresentation self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_Volume3dElementRepresentation self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_Name(self, *args)


    def SetItems(self, *args):
        """
        SetItems(Handle_StepFEA_Volume3dElementRepresentation self, Handle_StepRepr_HArray1OfRepresentationItem aItems)

        :type aItems: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_SetItems(self, *args)


    def Items(self, *args):
        """
        Items(Handle_StepFEA_Volume3dElementRepresentation self) -> Handle_StepRepr_HArray1OfRepresentationItem

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_HArray1OfRepresentationItem

        """
        return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_Items(self, *args)


    def ItemsValue(self, *args):
        """
        ItemsValue(Handle_StepFEA_Volume3dElementRepresentation self, Standard_Integer const num) -> Handle_StepRepr_RepresentationItem

        :type num: int
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_ItemsValue(self, *args)


    def NbItems(self, *args):
        """
        NbItems(Handle_StepFEA_Volume3dElementRepresentation self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_NbItems(self, *args)


    def SetContextOfItems(self, *args):
        """
        SetContextOfItems(Handle_StepFEA_Volume3dElementRepresentation self, Handle_StepRepr_RepresentationContext aContextOfItems)

        :type aContextOfItems: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_SetContextOfItems(self, *args)


    def ContextOfItems(self, *args):
        """
        ContextOfItems(Handle_StepFEA_Volume3dElementRepresentation self) -> Handle_StepRepr_RepresentationContext

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_ContextOfItems(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_Volume3dElementRepresentation self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_Volume3dElementRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_Volume3dElementRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_Volume3dElementRepresentation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_Volume3dElementRepresentation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_Volume3dElementRepresentation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_Volume3dElementRepresentation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_Volume3dElementRepresentation self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_Volume3dElementRepresentation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_DecrementRefCounter(self, *args)

Handle_StepFEA_Volume3dElementRepresentation_swigregister = _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_swigregister
Handle_StepFEA_Volume3dElementRepresentation_swigregister(Handle_StepFEA_Volume3dElementRepresentation)

def Handle_StepFEA_Volume3dElementRepresentation_DownCast(thing):
    return _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_DownCast(thing)
Handle_StepFEA_Volume3dElementRepresentation_DownCast = _StepFEA.Handle_StepFEA_Volume3dElementRepresentation_DownCast

class Handle_StepFEA_AlignedCurve3dElementCoordinateSystem(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_StepFEA_AlignedCurve3dElementCoordinateSystem self)

        Nullify the handle


        """
        return _StepFEA.Handle_StepFEA_AlignedCurve3dElementCoordinateSystem_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_StepFEA_AlignedCurve3dElementCoordinateSystem self) -> bool

        Check for being null

        :rtype: bool

        """
        return _StepFEA.Handle_StepFEA_AlignedCurve3dElementCoordinateSystem_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_StepFEA_AlignedCurve3dElementCoordinateSystem self, StepFEA_AlignedCurve3dElementCoordinateSystem thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _StepFEA.Handle_StepFEA_AlignedCurve3dElementCoordinateSystem_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_StepFEA_AlignedCurve3dElementCoordinateSystem self, Handle_StepFEA_AlignedCurve3dElementCoordinateSystem theHandle) -> Handle_StepFEA_AlignedCurve3dElementCoordinateSystem
        assign(Handle_StepFEA_AlignedCurve3dElementCoordinateSystem self, StepFEA_AlignedCurve3dElementCoordinateSystem thePtr) -> Handle_StepFEA_AlignedCurve3dElementCoordinateSystem
        assign(Handle_StepFEA_AlignedCurve3dElementCoordinateSystem self, Handle_StepFEA_AlignedCurve3dElementCoordinateSystem theHandle) -> Handle_StepFEA_AlignedCurve3dElementCoordinateSystem

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _StepFEA.Handle_StepFEA_AlignedCurve3dElementCoordinateSystem_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_StepFEA_AlignedCurve3dElementCoordinateSystem self) -> StepFEA_AlignedCurve3dElementCoordinateSystem

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_AlignedCurve3dElementCoordinateSystem_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_StepFEA_AlignedCurve3dElementCoordinateSystem self) -> StepFEA_AlignedCurve3dElementCoordinateSystem

        Member access operator (note non-const)

        :rtype: T *

        """
        return _StepFEA.Handle_StepFEA_AlignedCurve3dElementCoordinateSystem___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_StepFEA_AlignedCurve3dElementCoordinateSystem self) -> StepFEA_AlignedCurve3dElementCoordinateSystem

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _StepFEA.Handle_StepFEA_AlignedCurve3dElementCoordinateSystem___ref__(self, *args)


    def __hash__(self):
        return _StepFEA.Handle_StepFEA_AlignedCurve3dElementCoordinateSystem___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _StepFEA.Handle_StepFEA_AlignedCurve3dElementCoordinateSystem___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _StepFEA.new_Handle_StepFEA_AlignedCurve3dElementCoordinateSystem(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_StepFEA.Handle_StepFEA_AlignedCurve3dElementCoordinateSystem_DownCast)
    __swig_destroy__ = _StepFEA.delete_Handle_StepFEA_AlignedCurve3dElementCoordinateSystem

    def Init(self, *args):
        """
        Init(Handle_StepFEA_AlignedCurve3dElementCoordinateSystem self, Handle_TCollection_HAsciiString aRepresentationItem_Name, Handle_StepFEA_FeaAxis2Placement3d aCoordinateSystem)

        Initialize all fields (own and inherited)

        :type aRepresentationItem_Name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type aCoordinateSystem: OCC.wrapper.StepFEA.Handle_StepFEA_FeaAxis2Placement3d

        """
        return _StepFEA.Handle_StepFEA_AlignedCurve3dElementCoordinateSystem_Init(self, *args)


    def CoordinateSystem(self, *args):
        """
        CoordinateSystem(Handle_StepFEA_AlignedCurve3dElementCoordinateSystem self) -> Handle_StepFEA_FeaAxis2Placement3d

        Returns field CoordinateSystem

        :rtype: OCC.wrapper.StepFEA.Handle_StepFEA_FeaAxis2Placement3d

        """
        return _StepFEA.Handle_StepFEA_AlignedCurve3dElementCoordinateSystem_CoordinateSystem(self, *args)


    def SetCoordinateSystem(self, *args):
        """
        SetCoordinateSystem(Handle_StepFEA_AlignedCurve3dElementCoordinateSystem self, Handle_StepFEA_FeaAxis2Placement3d CoordinateSystem)

        Set field CoordinateSystem

        :type CoordinateSystem: OCC.wrapper.StepFEA.Handle_StepFEA_FeaAxis2Placement3d

        """
        return _StepFEA.Handle_StepFEA_AlignedCurve3dElementCoordinateSystem_SetCoordinateSystem(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_StepFEA_AlignedCurve3dElementCoordinateSystem self) -> char const *

        :rtype: const char *

        """
        return _StepFEA.Handle_StepFEA_AlignedCurve3dElementCoordinateSystem_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_AlignedCurve3dElementCoordinateSystem_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _StepFEA.Handle_StepFEA_AlignedCurve3dElementCoordinateSystem_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetName(self, *args):
        """
        SetName(Handle_StepFEA_AlignedCurve3dElementCoordinateSystem self, Handle_TCollection_HAsciiString aName)

        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_AlignedCurve3dElementCoordinateSystem_SetName(self, *args)


    def Name(self, *args):
        """
        Name(Handle_StepFEA_AlignedCurve3dElementCoordinateSystem self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _StepFEA.Handle_StepFEA_AlignedCurve3dElementCoordinateSystem_Name(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_StepFEA_AlignedCurve3dElementCoordinateSystem self)

        Memory deallocator for transient classes


        """
        return _StepFEA.Handle_StepFEA_AlignedCurve3dElementCoordinateSystem_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_StepFEA_AlignedCurve3dElementCoordinateSystem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_StepFEA_AlignedCurve3dElementCoordinateSystem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_AlignedCurve3dElementCoordinateSystem_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_StepFEA_AlignedCurve3dElementCoordinateSystem self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_StepFEA_AlignedCurve3dElementCoordinateSystem self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StepFEA.Handle_StepFEA_AlignedCurve3dElementCoordinateSystem_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_StepFEA_AlignedCurve3dElementCoordinateSystem self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _StepFEA.Handle_StepFEA_AlignedCurve3dElementCoordinateSystem_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_StepFEA_AlignedCurve3dElementCoordinateSystem self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_AlignedCurve3dElementCoordinateSystem_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_StepFEA_AlignedCurve3dElementCoordinateSystem self)

        Increments the reference counter of this object


        """
        return _StepFEA.Handle_StepFEA_AlignedCurve3dElementCoordinateSystem_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_StepFEA_AlignedCurve3dElementCoordinateSystem self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StepFEA.Handle_StepFEA_AlignedCurve3dElementCoordinateSystem_DecrementRefCounter(self, *args)

Handle_StepFEA_AlignedCurve3dElementCoordinateSystem_swigregister = _StepFEA.Handle_StepFEA_AlignedCurve3dElementCoordinateSystem_swigregister
Handle_StepFEA_AlignedCurve3dElementCoordinateSystem_swigregister(Handle_StepFEA_AlignedCurve3dElementCoordinateSystem)

def Handle_StepFEA_AlignedCurve3dElementCoordinateSystem_DownCast(thing):
    return _StepFEA.Handle_StepFEA_AlignedCurve3dElementCoordinateSystem_DownCast(thing)
Handle_StepFEA_AlignedCurve3dElementCoordinateSystem_DownCast = _StepFEA.Handle_StepFEA_AlignedCurve3dElementCoordinateSystem_DownCast




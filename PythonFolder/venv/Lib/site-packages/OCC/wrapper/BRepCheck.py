# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BRepCheck')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BRepCheck')
    _BRepCheck = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BRepCheck', [dirname(__file__)])
        except ImportError:
            import _BRepCheck
            return _BRepCheck
        try:
            _mod = imp.load_module('_BRepCheck', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BRepCheck = swig_import_helper()
    del swig_import_helper
else:
    import _BRepCheck
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BRepCheck.delete_SwigPyIterator

    def value(self):
        return _BRepCheck.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _BRepCheck.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _BRepCheck.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _BRepCheck.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _BRepCheck.SwigPyIterator_equal(self, x)

    def copy(self):
        return _BRepCheck.SwigPyIterator_copy(self)

    def next(self):
        return _BRepCheck.SwigPyIterator_next(self)

    def __next__(self):
        return _BRepCheck.SwigPyIterator___next__(self)

    def previous(self):
        return _BRepCheck.SwigPyIterator_previous(self)

    def advance(self, n):
        return _BRepCheck.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _BRepCheck.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _BRepCheck.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _BRepCheck.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _BRepCheck.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _BRepCheck.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _BRepCheck.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _BRepCheck.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepCheck.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_BRepCheck.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepCheck.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepCheck.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepCheck.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _BRepCheck.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _BRepCheck.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _BRepCheck.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepCheck.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_BRepCheck.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepCheck.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepCheck.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepCheck.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _BRepCheck.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _BRepCheck.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _BRepCheck.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _BRepCheck.ptr_to_number(item)
ptr_to_number = _BRepCheck.ptr_to_number

def HashCode(*args):
    return _BRepCheck.HashCode(*args)
HashCode = _BRepCheck.HashCode

def ptr_equal(a, b):
    return _BRepCheck.ptr_equal(a, b)
ptr_equal = _BRepCheck.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
BRepCheck_NoError = _BRepCheck.BRepCheck_NoError
BRepCheck_InvalidPointOnCurve = _BRepCheck.BRepCheck_InvalidPointOnCurve
BRepCheck_InvalidPointOnCurveOnSurface = _BRepCheck.BRepCheck_InvalidPointOnCurveOnSurface
BRepCheck_InvalidPointOnSurface = _BRepCheck.BRepCheck_InvalidPointOnSurface
BRepCheck_No3DCurve = _BRepCheck.BRepCheck_No3DCurve
BRepCheck_Multiple3DCurve = _BRepCheck.BRepCheck_Multiple3DCurve
BRepCheck_Invalid3DCurve = _BRepCheck.BRepCheck_Invalid3DCurve
BRepCheck_NoCurveOnSurface = _BRepCheck.BRepCheck_NoCurveOnSurface
BRepCheck_InvalidCurveOnSurface = _BRepCheck.BRepCheck_InvalidCurveOnSurface
BRepCheck_InvalidCurveOnClosedSurface = _BRepCheck.BRepCheck_InvalidCurveOnClosedSurface
BRepCheck_InvalidSameRangeFlag = _BRepCheck.BRepCheck_InvalidSameRangeFlag
BRepCheck_InvalidSameParameterFlag = _BRepCheck.BRepCheck_InvalidSameParameterFlag
BRepCheck_InvalidDegeneratedFlag = _BRepCheck.BRepCheck_InvalidDegeneratedFlag
BRepCheck_FreeEdge = _BRepCheck.BRepCheck_FreeEdge
BRepCheck_InvalidMultiConnexity = _BRepCheck.BRepCheck_InvalidMultiConnexity
BRepCheck_InvalidRange = _BRepCheck.BRepCheck_InvalidRange
BRepCheck_EmptyWire = _BRepCheck.BRepCheck_EmptyWire
BRepCheck_RedundantEdge = _BRepCheck.BRepCheck_RedundantEdge
BRepCheck_SelfIntersectingWire = _BRepCheck.BRepCheck_SelfIntersectingWire
BRepCheck_NoSurface = _BRepCheck.BRepCheck_NoSurface
BRepCheck_InvalidWire = _BRepCheck.BRepCheck_InvalidWire
BRepCheck_RedundantWire = _BRepCheck.BRepCheck_RedundantWire
BRepCheck_IntersectingWires = _BRepCheck.BRepCheck_IntersectingWires
BRepCheck_InvalidImbricationOfWires = _BRepCheck.BRepCheck_InvalidImbricationOfWires
BRepCheck_EmptyShell = _BRepCheck.BRepCheck_EmptyShell
BRepCheck_RedundantFace = _BRepCheck.BRepCheck_RedundantFace
BRepCheck_InvalidImbricationOfShells = _BRepCheck.BRepCheck_InvalidImbricationOfShells
BRepCheck_UnorientableShape = _BRepCheck.BRepCheck_UnorientableShape
BRepCheck_NotClosed = _BRepCheck.BRepCheck_NotClosed
BRepCheck_NotConnected = _BRepCheck.BRepCheck_NotConnected
BRepCheck_SubshapeNotInShape = _BRepCheck.BRepCheck_SubshapeNotInShape
BRepCheck_BadOrientation = _BRepCheck.BRepCheck_BadOrientation
BRepCheck_BadOrientationOfSubshape = _BRepCheck.BRepCheck_BadOrientationOfSubshape
BRepCheck_InvalidPolygonOnTriangulation = _BRepCheck.BRepCheck_InvalidPolygonOnTriangulation
BRepCheck_InvalidToleranceValue = _BRepCheck.BRepCheck_InvalidToleranceValue
BRepCheck_EnclosedRegion = _BRepCheck.BRepCheck_EnclosedRegion
BRepCheck_CheckFail = _BRepCheck.BRepCheck_CheckFail
class BRepCheck_Result(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepCheck_Result
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepCheck_Result(self) 
            return h


    def Init(self, *args):
        """
        Init(BRepCheck_Result self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepCheck.BRepCheck_Result_Init(self, *args)


    def InContext(self, *args):
        """
        InContext(BRepCheck_Result self, TopoDS_Shape ContextShape)

        :type ContextShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepCheck.BRepCheck_Result_InContext(self, *args)


    def Minimum(self, *args):
        """Minimum(BRepCheck_Result self)"""
        return _BRepCheck.BRepCheck_Result_Minimum(self, *args)


    def Blind(self, *args):
        """Blind(BRepCheck_Result self)"""
        return _BRepCheck.BRepCheck_Result_Blind(self, *args)


    def SetFailStatus(self, *args):
        """
        SetFailStatus(BRepCheck_Result self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepCheck.BRepCheck_Result_SetFailStatus(self, *args)


    def Status(self, *args):
        """
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_ListOfStatus

        """
        res = _BRepCheck.BRepCheck_Result_Status(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsMinimum(self, *args):
        """
        IsMinimum(BRepCheck_Result self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.BRepCheck_Result_IsMinimum(self, *args)


    def IsBlind(self, *args):
        """
        IsBlind(BRepCheck_Result self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.BRepCheck_Result_IsBlind(self, *args)


    def InitContextIterator(self, *args):
        """InitContextIterator(BRepCheck_Result self)"""
        return _BRepCheck.BRepCheck_Result_InitContextIterator(self, *args)


    def MoreShapeInContext(self, *args):
        """
        MoreShapeInContext(BRepCheck_Result self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.BRepCheck_Result_MoreShapeInContext(self, *args)


    def ContextualShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepCheck.BRepCheck_Result_ContextualShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def StatusOnShape(self, *args):
        """
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_ListOfStatus

        """
        res = _BRepCheck.BRepCheck_Result_StatusOnShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NextShapeInContext(self, *args):
        """NextShapeInContext(BRepCheck_Result self)"""
        return _BRepCheck.BRepCheck_Result_NextShapeInContext(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepCheck.BRepCheck_Result_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepCheck.BRepCheck_Result_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepCheck.BRepCheck_Result_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepCheck.delete_BRepCheck_Result
BRepCheck_Result_swigregister = _BRepCheck.BRepCheck_Result_swigregister
BRepCheck_Result_swigregister(BRepCheck_Result)

def BRepCheck_Result_get_type_name(*args):
    """
    BRepCheck_Result_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepCheck.BRepCheck_Result_get_type_name(*args)

def BRepCheck_Result_get_type_descriptor(*args):
    """
    BRepCheck_Result_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepCheck.BRepCheck_Result_get_type_descriptor(*args)

class BRepCheck_Face(BRepCheck_Result):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepCheck_Face
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepCheck_Face(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRepCheck_Face self, TopoDS_Face F) -> BRepCheck_Face

        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        this = _BRepCheck.new_BRepCheck_Face(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def InContext(self, *args):
        """
        InContext(BRepCheck_Face self, TopoDS_Shape ContextShape)

        :type ContextShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepCheck.BRepCheck_Face_InContext(self, *args)


    def Minimum(self, *args):
        """Minimum(BRepCheck_Face self)"""
        return _BRepCheck.BRepCheck_Face_Minimum(self, *args)


    def Blind(self, *args):
        """Blind(BRepCheck_Face self)"""
        return _BRepCheck.BRepCheck_Face_Blind(self, *args)


    def IntersectWires(self, *args):
        """
        IntersectWires(BRepCheck_Face self, Standard_Boolean const Update) -> BRepCheck_Status

        :type Update: bool
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_Status

        """
        return _BRepCheck.BRepCheck_Face_IntersectWires(self, *args)


    def ClassifyWires(self, *args):
        """
        ClassifyWires(BRepCheck_Face self, Standard_Boolean const Update) -> BRepCheck_Status

        :type Update: bool
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_Status

        """
        return _BRepCheck.BRepCheck_Face_ClassifyWires(self, *args)


    def OrientationOfWires(self, *args):
        """
        OrientationOfWires(BRepCheck_Face self, Standard_Boolean const Update) -> BRepCheck_Status

        :type Update: bool
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_Status

        """
        return _BRepCheck.BRepCheck_Face_OrientationOfWires(self, *args)


    def SetUnorientable(self, *args):
        """SetUnorientable(BRepCheck_Face self)"""
        return _BRepCheck.BRepCheck_Face_SetUnorientable(self, *args)


    def SetStatus(self, *args):
        """
        SetStatus(BRepCheck_Face self, BRepCheck_Status const theStatus)

        Sets status of Face;

        :type theStatus: OCC.wrapper.BRepCheck.BRepCheck_Status

        """
        return _BRepCheck.BRepCheck_Face_SetStatus(self, *args)


    def IsUnorientable(self, *args):
        """
        IsUnorientable(BRepCheck_Face self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.BRepCheck_Face_IsUnorientable(self, *args)


    def GeometricControls(self, *args):
        """
        GeometricControls(BRepCheck_Face self) -> Standard_Boolean
        GeometricControls(BRepCheck_Face self, Standard_Boolean const B)

        :type B: bool

        """
        return _BRepCheck.BRepCheck_Face_GeometricControls(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepCheck.BRepCheck_Face_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepCheck.BRepCheck_Face_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepCheck.BRepCheck_Face_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepCheck.delete_BRepCheck_Face
BRepCheck_Face_swigregister = _BRepCheck.BRepCheck_Face_swigregister
BRepCheck_Face_swigregister(BRepCheck_Face)

def BRepCheck_Face_get_type_name(*args):
    """
    BRepCheck_Face_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepCheck.BRepCheck_Face_get_type_name(*args)

def BRepCheck_Face_get_type_descriptor(*args):
    """
    BRepCheck_Face_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepCheck.BRepCheck_Face_get_type_descriptor(*args)

class BRepCheck_Shell(BRepCheck_Result):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepCheck_Shell
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepCheck_Shell(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRepCheck_Shell self, TopoDS_Shell S) -> BRepCheck_Shell

        :type S: OCC.wrapper.TopoDS.TopoDS_Shell

        """
        this = _BRepCheck.new_BRepCheck_Shell(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def InContext(self, *args):
        """
        InContext(BRepCheck_Shell self, TopoDS_Shape ContextShape)

        :type ContextShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepCheck.BRepCheck_Shell_InContext(self, *args)


    def Minimum(self, *args):
        """Minimum(BRepCheck_Shell self)"""
        return _BRepCheck.BRepCheck_Shell_Minimum(self, *args)


    def Blind(self, *args):
        """Blind(BRepCheck_Shell self)"""
        return _BRepCheck.BRepCheck_Shell_Blind(self, *args)


    def Closed(self, *args):
        """
        Closed(BRepCheck_Shell self, Standard_Boolean const Update) -> BRepCheck_Status

        Checks if the oriented  faces of the shell  give a
        closed shell.    If the  wire is  closed,  returns
        BRepCheck_NoError.If      <Update>     is  set  to
        Standard_True, registers the status in the list.

        :type Update: bool
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_Status

        """
        return _BRepCheck.BRepCheck_Shell_Closed(self, *args)


    def Orientation(self, *args):
        """
        Orientation(BRepCheck_Shell self, Standard_Boolean const Update) -> BRepCheck_Status

        Checks if the   oriented faces  of  the shell  are
        correctly oriented.  An internal  call is  made to
        the  method  Closed.   If  <Update>    is set   to
        Standard_True, registers the status in the list.

        :type Update: bool
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_Status

        """
        return _BRepCheck.BRepCheck_Shell_Orientation(self, *args)


    def SetUnorientable(self, *args):
        """SetUnorientable(BRepCheck_Shell self)"""
        return _BRepCheck.BRepCheck_Shell_SetUnorientable(self, *args)


    def IsUnorientable(self, *args):
        """
        IsUnorientable(BRepCheck_Shell self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.BRepCheck_Shell_IsUnorientable(self, *args)


    def NbConnectedSet(self, *args):
        """
        NbConnectedSet(BRepCheck_Shell self, NCollection_List_TopoDS_Shape theSets) -> Standard_Integer

        :type theSets: OCC.wrapper.TopTools.TopTools_ListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepCheck.BRepCheck_Shell_NbConnectedSet(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepCheck.BRepCheck_Shell_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepCheck.BRepCheck_Shell_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepCheck.BRepCheck_Shell_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepCheck.delete_BRepCheck_Shell
BRepCheck_Shell_swigregister = _BRepCheck.BRepCheck_Shell_swigregister
BRepCheck_Shell_swigregister(BRepCheck_Shell)

def BRepCheck_Shell_get_type_name(*args):
    """
    BRepCheck_Shell_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepCheck.BRepCheck_Shell_get_type_name(*args)

def BRepCheck_Shell_get_type_descriptor(*args):
    """
    BRepCheck_Shell_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepCheck.BRepCheck_Shell_get_type_descriptor(*args)

class BRepCheck_Vertex(BRepCheck_Result):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepCheck_Vertex
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepCheck_Vertex(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRepCheck_Vertex self, TopoDS_Vertex V) -> BRepCheck_Vertex

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        this = _BRepCheck.new_BRepCheck_Vertex(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def InContext(self, *args):
        """
        InContext(BRepCheck_Vertex self, TopoDS_Shape ContextShape)

        :type ContextShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepCheck.BRepCheck_Vertex_InContext(self, *args)


    def Minimum(self, *args):
        """Minimum(BRepCheck_Vertex self)"""
        return _BRepCheck.BRepCheck_Vertex_Minimum(self, *args)


    def Blind(self, *args):
        """Blind(BRepCheck_Vertex self)"""
        return _BRepCheck.BRepCheck_Vertex_Blind(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(BRepCheck_Vertex self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepCheck.BRepCheck_Vertex_Tolerance(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepCheck.BRepCheck_Vertex_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepCheck.BRepCheck_Vertex_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepCheck.BRepCheck_Vertex_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepCheck.delete_BRepCheck_Vertex
BRepCheck_Vertex_swigregister = _BRepCheck.BRepCheck_Vertex_swigregister
BRepCheck_Vertex_swigregister(BRepCheck_Vertex)

def BRepCheck_Vertex_get_type_name(*args):
    """
    BRepCheck_Vertex_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepCheck.BRepCheck_Vertex_get_type_name(*args)

def BRepCheck_Vertex_get_type_descriptor(*args):
    """
    BRepCheck_Vertex_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepCheck.BRepCheck_Vertex_get_type_descriptor(*args)

class NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< BRepCheck_Result >,TopTools_OrientedShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< BRepCheck_Result >,TopTools_OrientedShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< BRepCheck_Result >,TopTools_OrientedShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< BRepCheck_Result >,TopTools_OrientedShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _BRepCheck.new_NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey, Handle_BRepCheck_Result theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey, Handle_BRepCheck_Result theItem) -> Handle_BRepCheck_Result

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey) -> Handle_BRepCheck_Result

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepCheck.NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey) -> Handle_BRepCheck_Result

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher self, TopoDS_Shape theKey) -> Handle_BRepCheck_Result

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepCheck.NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher___iter__(self)
    __swig_destroy__ = _BRepCheck.delete_NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher
NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher_swigregister = _BRepCheck.NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BRepCheck.new_NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepCheck.delete_NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher_IteratorHelper

    def __next__(self):
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher_IteratorHelper_swigregister = _BRepCheck.NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher_IteratorHelper)


try:
	BRepCheck_DataMapOfShapeResult = NCollection_DataMap_TopoDS_Shape_Handle_BRepCheck_Result_TopTools_OrientedShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class BRepCheck_Solid(BRepCheck_Result):
    """The class is to check a solid."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepCheck_Solid
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepCheck_Solid(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRepCheck_Solid self, TopoDS_Solid theS) -> BRepCheck_Solid

        Constructor
        <theS> is the solid to check

        :type theS: OCC.wrapper.TopoDS.TopoDS_Solid

        """
        this = _BRepCheck.new_BRepCheck_Solid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def InContext(self, *args):
        """
        InContext(BRepCheck_Solid self, TopoDS_Shape theContextShape)

        Checks the solid in context of
        the shape <theContextShape>

        :type theContextShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepCheck.BRepCheck_Solid_InContext(self, *args)


    def Minimum(self, *args):
        """
        Minimum(BRepCheck_Solid self)

        Checks the solid per se.

        The scan area is:
        1.  Shells that overlaps each other
        Status:  BRepCheck_InvalidImbricationOfShells

        2.  Detached parts of the solid (vertices, edges)
        that have non-internal orientation
        Status:  BRepCheck_BadOrientationOfSubshape

        3.  For closed, non-internal shells:
        3.1 Shells containing entities  of the solid that
        are outside towards the shells
        Status:  BRepCheck_SubshapeNotInShape

        3.2 Shells that encloses other Shells
        (for non-holes)
        Status:  BRepCheck_EnclosedRegion


        """
        return _BRepCheck.BRepCheck_Solid_Minimum(self, *args)


    def Blind(self, *args):
        """
        Blind(BRepCheck_Solid self)

        see the parent class for more details


        """
        return _BRepCheck.BRepCheck_Solid_Blind(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepCheck.BRepCheck_Solid_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepCheck.BRepCheck_Solid_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepCheck.BRepCheck_Solid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepCheck.delete_BRepCheck_Solid
BRepCheck_Solid_swigregister = _BRepCheck.BRepCheck_Solid_swigregister
BRepCheck_Solid_swigregister(BRepCheck_Solid)

def BRepCheck_Solid_get_type_name(*args):
    """
    BRepCheck_Solid_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepCheck.BRepCheck_Solid_get_type_name(*args)

def BRepCheck_Solid_get_type_descriptor(*args):
    """
    BRepCheck_Solid_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepCheck.BRepCheck_Solid_get_type_descriptor(*args)

class BRepCheck_(object):
    """
    This package  provides tools to check the validity
    of the BRep.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args):
        """
        Add(NCollection_List_BRepCheck_Status List, BRepCheck_Status const Stat)

        :type List: OCC.wrapper.BRepCheck.BRepCheck_ListOfStatus
        :type Stat: OCC.wrapper.BRepCheck.BRepCheck_Status

        """
        return _BRepCheck.BRepCheck__Add(*args)

    Add = staticmethod(Add)

    def Print(*args):
        """
        Print(BRepCheck_Status const Stat, Standard_OStream & OS)

        :type Stat: OCC.wrapper.BRepCheck.BRepCheck_Status
        :type OS: OCC.wrapper.Standard.Standard_OStream

        """
        return _BRepCheck.BRepCheck__Print(*args)

    Print = staticmethod(Print)

    def SelfIntersection(*args):
        """
        SelfIntersection(TopoDS_Wire W, TopoDS_Face F, TopoDS_Edge E1, TopoDS_Edge E2) -> Standard_Boolean

        :type W: OCC.wrapper.TopoDS.TopoDS_Wire
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type E1: OCC.wrapper.TopoDS.TopoDS_Edge
        :type E2: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.BRepCheck__SelfIntersection(*args)

    SelfIntersection = staticmethod(SelfIntersection)

    def PrecCurve(*args):
        """
        PrecCurve(Adaptor3d_Curve aAC3D) -> Standard_Real

        Returns the resolution on the 3d curve

        :type aAC3D: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepCheck.BRepCheck__PrecCurve(*args)

    PrecCurve = staticmethod(PrecCurve)

    def PrecSurface(*args):
        """
        PrecSurface(Handle_Adaptor3d_HSurface aAHSurf) -> Standard_Real

        Returns the resolution on the surface

        :type aAHSurf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepCheck.BRepCheck__PrecSurface(*args)

    PrecSurface = staticmethod(PrecSurface)

    def __init__(self):
        """
        This package  provides tools to check the validity
        of the BRep.
        """
        this = _BRepCheck.new_BRepCheck_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepCheck.delete_BRepCheck_
BRepCheck__swigregister = _BRepCheck.BRepCheck__swigregister
BRepCheck__swigregister(BRepCheck_)

def BRepCheck__Add(*args):
    """
    BRepCheck__Add(NCollection_List_BRepCheck_Status List, BRepCheck_Status const Stat)

    :type List: OCC.wrapper.BRepCheck.BRepCheck_ListOfStatus
    :type Stat: OCC.wrapper.BRepCheck.BRepCheck_Status

    """
    return _BRepCheck.BRepCheck__Add(*args)

def BRepCheck__Print(*args):
    """
    BRepCheck__Print(BRepCheck_Status const Stat, Standard_OStream & OS)

    :type Stat: OCC.wrapper.BRepCheck.BRepCheck_Status
    :type OS: OCC.wrapper.Standard.Standard_OStream

    """
    return _BRepCheck.BRepCheck__Print(*args)

def BRepCheck__SelfIntersection(*args):
    """
    BRepCheck__SelfIntersection(TopoDS_Wire W, TopoDS_Face F, TopoDS_Edge E1, TopoDS_Edge E2) -> Standard_Boolean

    :type W: OCC.wrapper.TopoDS.TopoDS_Wire
    :type F: OCC.wrapper.TopoDS.TopoDS_Face
    :type E1: OCC.wrapper.TopoDS.TopoDS_Edge
    :type E2: OCC.wrapper.TopoDS.TopoDS_Edge
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepCheck.BRepCheck__SelfIntersection(*args)

def BRepCheck__PrecCurve(*args):
    """
    BRepCheck__PrecCurve(Adaptor3d_Curve aAC3D) -> Standard_Real

    Returns the resolution on the 3d curve

    :type aAC3D: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRepCheck.BRepCheck__PrecCurve(*args)

def BRepCheck__PrecSurface(*args):
    """
    BRepCheck__PrecSurface(Handle_Adaptor3d_HSurface aAHSurf) -> Standard_Real

    Returns the resolution on the surface

    :type aAHSurf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRepCheck.BRepCheck__PrecSurface(*args)

class Handle_BRepCheck_Shell(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepCheck_Shell self)

        Nullify the handle


        """
        return _BRepCheck.Handle_BRepCheck_Shell_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepCheck_Shell self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepCheck.Handle_BRepCheck_Shell_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepCheck_Shell self, BRepCheck_Shell thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepCheck.Handle_BRepCheck_Shell_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepCheck_Shell self, Handle_BRepCheck_Shell theHandle) -> Handle_BRepCheck_Shell
        assign(Handle_BRepCheck_Shell self, BRepCheck_Shell thePtr) -> Handle_BRepCheck_Shell
        assign(Handle_BRepCheck_Shell self, Handle_BRepCheck_Shell theHandle) -> Handle_BRepCheck_Shell

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepCheck.Handle_BRepCheck_Shell_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepCheck_Shell self) -> BRepCheck_Shell

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepCheck.Handle_BRepCheck_Shell_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepCheck_Shell self) -> BRepCheck_Shell

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepCheck.Handle_BRepCheck_Shell___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepCheck_Shell self) -> BRepCheck_Shell

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepCheck.Handle_BRepCheck_Shell___ref__(self, *args)


    def __hash__(self):
        return _BRepCheck.Handle_BRepCheck_Shell___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepCheck.Handle_BRepCheck_Shell___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepCheck.new_Handle_BRepCheck_Shell(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepCheck.Handle_BRepCheck_Shell_DownCast)
    __swig_destroy__ = _BRepCheck.delete_Handle_BRepCheck_Shell

    def InContext(self, *args):
        """
        InContext(Handle_BRepCheck_Shell self, TopoDS_Shape ContextShape)

        :type ContextShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepCheck.Handle_BRepCheck_Shell_InContext(self, *args)


    def Minimum(self, *args):
        """Minimum(Handle_BRepCheck_Shell self)"""
        return _BRepCheck.Handle_BRepCheck_Shell_Minimum(self, *args)


    def Blind(self, *args):
        """Blind(Handle_BRepCheck_Shell self)"""
        return _BRepCheck.Handle_BRepCheck_Shell_Blind(self, *args)


    def Closed(self, *args):
        """
        Closed(Handle_BRepCheck_Shell self, Standard_Boolean const Update) -> BRepCheck_Status

        Checks if the oriented  faces of the shell  give a
        closed shell.    If the  wire is  closed,  returns
        BRepCheck_NoError.If      <Update>     is  set  to
        Standard_True, registers the status in the list.

        :type Update: bool
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_Status

        """
        return _BRepCheck.Handle_BRepCheck_Shell_Closed(self, *args)


    def Orientation(self, *args):
        """
        Orientation(Handle_BRepCheck_Shell self, Standard_Boolean const Update) -> BRepCheck_Status

        Checks if the   oriented faces  of  the shell  are
        correctly oriented.  An internal  call is  made to
        the  method  Closed.   If  <Update>    is set   to
        Standard_True, registers the status in the list.

        :type Update: bool
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_Status

        """
        return _BRepCheck.Handle_BRepCheck_Shell_Orientation(self, *args)


    def SetUnorientable(self, *args):
        """SetUnorientable(Handle_BRepCheck_Shell self)"""
        return _BRepCheck.Handle_BRepCheck_Shell_SetUnorientable(self, *args)


    def IsUnorientable(self, *args):
        """
        IsUnorientable(Handle_BRepCheck_Shell self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Shell_IsUnorientable(self, *args)


    def NbConnectedSet(self, *args):
        """
        NbConnectedSet(Handle_BRepCheck_Shell self, NCollection_List_TopoDS_Shape theSets) -> Standard_Integer

        :type theSets: OCC.wrapper.TopTools.TopTools_ListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepCheck.Handle_BRepCheck_Shell_NbConnectedSet(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepCheck_Shell self) -> char const *

        :rtype: const char *

        """
        return _BRepCheck.Handle_BRepCheck_Shell_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepCheck.Handle_BRepCheck_Shell_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepCheck.Handle_BRepCheck_Shell_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_BRepCheck_Shell self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepCheck.Handle_BRepCheck_Shell_Init(self, *args)


    def SetFailStatus(self, *args):
        """
        SetFailStatus(Handle_BRepCheck_Shell self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepCheck.Handle_BRepCheck_Shell_SetFailStatus(self, *args)


    def Status(self, *args):
        """
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_ListOfStatus

        """
        res = _BRepCheck.Handle_BRepCheck_Shell_Status(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsMinimum(self, *args):
        """
        IsMinimum(Handle_BRepCheck_Shell self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Shell_IsMinimum(self, *args)


    def IsBlind(self, *args):
        """
        IsBlind(Handle_BRepCheck_Shell self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Shell_IsBlind(self, *args)


    def StatusOnShape(self, *args):
        """
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_ListOfStatus

        """
        res = _BRepCheck.Handle_BRepCheck_Shell_StatusOnShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InitContextIterator(self, *args):
        """InitContextIterator(Handle_BRepCheck_Shell self)"""
        return _BRepCheck.Handle_BRepCheck_Shell_InitContextIterator(self, *args)


    def MoreShapeInContext(self, *args):
        """
        MoreShapeInContext(Handle_BRepCheck_Shell self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Shell_MoreShapeInContext(self, *args)


    def ContextualShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepCheck.Handle_BRepCheck_Shell_ContextualShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NextShapeInContext(self, *args):
        """NextShapeInContext(Handle_BRepCheck_Shell self)"""
        return _BRepCheck.Handle_BRepCheck_Shell_NextShapeInContext(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_BRepCheck_Shell self)

        Memory deallocator for transient classes


        """
        return _BRepCheck.Handle_BRepCheck_Shell_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepCheck_Shell self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepCheck_Shell self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Shell_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepCheck_Shell self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepCheck_Shell self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Shell_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepCheck_Shell self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepCheck.Handle_BRepCheck_Shell_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepCheck_Shell self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepCheck.Handle_BRepCheck_Shell_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepCheck_Shell self)

        Increments the reference counter of this object


        """
        return _BRepCheck.Handle_BRepCheck_Shell_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepCheck_Shell self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepCheck.Handle_BRepCheck_Shell_DecrementRefCounter(self, *args)

Handle_BRepCheck_Shell_swigregister = _BRepCheck.Handle_BRepCheck_Shell_swigregister
Handle_BRepCheck_Shell_swigregister(Handle_BRepCheck_Shell)

def Handle_BRepCheck_Shell_DownCast(thing):
    return _BRepCheck.Handle_BRepCheck_Shell_DownCast(thing)
Handle_BRepCheck_Shell_DownCast = _BRepCheck.Handle_BRepCheck_Shell_DownCast

class Handle_BRepCheck_Face(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepCheck_Face self)

        Nullify the handle


        """
        return _BRepCheck.Handle_BRepCheck_Face_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepCheck_Face self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepCheck.Handle_BRepCheck_Face_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepCheck_Face self, BRepCheck_Face thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepCheck.Handle_BRepCheck_Face_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepCheck_Face self, Handle_BRepCheck_Face theHandle) -> Handle_BRepCheck_Face
        assign(Handle_BRepCheck_Face self, BRepCheck_Face thePtr) -> Handle_BRepCheck_Face
        assign(Handle_BRepCheck_Face self, Handle_BRepCheck_Face theHandle) -> Handle_BRepCheck_Face

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepCheck.Handle_BRepCheck_Face_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepCheck_Face self) -> BRepCheck_Face

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepCheck.Handle_BRepCheck_Face_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepCheck_Face self) -> BRepCheck_Face

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepCheck.Handle_BRepCheck_Face___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepCheck_Face self) -> BRepCheck_Face

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepCheck.Handle_BRepCheck_Face___ref__(self, *args)


    def __hash__(self):
        return _BRepCheck.Handle_BRepCheck_Face___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepCheck.Handle_BRepCheck_Face___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepCheck.new_Handle_BRepCheck_Face(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepCheck.Handle_BRepCheck_Face_DownCast)
    __swig_destroy__ = _BRepCheck.delete_Handle_BRepCheck_Face

    def InContext(self, *args):
        """
        InContext(Handle_BRepCheck_Face self, TopoDS_Shape ContextShape)

        :type ContextShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepCheck.Handle_BRepCheck_Face_InContext(self, *args)


    def Minimum(self, *args):
        """Minimum(Handle_BRepCheck_Face self)"""
        return _BRepCheck.Handle_BRepCheck_Face_Minimum(self, *args)


    def Blind(self, *args):
        """Blind(Handle_BRepCheck_Face self)"""
        return _BRepCheck.Handle_BRepCheck_Face_Blind(self, *args)


    def IntersectWires(self, *args):
        """
        IntersectWires(Handle_BRepCheck_Face self, Standard_Boolean const Update) -> BRepCheck_Status

        :type Update: bool
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_Status

        """
        return _BRepCheck.Handle_BRepCheck_Face_IntersectWires(self, *args)


    def ClassifyWires(self, *args):
        """
        ClassifyWires(Handle_BRepCheck_Face self, Standard_Boolean const Update) -> BRepCheck_Status

        :type Update: bool
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_Status

        """
        return _BRepCheck.Handle_BRepCheck_Face_ClassifyWires(self, *args)


    def OrientationOfWires(self, *args):
        """
        OrientationOfWires(Handle_BRepCheck_Face self, Standard_Boolean const Update) -> BRepCheck_Status

        :type Update: bool
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_Status

        """
        return _BRepCheck.Handle_BRepCheck_Face_OrientationOfWires(self, *args)


    def SetUnorientable(self, *args):
        """SetUnorientable(Handle_BRepCheck_Face self)"""
        return _BRepCheck.Handle_BRepCheck_Face_SetUnorientable(self, *args)


    def SetStatus(self, *args):
        """
        SetStatus(Handle_BRepCheck_Face self, BRepCheck_Status const theStatus)

        Sets status of Face;

        :type theStatus: OCC.wrapper.BRepCheck.BRepCheck_Status

        """
        return _BRepCheck.Handle_BRepCheck_Face_SetStatus(self, *args)


    def IsUnorientable(self, *args):
        """
        IsUnorientable(Handle_BRepCheck_Face self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Face_IsUnorientable(self, *args)


    def GeometricControls(self, *args):
        """
        GeometricControls(Handle_BRepCheck_Face self) -> Standard_Boolean
        GeometricControls(Handle_BRepCheck_Face self, Standard_Boolean const B)

        :type B: bool

        """
        return _BRepCheck.Handle_BRepCheck_Face_GeometricControls(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepCheck_Face self) -> char const *

        :rtype: const char *

        """
        return _BRepCheck.Handle_BRepCheck_Face_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepCheck.Handle_BRepCheck_Face_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepCheck.Handle_BRepCheck_Face_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_BRepCheck_Face self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepCheck.Handle_BRepCheck_Face_Init(self, *args)


    def SetFailStatus(self, *args):
        """
        SetFailStatus(Handle_BRepCheck_Face self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepCheck.Handle_BRepCheck_Face_SetFailStatus(self, *args)


    def Status(self, *args):
        """
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_ListOfStatus

        """
        res = _BRepCheck.Handle_BRepCheck_Face_Status(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsMinimum(self, *args):
        """
        IsMinimum(Handle_BRepCheck_Face self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Face_IsMinimum(self, *args)


    def IsBlind(self, *args):
        """
        IsBlind(Handle_BRepCheck_Face self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Face_IsBlind(self, *args)


    def StatusOnShape(self, *args):
        """
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_ListOfStatus

        """
        res = _BRepCheck.Handle_BRepCheck_Face_StatusOnShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InitContextIterator(self, *args):
        """InitContextIterator(Handle_BRepCheck_Face self)"""
        return _BRepCheck.Handle_BRepCheck_Face_InitContextIterator(self, *args)


    def MoreShapeInContext(self, *args):
        """
        MoreShapeInContext(Handle_BRepCheck_Face self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Face_MoreShapeInContext(self, *args)


    def ContextualShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepCheck.Handle_BRepCheck_Face_ContextualShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NextShapeInContext(self, *args):
        """NextShapeInContext(Handle_BRepCheck_Face self)"""
        return _BRepCheck.Handle_BRepCheck_Face_NextShapeInContext(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_BRepCheck_Face self)

        Memory deallocator for transient classes


        """
        return _BRepCheck.Handle_BRepCheck_Face_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepCheck_Face self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepCheck_Face self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Face_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepCheck_Face self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepCheck_Face self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Face_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepCheck_Face self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepCheck.Handle_BRepCheck_Face_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepCheck_Face self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepCheck.Handle_BRepCheck_Face_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepCheck_Face self)

        Increments the reference counter of this object


        """
        return _BRepCheck.Handle_BRepCheck_Face_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepCheck_Face self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepCheck.Handle_BRepCheck_Face_DecrementRefCounter(self, *args)

Handle_BRepCheck_Face_swigregister = _BRepCheck.Handle_BRepCheck_Face_swigregister
Handle_BRepCheck_Face_swigregister(Handle_BRepCheck_Face)

def Handle_BRepCheck_Face_DownCast(thing):
    return _BRepCheck.Handle_BRepCheck_Face_DownCast(thing)
Handle_BRepCheck_Face_DownCast = _BRepCheck.Handle_BRepCheck_Face_DownCast

class BRepCheck_Analyzer(object):
    """
    A framework to check the overall
    validity of a shape. For a shape to be valid in Open
    CASCADE, it - or its component subshapes - must respect certain
    criteria. These criteria are checked by the function IsValid.
    Once you have determined whether a shape is valid or not, you can
    diagnose its specific anomalies and correct them using the services of
    the ShapeAnalysis, ShapeUpgrade, and ShapeFix packages.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepCheck_Analyzer self, TopoDS_Shape S, Standard_Boolean const GeomControls) -> BRepCheck_Analyzer

        Constructs a shape validation object defined by the shape S.
        <S> is the  shape  to control.  <GeomControls>  If
        False   only topological informaions  are checked.
        The geometricals controls are
        For a Vertex :
        BRepCheck_InvalidToleranceValue  NYI
        For an Edge :
        BRepCheck_InvalidCurveOnClosedSurface,
        BRepCheck_InvalidCurveOnSurface,
        BRepCheck_InvalidSameParameterFlag,
        BRepCheck_InvalidToleranceValue  NYI
        For a face :
        BRepCheck_UnorientableShape,
        BRepCheck_IntersectingWires,
        BRepCheck_InvalidToleranceValue  NYI
        For a wire :
        BRepCheck_SelfIntersectingWire

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type GeomControls: bool

        """
        this = _BRepCheck.new_BRepCheck_Analyzer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepCheck_Analyzer self, TopoDS_Shape S, Standard_Boolean const GeomControls)

        <S> is the  shape  to control.  <GeomControls>  If
        False   only topological informaions  are checked.
        The geometricals controls are
        For a Vertex :
        BRepCheck_InvalidTolerance  NYI
        For an Edge :
        BRepCheck_InvalidCurveOnClosedSurface,
        BRepCheck_InvalidCurveOnSurface,
        BRepCheck_InvalidSameParameterFlag,
        BRepCheck_InvalidTolerance  NYI
        For a face :
        BRepCheck_UnorientableShape,
        BRepCheck_IntersectingWires,
        BRepCheck_InvalidTolerance  NYI
        For a wire :
        BRepCheck_SelfIntersectingWire

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type GeomControls: bool

        """
        return _BRepCheck.BRepCheck_Analyzer_Init(self, *args)


    def IsValid(self, *args):
        """
        IsValid(BRepCheck_Analyzer self, TopoDS_Shape S) -> Standard_Boolean
        IsValid(BRepCheck_Analyzer self) -> Standard_Boolean

        Returns true if no defect is
        detected on the shape S or any of its subshapes.
        Returns true if the shape S is valid.
        This function checks whether a given shape is valid by checking that:
        -      the topology is correct
        -      parameterization of edges in particular is correct.
        For the topology to be correct, the following conditions must be satisfied:
        -      edges should have at least two vertices if they are not
        degenerate edges. The vertices should be within the range of
        the bounding edges at the tolerance specified in the vertex,
        -      edges should share at least one face. The representation of
        the edges should be within the tolerance criterion assigned to them.
        -      wires defining a face should not self-intersect and should be closed,
        - there should be one wire which contains all other wires inside a face,
        -      wires should be correctly oriented with respect to each of the edges,
        -      faces should be correctly oriented, in particular with
        respect to adjacent faces if these faces define a solid,
        -      shells defining a solid should be closed. There should
        be one enclosing shell if the shape is a solid;
        To check parameterization of edge, there are 2 approaches depending on
        the edge?s contextual situation.
        -      if the edge is either single, or it is in the context
        of a wire or a compound, its parameterization is defined by
        the parameterization of its 3D curve and is considered as    valid.
        -      If the edge is in the context of a face, it should
        have SameParameter and SameRange flags set to Standard_True. To
        check these flags, you should call the function
        BRep_Tool::SameParameter and BRep_Tool::SameRange for an
        edge. If at least one of these flags is set to Standard_False,
        the edge is considered as invalid without any additional check.
        If the edge is contained by a face, and it has SameParameter and
        SameRange flags set to Standard_True, IsValid checks
        whether representation of the edge on face, in context of which the
        edge is considered, has the same parameterization up to the
        tolerance value coded on the edge. For a given parameter t on the edge
        having C as a 3D curve and one PCurve P on a surface S (base
        surface of the reference face), this checks that |C(t) - S(P(t))|
        is less than or equal to tolerance, where tolerance is the tolerance
        value coded on the edge.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.BRepCheck_Analyzer_IsValid(self, *args)


    def Result(self, *args):
        """
        :type SubS: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.BRepCheck.Handle_BRepCheck_Result

        """
        res = _BRepCheck.BRepCheck_Analyzer_Result(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepCheck.delete_BRepCheck_Analyzer
BRepCheck_Analyzer_swigregister = _BRepCheck.BRepCheck_Analyzer_swigregister
BRepCheck_Analyzer_swigregister(BRepCheck_Analyzer)

class BRepCheck_Wire(BRepCheck_Result):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepCheck_Wire
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepCheck_Wire(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRepCheck_Wire self, TopoDS_Wire W) -> BRepCheck_Wire

        :type W: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        this = _BRepCheck.new_BRepCheck_Wire(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def InContext(self, *args):
        """
        InContext(BRepCheck_Wire self, TopoDS_Shape ContextShape)

        if <ContextShape> is  a  face, consequently checks
        SelfIntersect(),   Closed(),   Orientation()   and
        Closed2d until faulty is found

        :type ContextShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepCheck.BRepCheck_Wire_InContext(self, *args)


    def Minimum(self, *args):
        """
        Minimum(BRepCheck_Wire self)

        checks that the  wire  is  not empty and "connex".
        Called by constructor


        """
        return _BRepCheck.BRepCheck_Wire_Minimum(self, *args)


    def Blind(self, *args):
        """
        Blind(BRepCheck_Wire self)

        Does nothing


        """
        return _BRepCheck.BRepCheck_Wire_Blind(self, *args)


    def Closed(self, *args):
        """
        Closed(BRepCheck_Wire self, Standard_Boolean const Update) -> BRepCheck_Status

        Checks if the  oriented  edges of the wire  give a
        closed  wire.   If the  wire   is closed,  returns
        BRepCheck_NoError.    Warning :  if the first  and
        last  edge   are  infinite,   the  wire   will  be
        considered as a closed one.  If <Update> is set to
        Standard_True, registers the status in the list.
        May return (and registers):
        **BRepCheck_NotConnected,   if    wire    is   not
        topologically closed
        **BRepCheck_RedundantEdge, if an  edge  is in wire
        more than 3 times  or  in  case of 2 occurences if
        not with FORWARD and REVERSED orientation.
        **BRepCheck_NoError

        :type Update: bool
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_Status

        """
        return _BRepCheck.BRepCheck_Wire_Closed(self, *args)


    def Closed2d(self, *args):
        """
        Closed2d(BRepCheck_Wire self, TopoDS_Face F, Standard_Boolean const Update) -> BRepCheck_Status

        Checks if edges of the  wire give a wire closed in
        2d space.
        Returns BRepCheck_NoError,  or BRepCheck_NotClosed
        If <Update> is set to Standard_True, registers the
        status in the list.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type Update: bool
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_Status

        """
        return _BRepCheck.BRepCheck_Wire_Closed2d(self, *args)


    def Orientation(self, *args):
        """
        Orientation(BRepCheck_Wire self, TopoDS_Face F, Standard_Boolean const Update) -> BRepCheck_Status

        Checks   if  the oriented edges   of  the wire are
        correctly oriented.  An  internal call is made  to
        the  method Closed.   If no face  exists, call the
        method with   a  null  face  (TopoDS_face()).   If
        <Update> is  set  to Standard_True,  registers the
        status in the list.
        May return (and registers):
        BRepCheck_InvalidDegeneratedFlag,
        BRepCheck_BadOrientationOfSubshape,
        BRepCheck_NotClosed,
        BRepCheck_NoError

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type Update: bool
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_Status

        """
        return _BRepCheck.BRepCheck_Wire_Orientation(self, *args)


    def SelfIntersect(self, *args):
        """
        SelfIntersect(BRepCheck_Wire self, TopoDS_Face F, TopoDS_Edge E1, TopoDS_Edge E2, Standard_Boolean const Update) -> BRepCheck_Status

        Checks if  the wire intersect   itself on the face
        <F>.  <E1>  and <E2>   are the first  intersecting
        edges  found.  <E2>  may  be a  null  edge when  a
        self-intersecting edge is found.If <Update> is set
        to Standard_True,   registers  the  status in  the
        list.
        May return (and register):
        BRepCheck_EmptyWire,
        BRepCheck_SelfIntersectingWire,
        BRepCheck_NoCurveOnSurface,
        BRepCheck_NoError

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type E1: OCC.wrapper.TopoDS.TopoDS_Edge
        :type E2: OCC.wrapper.TopoDS.TopoDS_Edge
        :type Update: bool
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_Status

        """
        return _BRepCheck.BRepCheck_Wire_SelfIntersect(self, *args)


    def GeometricControls(self, *args):
        """
        GeometricControls(BRepCheck_Wire self) -> Standard_Boolean
        GeometricControls(BRepCheck_Wire self, Standard_Boolean const B)

        set SelfIntersect() to be checked

        :type B: bool

        """
        return _BRepCheck.BRepCheck_Wire_GeometricControls(self, *args)


    def SetStatus(self, *args):
        """
        SetStatus(BRepCheck_Wire self, BRepCheck_Status const theStatus)

        Sets status of Wire;

        :type theStatus: OCC.wrapper.BRepCheck.BRepCheck_Status

        """
        return _BRepCheck.BRepCheck_Wire_SetStatus(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepCheck.BRepCheck_Wire_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepCheck.BRepCheck_Wire_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepCheck.BRepCheck_Wire_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepCheck.delete_BRepCheck_Wire
BRepCheck_Wire_swigregister = _BRepCheck.BRepCheck_Wire_swigregister
BRepCheck_Wire_swigregister(BRepCheck_Wire)

def BRepCheck_Wire_get_type_name(*args):
    """
    BRepCheck_Wire_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepCheck.BRepCheck_Wire_get_type_name(*args)

def BRepCheck_Wire_get_type_descriptor(*args):
    """
    BRepCheck_Wire_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepCheck.BRepCheck_Wire_get_type_descriptor(*args)

class Handle_BRepCheck_Result(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepCheck_Result self)

        Nullify the handle


        """
        return _BRepCheck.Handle_BRepCheck_Result_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepCheck_Result self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepCheck.Handle_BRepCheck_Result_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepCheck_Result self, BRepCheck_Result thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepCheck.Handle_BRepCheck_Result_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepCheck_Result self, Handle_BRepCheck_Result theHandle) -> Handle_BRepCheck_Result
        assign(Handle_BRepCheck_Result self, BRepCheck_Result thePtr) -> Handle_BRepCheck_Result
        assign(Handle_BRepCheck_Result self, Handle_BRepCheck_Result theHandle) -> Handle_BRepCheck_Result

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepCheck.Handle_BRepCheck_Result_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepCheck_Result self) -> BRepCheck_Result

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepCheck.Handle_BRepCheck_Result_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepCheck_Result self) -> BRepCheck_Result

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepCheck.Handle_BRepCheck_Result___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepCheck_Result self) -> BRepCheck_Result

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepCheck.Handle_BRepCheck_Result___ref__(self, *args)


    def __hash__(self):
        return _BRepCheck.Handle_BRepCheck_Result___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepCheck.Handle_BRepCheck_Result___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepCheck.new_Handle_BRepCheck_Result(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepCheck.Handle_BRepCheck_Result_DownCast)
    __swig_destroy__ = _BRepCheck.delete_Handle_BRepCheck_Result

    def Init(self, *args):
        """
        Init(Handle_BRepCheck_Result self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepCheck.Handle_BRepCheck_Result_Init(self, *args)


    def InContext(self, *args):
        """
        InContext(Handle_BRepCheck_Result self, TopoDS_Shape ContextShape)

        :type ContextShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepCheck.Handle_BRepCheck_Result_InContext(self, *args)


    def Minimum(self, *args):
        """Minimum(Handle_BRepCheck_Result self)"""
        return _BRepCheck.Handle_BRepCheck_Result_Minimum(self, *args)


    def Blind(self, *args):
        """Blind(Handle_BRepCheck_Result self)"""
        return _BRepCheck.Handle_BRepCheck_Result_Blind(self, *args)


    def SetFailStatus(self, *args):
        """
        SetFailStatus(Handle_BRepCheck_Result self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepCheck.Handle_BRepCheck_Result_SetFailStatus(self, *args)


    def Status(self, *args):
        """
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_ListOfStatus

        """
        res = _BRepCheck.Handle_BRepCheck_Result_Status(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsMinimum(self, *args):
        """
        IsMinimum(Handle_BRepCheck_Result self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Result_IsMinimum(self, *args)


    def IsBlind(self, *args):
        """
        IsBlind(Handle_BRepCheck_Result self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Result_IsBlind(self, *args)


    def StatusOnShape(self, *args):
        """
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_ListOfStatus

        """
        res = _BRepCheck.Handle_BRepCheck_Result_StatusOnShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InitContextIterator(self, *args):
        """InitContextIterator(Handle_BRepCheck_Result self)"""
        return _BRepCheck.Handle_BRepCheck_Result_InitContextIterator(self, *args)


    def MoreShapeInContext(self, *args):
        """
        MoreShapeInContext(Handle_BRepCheck_Result self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Result_MoreShapeInContext(self, *args)


    def ContextualShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepCheck.Handle_BRepCheck_Result_ContextualShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NextShapeInContext(self, *args):
        """NextShapeInContext(Handle_BRepCheck_Result self)"""
        return _BRepCheck.Handle_BRepCheck_Result_NextShapeInContext(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepCheck_Result self) -> char const *

        :rtype: const char *

        """
        return _BRepCheck.Handle_BRepCheck_Result_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepCheck.Handle_BRepCheck_Result_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepCheck.Handle_BRepCheck_Result_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRepCheck_Result self)

        Memory deallocator for transient classes


        """
        return _BRepCheck.Handle_BRepCheck_Result_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepCheck_Result self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepCheck_Result self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Result_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepCheck_Result self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepCheck_Result self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Result_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepCheck_Result self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepCheck.Handle_BRepCheck_Result_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepCheck_Result self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepCheck.Handle_BRepCheck_Result_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepCheck_Result self)

        Increments the reference counter of this object


        """
        return _BRepCheck.Handle_BRepCheck_Result_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepCheck_Result self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepCheck.Handle_BRepCheck_Result_DecrementRefCounter(self, *args)

Handle_BRepCheck_Result_swigregister = _BRepCheck.Handle_BRepCheck_Result_swigregister
Handle_BRepCheck_Result_swigregister(Handle_BRepCheck_Result)

def Handle_BRepCheck_Result_DownCast(thing):
    return _BRepCheck.Handle_BRepCheck_Result_DownCast(thing)
Handle_BRepCheck_Result_DownCast = _BRepCheck.Handle_BRepCheck_Result_DownCast

class NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,BRepCheck_ListOfStatus,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,BRepCheck_ListOfStatus,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,BRepCheck_ListOfStatus,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,BRepCheck_ListOfStatus,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _BRepCheck.new_NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, NCollection_List_BRepCheck_Status theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, NCollection_List_BRepCheck_Status theItem) -> NCollection_List_BRepCheck_Status

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_List_BRepCheck_Status

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepCheck.NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_List_BRepCheck_Status

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> NCollection_List_BRepCheck_Status

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepCheck.NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _BRepCheck.delete_NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher_swigregister = _BRepCheck.NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BRepCheck.new_NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepCheck.delete_NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _BRepCheck.NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _BRepCheck.NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher_IteratorHelper)


try:
	BRepCheck_DataMapOfShapeListOfStatus = NCollection_DataMap_TopoDS_Shape_BRepCheck_ListOfStatus_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_List_BRepCheck_Status(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_BRepCheck_Status self) -> NCollection_List< BRepCheck_Status >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _BRepCheck.NCollection_List_BRepCheck_Status_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_BRepCheck_Status self) -> NCollection_List< BRepCheck_Status >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _BRepCheck.NCollection_List_BRepCheck_Status_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_BRepCheck_Status self) -> NCollection_List< BRepCheck_Status >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _BRepCheck.NCollection_List_BRepCheck_Status_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_BRepCheck_Status self) -> NCollection_List< BRepCheck_Status >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _BRepCheck.NCollection_List_BRepCheck_Status_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _BRepCheck.new_NCollection_List_BRepCheck_Status(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_BRepCheck_Status self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepCheck.NCollection_List_BRepCheck_Status_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_BRepCheck_Status self, NCollection_List_BRepCheck_Status theOther) -> NCollection_List_BRepCheck_Status

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _BRepCheck.NCollection_List_BRepCheck_Status_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_BRepCheck_Status self, NCollection_List_BRepCheck_Status theOther) -> NCollection_List_BRepCheck_Status

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _BRepCheck.NCollection_List_BRepCheck_Status_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_BRepCheck_Status self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepCheck.NCollection_List_BRepCheck_Status_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _BRepCheck.NCollection_List_BRepCheck_Status_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _BRepCheck.NCollection_List_BRepCheck_Status_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_BRepCheck_Status self, BRepCheck_Status const & theItem) -> BRepCheck_Status
        Append(NCollection_List_BRepCheck_Status self, BRepCheck_Status const & theItem, NCollection_List< BRepCheck_Status >::Iterator & theIter)
        Append(NCollection_List_BRepCheck_Status self, NCollection_List_BRepCheck_Status theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _BRepCheck.NCollection_List_BRepCheck_Status_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_BRepCheck_Status self, BRepCheck_Status const & theItem) -> BRepCheck_Status
        Prepend(NCollection_List_BRepCheck_Status self, NCollection_List_BRepCheck_Status theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _BRepCheck.NCollection_List_BRepCheck_Status_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_BRepCheck_Status self)

        RemoveFirst item


        """
        return _BRepCheck.NCollection_List_BRepCheck_Status_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_BRepCheck_Status self, NCollection_List< BRepCheck_Status >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _BRepCheck.NCollection_List_BRepCheck_Status_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_BRepCheck_Status self, BRepCheck_Status const & theItem, NCollection_List< BRepCheck_Status >::Iterator & theIter) -> BRepCheck_Status
        InsertBefore(NCollection_List_BRepCheck_Status self, NCollection_List_BRepCheck_Status theOther, NCollection_List< BRepCheck_Status >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _BRepCheck.NCollection_List_BRepCheck_Status_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_BRepCheck_Status self, BRepCheck_Status const & theItem, NCollection_List< BRepCheck_Status >::Iterator & theIter) -> BRepCheck_Status
        InsertAfter(NCollection_List_BRepCheck_Status self, NCollection_List_BRepCheck_Status theOther, NCollection_List< BRepCheck_Status >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _BRepCheck.NCollection_List_BRepCheck_Status_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_BRepCheck_Status self)

        Reverse the list


        """
        return _BRepCheck.NCollection_List_BRepCheck_Status_Reverse(self, *args)


    def __iter__(self):
        return _BRepCheck.NCollection_List_BRepCheck_Status___iter__(self)
    __swig_destroy__ = _BRepCheck.delete_NCollection_List_BRepCheck_Status
NCollection_List_BRepCheck_Status_swigregister = _BRepCheck.NCollection_List_BRepCheck_Status_swigregister
NCollection_List_BRepCheck_Status_swigregister(NCollection_List_BRepCheck_Status)

class NCollection_List_BRepCheck_Status_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BRepCheck.new_NCollection_List_BRepCheck_Status_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepCheck.delete_NCollection_List_BRepCheck_Status_IteratorHelper

    def __next__(self):
        return _BRepCheck.NCollection_List_BRepCheck_Status_IteratorHelper___next__(self)
NCollection_List_BRepCheck_Status_IteratorHelper_swigregister = _BRepCheck.NCollection_List_BRepCheck_Status_IteratorHelper_swigregister
NCollection_List_BRepCheck_Status_IteratorHelper_swigregister(NCollection_List_BRepCheck_Status_IteratorHelper)


try:
	BRepCheck_ListOfStatus = NCollection_List_BRepCheck_Status
except NameError:
	pass # does not exist, probably ignored

class Handle_BRepCheck_Vertex(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepCheck_Vertex self)

        Nullify the handle


        """
        return _BRepCheck.Handle_BRepCheck_Vertex_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepCheck_Vertex self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepCheck.Handle_BRepCheck_Vertex_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepCheck_Vertex self, BRepCheck_Vertex thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepCheck.Handle_BRepCheck_Vertex_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepCheck_Vertex self, Handle_BRepCheck_Vertex theHandle) -> Handle_BRepCheck_Vertex
        assign(Handle_BRepCheck_Vertex self, BRepCheck_Vertex thePtr) -> Handle_BRepCheck_Vertex
        assign(Handle_BRepCheck_Vertex self, Handle_BRepCheck_Vertex theHandle) -> Handle_BRepCheck_Vertex

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepCheck.Handle_BRepCheck_Vertex_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepCheck_Vertex self) -> BRepCheck_Vertex

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepCheck.Handle_BRepCheck_Vertex_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepCheck_Vertex self) -> BRepCheck_Vertex

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepCheck.Handle_BRepCheck_Vertex___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepCheck_Vertex self) -> BRepCheck_Vertex

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepCheck.Handle_BRepCheck_Vertex___ref__(self, *args)


    def __hash__(self):
        return _BRepCheck.Handle_BRepCheck_Vertex___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepCheck.Handle_BRepCheck_Vertex___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepCheck.new_Handle_BRepCheck_Vertex(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepCheck.Handle_BRepCheck_Vertex_DownCast)
    __swig_destroy__ = _BRepCheck.delete_Handle_BRepCheck_Vertex

    def InContext(self, *args):
        """
        InContext(Handle_BRepCheck_Vertex self, TopoDS_Shape ContextShape)

        :type ContextShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepCheck.Handle_BRepCheck_Vertex_InContext(self, *args)


    def Minimum(self, *args):
        """Minimum(Handle_BRepCheck_Vertex self)"""
        return _BRepCheck.Handle_BRepCheck_Vertex_Minimum(self, *args)


    def Blind(self, *args):
        """Blind(Handle_BRepCheck_Vertex self)"""
        return _BRepCheck.Handle_BRepCheck_Vertex_Blind(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(Handle_BRepCheck_Vertex self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepCheck.Handle_BRepCheck_Vertex_Tolerance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepCheck_Vertex self) -> char const *

        :rtype: const char *

        """
        return _BRepCheck.Handle_BRepCheck_Vertex_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepCheck.Handle_BRepCheck_Vertex_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepCheck.Handle_BRepCheck_Vertex_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_BRepCheck_Vertex self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepCheck.Handle_BRepCheck_Vertex_Init(self, *args)


    def SetFailStatus(self, *args):
        """
        SetFailStatus(Handle_BRepCheck_Vertex self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepCheck.Handle_BRepCheck_Vertex_SetFailStatus(self, *args)


    def Status(self, *args):
        """
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_ListOfStatus

        """
        res = _BRepCheck.Handle_BRepCheck_Vertex_Status(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsMinimum(self, *args):
        """
        IsMinimum(Handle_BRepCheck_Vertex self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Vertex_IsMinimum(self, *args)


    def IsBlind(self, *args):
        """
        IsBlind(Handle_BRepCheck_Vertex self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Vertex_IsBlind(self, *args)


    def StatusOnShape(self, *args):
        """
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_ListOfStatus

        """
        res = _BRepCheck.Handle_BRepCheck_Vertex_StatusOnShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InitContextIterator(self, *args):
        """InitContextIterator(Handle_BRepCheck_Vertex self)"""
        return _BRepCheck.Handle_BRepCheck_Vertex_InitContextIterator(self, *args)


    def MoreShapeInContext(self, *args):
        """
        MoreShapeInContext(Handle_BRepCheck_Vertex self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Vertex_MoreShapeInContext(self, *args)


    def ContextualShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepCheck.Handle_BRepCheck_Vertex_ContextualShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NextShapeInContext(self, *args):
        """NextShapeInContext(Handle_BRepCheck_Vertex self)"""
        return _BRepCheck.Handle_BRepCheck_Vertex_NextShapeInContext(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_BRepCheck_Vertex self)

        Memory deallocator for transient classes


        """
        return _BRepCheck.Handle_BRepCheck_Vertex_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepCheck_Vertex self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepCheck_Vertex self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Vertex_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepCheck_Vertex self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepCheck_Vertex self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Vertex_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepCheck_Vertex self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepCheck.Handle_BRepCheck_Vertex_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepCheck_Vertex self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepCheck.Handle_BRepCheck_Vertex_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepCheck_Vertex self)

        Increments the reference counter of this object


        """
        return _BRepCheck.Handle_BRepCheck_Vertex_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepCheck_Vertex self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepCheck.Handle_BRepCheck_Vertex_DecrementRefCounter(self, *args)

Handle_BRepCheck_Vertex_swigregister = _BRepCheck.Handle_BRepCheck_Vertex_swigregister
Handle_BRepCheck_Vertex_swigregister(Handle_BRepCheck_Vertex)

def Handle_BRepCheck_Vertex_DownCast(thing):
    return _BRepCheck.Handle_BRepCheck_Vertex_DownCast(thing)
Handle_BRepCheck_Vertex_DownCast = _BRepCheck.Handle_BRepCheck_Vertex_DownCast

class Handle_BRepCheck_Solid(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepCheck_Solid self)

        Nullify the handle


        """
        return _BRepCheck.Handle_BRepCheck_Solid_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepCheck_Solid self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepCheck.Handle_BRepCheck_Solid_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepCheck_Solid self, BRepCheck_Solid thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepCheck.Handle_BRepCheck_Solid_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepCheck_Solid self, Handle_BRepCheck_Solid theHandle) -> Handle_BRepCheck_Solid
        assign(Handle_BRepCheck_Solid self, BRepCheck_Solid thePtr) -> Handle_BRepCheck_Solid
        assign(Handle_BRepCheck_Solid self, Handle_BRepCheck_Solid theHandle) -> Handle_BRepCheck_Solid

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepCheck.Handle_BRepCheck_Solid_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepCheck_Solid self) -> BRepCheck_Solid

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepCheck.Handle_BRepCheck_Solid_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepCheck_Solid self) -> BRepCheck_Solid

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepCheck.Handle_BRepCheck_Solid___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepCheck_Solid self) -> BRepCheck_Solid

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepCheck.Handle_BRepCheck_Solid___ref__(self, *args)


    def __hash__(self):
        return _BRepCheck.Handle_BRepCheck_Solid___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepCheck.Handle_BRepCheck_Solid___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepCheck.new_Handle_BRepCheck_Solid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepCheck.Handle_BRepCheck_Solid_DownCast)
    __swig_destroy__ = _BRepCheck.delete_Handle_BRepCheck_Solid

    def InContext(self, *args):
        """
        InContext(Handle_BRepCheck_Solid self, TopoDS_Shape theContextShape)

        Checks the solid in context of
        the shape <theContextShape>

        :type theContextShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepCheck.Handle_BRepCheck_Solid_InContext(self, *args)


    def Minimum(self, *args):
        """
        Minimum(Handle_BRepCheck_Solid self)

        Checks the solid per se.

        The scan area is:
        1.  Shells that overlaps each other
        Status:  BRepCheck_InvalidImbricationOfShells

        2.  Detached parts of the solid (vertices, edges)
        that have non-internal orientation
        Status:  BRepCheck_BadOrientationOfSubshape

        3.  For closed, non-internal shells:
        3.1 Shells containing entities  of the solid that
        are outside towards the shells
        Status:  BRepCheck_SubshapeNotInShape

        3.2 Shells that encloses other Shells
        (for non-holes)
        Status:  BRepCheck_EnclosedRegion


        """
        return _BRepCheck.Handle_BRepCheck_Solid_Minimum(self, *args)


    def Blind(self, *args):
        """
        Blind(Handle_BRepCheck_Solid self)

        see the parent class for more details


        """
        return _BRepCheck.Handle_BRepCheck_Solid_Blind(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepCheck_Solid self) -> char const *

        :rtype: const char *

        """
        return _BRepCheck.Handle_BRepCheck_Solid_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepCheck.Handle_BRepCheck_Solid_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepCheck.Handle_BRepCheck_Solid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_BRepCheck_Solid self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepCheck.Handle_BRepCheck_Solid_Init(self, *args)


    def SetFailStatus(self, *args):
        """
        SetFailStatus(Handle_BRepCheck_Solid self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepCheck.Handle_BRepCheck_Solid_SetFailStatus(self, *args)


    def Status(self, *args):
        """
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_ListOfStatus

        """
        res = _BRepCheck.Handle_BRepCheck_Solid_Status(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsMinimum(self, *args):
        """
        IsMinimum(Handle_BRepCheck_Solid self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Solid_IsMinimum(self, *args)


    def IsBlind(self, *args):
        """
        IsBlind(Handle_BRepCheck_Solid self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Solid_IsBlind(self, *args)


    def StatusOnShape(self, *args):
        """
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_ListOfStatus

        """
        res = _BRepCheck.Handle_BRepCheck_Solid_StatusOnShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InitContextIterator(self, *args):
        """InitContextIterator(Handle_BRepCheck_Solid self)"""
        return _BRepCheck.Handle_BRepCheck_Solid_InitContextIterator(self, *args)


    def MoreShapeInContext(self, *args):
        """
        MoreShapeInContext(Handle_BRepCheck_Solid self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Solid_MoreShapeInContext(self, *args)


    def ContextualShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepCheck.Handle_BRepCheck_Solid_ContextualShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NextShapeInContext(self, *args):
        """NextShapeInContext(Handle_BRepCheck_Solid self)"""
        return _BRepCheck.Handle_BRepCheck_Solid_NextShapeInContext(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_BRepCheck_Solid self)

        Memory deallocator for transient classes


        """
        return _BRepCheck.Handle_BRepCheck_Solid_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepCheck_Solid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepCheck_Solid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Solid_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepCheck_Solid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepCheck_Solid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Solid_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepCheck_Solid self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepCheck.Handle_BRepCheck_Solid_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepCheck_Solid self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepCheck.Handle_BRepCheck_Solid_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepCheck_Solid self)

        Increments the reference counter of this object


        """
        return _BRepCheck.Handle_BRepCheck_Solid_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepCheck_Solid self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepCheck.Handle_BRepCheck_Solid_DecrementRefCounter(self, *args)

Handle_BRepCheck_Solid_swigregister = _BRepCheck.Handle_BRepCheck_Solid_swigregister
Handle_BRepCheck_Solid_swigregister(Handle_BRepCheck_Solid)

def Handle_BRepCheck_Solid_DownCast(thing):
    return _BRepCheck.Handle_BRepCheck_Solid_DownCast(thing)
Handle_BRepCheck_Solid_DownCast = _BRepCheck.Handle_BRepCheck_Solid_DownCast

class BRepCheck_Edge(BRepCheck_Result):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepCheck_Edge
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepCheck_Edge(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRepCheck_Edge self, TopoDS_Edge E) -> BRepCheck_Edge

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        this = _BRepCheck.new_BRepCheck_Edge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def InContext(self, *args):
        """
        InContext(BRepCheck_Edge self, TopoDS_Shape ContextShape)

        :type ContextShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepCheck.BRepCheck_Edge_InContext(self, *args)


    def Minimum(self, *args):
        """Minimum(BRepCheck_Edge self)"""
        return _BRepCheck.BRepCheck_Edge_Minimum(self, *args)


    def Blind(self, *args):
        """Blind(BRepCheck_Edge self)"""
        return _BRepCheck.BRepCheck_Edge_Blind(self, *args)


    def GeometricControls(self, *args):
        """
        GeometricControls(BRepCheck_Edge self) -> Standard_Boolean
        GeometricControls(BRepCheck_Edge self, Standard_Boolean const B)

        :type B: bool

        """
        return _BRepCheck.BRepCheck_Edge_GeometricControls(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(BRepCheck_Edge self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepCheck.BRepCheck_Edge_Tolerance(self, *args)


    def SetStatus(self, *args):
        """
        SetStatus(BRepCheck_Edge self, BRepCheck_Status const theStatus)

        Sets status of Edge;

        :type theStatus: OCC.wrapper.BRepCheck.BRepCheck_Status

        """
        return _BRepCheck.BRepCheck_Edge_SetStatus(self, *args)


    def CheckPolygonOnTriangulation(self, *args):
        """
        CheckPolygonOnTriangulation(BRepCheck_Edge self, TopoDS_Edge theEdge) -> BRepCheck_Status

        Checks, if polygon on triangulation of heEdge
        is out of 3D-curve of this edge.

        :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_Status

        """
        return _BRepCheck.BRepCheck_Edge_CheckPolygonOnTriangulation(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepCheck.BRepCheck_Edge_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepCheck.BRepCheck_Edge_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepCheck.BRepCheck_Edge_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepCheck.delete_BRepCheck_Edge
BRepCheck_Edge_swigregister = _BRepCheck.BRepCheck_Edge_swigregister
BRepCheck_Edge_swigregister(BRepCheck_Edge)

def BRepCheck_Edge_get_type_name(*args):
    """
    BRepCheck_Edge_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepCheck.BRepCheck_Edge_get_type_name(*args)

def BRepCheck_Edge_get_type_descriptor(*args):
    """
    BRepCheck_Edge_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepCheck.BRepCheck_Edge_get_type_descriptor(*args)

class Handle_BRepCheck_Edge(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepCheck_Edge self)

        Nullify the handle


        """
        return _BRepCheck.Handle_BRepCheck_Edge_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepCheck_Edge self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepCheck.Handle_BRepCheck_Edge_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepCheck_Edge self, BRepCheck_Edge thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepCheck.Handle_BRepCheck_Edge_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepCheck_Edge self, Handle_BRepCheck_Edge theHandle) -> Handle_BRepCheck_Edge
        assign(Handle_BRepCheck_Edge self, BRepCheck_Edge thePtr) -> Handle_BRepCheck_Edge
        assign(Handle_BRepCheck_Edge self, Handle_BRepCheck_Edge theHandle) -> Handle_BRepCheck_Edge

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepCheck.Handle_BRepCheck_Edge_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepCheck_Edge self) -> BRepCheck_Edge

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepCheck.Handle_BRepCheck_Edge_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepCheck_Edge self) -> BRepCheck_Edge

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepCheck.Handle_BRepCheck_Edge___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepCheck_Edge self) -> BRepCheck_Edge

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepCheck.Handle_BRepCheck_Edge___ref__(self, *args)


    def __hash__(self):
        return _BRepCheck.Handle_BRepCheck_Edge___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepCheck.Handle_BRepCheck_Edge___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepCheck.new_Handle_BRepCheck_Edge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepCheck.Handle_BRepCheck_Edge_DownCast)
    __swig_destroy__ = _BRepCheck.delete_Handle_BRepCheck_Edge

    def InContext(self, *args):
        """
        InContext(Handle_BRepCheck_Edge self, TopoDS_Shape ContextShape)

        :type ContextShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepCheck.Handle_BRepCheck_Edge_InContext(self, *args)


    def Minimum(self, *args):
        """Minimum(Handle_BRepCheck_Edge self)"""
        return _BRepCheck.Handle_BRepCheck_Edge_Minimum(self, *args)


    def Blind(self, *args):
        """Blind(Handle_BRepCheck_Edge self)"""
        return _BRepCheck.Handle_BRepCheck_Edge_Blind(self, *args)


    def GeometricControls(self, *args):
        """
        GeometricControls(Handle_BRepCheck_Edge self) -> Standard_Boolean
        GeometricControls(Handle_BRepCheck_Edge self, Standard_Boolean const B)

        :type B: bool

        """
        return _BRepCheck.Handle_BRepCheck_Edge_GeometricControls(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(Handle_BRepCheck_Edge self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepCheck.Handle_BRepCheck_Edge_Tolerance(self, *args)


    def SetStatus(self, *args):
        """
        SetStatus(Handle_BRepCheck_Edge self, BRepCheck_Status const theStatus)

        Sets status of Edge;

        :type theStatus: OCC.wrapper.BRepCheck.BRepCheck_Status

        """
        return _BRepCheck.Handle_BRepCheck_Edge_SetStatus(self, *args)


    def CheckPolygonOnTriangulation(self, *args):
        """
        CheckPolygonOnTriangulation(Handle_BRepCheck_Edge self, TopoDS_Edge theEdge) -> BRepCheck_Status

        Checks, if polygon on triangulation of heEdge
        is out of 3D-curve of this edge.

        :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_Status

        """
        return _BRepCheck.Handle_BRepCheck_Edge_CheckPolygonOnTriangulation(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepCheck_Edge self) -> char const *

        :rtype: const char *

        """
        return _BRepCheck.Handle_BRepCheck_Edge_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepCheck.Handle_BRepCheck_Edge_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepCheck.Handle_BRepCheck_Edge_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_BRepCheck_Edge self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepCheck.Handle_BRepCheck_Edge_Init(self, *args)


    def SetFailStatus(self, *args):
        """
        SetFailStatus(Handle_BRepCheck_Edge self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepCheck.Handle_BRepCheck_Edge_SetFailStatus(self, *args)


    def Status(self, *args):
        """
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_ListOfStatus

        """
        res = _BRepCheck.Handle_BRepCheck_Edge_Status(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsMinimum(self, *args):
        """
        IsMinimum(Handle_BRepCheck_Edge self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Edge_IsMinimum(self, *args)


    def IsBlind(self, *args):
        """
        IsBlind(Handle_BRepCheck_Edge self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Edge_IsBlind(self, *args)


    def StatusOnShape(self, *args):
        """
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_ListOfStatus

        """
        res = _BRepCheck.Handle_BRepCheck_Edge_StatusOnShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InitContextIterator(self, *args):
        """InitContextIterator(Handle_BRepCheck_Edge self)"""
        return _BRepCheck.Handle_BRepCheck_Edge_InitContextIterator(self, *args)


    def MoreShapeInContext(self, *args):
        """
        MoreShapeInContext(Handle_BRepCheck_Edge self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Edge_MoreShapeInContext(self, *args)


    def ContextualShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepCheck.Handle_BRepCheck_Edge_ContextualShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NextShapeInContext(self, *args):
        """NextShapeInContext(Handle_BRepCheck_Edge self)"""
        return _BRepCheck.Handle_BRepCheck_Edge_NextShapeInContext(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_BRepCheck_Edge self)

        Memory deallocator for transient classes


        """
        return _BRepCheck.Handle_BRepCheck_Edge_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepCheck_Edge self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepCheck_Edge self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Edge_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepCheck_Edge self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepCheck_Edge self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Edge_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepCheck_Edge self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepCheck.Handle_BRepCheck_Edge_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepCheck_Edge self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepCheck.Handle_BRepCheck_Edge_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepCheck_Edge self)

        Increments the reference counter of this object


        """
        return _BRepCheck.Handle_BRepCheck_Edge_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepCheck_Edge self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepCheck.Handle_BRepCheck_Edge_DecrementRefCounter(self, *args)

Handle_BRepCheck_Edge_swigregister = _BRepCheck.Handle_BRepCheck_Edge_swigregister
Handle_BRepCheck_Edge_swigregister(Handle_BRepCheck_Edge)

def Handle_BRepCheck_Edge_DownCast(thing):
    return _BRepCheck.Handle_BRepCheck_Edge_DownCast(thing)
Handle_BRepCheck_Edge_DownCast = _BRepCheck.Handle_BRepCheck_Edge_DownCast

class Handle_BRepCheck_Wire(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepCheck_Wire self)

        Nullify the handle


        """
        return _BRepCheck.Handle_BRepCheck_Wire_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepCheck_Wire self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepCheck.Handle_BRepCheck_Wire_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepCheck_Wire self, BRepCheck_Wire thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepCheck.Handle_BRepCheck_Wire_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepCheck_Wire self, Handle_BRepCheck_Wire theHandle) -> Handle_BRepCheck_Wire
        assign(Handle_BRepCheck_Wire self, BRepCheck_Wire thePtr) -> Handle_BRepCheck_Wire
        assign(Handle_BRepCheck_Wire self, Handle_BRepCheck_Wire theHandle) -> Handle_BRepCheck_Wire

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepCheck.Handle_BRepCheck_Wire_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepCheck_Wire self) -> BRepCheck_Wire

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepCheck.Handle_BRepCheck_Wire_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepCheck_Wire self) -> BRepCheck_Wire

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepCheck.Handle_BRepCheck_Wire___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepCheck_Wire self) -> BRepCheck_Wire

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepCheck.Handle_BRepCheck_Wire___ref__(self, *args)


    def __hash__(self):
        return _BRepCheck.Handle_BRepCheck_Wire___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepCheck.Handle_BRepCheck_Wire___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepCheck.new_Handle_BRepCheck_Wire(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepCheck.Handle_BRepCheck_Wire_DownCast)
    __swig_destroy__ = _BRepCheck.delete_Handle_BRepCheck_Wire

    def InContext(self, *args):
        """
        InContext(Handle_BRepCheck_Wire self, TopoDS_Shape ContextShape)

        if <ContextShape> is  a  face, consequently checks
        SelfIntersect(),   Closed(),   Orientation()   and
        Closed2d until faulty is found

        :type ContextShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepCheck.Handle_BRepCheck_Wire_InContext(self, *args)


    def Minimum(self, *args):
        """
        Minimum(Handle_BRepCheck_Wire self)

        checks that the  wire  is  not empty and "connex".
        Called by constructor


        """
        return _BRepCheck.Handle_BRepCheck_Wire_Minimum(self, *args)


    def Blind(self, *args):
        """
        Blind(Handle_BRepCheck_Wire self)

        Does nothing


        """
        return _BRepCheck.Handle_BRepCheck_Wire_Blind(self, *args)


    def Closed(self, *args):
        """
        Closed(Handle_BRepCheck_Wire self, Standard_Boolean const Update) -> BRepCheck_Status

        Checks if the  oriented  edges of the wire  give a
        closed  wire.   If the  wire   is closed,  returns
        BRepCheck_NoError.    Warning :  if the first  and
        last  edge   are  infinite,   the  wire   will  be
        considered as a closed one.  If <Update> is set to
        Standard_True, registers the status in the list.
        May return (and registers):
        **BRepCheck_NotConnected,   if    wire    is   not
        topologically closed
        **BRepCheck_RedundantEdge, if an  edge  is in wire
        more than 3 times  or  in  case of 2 occurences if
        not with FORWARD and REVERSED orientation.
        **BRepCheck_NoError

        :type Update: bool
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_Status

        """
        return _BRepCheck.Handle_BRepCheck_Wire_Closed(self, *args)


    def Closed2d(self, *args):
        """
        Closed2d(Handle_BRepCheck_Wire self, TopoDS_Face F, Standard_Boolean const Update) -> BRepCheck_Status

        Checks if edges of the  wire give a wire closed in
        2d space.
        Returns BRepCheck_NoError,  or BRepCheck_NotClosed
        If <Update> is set to Standard_True, registers the
        status in the list.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type Update: bool
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_Status

        """
        return _BRepCheck.Handle_BRepCheck_Wire_Closed2d(self, *args)


    def Orientation(self, *args):
        """
        Orientation(Handle_BRepCheck_Wire self, TopoDS_Face F, Standard_Boolean const Update) -> BRepCheck_Status

        Checks   if  the oriented edges   of  the wire are
        correctly oriented.  An  internal call is made  to
        the  method Closed.   If no face  exists, call the
        method with   a  null  face  (TopoDS_face()).   If
        <Update> is  set  to Standard_True,  registers the
        status in the list.
        May return (and registers):
        BRepCheck_InvalidDegeneratedFlag,
        BRepCheck_BadOrientationOfSubshape,
        BRepCheck_NotClosed,
        BRepCheck_NoError

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type Update: bool
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_Status

        """
        return _BRepCheck.Handle_BRepCheck_Wire_Orientation(self, *args)


    def SelfIntersect(self, *args):
        """
        SelfIntersect(Handle_BRepCheck_Wire self, TopoDS_Face F, TopoDS_Edge E1, TopoDS_Edge E2, Standard_Boolean const Update) -> BRepCheck_Status

        Checks if  the wire intersect   itself on the face
        <F>.  <E1>  and <E2>   are the first  intersecting
        edges  found.  <E2>  may  be a  null  edge when  a
        self-intersecting edge is found.If <Update> is set
        to Standard_True,   registers  the  status in  the
        list.
        May return (and register):
        BRepCheck_EmptyWire,
        BRepCheck_SelfIntersectingWire,
        BRepCheck_NoCurveOnSurface,
        BRepCheck_NoError

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type E1: OCC.wrapper.TopoDS.TopoDS_Edge
        :type E2: OCC.wrapper.TopoDS.TopoDS_Edge
        :type Update: bool
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_Status

        """
        return _BRepCheck.Handle_BRepCheck_Wire_SelfIntersect(self, *args)


    def GeometricControls(self, *args):
        """
        GeometricControls(Handle_BRepCheck_Wire self) -> Standard_Boolean
        GeometricControls(Handle_BRepCheck_Wire self, Standard_Boolean const B)

        set SelfIntersect() to be checked

        :type B: bool

        """
        return _BRepCheck.Handle_BRepCheck_Wire_GeometricControls(self, *args)


    def SetStatus(self, *args):
        """
        SetStatus(Handle_BRepCheck_Wire self, BRepCheck_Status const theStatus)

        Sets status of Wire;

        :type theStatus: OCC.wrapper.BRepCheck.BRepCheck_Status

        """
        return _BRepCheck.Handle_BRepCheck_Wire_SetStatus(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepCheck_Wire self) -> char const *

        :rtype: const char *

        """
        return _BRepCheck.Handle_BRepCheck_Wire_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepCheck.Handle_BRepCheck_Wire_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepCheck.Handle_BRepCheck_Wire_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_BRepCheck_Wire self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepCheck.Handle_BRepCheck_Wire_Init(self, *args)


    def SetFailStatus(self, *args):
        """
        SetFailStatus(Handle_BRepCheck_Wire self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepCheck.Handle_BRepCheck_Wire_SetFailStatus(self, *args)


    def Status(self, *args):
        """
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_ListOfStatus

        """
        res = _BRepCheck.Handle_BRepCheck_Wire_Status(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsMinimum(self, *args):
        """
        IsMinimum(Handle_BRepCheck_Wire self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Wire_IsMinimum(self, *args)


    def IsBlind(self, *args):
        """
        IsBlind(Handle_BRepCheck_Wire self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Wire_IsBlind(self, *args)


    def StatusOnShape(self, *args):
        """
        :rtype: OCC.wrapper.BRepCheck.BRepCheck_ListOfStatus

        """
        res = _BRepCheck.Handle_BRepCheck_Wire_StatusOnShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InitContextIterator(self, *args):
        """InitContextIterator(Handle_BRepCheck_Wire self)"""
        return _BRepCheck.Handle_BRepCheck_Wire_InitContextIterator(self, *args)


    def MoreShapeInContext(self, *args):
        """
        MoreShapeInContext(Handle_BRepCheck_Wire self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Wire_MoreShapeInContext(self, *args)


    def ContextualShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepCheck.Handle_BRepCheck_Wire_ContextualShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NextShapeInContext(self, *args):
        """NextShapeInContext(Handle_BRepCheck_Wire self)"""
        return _BRepCheck.Handle_BRepCheck_Wire_NextShapeInContext(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_BRepCheck_Wire self)

        Memory deallocator for transient classes


        """
        return _BRepCheck.Handle_BRepCheck_Wire_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepCheck_Wire self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepCheck_Wire self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Wire_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepCheck_Wire self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepCheck_Wire self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepCheck.Handle_BRepCheck_Wire_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepCheck_Wire self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepCheck.Handle_BRepCheck_Wire_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepCheck_Wire self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepCheck.Handle_BRepCheck_Wire_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepCheck_Wire self)

        Increments the reference counter of this object


        """
        return _BRepCheck.Handle_BRepCheck_Wire_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepCheck_Wire self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepCheck.Handle_BRepCheck_Wire_DecrementRefCounter(self, *args)

Handle_BRepCheck_Wire_swigregister = _BRepCheck.Handle_BRepCheck_Wire_swigregister
Handle_BRepCheck_Wire_swigregister(Handle_BRepCheck_Wire)

def Handle_BRepCheck_Wire_DownCast(thing):
    return _BRepCheck.Handle_BRepCheck_Wire_DownCast(thing)
Handle_BRepCheck_Wire_DownCast = _BRepCheck.Handle_BRepCheck_Wire_DownCast




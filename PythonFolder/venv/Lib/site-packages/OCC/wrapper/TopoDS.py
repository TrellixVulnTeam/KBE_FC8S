# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_TopoDS')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_TopoDS')
    _TopoDS = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_TopoDS', [dirname(__file__)])
        except ImportError:
            import _TopoDS
            return _TopoDS
        try:
            _mod = imp.load_module('_TopoDS', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _TopoDS = swig_import_helper()
    del swig_import_helper
else:
    import _TopoDS
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _TopoDS.delete_SwigPyIterator

    def value(self):
        return _TopoDS.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _TopoDS.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _TopoDS.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _TopoDS.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _TopoDS.SwigPyIterator_equal(self, x)

    def copy(self):
        return _TopoDS.SwigPyIterator_copy(self)

    def next(self):
        return _TopoDS.SwigPyIterator_next(self)

    def __next__(self):
        return _TopoDS.SwigPyIterator___next__(self)

    def previous(self):
        return _TopoDS.SwigPyIterator_previous(self)

    def advance(self, n):
        return _TopoDS.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _TopoDS.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _TopoDS.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _TopoDS.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _TopoDS.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _TopoDS.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _TopoDS.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _TopoDS.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _TopoDS.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_TopoDS.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _TopoDS.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _TopoDS.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopoDS.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _TopoDS.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _TopoDS.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _TopoDS.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _TopoDS.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_TopoDS.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _TopoDS.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _TopoDS.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopoDS.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _TopoDS.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _TopoDS.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _TopoDS.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _TopoDS.ptr_to_number(item)
ptr_to_number = _TopoDS.ptr_to_number

def HashCode(*args):
    return _TopoDS.HashCode(*args)
HashCode = _TopoDS.HashCode

def ptr_equal(a, b):
    return _TopoDS.ptr_equal(a, b)
ptr_equal = _TopoDS.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
class TopoDS_TShape(Standard.Standard_Transient):
    """
    A TShape  is a topological  structure describing a
    set of points in a 2D or 3D space.

    A topological shape is a structure made from other
    shapes.  This is a deferred class  used to support
    topological objects.

    TShapes are   defined   by  their  optional domain
    (geometry)  and  their  components  (other TShapes
    with  Locations and Orientations).  The components
    are stored in a List of Shapes.

    A   TShape contains  the   following boolean flags :

    - Free       : Free or Frozen.
    - Modified   : Has been modified.
    - Checked    : Has been checked.
    - Orientable : Can be oriented.
    - Closed     : Is closed (note that only Wires and Shells may be closed).
    - Infinite   : Is infinite.
    - Convex     : Is convex.

    Users have no direct access to the classes derived
    from TShape.  They  handle them with   the classes
    derived from Shape.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopoDS_TShape
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopoDS_TShape(self) 
            return h


    def Free(self, *args):
        """
        Free(TopoDS_TShape self) -> Standard_Boolean
        Free(TopoDS_TShape self, Standard_Boolean const F)

        Sets the free flag.

        :type F: bool

        """
        return _TopoDS.TopoDS_TShape_Free(self, *args)


    def Locked(self, *args):
        """
        Locked(TopoDS_TShape self) -> Standard_Boolean
        Locked(TopoDS_TShape self, Standard_Boolean const F)

        Sets the locked flag.

        :type F: bool

        """
        return _TopoDS.TopoDS_TShape_Locked(self, *args)


    def Modified(self, *args):
        """
        Modified(TopoDS_TShape self) -> Standard_Boolean
        Modified(TopoDS_TShape self, Standard_Boolean const M)

        Sets the modification flag.

        :type M: bool

        """
        return _TopoDS.TopoDS_TShape_Modified(self, *args)


    def Checked(self, *args):
        """
        Checked(TopoDS_TShape self) -> Standard_Boolean
        Checked(TopoDS_TShape self, Standard_Boolean const C)

        Sets the checked flag.

        :type C: bool

        """
        return _TopoDS.TopoDS_TShape_Checked(self, *args)


    def Orientable(self, *args):
        """
        Orientable(TopoDS_TShape self) -> Standard_Boolean
        Orientable(TopoDS_TShape self, Standard_Boolean const C)

        Sets the orientability flag.

        :type C: bool

        """
        return _TopoDS.TopoDS_TShape_Orientable(self, *args)


    def Closed(self, *args):
        """
        Closed(TopoDS_TShape self) -> Standard_Boolean
        Closed(TopoDS_TShape self, Standard_Boolean const C)

        Sets the closedness flag.

        :type C: bool

        """
        return _TopoDS.TopoDS_TShape_Closed(self, *args)


    def Infinite(self, *args):
        """
        Infinite(TopoDS_TShape self) -> Standard_Boolean
        Infinite(TopoDS_TShape self, Standard_Boolean const C)

        Sets the infinity flag.

        :type C: bool

        """
        return _TopoDS.TopoDS_TShape_Infinite(self, *args)


    def Convex(self, *args):
        """
        Convex(TopoDS_TShape self) -> Standard_Boolean
        Convex(TopoDS_TShape self, Standard_Boolean const C)

        Sets the convexness flag.

        :type C: bool

        """
        return _TopoDS.TopoDS_TShape_Convex(self, *args)


    def ShapeType(self, *args):
        """
        ShapeType(TopoDS_TShape self) -> TopAbs_ShapeEnum

        Returns the type as a term of the ShapeEnum enum :
        VERTEX, EDGE, WIRE, FACE, ....

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopoDS.TopoDS_TShape_ShapeType(self, *args)


    def EmptyCopy(self, *args):
        """
        EmptyCopy(TopoDS_TShape self) -> Handle_TopoDS_TShape

        Returns a copy  of the  TShape  with no sub-shapes.

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        return _TopoDS.TopoDS_TShape_EmptyCopy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopoDS.TopoDS_TShape_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopoDS.TopoDS_TShape_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.TopoDS_TShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopoDS.delete_TopoDS_TShape
TopoDS_TShape_swigregister = _TopoDS.TopoDS_TShape_swigregister
TopoDS_TShape_swigregister(TopoDS_TShape)

def TopoDS_TShape_get_type_name(*args):
    """
    TopoDS_TShape_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopoDS.TopoDS_TShape_get_type_name(*args)

def TopoDS_TShape_get_type_descriptor(*args):
    """
    TopoDS_TShape_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopoDS.TopoDS_TShape_get_type_descriptor(*args)

class TopoDS_TVertex(TopoDS_TShape):
    """
    A  Vertex is a topological  point in  two or three
    dimensions.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopoDS_TVertex
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopoDS_TVertex(self) 
            return h


    def ShapeType(self, *args):
        """
        ShapeType(TopoDS_TVertex self) -> TopAbs_ShapeEnum

        Returns VERTEX.

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopoDS.TopoDS_TVertex_ShapeType(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopoDS.TopoDS_TVertex_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopoDS.TopoDS_TVertex_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.TopoDS_TVertex_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopoDS.delete_TopoDS_TVertex
TopoDS_TVertex_swigregister = _TopoDS.TopoDS_TVertex_swigregister
TopoDS_TVertex_swigregister(TopoDS_TVertex)

def TopoDS_TVertex_get_type_name(*args):
    """
    TopoDS_TVertex_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopoDS.TopoDS_TVertex_get_type_name(*args)

def TopoDS_TVertex_get_type_descriptor(*args):
    """
    TopoDS_TVertex_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopoDS.TopoDS_TVertex_get_type_descriptor(*args)

class TopoDS_Shape(object):
    """
    Describes a shape which
    - references an underlying shape with the potential
    to be given a location and an orientation
    - has a location for the underlying shape, giving its
    placement in the local coordinate system
    - has an orientation for the underlying shape, in
    terms of its geometry (as opposed to orientation in
    relation to other shapes).
    Note: A Shape is empty if it references an underlying
    shape which has an empty list of shapes.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopoDS_Shape self) -> TopoDS_Shape

        Creates a NULL Shape referring to nothing.


        """
        this = _TopoDS.new_TopoDS_Shape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsNull(self, *args):
        """
        IsNull(TopoDS_Shape self) -> Standard_Boolean

        Returns true if this shape is null. In other words, it
        references no underlying shape with the potential to
        be given a location and an orientation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.TopoDS_Shape_IsNull(self, *args)


    def Nullify(self, *args):
        """
        Nullify(TopoDS_Shape self)

        Destroys the reference to the underlying shape
        stored in this shape. As a result, this shape becomes null.


        """
        return _TopoDS.TopoDS_Shape_Nullify(self, *args)


    def Location(self, *args):
        """
        Returns the shape local coordinate system.

        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _TopoDS.TopoDS_Shape_Location(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Located(self, *args):
        """
        Located(TopoDS_Shape self, TopLoc_Location Loc) -> TopoDS_Shape

        Returns a  shape  similar to <me> with   the local
        coordinate system set to <Loc>.

        :type Loc: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopoDS.TopoDS_Shape_Located(self, *args)


    def Orientation(self, *args):
        """
        Orientation(TopoDS_Shape self) -> TopAbs_Orientation
        Orientation(TopoDS_Shape self, TopAbs_Orientation const Orient)

        Sets the shape orientation.

        :type Orient: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _TopoDS.TopoDS_Shape_Orientation(self, *args)


    def Oriented(self, *args):
        """
        Oriented(TopoDS_Shape self, TopAbs_Orientation const Or) -> TopoDS_Shape

        Returns  a    shape  similar  to  <me>   with  the
        orientation set to <Or>.

        :type Or: OCC.wrapper.TopAbs.TopAbs_Orientation
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopoDS.TopoDS_Shape_Oriented(self, *args)


    def ShapeType(self, *args):
        """
        ShapeType(TopoDS_Shape self) -> TopAbs_ShapeEnum

        Returns the value of the TopAbs_ShapeEnum
        enumeration that corresponds to this shape, for
        example VERTEX, EDGE, and so on.
        Exceptions
        Standard_NullObject if this shape is null.

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopoDS.TopoDS_Shape_ShapeType(self, *args)


    def Free(self, *args):
        """
        Free(TopoDS_Shape self) -> Standard_Boolean
        Free(TopoDS_Shape self, Standard_Boolean const F)

        Sets the free flag.

        :type F: bool

        """
        return _TopoDS.TopoDS_Shape_Free(self, *args)


    def Locked(self, *args):
        """
        Locked(TopoDS_Shape self) -> Standard_Boolean
        Locked(TopoDS_Shape self, Standard_Boolean const F)

        Sets the locked flag.

        :type F: bool

        """
        return _TopoDS.TopoDS_Shape_Locked(self, *args)


    def Modified(self, *args):
        """
        Modified(TopoDS_Shape self) -> Standard_Boolean
        Modified(TopoDS_Shape self, Standard_Boolean const M)

        Sets the modification flag.

        :type M: bool

        """
        return _TopoDS.TopoDS_Shape_Modified(self, *args)


    def Checked(self, *args):
        """
        Checked(TopoDS_Shape self) -> Standard_Boolean
        Checked(TopoDS_Shape self, Standard_Boolean const C)

        Sets the checked flag.

        :type C: bool

        """
        return _TopoDS.TopoDS_Shape_Checked(self, *args)


    def Orientable(self, *args):
        """
        Orientable(TopoDS_Shape self) -> Standard_Boolean
        Orientable(TopoDS_Shape self, Standard_Boolean const C)

        Sets the orientability flag.

        :type C: bool

        """
        return _TopoDS.TopoDS_Shape_Orientable(self, *args)


    def Closed(self, *args):
        """
        Closed(TopoDS_Shape self) -> Standard_Boolean
        Closed(TopoDS_Shape self, Standard_Boolean const C)

        Sets the closedness flag.

        :type C: bool

        """
        return _TopoDS.TopoDS_Shape_Closed(self, *args)


    def Infinite(self, *args):
        """
        Infinite(TopoDS_Shape self) -> Standard_Boolean
        Infinite(TopoDS_Shape self, Standard_Boolean const C)

        Sets the infinity flag.

        :type C: bool

        """
        return _TopoDS.TopoDS_Shape_Infinite(self, *args)


    def Convex(self, *args):
        """
        Convex(TopoDS_Shape self) -> Standard_Boolean
        Convex(TopoDS_Shape self, Standard_Boolean const C)

        Sets the convexness flag.

        :type C: bool

        """
        return _TopoDS.TopoDS_Shape_Convex(self, *args)


    def Move(self, *args):
        """
        Move(TopoDS_Shape self, TopLoc_Location position)

        Multiplies the Shape location by <position>.

        :type position: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _TopoDS.TopoDS_Shape_Move(self, *args)


    def Moved(self, *args):
        """
        Moved(TopoDS_Shape self, TopLoc_Location position) -> TopoDS_Shape

        Returns  a shape similar  to  <me> with a location
        multiplied  by <position>.

        :type position: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopoDS.TopoDS_Shape_Moved(self, *args)


    def Reverse(self, *args):
        """
        Reverse(TopoDS_Shape self)

        Reverses the orientation, using the Reverse method
        from the TopAbs package.


        """
        return _TopoDS.TopoDS_Shape_Reverse(self, *args)


    def Reversed(self, *args):
        """
        Reversed(TopoDS_Shape self) -> TopoDS_Shape

        Returns    a shape  similar    to  <me>  with  the
        orientation  reversed, using  the   Reverse method
        from the TopAbs package.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopoDS.TopoDS_Shape_Reversed(self, *args)


    def Complement(self, *args):
        """
        Complement(TopoDS_Shape self)

        Complements the orientation, using the  Complement
        method from the TopAbs package.


        """
        return _TopoDS.TopoDS_Shape_Complement(self, *args)


    def Complemented(self, *args):
        """
        Complemented(TopoDS_Shape self) -> TopoDS_Shape

        Returns  a   shape  similar  to   <me>   with  the
        orientation complemented,  using   the  Complement
        method from the TopAbs package.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopoDS.TopoDS_Shape_Complemented(self, *args)


    def Compose(self, *args):
        """
        Compose(TopoDS_Shape self, TopAbs_Orientation const Orient)

        Updates the  Shape Orientation by composition with
        <Orient>, using the Compose method from the TopAbs
        package.

        :type Orient: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _TopoDS.TopoDS_Shape_Compose(self, *args)


    def Composed(self, *args):
        """
        Composed(TopoDS_Shape self, TopAbs_Orientation const Orient) -> TopoDS_Shape

        Returns  a  shape   similar   to  <me>   with  the
        orientation  composed  with <Orient>,   using  the
        Compose method from the TopAbs package.

        :type Orient: OCC.wrapper.TopAbs.TopAbs_Orientation
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopoDS.TopoDS_Shape_Composed(self, *args)


    def IsPartner(self, *args):
        """
        IsPartner(TopoDS_Shape self, TopoDS_Shape other) -> Standard_Boolean

        Returns True if two shapes  are partners, i.e.  if
        they   share   the   same  TShape.  Locations  and
        Orientations may differ.

        :type other: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.TopoDS_Shape_IsPartner(self, *args)


    def IsSame(self, *args):
        """
        IsSame(TopoDS_Shape self, TopoDS_Shape other) -> Standard_Boolean

        Returns True if two shapes are same, i.e.  if they
        share  the  same TShape  with the same  Locations.
        Orientations may differ.

        :type other: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.TopoDS_Shape_IsSame(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(TopoDS_Shape self, TopoDS_Shape other) -> Standard_Boolean

        Returns True if two shapes are equal, i.e. if they
        share the same TShape with  the same Locations and
        Orientations.

        :type other: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.TopoDS_Shape_IsEqual(self, *args)


    def __eq__(self, other):
        """__eq__(TopoDS_Shape self, TopoDS_Shape other) -> Standard_Boolean

        :type other: OCC.TopoDS.TopoDS_Shape
        :rtype: OCC.Standard.Standard_Boolean
        """
        if isinstance(other, TopoDS_Shape):
            return self.IsSame(other)
        else:
            return NotImplemented



    def IsNotEqual(self, *args):
        """
        IsNotEqual(TopoDS_Shape self, TopoDS_Shape other) -> Standard_Boolean

        Negation of the IsEqual method.

        :type other: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.TopoDS_Shape_IsNotEqual(self, *args)


    def __ne__(self, *args):
        """
        __ne__(TopoDS_Shape self, TopoDS_Shape other) -> Standard_Boolean

        :type other: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.TopoDS_Shape___ne__(self, *args)


    def HashCode(self, *args):
        """
        HashCode(TopoDS_Shape self, Standard_Integer const Upper) -> Standard_Integer

        Returns a hashed value  denoting <me>.  This value
        is in the range  1..<Upper>.  It is  computed from
        the  TShape  and the  Location. The Orientation is
        not used.

        :type Upper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopoDS.TopoDS_Shape_HashCode(self, *args)


    def __hash__(self, *args):
        """
        __hash__(TopoDS_Shape self) -> Standard_Integer

        Returns the a hashcode based on the HashCode method, suitable for a python __hash__

        :rtype: int
        """
        return _TopoDS.TopoDS_Shape___hash__(self, *args)


    def EmptyCopy(self, *args):
        """
        EmptyCopy(TopoDS_Shape self)

        Replace   <me> by  a  new   Shape with the    same
        Orientation and Location and a new TShape with the
        same geometry and no sub-shapes.


        """
        return _TopoDS.TopoDS_Shape_EmptyCopy(self, *args)


    def EmptyCopied(self, *args):
        """
        EmptyCopied(TopoDS_Shape self) -> TopoDS_Shape

        Returns a new Shape with the  same Orientation and
        Location and  a new TShape  with the same geometry
        and no sub-shapes.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopoDS.TopoDS_Shape_EmptyCopied(self, *args)


    def TShape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        res = _TopoDS.TopoDS_Shape_TShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getstate__(self):
        """
        Return a serialization of this object

        :rtype: (int, str)
        """
        from OCC.wrapper.BinTools import BinTools_ShapeSet
        from io import BytesIO

        bt = BinTools_ShapeSet()
        ss = BytesIO()

        i = bt.Add(self)
        bt.Write(ss)

        return i, ss.getvalue()

    def __setstate__(self, state):
        from OCC.wrapper.BinTools import BinTools_ShapeSet
        from io import BytesIO

        i, ds = state
        bt = BinTools_ShapeSet()
        ss = BytesIO(ds)

        ss.seek(1)  # bug of stringstream, prepends a newline
        bt.Read(ss)
        shape = bt.Shape(i)
        self.this = shape.this
        self.builder = bt  # need to cache it, it maintains the shape


    __swig_destroy__ = _TopoDS.delete_TopoDS_Shape
TopoDS_Shape_swigregister = _TopoDS.TopoDS_Shape_swigregister
TopoDS_Shape_swigregister(TopoDS_Shape)

class TopoDS_UnCompatibleShapes(Standard.Standard_DomainError):
    """An incorrect insertion was attempted."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopoDS_UnCompatibleShapes
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopoDS_UnCompatibleShapes(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TopoDS_UnCompatibleShapes self) -> TopoDS_UnCompatibleShapes
        __init__(TopoDS_UnCompatibleShapes self, Standard_CString const theMessage) -> TopoDS_UnCompatibleShapes

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _TopoDS.new_TopoDS_UnCompatibleShapes(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_TopoDS_UnCompatibleShapes

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_UnCompatibleShapes

        """
        return _TopoDS.TopoDS_UnCompatibleShapes_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopoDS.TopoDS_UnCompatibleShapes_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopoDS.TopoDS_UnCompatibleShapes_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.TopoDS_UnCompatibleShapes_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopoDS.delete_TopoDS_UnCompatibleShapes
TopoDS_UnCompatibleShapes_swigregister = _TopoDS.TopoDS_UnCompatibleShapes_swigregister
TopoDS_UnCompatibleShapes_swigregister(TopoDS_UnCompatibleShapes)

def TopoDS_UnCompatibleShapes_NewInstance(*args):
    """
    TopoDS_UnCompatibleShapes_NewInstance(Standard_CString const theMessage) -> Handle_TopoDS_UnCompatibleShapes

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_UnCompatibleShapes

    """
    return _TopoDS.TopoDS_UnCompatibleShapes_NewInstance(*args)

def TopoDS_UnCompatibleShapes_get_type_name(*args):
    """
    TopoDS_UnCompatibleShapes_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopoDS.TopoDS_UnCompatibleShapes_get_type_name(*args)

def TopoDS_UnCompatibleShapes_get_type_descriptor(*args):
    """
    TopoDS_UnCompatibleShapes_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopoDS.TopoDS_UnCompatibleShapes_get_type_descriptor(*args)

class TopoDS_FrozenShape(Standard.Standard_DomainError):
    """
    An  attempt was  made to   modify  a Shape  already
    shared or protected.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopoDS_FrozenShape
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopoDS_FrozenShape(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TopoDS_FrozenShape self) -> TopoDS_FrozenShape
        __init__(TopoDS_FrozenShape self, Standard_CString const theMessage) -> TopoDS_FrozenShape

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _TopoDS.new_TopoDS_FrozenShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_TopoDS_FrozenShape

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_FrozenShape

        """
        return _TopoDS.TopoDS_FrozenShape_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopoDS.TopoDS_FrozenShape_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopoDS.TopoDS_FrozenShape_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.TopoDS_FrozenShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopoDS.delete_TopoDS_FrozenShape
TopoDS_FrozenShape_swigregister = _TopoDS.TopoDS_FrozenShape_swigregister
TopoDS_FrozenShape_swigregister(TopoDS_FrozenShape)

def TopoDS_FrozenShape_NewInstance(*args):
    """
    TopoDS_FrozenShape_NewInstance(Standard_CString const theMessage) -> Handle_TopoDS_FrozenShape

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_FrozenShape

    """
    return _TopoDS.TopoDS_FrozenShape_NewInstance(*args)

def TopoDS_FrozenShape_get_type_name(*args):
    """
    TopoDS_FrozenShape_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopoDS.TopoDS_FrozenShape_get_type_name(*args)

def TopoDS_FrozenShape_get_type_descriptor(*args):
    """
    TopoDS_FrozenShape_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopoDS.TopoDS_FrozenShape_get_type_descriptor(*args)

class TopoDS_TShell(TopoDS_TShape):
    """A set of faces connected by their edges."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopoDS_TShell
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopoDS_TShell(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TopoDS_TShell self) -> TopoDS_TShell

        Creates an empty TShell.


        """
        this = _TopoDS.new_TopoDS_TShell(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ShapeType(self, *args):
        """
        ShapeType(TopoDS_TShell self) -> TopAbs_ShapeEnum

        Returns SHELL.

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopoDS.TopoDS_TShell_ShapeType(self, *args)


    def EmptyCopy(self, *args):
        """
        EmptyCopy(TopoDS_TShell self) -> Handle_TopoDS_TShape

        Returns an empty TShell.

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        return _TopoDS.TopoDS_TShell_EmptyCopy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopoDS.TopoDS_TShell_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopoDS.TopoDS_TShell_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.TopoDS_TShell_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopoDS.delete_TopoDS_TShell
TopoDS_TShell_swigregister = _TopoDS.TopoDS_TShell_swigregister
TopoDS_TShell_swigregister(TopoDS_TShell)

def TopoDS_TShell_get_type_name(*args):
    """
    TopoDS_TShell_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopoDS.TopoDS_TShell_get_type_name(*args)

def TopoDS_TShell_get_type_descriptor(*args):
    """
    TopoDS_TShell_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopoDS.TopoDS_TShell_get_type_descriptor(*args)

class TopoDS_TWire(TopoDS_TShape):
    """A set of edges connected by their vertices."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopoDS_TWire
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopoDS_TWire(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TopoDS_TWire self) -> TopoDS_TWire

        Creates an empty TWire.


        """
        this = _TopoDS.new_TopoDS_TWire(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ShapeType(self, *args):
        """
        ShapeType(TopoDS_TWire self) -> TopAbs_ShapeEnum

        Returns WIRE.

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopoDS.TopoDS_TWire_ShapeType(self, *args)


    def EmptyCopy(self, *args):
        """
        EmptyCopy(TopoDS_TWire self) -> Handle_TopoDS_TShape

        Returns an empty TWire.

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        return _TopoDS.TopoDS_TWire_EmptyCopy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopoDS.TopoDS_TWire_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopoDS.TopoDS_TWire_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.TopoDS_TWire_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopoDS.delete_TopoDS_TWire
TopoDS_TWire_swigregister = _TopoDS.TopoDS_TWire_swigregister
TopoDS_TWire_swigregister(TopoDS_TWire)

def TopoDS_TWire_get_type_name(*args):
    """
    TopoDS_TWire_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopoDS.TopoDS_TWire_get_type_name(*args)

def TopoDS_TWire_get_type_descriptor(*args):
    """
    TopoDS_TWire_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopoDS.TopoDS_TWire_get_type_descriptor(*args)

class Handle_TopoDS_TVertex(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopoDS_TVertex self)

        Nullify the handle


        """
        return _TopoDS.Handle_TopoDS_TVertex_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopoDS_TVertex self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopoDS.Handle_TopoDS_TVertex_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopoDS_TVertex self, TopoDS_TVertex thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopoDS.Handle_TopoDS_TVertex_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopoDS_TVertex self, Handle_TopoDS_TVertex theHandle) -> Handle_TopoDS_TVertex
        assign(Handle_TopoDS_TVertex self, TopoDS_TVertex thePtr) -> Handle_TopoDS_TVertex
        assign(Handle_TopoDS_TVertex self, Handle_TopoDS_TVertex theHandle) -> Handle_TopoDS_TVertex

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopoDS.Handle_TopoDS_TVertex_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopoDS_TVertex self) -> TopoDS_TVertex

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopoDS.Handle_TopoDS_TVertex_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopoDS_TVertex self) -> TopoDS_TVertex

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopoDS.Handle_TopoDS_TVertex___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopoDS_TVertex self) -> TopoDS_TVertex

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopoDS.Handle_TopoDS_TVertex___ref__(self, *args)


    def __hash__(self):
        return _TopoDS.Handle_TopoDS_TVertex___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopoDS.Handle_TopoDS_TVertex___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopoDS.new_Handle_TopoDS_TVertex(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopoDS.Handle_TopoDS_TVertex_DownCast)
    __swig_destroy__ = _TopoDS.delete_Handle_TopoDS_TVertex

    def ShapeType(self, *args):
        """
        ShapeType(Handle_TopoDS_TVertex self) -> TopAbs_ShapeEnum

        Returns VERTEX.

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopoDS.Handle_TopoDS_TVertex_ShapeType(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopoDS_TVertex self) -> char const *

        :rtype: const char *

        """
        return _TopoDS.Handle_TopoDS_TVertex_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.Handle_TopoDS_TVertex_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.Handle_TopoDS_TVertex_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Free(self, *args):
        """
        Free(Handle_TopoDS_TVertex self) -> Standard_Boolean
        Free(Handle_TopoDS_TVertex self, Standard_Boolean const F)

        Sets the free flag.

        :type F: bool

        """
        return _TopoDS.Handle_TopoDS_TVertex_Free(self, *args)


    def Locked(self, *args):
        """
        Locked(Handle_TopoDS_TVertex self) -> Standard_Boolean
        Locked(Handle_TopoDS_TVertex self, Standard_Boolean const F)

        Sets the locked flag.

        :type F: bool

        """
        return _TopoDS.Handle_TopoDS_TVertex_Locked(self, *args)


    def Modified(self, *args):
        """
        Modified(Handle_TopoDS_TVertex self) -> Standard_Boolean
        Modified(Handle_TopoDS_TVertex self, Standard_Boolean const M)

        Sets the modification flag.

        :type M: bool

        """
        return _TopoDS.Handle_TopoDS_TVertex_Modified(self, *args)


    def Checked(self, *args):
        """
        Checked(Handle_TopoDS_TVertex self) -> Standard_Boolean
        Checked(Handle_TopoDS_TVertex self, Standard_Boolean const C)

        Sets the checked flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TVertex_Checked(self, *args)


    def Orientable(self, *args):
        """
        Orientable(Handle_TopoDS_TVertex self) -> Standard_Boolean
        Orientable(Handle_TopoDS_TVertex self, Standard_Boolean const C)

        Sets the orientability flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TVertex_Orientable(self, *args)


    def Closed(self, *args):
        """
        Closed(Handle_TopoDS_TVertex self) -> Standard_Boolean
        Closed(Handle_TopoDS_TVertex self, Standard_Boolean const C)

        Sets the closedness flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TVertex_Closed(self, *args)


    def Infinite(self, *args):
        """
        Infinite(Handle_TopoDS_TVertex self) -> Standard_Boolean
        Infinite(Handle_TopoDS_TVertex self, Standard_Boolean const C)

        Sets the infinity flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TVertex_Infinite(self, *args)


    def Convex(self, *args):
        """
        Convex(Handle_TopoDS_TVertex self) -> Standard_Boolean
        Convex(Handle_TopoDS_TVertex self, Standard_Boolean const C)

        Sets the convexness flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TVertex_Convex(self, *args)


    def EmptyCopy(self, *args):
        """
        EmptyCopy(Handle_TopoDS_TVertex self) -> Handle_TopoDS_TShape

        Returns a copy  of the  TShape  with no sub-shapes.

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        return _TopoDS.Handle_TopoDS_TVertex_EmptyCopy(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TopoDS_TVertex self)

        Memory deallocator for transient classes


        """
        return _TopoDS.Handle_TopoDS_TVertex_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopoDS_TVertex self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopoDS_TVertex self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.Handle_TopoDS_TVertex_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopoDS_TVertex self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopoDS_TVertex self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.Handle_TopoDS_TVertex_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopoDS_TVertex self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopoDS.Handle_TopoDS_TVertex_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopoDS_TVertex self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopoDS.Handle_TopoDS_TVertex_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopoDS_TVertex self)

        Increments the reference counter of this object


        """
        return _TopoDS.Handle_TopoDS_TVertex_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopoDS_TVertex self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopoDS.Handle_TopoDS_TVertex_DecrementRefCounter(self, *args)

Handle_TopoDS_TVertex_swigregister = _TopoDS.Handle_TopoDS_TVertex_swigregister
Handle_TopoDS_TVertex_swigregister(Handle_TopoDS_TVertex)

def Handle_TopoDS_TVertex_DownCast(thing):
    return _TopoDS.Handle_TopoDS_TVertex_DownCast(thing)
Handle_TopoDS_TVertex_DownCast = _TopoDS.Handle_TopoDS_TVertex_DownCast

class TopoDS_TCompound(TopoDS_TShape):
    """A TCompound is an all-purpose set of Shapes."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopoDS_TCompound
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopoDS_TCompound(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TopoDS_TCompound self) -> TopoDS_TCompound

        Creates an empty TCompound.


        """
        this = _TopoDS.new_TopoDS_TCompound(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ShapeType(self, *args):
        """
        ShapeType(TopoDS_TCompound self) -> TopAbs_ShapeEnum

        Returns COMPOUND.

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopoDS.TopoDS_TCompound_ShapeType(self, *args)


    def EmptyCopy(self, *args):
        """
        EmptyCopy(TopoDS_TCompound self) -> Handle_TopoDS_TShape

        Returns an empty TCompound.

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        return _TopoDS.TopoDS_TCompound_EmptyCopy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopoDS.TopoDS_TCompound_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopoDS.TopoDS_TCompound_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.TopoDS_TCompound_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopoDS.delete_TopoDS_TCompound
TopoDS_TCompound_swigregister = _TopoDS.TopoDS_TCompound_swigregister
TopoDS_TCompound_swigregister(TopoDS_TCompound)

def TopoDS_TCompound_get_type_name(*args):
    """
    TopoDS_TCompound_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopoDS.TopoDS_TCompound_get_type_name(*args)

def TopoDS_TCompound_get_type_descriptor(*args):
    """
    TopoDS_TCompound_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopoDS.TopoDS_TCompound_get_type_descriptor(*args)

class TopoDS_Edge(TopoDS_Shape):
    """
    Describes an edge which
    - references an underlying edge with the potential to
    be given a location and an orientation
    - has a location for the underlying edge, giving its
    placement in the local coordinate system
    - has an orientation for the underlying edge, in terms
    of its geometry (as opposed to orientation in
    relation to other shapes).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopoDS_Edge self) -> TopoDS_Edge

        Undefined Edge.


        """
        this = _TopoDS.new_TopoDS_Edge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopoDS.delete_TopoDS_Edge
TopoDS_Edge_swigregister = _TopoDS.TopoDS_Edge_swigregister
TopoDS_Edge_swigregister(TopoDS_Edge)

class Handle_TopoDS_UnCompatibleShapes(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopoDS_UnCompatibleShapes self)

        Nullify the handle


        """
        return _TopoDS.Handle_TopoDS_UnCompatibleShapes_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopoDS_UnCompatibleShapes self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopoDS.Handle_TopoDS_UnCompatibleShapes_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopoDS_UnCompatibleShapes self, TopoDS_UnCompatibleShapes thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopoDS.Handle_TopoDS_UnCompatibleShapes_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopoDS_UnCompatibleShapes self, Handle_TopoDS_UnCompatibleShapes theHandle) -> Handle_TopoDS_UnCompatibleShapes
        assign(Handle_TopoDS_UnCompatibleShapes self, TopoDS_UnCompatibleShapes thePtr) -> Handle_TopoDS_UnCompatibleShapes
        assign(Handle_TopoDS_UnCompatibleShapes self, Handle_TopoDS_UnCompatibleShapes theHandle) -> Handle_TopoDS_UnCompatibleShapes

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopoDS.Handle_TopoDS_UnCompatibleShapes_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopoDS_UnCompatibleShapes self) -> TopoDS_UnCompatibleShapes

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopoDS.Handle_TopoDS_UnCompatibleShapes_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopoDS_UnCompatibleShapes self) -> TopoDS_UnCompatibleShapes

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopoDS.Handle_TopoDS_UnCompatibleShapes___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopoDS_UnCompatibleShapes self) -> TopoDS_UnCompatibleShapes

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopoDS.Handle_TopoDS_UnCompatibleShapes___ref__(self, *args)


    def __hash__(self):
        return _TopoDS.Handle_TopoDS_UnCompatibleShapes___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopoDS.Handle_TopoDS_UnCompatibleShapes___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopoDS.new_Handle_TopoDS_UnCompatibleShapes(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopoDS.Handle_TopoDS_UnCompatibleShapes_DownCast)
    __swig_destroy__ = _TopoDS.delete_Handle_TopoDS_UnCompatibleShapes

    def NewInstance(self, *args):
        """
        NewInstance(Handle_TopoDS_UnCompatibleShapes self, Standard_CString const theMessage) -> Handle_TopoDS_UnCompatibleShapes

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_UnCompatibleShapes

        """
        return _TopoDS.Handle_TopoDS_UnCompatibleShapes_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopoDS_UnCompatibleShapes self) -> char const *

        :rtype: const char *

        """
        return _TopoDS.Handle_TopoDS_UnCompatibleShapes_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.Handle_TopoDS_UnCompatibleShapes_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.Handle_TopoDS_UnCompatibleShapes_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_TopoDS_UnCompatibleShapes self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _TopoDS.Handle_TopoDS_UnCompatibleShapes_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_TopoDS_UnCompatibleShapes self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _TopoDS.Handle_TopoDS_UnCompatibleShapes_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_TopoDS_UnCompatibleShapes self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _TopoDS.Handle_TopoDS_UnCompatibleShapes_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_TopoDS_UnCompatibleShapes self)
        Reraise(Handle_TopoDS_UnCompatibleShapes self, Standard_CString const aMessage)
        Reraise(Handle_TopoDS_UnCompatibleShapes self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _TopoDS.Handle_TopoDS_UnCompatibleShapes_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_TopoDS_UnCompatibleShapes self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _TopoDS.Handle_TopoDS_UnCompatibleShapes_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_TopoDS_UnCompatibleShapes self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _TopoDS.Handle_TopoDS_UnCompatibleShapes_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TopoDS_UnCompatibleShapes self)

        Memory deallocator for transient classes


        """
        return _TopoDS.Handle_TopoDS_UnCompatibleShapes_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopoDS_UnCompatibleShapes self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopoDS_UnCompatibleShapes self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.Handle_TopoDS_UnCompatibleShapes_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopoDS_UnCompatibleShapes self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopoDS_UnCompatibleShapes self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.Handle_TopoDS_UnCompatibleShapes_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopoDS_UnCompatibleShapes self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopoDS.Handle_TopoDS_UnCompatibleShapes_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopoDS_UnCompatibleShapes self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopoDS.Handle_TopoDS_UnCompatibleShapes_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopoDS_UnCompatibleShapes self)

        Increments the reference counter of this object


        """
        return _TopoDS.Handle_TopoDS_UnCompatibleShapes_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopoDS_UnCompatibleShapes self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopoDS.Handle_TopoDS_UnCompatibleShapes_DecrementRefCounter(self, *args)

Handle_TopoDS_UnCompatibleShapes_swigregister = _TopoDS.Handle_TopoDS_UnCompatibleShapes_swigregister
Handle_TopoDS_UnCompatibleShapes_swigregister(Handle_TopoDS_UnCompatibleShapes)

def Handle_TopoDS_UnCompatibleShapes_DownCast(thing):
    return _TopoDS.Handle_TopoDS_UnCompatibleShapes_DownCast(thing)
Handle_TopoDS_UnCompatibleShapes_DownCast = _TopoDS.Handle_TopoDS_UnCompatibleShapes_DownCast

class TopoDS_TCompSolid(TopoDS_TShape):
    """A set of solids connected by their faces."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopoDS_TCompSolid
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopoDS_TCompSolid(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TopoDS_TCompSolid self) -> TopoDS_TCompSolid

        Creates an empty TCompSolid.


        """
        this = _TopoDS.new_TopoDS_TCompSolid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ShapeType(self, *args):
        """
        ShapeType(TopoDS_TCompSolid self) -> TopAbs_ShapeEnum

        returns COMPSOLID

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopoDS.TopoDS_TCompSolid_ShapeType(self, *args)


    def EmptyCopy(self, *args):
        """
        EmptyCopy(TopoDS_TCompSolid self) -> Handle_TopoDS_TShape

        Returns an empty TCompSolid.

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        return _TopoDS.TopoDS_TCompSolid_EmptyCopy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopoDS.TopoDS_TCompSolid_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopoDS.TopoDS_TCompSolid_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.TopoDS_TCompSolid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopoDS.delete_TopoDS_TCompSolid
TopoDS_TCompSolid_swigregister = _TopoDS.TopoDS_TCompSolid_swigregister
TopoDS_TCompSolid_swigregister(TopoDS_TCompSolid)

def TopoDS_TCompSolid_get_type_name(*args):
    """
    TopoDS_TCompSolid_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopoDS.TopoDS_TCompSolid_get_type_name(*args)

def TopoDS_TCompSolid_get_type_descriptor(*args):
    """
    TopoDS_TCompSolid_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopoDS.TopoDS_TCompSolid_get_type_descriptor(*args)

class TopoDS_TSolid(TopoDS_TShape):
    """
    A Topological part of 3D space, bounded by shells,
    edges and vertices.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopoDS_TSolid
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopoDS_TSolid(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TopoDS_TSolid self) -> TopoDS_TSolid

        Creates an empty TSolid.


        """
        this = _TopoDS.new_TopoDS_TSolid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ShapeType(self, *args):
        """
        ShapeType(TopoDS_TSolid self) -> TopAbs_ShapeEnum

        returns SOLID.

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopoDS.TopoDS_TSolid_ShapeType(self, *args)


    def EmptyCopy(self, *args):
        """
        EmptyCopy(TopoDS_TSolid self) -> Handle_TopoDS_TShape

        Returns an empty TSolid.

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        return _TopoDS.TopoDS_TSolid_EmptyCopy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopoDS.TopoDS_TSolid_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopoDS.TopoDS_TSolid_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.TopoDS_TSolid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopoDS.delete_TopoDS_TSolid
TopoDS_TSolid_swigregister = _TopoDS.TopoDS_TSolid_swigregister
TopoDS_TSolid_swigregister(TopoDS_TSolid)

def TopoDS_TSolid_get_type_name(*args):
    """
    TopoDS_TSolid_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopoDS.TopoDS_TSolid_get_type_name(*args)

def TopoDS_TSolid_get_type_descriptor(*args):
    """
    TopoDS_TSolid_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopoDS.TopoDS_TSolid_get_type_descriptor(*args)

class TopoDS_Shell(TopoDS_Shape):
    """
    Describes a shell which
    - references an underlying shell with the potential to
    be given a location and an orientation
    - has a location for the underlying shell, giving its
    placement in the local coordinate system
    - has an orientation for the underlying shell, in terms
    of its geometry (as opposed to orientation in relation to other shapes).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopoDS_Shell self) -> TopoDS_Shell

        Constructs an Undefined Shell.


        """
        this = _TopoDS.new_TopoDS_Shell(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopoDS.delete_TopoDS_Shell
TopoDS_Shell_swigregister = _TopoDS.TopoDS_Shell_swigregister
TopoDS_Shell_swigregister(TopoDS_Shell)

class Handle_TopoDS_FrozenShape(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopoDS_FrozenShape self)

        Nullify the handle


        """
        return _TopoDS.Handle_TopoDS_FrozenShape_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopoDS_FrozenShape self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopoDS.Handle_TopoDS_FrozenShape_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopoDS_FrozenShape self, TopoDS_FrozenShape thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopoDS.Handle_TopoDS_FrozenShape_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopoDS_FrozenShape self, Handle_TopoDS_FrozenShape theHandle) -> Handle_TopoDS_FrozenShape
        assign(Handle_TopoDS_FrozenShape self, TopoDS_FrozenShape thePtr) -> Handle_TopoDS_FrozenShape
        assign(Handle_TopoDS_FrozenShape self, Handle_TopoDS_FrozenShape theHandle) -> Handle_TopoDS_FrozenShape

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopoDS.Handle_TopoDS_FrozenShape_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopoDS_FrozenShape self) -> TopoDS_FrozenShape

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopoDS.Handle_TopoDS_FrozenShape_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopoDS_FrozenShape self) -> TopoDS_FrozenShape

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopoDS.Handle_TopoDS_FrozenShape___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopoDS_FrozenShape self) -> TopoDS_FrozenShape

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopoDS.Handle_TopoDS_FrozenShape___ref__(self, *args)


    def __hash__(self):
        return _TopoDS.Handle_TopoDS_FrozenShape___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopoDS.Handle_TopoDS_FrozenShape___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopoDS.new_Handle_TopoDS_FrozenShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopoDS.Handle_TopoDS_FrozenShape_DownCast)
    __swig_destroy__ = _TopoDS.delete_Handle_TopoDS_FrozenShape

    def NewInstance(self, *args):
        """
        NewInstance(Handle_TopoDS_FrozenShape self, Standard_CString const theMessage) -> Handle_TopoDS_FrozenShape

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_FrozenShape

        """
        return _TopoDS.Handle_TopoDS_FrozenShape_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopoDS_FrozenShape self) -> char const *

        :rtype: const char *

        """
        return _TopoDS.Handle_TopoDS_FrozenShape_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.Handle_TopoDS_FrozenShape_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.Handle_TopoDS_FrozenShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_TopoDS_FrozenShape self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _TopoDS.Handle_TopoDS_FrozenShape_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_TopoDS_FrozenShape self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _TopoDS.Handle_TopoDS_FrozenShape_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_TopoDS_FrozenShape self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _TopoDS.Handle_TopoDS_FrozenShape_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_TopoDS_FrozenShape self)
        Reraise(Handle_TopoDS_FrozenShape self, Standard_CString const aMessage)
        Reraise(Handle_TopoDS_FrozenShape self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _TopoDS.Handle_TopoDS_FrozenShape_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_TopoDS_FrozenShape self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _TopoDS.Handle_TopoDS_FrozenShape_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_TopoDS_FrozenShape self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _TopoDS.Handle_TopoDS_FrozenShape_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TopoDS_FrozenShape self)

        Memory deallocator for transient classes


        """
        return _TopoDS.Handle_TopoDS_FrozenShape_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopoDS_FrozenShape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopoDS_FrozenShape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.Handle_TopoDS_FrozenShape_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopoDS_FrozenShape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopoDS_FrozenShape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.Handle_TopoDS_FrozenShape_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopoDS_FrozenShape self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopoDS.Handle_TopoDS_FrozenShape_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopoDS_FrozenShape self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopoDS.Handle_TopoDS_FrozenShape_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopoDS_FrozenShape self)

        Increments the reference counter of this object


        """
        return _TopoDS.Handle_TopoDS_FrozenShape_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopoDS_FrozenShape self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopoDS.Handle_TopoDS_FrozenShape_DecrementRefCounter(self, *args)

Handle_TopoDS_FrozenShape_swigregister = _TopoDS.Handle_TopoDS_FrozenShape_swigregister
Handle_TopoDS_FrozenShape_swigregister(Handle_TopoDS_FrozenShape)

def Handle_TopoDS_FrozenShape_DownCast(thing):
    return _TopoDS.Handle_TopoDS_FrozenShape_DownCast(thing)
Handle_TopoDS_FrozenShape_DownCast = _TopoDS.Handle_TopoDS_FrozenShape_DownCast

class TopoDS_TEdge(TopoDS_TShape):
    """
    A topological part  of a  curve  in 2D or 3D,  the
    boundary    is   a   set  of oriented    Vertices.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopoDS_TEdge
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopoDS_TEdge(self) 
            return h


    def ShapeType(self, *args):
        """
        ShapeType(TopoDS_TEdge self) -> TopAbs_ShapeEnum

        Returns  EDGE.

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopoDS.TopoDS_TEdge_ShapeType(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopoDS.TopoDS_TEdge_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopoDS.TopoDS_TEdge_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.TopoDS_TEdge_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopoDS.delete_TopoDS_TEdge
TopoDS_TEdge_swigregister = _TopoDS.TopoDS_TEdge_swigregister
TopoDS_TEdge_swigregister(TopoDS_TEdge)

def TopoDS_TEdge_get_type_name(*args):
    """
    TopoDS_TEdge_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopoDS.TopoDS_TEdge_get_type_name(*args)

def TopoDS_TEdge_get_type_descriptor(*args):
    """
    TopoDS_TEdge_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopoDS.TopoDS_TEdge_get_type_descriptor(*args)

class Handle_TopoDS_TEdge(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopoDS_TEdge self)

        Nullify the handle


        """
        return _TopoDS.Handle_TopoDS_TEdge_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopoDS_TEdge self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopoDS.Handle_TopoDS_TEdge_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopoDS_TEdge self, TopoDS_TEdge thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopoDS.Handle_TopoDS_TEdge_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopoDS_TEdge self, Handle_TopoDS_TEdge theHandle) -> Handle_TopoDS_TEdge
        assign(Handle_TopoDS_TEdge self, TopoDS_TEdge thePtr) -> Handle_TopoDS_TEdge
        assign(Handle_TopoDS_TEdge self, Handle_TopoDS_TEdge theHandle) -> Handle_TopoDS_TEdge

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopoDS.Handle_TopoDS_TEdge_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopoDS_TEdge self) -> TopoDS_TEdge

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopoDS.Handle_TopoDS_TEdge_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopoDS_TEdge self) -> TopoDS_TEdge

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopoDS.Handle_TopoDS_TEdge___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopoDS_TEdge self) -> TopoDS_TEdge

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopoDS.Handle_TopoDS_TEdge___ref__(self, *args)


    def __hash__(self):
        return _TopoDS.Handle_TopoDS_TEdge___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopoDS.Handle_TopoDS_TEdge___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopoDS.new_Handle_TopoDS_TEdge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopoDS.Handle_TopoDS_TEdge_DownCast)
    __swig_destroy__ = _TopoDS.delete_Handle_TopoDS_TEdge

    def ShapeType(self, *args):
        """
        ShapeType(Handle_TopoDS_TEdge self) -> TopAbs_ShapeEnum

        Returns  EDGE.

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopoDS.Handle_TopoDS_TEdge_ShapeType(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopoDS_TEdge self) -> char const *

        :rtype: const char *

        """
        return _TopoDS.Handle_TopoDS_TEdge_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.Handle_TopoDS_TEdge_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.Handle_TopoDS_TEdge_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Free(self, *args):
        """
        Free(Handle_TopoDS_TEdge self) -> Standard_Boolean
        Free(Handle_TopoDS_TEdge self, Standard_Boolean const F)

        Sets the free flag.

        :type F: bool

        """
        return _TopoDS.Handle_TopoDS_TEdge_Free(self, *args)


    def Locked(self, *args):
        """
        Locked(Handle_TopoDS_TEdge self) -> Standard_Boolean
        Locked(Handle_TopoDS_TEdge self, Standard_Boolean const F)

        Sets the locked flag.

        :type F: bool

        """
        return _TopoDS.Handle_TopoDS_TEdge_Locked(self, *args)


    def Modified(self, *args):
        """
        Modified(Handle_TopoDS_TEdge self) -> Standard_Boolean
        Modified(Handle_TopoDS_TEdge self, Standard_Boolean const M)

        Sets the modification flag.

        :type M: bool

        """
        return _TopoDS.Handle_TopoDS_TEdge_Modified(self, *args)


    def Checked(self, *args):
        """
        Checked(Handle_TopoDS_TEdge self) -> Standard_Boolean
        Checked(Handle_TopoDS_TEdge self, Standard_Boolean const C)

        Sets the checked flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TEdge_Checked(self, *args)


    def Orientable(self, *args):
        """
        Orientable(Handle_TopoDS_TEdge self) -> Standard_Boolean
        Orientable(Handle_TopoDS_TEdge self, Standard_Boolean const C)

        Sets the orientability flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TEdge_Orientable(self, *args)


    def Closed(self, *args):
        """
        Closed(Handle_TopoDS_TEdge self) -> Standard_Boolean
        Closed(Handle_TopoDS_TEdge self, Standard_Boolean const C)

        Sets the closedness flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TEdge_Closed(self, *args)


    def Infinite(self, *args):
        """
        Infinite(Handle_TopoDS_TEdge self) -> Standard_Boolean
        Infinite(Handle_TopoDS_TEdge self, Standard_Boolean const C)

        Sets the infinity flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TEdge_Infinite(self, *args)


    def Convex(self, *args):
        """
        Convex(Handle_TopoDS_TEdge self) -> Standard_Boolean
        Convex(Handle_TopoDS_TEdge self, Standard_Boolean const C)

        Sets the convexness flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TEdge_Convex(self, *args)


    def EmptyCopy(self, *args):
        """
        EmptyCopy(Handle_TopoDS_TEdge self) -> Handle_TopoDS_TShape

        Returns a copy  of the  TShape  with no sub-shapes.

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        return _TopoDS.Handle_TopoDS_TEdge_EmptyCopy(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TopoDS_TEdge self)

        Memory deallocator for transient classes


        """
        return _TopoDS.Handle_TopoDS_TEdge_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopoDS_TEdge self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopoDS_TEdge self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.Handle_TopoDS_TEdge_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopoDS_TEdge self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopoDS_TEdge self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.Handle_TopoDS_TEdge_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopoDS_TEdge self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopoDS.Handle_TopoDS_TEdge_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopoDS_TEdge self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopoDS.Handle_TopoDS_TEdge_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopoDS_TEdge self)

        Increments the reference counter of this object


        """
        return _TopoDS.Handle_TopoDS_TEdge_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopoDS_TEdge self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopoDS.Handle_TopoDS_TEdge_DecrementRefCounter(self, *args)

Handle_TopoDS_TEdge_swigregister = _TopoDS.Handle_TopoDS_TEdge_swigregister
Handle_TopoDS_TEdge_swigregister(Handle_TopoDS_TEdge)

def Handle_TopoDS_TEdge_DownCast(thing):
    return _TopoDS.Handle_TopoDS_TEdge_DownCast(thing)
Handle_TopoDS_TEdge_DownCast = _TopoDS.Handle_TopoDS_TEdge_DownCast

class TopoDS_AlertWithShape(Message.Message_Alert):
    """Alert object storing TopoDS shape in its field"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopoDS_AlertWithShape
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopoDS_AlertWithShape(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TopoDS_AlertWithShape self, TopoDS_Shape theShape) -> TopoDS_AlertWithShape

        Constructor with shape argument

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _TopoDS.new_TopoDS_AlertWithShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def GetShape(self, *args):
        """
        Returns contained shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopoDS.TopoDS_AlertWithShape_GetShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SupportsMerge(self, *args):
        """
        SupportsMerge(TopoDS_AlertWithShape self) -> Standard_Boolean

        Returns false.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.TopoDS_AlertWithShape_SupportsMerge(self, *args)


    def Merge(self, *args):
        """
        Merge(TopoDS_AlertWithShape self, Handle_Message_Alert theTarget) -> Standard_Boolean

        Returns false.

        :type theTarget: OCC.wrapper.Message.Handle_Message_Alert
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.TopoDS_AlertWithShape_Merge(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopoDS.TopoDS_AlertWithShape_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopoDS.TopoDS_AlertWithShape_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.TopoDS_AlertWithShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopoDS.delete_TopoDS_AlertWithShape
TopoDS_AlertWithShape_swigregister = _TopoDS.TopoDS_AlertWithShape_swigregister
TopoDS_AlertWithShape_swigregister(TopoDS_AlertWithShape)

def TopoDS_AlertWithShape_get_type_name(*args):
    """
    TopoDS_AlertWithShape_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopoDS.TopoDS_AlertWithShape_get_type_name(*args)

def TopoDS_AlertWithShape_get_type_descriptor(*args):
    """
    TopoDS_AlertWithShape_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopoDS.TopoDS_AlertWithShape_get_type_descriptor(*args)

class Handle_TopoDS_TSolid(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopoDS_TSolid self)

        Nullify the handle


        """
        return _TopoDS.Handle_TopoDS_TSolid_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopoDS_TSolid self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopoDS.Handle_TopoDS_TSolid_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopoDS_TSolid self, TopoDS_TSolid thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopoDS.Handle_TopoDS_TSolid_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopoDS_TSolid self, Handle_TopoDS_TSolid theHandle) -> Handle_TopoDS_TSolid
        assign(Handle_TopoDS_TSolid self, TopoDS_TSolid thePtr) -> Handle_TopoDS_TSolid
        assign(Handle_TopoDS_TSolid self, Handle_TopoDS_TSolid theHandle) -> Handle_TopoDS_TSolid

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopoDS.Handle_TopoDS_TSolid_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopoDS_TSolid self) -> TopoDS_TSolid

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopoDS.Handle_TopoDS_TSolid_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopoDS_TSolid self) -> TopoDS_TSolid

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopoDS.Handle_TopoDS_TSolid___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopoDS_TSolid self) -> TopoDS_TSolid

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopoDS.Handle_TopoDS_TSolid___ref__(self, *args)


    def __hash__(self):
        return _TopoDS.Handle_TopoDS_TSolid___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopoDS.Handle_TopoDS_TSolid___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopoDS.new_Handle_TopoDS_TSolid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopoDS.Handle_TopoDS_TSolid_DownCast)
    __swig_destroy__ = _TopoDS.delete_Handle_TopoDS_TSolid

    def ShapeType(self, *args):
        """
        ShapeType(Handle_TopoDS_TSolid self) -> TopAbs_ShapeEnum

        returns SOLID.

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopoDS.Handle_TopoDS_TSolid_ShapeType(self, *args)


    def EmptyCopy(self, *args):
        """
        EmptyCopy(Handle_TopoDS_TSolid self) -> Handle_TopoDS_TShape

        Returns an empty TSolid.

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        return _TopoDS.Handle_TopoDS_TSolid_EmptyCopy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopoDS_TSolid self) -> char const *

        :rtype: const char *

        """
        return _TopoDS.Handle_TopoDS_TSolid_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.Handle_TopoDS_TSolid_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.Handle_TopoDS_TSolid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Free(self, *args):
        """
        Free(Handle_TopoDS_TSolid self) -> Standard_Boolean
        Free(Handle_TopoDS_TSolid self, Standard_Boolean const F)

        Sets the free flag.

        :type F: bool

        """
        return _TopoDS.Handle_TopoDS_TSolid_Free(self, *args)


    def Locked(self, *args):
        """
        Locked(Handle_TopoDS_TSolid self) -> Standard_Boolean
        Locked(Handle_TopoDS_TSolid self, Standard_Boolean const F)

        Sets the locked flag.

        :type F: bool

        """
        return _TopoDS.Handle_TopoDS_TSolid_Locked(self, *args)


    def Modified(self, *args):
        """
        Modified(Handle_TopoDS_TSolid self) -> Standard_Boolean
        Modified(Handle_TopoDS_TSolid self, Standard_Boolean const M)

        Sets the modification flag.

        :type M: bool

        """
        return _TopoDS.Handle_TopoDS_TSolid_Modified(self, *args)


    def Checked(self, *args):
        """
        Checked(Handle_TopoDS_TSolid self) -> Standard_Boolean
        Checked(Handle_TopoDS_TSolid self, Standard_Boolean const C)

        Sets the checked flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TSolid_Checked(self, *args)


    def Orientable(self, *args):
        """
        Orientable(Handle_TopoDS_TSolid self) -> Standard_Boolean
        Orientable(Handle_TopoDS_TSolid self, Standard_Boolean const C)

        Sets the orientability flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TSolid_Orientable(self, *args)


    def Closed(self, *args):
        """
        Closed(Handle_TopoDS_TSolid self) -> Standard_Boolean
        Closed(Handle_TopoDS_TSolid self, Standard_Boolean const C)

        Sets the closedness flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TSolid_Closed(self, *args)


    def Infinite(self, *args):
        """
        Infinite(Handle_TopoDS_TSolid self) -> Standard_Boolean
        Infinite(Handle_TopoDS_TSolid self, Standard_Boolean const C)

        Sets the infinity flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TSolid_Infinite(self, *args)


    def Convex(self, *args):
        """
        Convex(Handle_TopoDS_TSolid self) -> Standard_Boolean
        Convex(Handle_TopoDS_TSolid self, Standard_Boolean const C)

        Sets the convexness flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TSolid_Convex(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TopoDS_TSolid self)

        Memory deallocator for transient classes


        """
        return _TopoDS.Handle_TopoDS_TSolid_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopoDS_TSolid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopoDS_TSolid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.Handle_TopoDS_TSolid_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopoDS_TSolid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopoDS_TSolid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.Handle_TopoDS_TSolid_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopoDS_TSolid self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopoDS.Handle_TopoDS_TSolid_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopoDS_TSolid self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopoDS.Handle_TopoDS_TSolid_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopoDS_TSolid self)

        Increments the reference counter of this object


        """
        return _TopoDS.Handle_TopoDS_TSolid_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopoDS_TSolid self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopoDS.Handle_TopoDS_TSolid_DecrementRefCounter(self, *args)

Handle_TopoDS_TSolid_swigregister = _TopoDS.Handle_TopoDS_TSolid_swigregister
Handle_TopoDS_TSolid_swigregister(Handle_TopoDS_TSolid)

def Handle_TopoDS_TSolid_DownCast(thing):
    return _TopoDS.Handle_TopoDS_TSolid_DownCast(thing)
Handle_TopoDS_TSolid_DownCast = _TopoDS.Handle_TopoDS_TSolid_DownCast

class TopoDS_Solid(TopoDS_Shape):
    """
    Describes a solid shape which
    - references an underlying solid shape with the
    potential to be given a location and an orientation
    - has a location for the underlying shape, giving its
    placement in the local coordinate system
    - has an orientation for the underlying shape, in
    terms of its geometry (as opposed to orientation in
    relation to other shapes).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopoDS_Solid self) -> TopoDS_Solid

        Constructs an Undefined Solid.


        """
        this = _TopoDS.new_TopoDS_Solid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopoDS.delete_TopoDS_Solid
TopoDS_Solid_swigregister = _TopoDS.TopoDS_Solid_swigregister
TopoDS_Solid_swigregister(TopoDS_Solid)

class TopoDS_Vertex(TopoDS_Shape):
    """
    Describes a vertex which
    - references an underlying vertex with the potential
    to be given a location and an orientation
    - has a location for the underlying vertex, giving its
    placement in the local coordinate system
    - has an orientation for the underlying vertex, in
    terms of its geometry (as opposed to orientation in
    relation to other shapes).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopoDS_Vertex self) -> TopoDS_Vertex

        Undefined Vertex.


        """
        this = _TopoDS.new_TopoDS_Vertex(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopoDS.delete_TopoDS_Vertex
TopoDS_Vertex_swigregister = _TopoDS.TopoDS_Vertex_swigregister
TopoDS_Vertex_swigregister(TopoDS_Vertex)

class TopoDS_Iterator(object):
    """
    Iterates on the underlying shape underlying a given
    TopoDS_Shape object, providing access to its
    component sub-shapes. Each component shape is
    returned as a TopoDS_Shape with an orientation,
    and a compound of the original values and the relative values.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopoDS_Iterator self) -> TopoDS_Iterator
        __init__(TopoDS_Iterator self, TopoDS_Shape S, Standard_Boolean const cumOri, Standard_Boolean const cumLoc) -> TopoDS_Iterator

        Creates an Iterator on <S> sub-shapes.
        Note:
        - If cumOri is true, the function composes all
        sub-shapes with the orientation of S.
        - If cumLoc is true, the function multiplies all
        sub-shapes by the location of S, i.e. it applies to
        each sub-shape the transformation that is associated with S.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type cumOri: bool
        :type cumLoc: bool

        """
        this = _TopoDS.new_TopoDS_Iterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(TopoDS_Iterator self, TopoDS_Shape S, Standard_Boolean const cumOri, Standard_Boolean const cumLoc)

        Initializes this iterator with shape S.
        Note:
        - If cumOri is true, the function composes all
        sub-shapes with the orientation of S.
        - If cumLoc is true, the function multiplies all
        sub-shapes by the location of S, i.e. it applies to
        each sub-shape the transformation that is associated with S.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type cumOri: bool
        :type cumLoc: bool

        """
        return _TopoDS.TopoDS_Iterator_Initialize(self, *args)


    def More(self, *args):
        """
        More(TopoDS_Iterator self) -> Standard_Boolean

        Returns true if there is another sub-shape in the
        shape which this iterator is scanning.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.TopoDS_Iterator_More(self, *args)


    def Next(self, *args):
        """
        Next(TopoDS_Iterator self)

        Moves on to the next sub-shape in the shape which
        this iterator is scanning.
        Exceptions
        Standard_NoMoreObject if there are no more sub-shapes in the shape.


        """
        return _TopoDS.TopoDS_Iterator_Next(self, *args)


    def Value(self, *args):
        """
        Returns the current sub-shape in the shape which
        this iterator is scanning.
        Exceptions
        Standard_NoSuchObject if there is no current sub-shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopoDS.TopoDS_Iterator_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopoDS.delete_TopoDS_Iterator
TopoDS_Iterator_swigregister = _TopoDS.TopoDS_Iterator_swigregister
TopoDS_Iterator_swigregister(TopoDS_Iterator)

class Handle_TopoDS_TWire(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopoDS_TWire self)

        Nullify the handle


        """
        return _TopoDS.Handle_TopoDS_TWire_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopoDS_TWire self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopoDS.Handle_TopoDS_TWire_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopoDS_TWire self, TopoDS_TWire thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopoDS.Handle_TopoDS_TWire_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopoDS_TWire self, Handle_TopoDS_TWire theHandle) -> Handle_TopoDS_TWire
        assign(Handle_TopoDS_TWire self, TopoDS_TWire thePtr) -> Handle_TopoDS_TWire
        assign(Handle_TopoDS_TWire self, Handle_TopoDS_TWire theHandle) -> Handle_TopoDS_TWire

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopoDS.Handle_TopoDS_TWire_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopoDS_TWire self) -> TopoDS_TWire

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopoDS.Handle_TopoDS_TWire_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopoDS_TWire self) -> TopoDS_TWire

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopoDS.Handle_TopoDS_TWire___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopoDS_TWire self) -> TopoDS_TWire

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopoDS.Handle_TopoDS_TWire___ref__(self, *args)


    def __hash__(self):
        return _TopoDS.Handle_TopoDS_TWire___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopoDS.Handle_TopoDS_TWire___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopoDS.new_Handle_TopoDS_TWire(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopoDS.Handle_TopoDS_TWire_DownCast)
    __swig_destroy__ = _TopoDS.delete_Handle_TopoDS_TWire

    def ShapeType(self, *args):
        """
        ShapeType(Handle_TopoDS_TWire self) -> TopAbs_ShapeEnum

        Returns WIRE.

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopoDS.Handle_TopoDS_TWire_ShapeType(self, *args)


    def EmptyCopy(self, *args):
        """
        EmptyCopy(Handle_TopoDS_TWire self) -> Handle_TopoDS_TShape

        Returns an empty TWire.

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        return _TopoDS.Handle_TopoDS_TWire_EmptyCopy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopoDS_TWire self) -> char const *

        :rtype: const char *

        """
        return _TopoDS.Handle_TopoDS_TWire_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.Handle_TopoDS_TWire_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.Handle_TopoDS_TWire_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Free(self, *args):
        """
        Free(Handle_TopoDS_TWire self) -> Standard_Boolean
        Free(Handle_TopoDS_TWire self, Standard_Boolean const F)

        Sets the free flag.

        :type F: bool

        """
        return _TopoDS.Handle_TopoDS_TWire_Free(self, *args)


    def Locked(self, *args):
        """
        Locked(Handle_TopoDS_TWire self) -> Standard_Boolean
        Locked(Handle_TopoDS_TWire self, Standard_Boolean const F)

        Sets the locked flag.

        :type F: bool

        """
        return _TopoDS.Handle_TopoDS_TWire_Locked(self, *args)


    def Modified(self, *args):
        """
        Modified(Handle_TopoDS_TWire self) -> Standard_Boolean
        Modified(Handle_TopoDS_TWire self, Standard_Boolean const M)

        Sets the modification flag.

        :type M: bool

        """
        return _TopoDS.Handle_TopoDS_TWire_Modified(self, *args)


    def Checked(self, *args):
        """
        Checked(Handle_TopoDS_TWire self) -> Standard_Boolean
        Checked(Handle_TopoDS_TWire self, Standard_Boolean const C)

        Sets the checked flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TWire_Checked(self, *args)


    def Orientable(self, *args):
        """
        Orientable(Handle_TopoDS_TWire self) -> Standard_Boolean
        Orientable(Handle_TopoDS_TWire self, Standard_Boolean const C)

        Sets the orientability flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TWire_Orientable(self, *args)


    def Closed(self, *args):
        """
        Closed(Handle_TopoDS_TWire self) -> Standard_Boolean
        Closed(Handle_TopoDS_TWire self, Standard_Boolean const C)

        Sets the closedness flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TWire_Closed(self, *args)


    def Infinite(self, *args):
        """
        Infinite(Handle_TopoDS_TWire self) -> Standard_Boolean
        Infinite(Handle_TopoDS_TWire self, Standard_Boolean const C)

        Sets the infinity flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TWire_Infinite(self, *args)


    def Convex(self, *args):
        """
        Convex(Handle_TopoDS_TWire self) -> Standard_Boolean
        Convex(Handle_TopoDS_TWire self, Standard_Boolean const C)

        Sets the convexness flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TWire_Convex(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TopoDS_TWire self)

        Memory deallocator for transient classes


        """
        return _TopoDS.Handle_TopoDS_TWire_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopoDS_TWire self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopoDS_TWire self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.Handle_TopoDS_TWire_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopoDS_TWire self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopoDS_TWire self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.Handle_TopoDS_TWire_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopoDS_TWire self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopoDS.Handle_TopoDS_TWire_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopoDS_TWire self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopoDS.Handle_TopoDS_TWire_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopoDS_TWire self)

        Increments the reference counter of this object


        """
        return _TopoDS.Handle_TopoDS_TWire_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopoDS_TWire self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopoDS.Handle_TopoDS_TWire_DecrementRefCounter(self, *args)

Handle_TopoDS_TWire_swigregister = _TopoDS.Handle_TopoDS_TWire_swigregister
Handle_TopoDS_TWire_swigregister(Handle_TopoDS_TWire)

def Handle_TopoDS_TWire_DownCast(thing):
    return _TopoDS.Handle_TopoDS_TWire_DownCast(thing)
Handle_TopoDS_TWire_DownCast = _TopoDS.Handle_TopoDS_TWire_DownCast

class Handle_TopoDS_TCompSolid(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopoDS_TCompSolid self)

        Nullify the handle


        """
        return _TopoDS.Handle_TopoDS_TCompSolid_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopoDS_TCompSolid self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopoDS.Handle_TopoDS_TCompSolid_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopoDS_TCompSolid self, TopoDS_TCompSolid thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopoDS.Handle_TopoDS_TCompSolid_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopoDS_TCompSolid self, Handle_TopoDS_TCompSolid theHandle) -> Handle_TopoDS_TCompSolid
        assign(Handle_TopoDS_TCompSolid self, TopoDS_TCompSolid thePtr) -> Handle_TopoDS_TCompSolid
        assign(Handle_TopoDS_TCompSolid self, Handle_TopoDS_TCompSolid theHandle) -> Handle_TopoDS_TCompSolid

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopoDS.Handle_TopoDS_TCompSolid_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopoDS_TCompSolid self) -> TopoDS_TCompSolid

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopoDS.Handle_TopoDS_TCompSolid_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopoDS_TCompSolid self) -> TopoDS_TCompSolid

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopoDS.Handle_TopoDS_TCompSolid___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopoDS_TCompSolid self) -> TopoDS_TCompSolid

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopoDS.Handle_TopoDS_TCompSolid___ref__(self, *args)


    def __hash__(self):
        return _TopoDS.Handle_TopoDS_TCompSolid___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopoDS.Handle_TopoDS_TCompSolid___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopoDS.new_Handle_TopoDS_TCompSolid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopoDS.Handle_TopoDS_TCompSolid_DownCast)
    __swig_destroy__ = _TopoDS.delete_Handle_TopoDS_TCompSolid

    def ShapeType(self, *args):
        """
        ShapeType(Handle_TopoDS_TCompSolid self) -> TopAbs_ShapeEnum

        returns COMPSOLID

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopoDS.Handle_TopoDS_TCompSolid_ShapeType(self, *args)


    def EmptyCopy(self, *args):
        """
        EmptyCopy(Handle_TopoDS_TCompSolid self) -> Handle_TopoDS_TShape

        Returns an empty TCompSolid.

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        return _TopoDS.Handle_TopoDS_TCompSolid_EmptyCopy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopoDS_TCompSolid self) -> char const *

        :rtype: const char *

        """
        return _TopoDS.Handle_TopoDS_TCompSolid_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.Handle_TopoDS_TCompSolid_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.Handle_TopoDS_TCompSolid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Free(self, *args):
        """
        Free(Handle_TopoDS_TCompSolid self) -> Standard_Boolean
        Free(Handle_TopoDS_TCompSolid self, Standard_Boolean const F)

        Sets the free flag.

        :type F: bool

        """
        return _TopoDS.Handle_TopoDS_TCompSolid_Free(self, *args)


    def Locked(self, *args):
        """
        Locked(Handle_TopoDS_TCompSolid self) -> Standard_Boolean
        Locked(Handle_TopoDS_TCompSolid self, Standard_Boolean const F)

        Sets the locked flag.

        :type F: bool

        """
        return _TopoDS.Handle_TopoDS_TCompSolid_Locked(self, *args)


    def Modified(self, *args):
        """
        Modified(Handle_TopoDS_TCompSolid self) -> Standard_Boolean
        Modified(Handle_TopoDS_TCompSolid self, Standard_Boolean const M)

        Sets the modification flag.

        :type M: bool

        """
        return _TopoDS.Handle_TopoDS_TCompSolid_Modified(self, *args)


    def Checked(self, *args):
        """
        Checked(Handle_TopoDS_TCompSolid self) -> Standard_Boolean
        Checked(Handle_TopoDS_TCompSolid self, Standard_Boolean const C)

        Sets the checked flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TCompSolid_Checked(self, *args)


    def Orientable(self, *args):
        """
        Orientable(Handle_TopoDS_TCompSolid self) -> Standard_Boolean
        Orientable(Handle_TopoDS_TCompSolid self, Standard_Boolean const C)

        Sets the orientability flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TCompSolid_Orientable(self, *args)


    def Closed(self, *args):
        """
        Closed(Handle_TopoDS_TCompSolid self) -> Standard_Boolean
        Closed(Handle_TopoDS_TCompSolid self, Standard_Boolean const C)

        Sets the closedness flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TCompSolid_Closed(self, *args)


    def Infinite(self, *args):
        """
        Infinite(Handle_TopoDS_TCompSolid self) -> Standard_Boolean
        Infinite(Handle_TopoDS_TCompSolid self, Standard_Boolean const C)

        Sets the infinity flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TCompSolid_Infinite(self, *args)


    def Convex(self, *args):
        """
        Convex(Handle_TopoDS_TCompSolid self) -> Standard_Boolean
        Convex(Handle_TopoDS_TCompSolid self, Standard_Boolean const C)

        Sets the convexness flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TCompSolid_Convex(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TopoDS_TCompSolid self)

        Memory deallocator for transient classes


        """
        return _TopoDS.Handle_TopoDS_TCompSolid_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopoDS_TCompSolid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopoDS_TCompSolid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.Handle_TopoDS_TCompSolid_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopoDS_TCompSolid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopoDS_TCompSolid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.Handle_TopoDS_TCompSolid_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopoDS_TCompSolid self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopoDS.Handle_TopoDS_TCompSolid_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopoDS_TCompSolid self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopoDS.Handle_TopoDS_TCompSolid_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopoDS_TCompSolid self)

        Increments the reference counter of this object


        """
        return _TopoDS.Handle_TopoDS_TCompSolid_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopoDS_TCompSolid self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopoDS.Handle_TopoDS_TCompSolid_DecrementRefCounter(self, *args)

Handle_TopoDS_TCompSolid_swigregister = _TopoDS.Handle_TopoDS_TCompSolid_swigregister
Handle_TopoDS_TCompSolid_swigregister(Handle_TopoDS_TCompSolid)

def Handle_TopoDS_TCompSolid_DownCast(thing):
    return _TopoDS.Handle_TopoDS_TCompSolid_DownCast(thing)
Handle_TopoDS_TCompSolid_DownCast = _TopoDS.Handle_TopoDS_TCompSolid_DownCast

class Handle_TopoDS_TShell(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopoDS_TShell self)

        Nullify the handle


        """
        return _TopoDS.Handle_TopoDS_TShell_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopoDS_TShell self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopoDS.Handle_TopoDS_TShell_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopoDS_TShell self, TopoDS_TShell thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopoDS.Handle_TopoDS_TShell_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopoDS_TShell self, Handle_TopoDS_TShell theHandle) -> Handle_TopoDS_TShell
        assign(Handle_TopoDS_TShell self, TopoDS_TShell thePtr) -> Handle_TopoDS_TShell
        assign(Handle_TopoDS_TShell self, Handle_TopoDS_TShell theHandle) -> Handle_TopoDS_TShell

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopoDS.Handle_TopoDS_TShell_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopoDS_TShell self) -> TopoDS_TShell

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopoDS.Handle_TopoDS_TShell_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopoDS_TShell self) -> TopoDS_TShell

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopoDS.Handle_TopoDS_TShell___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopoDS_TShell self) -> TopoDS_TShell

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopoDS.Handle_TopoDS_TShell___ref__(self, *args)


    def __hash__(self):
        return _TopoDS.Handle_TopoDS_TShell___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopoDS.Handle_TopoDS_TShell___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopoDS.new_Handle_TopoDS_TShell(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopoDS.Handle_TopoDS_TShell_DownCast)
    __swig_destroy__ = _TopoDS.delete_Handle_TopoDS_TShell

    def ShapeType(self, *args):
        """
        ShapeType(Handle_TopoDS_TShell self) -> TopAbs_ShapeEnum

        Returns SHELL.

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopoDS.Handle_TopoDS_TShell_ShapeType(self, *args)


    def EmptyCopy(self, *args):
        """
        EmptyCopy(Handle_TopoDS_TShell self) -> Handle_TopoDS_TShape

        Returns an empty TShell.

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        return _TopoDS.Handle_TopoDS_TShell_EmptyCopy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopoDS_TShell self) -> char const *

        :rtype: const char *

        """
        return _TopoDS.Handle_TopoDS_TShell_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.Handle_TopoDS_TShell_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.Handle_TopoDS_TShell_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Free(self, *args):
        """
        Free(Handle_TopoDS_TShell self) -> Standard_Boolean
        Free(Handle_TopoDS_TShell self, Standard_Boolean const F)

        Sets the free flag.

        :type F: bool

        """
        return _TopoDS.Handle_TopoDS_TShell_Free(self, *args)


    def Locked(self, *args):
        """
        Locked(Handle_TopoDS_TShell self) -> Standard_Boolean
        Locked(Handle_TopoDS_TShell self, Standard_Boolean const F)

        Sets the locked flag.

        :type F: bool

        """
        return _TopoDS.Handle_TopoDS_TShell_Locked(self, *args)


    def Modified(self, *args):
        """
        Modified(Handle_TopoDS_TShell self) -> Standard_Boolean
        Modified(Handle_TopoDS_TShell self, Standard_Boolean const M)

        Sets the modification flag.

        :type M: bool

        """
        return _TopoDS.Handle_TopoDS_TShell_Modified(self, *args)


    def Checked(self, *args):
        """
        Checked(Handle_TopoDS_TShell self) -> Standard_Boolean
        Checked(Handle_TopoDS_TShell self, Standard_Boolean const C)

        Sets the checked flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TShell_Checked(self, *args)


    def Orientable(self, *args):
        """
        Orientable(Handle_TopoDS_TShell self) -> Standard_Boolean
        Orientable(Handle_TopoDS_TShell self, Standard_Boolean const C)

        Sets the orientability flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TShell_Orientable(self, *args)


    def Closed(self, *args):
        """
        Closed(Handle_TopoDS_TShell self) -> Standard_Boolean
        Closed(Handle_TopoDS_TShell self, Standard_Boolean const C)

        Sets the closedness flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TShell_Closed(self, *args)


    def Infinite(self, *args):
        """
        Infinite(Handle_TopoDS_TShell self) -> Standard_Boolean
        Infinite(Handle_TopoDS_TShell self, Standard_Boolean const C)

        Sets the infinity flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TShell_Infinite(self, *args)


    def Convex(self, *args):
        """
        Convex(Handle_TopoDS_TShell self) -> Standard_Boolean
        Convex(Handle_TopoDS_TShell self, Standard_Boolean const C)

        Sets the convexness flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TShell_Convex(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TopoDS_TShell self)

        Memory deallocator for transient classes


        """
        return _TopoDS.Handle_TopoDS_TShell_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopoDS_TShell self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopoDS_TShell self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.Handle_TopoDS_TShell_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopoDS_TShell self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopoDS_TShell self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.Handle_TopoDS_TShell_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopoDS_TShell self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopoDS.Handle_TopoDS_TShell_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopoDS_TShell self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopoDS.Handle_TopoDS_TShell_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopoDS_TShell self)

        Increments the reference counter of this object


        """
        return _TopoDS.Handle_TopoDS_TShell_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopoDS_TShell self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopoDS.Handle_TopoDS_TShell_DecrementRefCounter(self, *args)

Handle_TopoDS_TShell_swigregister = _TopoDS.Handle_TopoDS_TShell_swigregister
Handle_TopoDS_TShell_swigregister(Handle_TopoDS_TShell)

def Handle_TopoDS_TShell_DownCast(thing):
    return _TopoDS.Handle_TopoDS_TShell_DownCast(thing)
Handle_TopoDS_TShell_DownCast = _TopoDS.Handle_TopoDS_TShell_DownCast

class Handle_TopoDS_TShape(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopoDS_TShape self)

        Nullify the handle


        """
        return _TopoDS.Handle_TopoDS_TShape_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopoDS_TShape self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopoDS.Handle_TopoDS_TShape_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopoDS_TShape self, TopoDS_TShape thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopoDS.Handle_TopoDS_TShape_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopoDS_TShape self, Handle_TopoDS_TShape theHandle) -> Handle_TopoDS_TShape
        assign(Handle_TopoDS_TShape self, TopoDS_TShape thePtr) -> Handle_TopoDS_TShape
        assign(Handle_TopoDS_TShape self, Handle_TopoDS_TShape theHandle) -> Handle_TopoDS_TShape

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopoDS.Handle_TopoDS_TShape_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopoDS_TShape self) -> TopoDS_TShape

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopoDS.Handle_TopoDS_TShape_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopoDS_TShape self) -> TopoDS_TShape

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopoDS.Handle_TopoDS_TShape___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopoDS_TShape self) -> TopoDS_TShape

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopoDS.Handle_TopoDS_TShape___ref__(self, *args)


    def __hash__(self):
        return _TopoDS.Handle_TopoDS_TShape___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopoDS.Handle_TopoDS_TShape___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopoDS.new_Handle_TopoDS_TShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopoDS.Handle_TopoDS_TShape_DownCast)
    __swig_destroy__ = _TopoDS.delete_Handle_TopoDS_TShape

    def Free(self, *args):
        """
        Free(Handle_TopoDS_TShape self) -> Standard_Boolean
        Free(Handle_TopoDS_TShape self, Standard_Boolean const F)

        Sets the free flag.

        :type F: bool

        """
        return _TopoDS.Handle_TopoDS_TShape_Free(self, *args)


    def Locked(self, *args):
        """
        Locked(Handle_TopoDS_TShape self) -> Standard_Boolean
        Locked(Handle_TopoDS_TShape self, Standard_Boolean const F)

        Sets the locked flag.

        :type F: bool

        """
        return _TopoDS.Handle_TopoDS_TShape_Locked(self, *args)


    def Modified(self, *args):
        """
        Modified(Handle_TopoDS_TShape self) -> Standard_Boolean
        Modified(Handle_TopoDS_TShape self, Standard_Boolean const M)

        Sets the modification flag.

        :type M: bool

        """
        return _TopoDS.Handle_TopoDS_TShape_Modified(self, *args)


    def Checked(self, *args):
        """
        Checked(Handle_TopoDS_TShape self) -> Standard_Boolean
        Checked(Handle_TopoDS_TShape self, Standard_Boolean const C)

        Sets the checked flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TShape_Checked(self, *args)


    def Orientable(self, *args):
        """
        Orientable(Handle_TopoDS_TShape self) -> Standard_Boolean
        Orientable(Handle_TopoDS_TShape self, Standard_Boolean const C)

        Sets the orientability flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TShape_Orientable(self, *args)


    def Closed(self, *args):
        """
        Closed(Handle_TopoDS_TShape self) -> Standard_Boolean
        Closed(Handle_TopoDS_TShape self, Standard_Boolean const C)

        Sets the closedness flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TShape_Closed(self, *args)


    def Infinite(self, *args):
        """
        Infinite(Handle_TopoDS_TShape self) -> Standard_Boolean
        Infinite(Handle_TopoDS_TShape self, Standard_Boolean const C)

        Sets the infinity flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TShape_Infinite(self, *args)


    def Convex(self, *args):
        """
        Convex(Handle_TopoDS_TShape self) -> Standard_Boolean
        Convex(Handle_TopoDS_TShape self, Standard_Boolean const C)

        Sets the convexness flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TShape_Convex(self, *args)


    def ShapeType(self, *args):
        """
        ShapeType(Handle_TopoDS_TShape self) -> TopAbs_ShapeEnum

        Returns the type as a term of the ShapeEnum enum :
        VERTEX, EDGE, WIRE, FACE, ....

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopoDS.Handle_TopoDS_TShape_ShapeType(self, *args)


    def EmptyCopy(self, *args):
        """
        EmptyCopy(Handle_TopoDS_TShape self) -> Handle_TopoDS_TShape

        Returns a copy  of the  TShape  with no sub-shapes.

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        return _TopoDS.Handle_TopoDS_TShape_EmptyCopy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopoDS_TShape self) -> char const *

        :rtype: const char *

        """
        return _TopoDS.Handle_TopoDS_TShape_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.Handle_TopoDS_TShape_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.Handle_TopoDS_TShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TopoDS_TShape self)

        Memory deallocator for transient classes


        """
        return _TopoDS.Handle_TopoDS_TShape_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopoDS_TShape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopoDS_TShape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.Handle_TopoDS_TShape_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopoDS_TShape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopoDS_TShape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.Handle_TopoDS_TShape_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopoDS_TShape self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopoDS.Handle_TopoDS_TShape_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopoDS_TShape self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopoDS.Handle_TopoDS_TShape_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopoDS_TShape self)

        Increments the reference counter of this object


        """
        return _TopoDS.Handle_TopoDS_TShape_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopoDS_TShape self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopoDS.Handle_TopoDS_TShape_DecrementRefCounter(self, *args)

Handle_TopoDS_TShape_swigregister = _TopoDS.Handle_TopoDS_TShape_swigregister
Handle_TopoDS_TShape_swigregister(Handle_TopoDS_TShape)

def Handle_TopoDS_TShape_DownCast(thing):
    return _TopoDS.Handle_TopoDS_TShape_DownCast(thing)
Handle_TopoDS_TShape_DownCast = _TopoDS.Handle_TopoDS_TShape_DownCast

class TopoDS_LockedShape(Standard.Standard_DomainError):
    """
    An attempt was made to modify a geometry of Shape already
    shared or protected.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopoDS_LockedShape
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopoDS_LockedShape(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TopoDS_LockedShape self) -> TopoDS_LockedShape
        __init__(TopoDS_LockedShape self, Standard_CString const theMessage) -> TopoDS_LockedShape

        :type theMessage: OCC.wrapper.Standard.Standard_CString

        """
        this = _TopoDS.new_TopoDS_LockedShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewInstance(*args):
        """
        NewInstance(Standard_CString const theMessage) -> Handle_TopoDS_LockedShape

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_LockedShape

        """
        return _TopoDS.TopoDS_LockedShape_NewInstance(*args)

    NewInstance = staticmethod(NewInstance)

    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopoDS.TopoDS_LockedShape_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopoDS.TopoDS_LockedShape_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.TopoDS_LockedShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopoDS.delete_TopoDS_LockedShape
TopoDS_LockedShape_swigregister = _TopoDS.TopoDS_LockedShape_swigregister
TopoDS_LockedShape_swigregister(TopoDS_LockedShape)

def TopoDS_LockedShape_NewInstance(*args):
    """
    TopoDS_LockedShape_NewInstance(Standard_CString const theMessage) -> Handle_TopoDS_LockedShape

    :type theMessage: OCC.wrapper.Standard.Standard_CString
    :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_LockedShape

    """
    return _TopoDS.TopoDS_LockedShape_NewInstance(*args)

def TopoDS_LockedShape_get_type_name(*args):
    """
    TopoDS_LockedShape_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopoDS.TopoDS_LockedShape_get_type_name(*args)

def TopoDS_LockedShape_get_type_descriptor(*args):
    """
    TopoDS_LockedShape_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopoDS.TopoDS_LockedShape_get_type_descriptor(*args)

class TopoDS_Wire(TopoDS_Shape):
    """
    Describes a wire which
    - references an underlying wire with the potential to
    be given a location and an orientation
    - has a location for the underlying wire, giving its
    placement in the local coordinate system
    - has an orientation for the underlying wire, in terms
    of its geometry (as opposed to orientation in relation to other shapes).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopoDS_Wire self) -> TopoDS_Wire

        Undefined Wire.


        """
        this = _TopoDS.new_TopoDS_Wire(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopoDS.delete_TopoDS_Wire
TopoDS_Wire_swigregister = _TopoDS.TopoDS_Wire_swigregister
TopoDS_Wire_swigregister(TopoDS_Wire)

class TopoDS_Face(TopoDS_Shape):
    """
    Describes a face which
    - references an underlying face with the potential to
    be given a location and an orientation
    - has a location for the underlying face, giving its
    placement in the local coordinate system
    - has an orientation for the underlying face, in terms
    of its geometry (as opposed to orientation in relation to other shapes).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopoDS_Face self) -> TopoDS_Face

        Undefined Face.


        """
        this = _TopoDS.new_TopoDS_Face(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopoDS.delete_TopoDS_Face
TopoDS_Face_swigregister = _TopoDS.TopoDS_Face_swigregister
TopoDS_Face_swigregister(TopoDS_Face)

class Handle_TopoDS_TCompound(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopoDS_TCompound self)

        Nullify the handle


        """
        return _TopoDS.Handle_TopoDS_TCompound_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopoDS_TCompound self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopoDS.Handle_TopoDS_TCompound_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopoDS_TCompound self, TopoDS_TCompound thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopoDS.Handle_TopoDS_TCompound_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopoDS_TCompound self, Handle_TopoDS_TCompound theHandle) -> Handle_TopoDS_TCompound
        assign(Handle_TopoDS_TCompound self, TopoDS_TCompound thePtr) -> Handle_TopoDS_TCompound
        assign(Handle_TopoDS_TCompound self, Handle_TopoDS_TCompound theHandle) -> Handle_TopoDS_TCompound

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopoDS.Handle_TopoDS_TCompound_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopoDS_TCompound self) -> TopoDS_TCompound

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopoDS.Handle_TopoDS_TCompound_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopoDS_TCompound self) -> TopoDS_TCompound

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopoDS.Handle_TopoDS_TCompound___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopoDS_TCompound self) -> TopoDS_TCompound

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopoDS.Handle_TopoDS_TCompound___ref__(self, *args)


    def __hash__(self):
        return _TopoDS.Handle_TopoDS_TCompound___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopoDS.Handle_TopoDS_TCompound___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopoDS.new_Handle_TopoDS_TCompound(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopoDS.Handle_TopoDS_TCompound_DownCast)
    __swig_destroy__ = _TopoDS.delete_Handle_TopoDS_TCompound

    def ShapeType(self, *args):
        """
        ShapeType(Handle_TopoDS_TCompound self) -> TopAbs_ShapeEnum

        Returns COMPOUND.

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopoDS.Handle_TopoDS_TCompound_ShapeType(self, *args)


    def EmptyCopy(self, *args):
        """
        EmptyCopy(Handle_TopoDS_TCompound self) -> Handle_TopoDS_TShape

        Returns an empty TCompound.

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        return _TopoDS.Handle_TopoDS_TCompound_EmptyCopy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopoDS_TCompound self) -> char const *

        :rtype: const char *

        """
        return _TopoDS.Handle_TopoDS_TCompound_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.Handle_TopoDS_TCompound_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.Handle_TopoDS_TCompound_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Free(self, *args):
        """
        Free(Handle_TopoDS_TCompound self) -> Standard_Boolean
        Free(Handle_TopoDS_TCompound self, Standard_Boolean const F)

        Sets the free flag.

        :type F: bool

        """
        return _TopoDS.Handle_TopoDS_TCompound_Free(self, *args)


    def Locked(self, *args):
        """
        Locked(Handle_TopoDS_TCompound self) -> Standard_Boolean
        Locked(Handle_TopoDS_TCompound self, Standard_Boolean const F)

        Sets the locked flag.

        :type F: bool

        """
        return _TopoDS.Handle_TopoDS_TCompound_Locked(self, *args)


    def Modified(self, *args):
        """
        Modified(Handle_TopoDS_TCompound self) -> Standard_Boolean
        Modified(Handle_TopoDS_TCompound self, Standard_Boolean const M)

        Sets the modification flag.

        :type M: bool

        """
        return _TopoDS.Handle_TopoDS_TCompound_Modified(self, *args)


    def Checked(self, *args):
        """
        Checked(Handle_TopoDS_TCompound self) -> Standard_Boolean
        Checked(Handle_TopoDS_TCompound self, Standard_Boolean const C)

        Sets the checked flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TCompound_Checked(self, *args)


    def Orientable(self, *args):
        """
        Orientable(Handle_TopoDS_TCompound self) -> Standard_Boolean
        Orientable(Handle_TopoDS_TCompound self, Standard_Boolean const C)

        Sets the orientability flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TCompound_Orientable(self, *args)


    def Closed(self, *args):
        """
        Closed(Handle_TopoDS_TCompound self) -> Standard_Boolean
        Closed(Handle_TopoDS_TCompound self, Standard_Boolean const C)

        Sets the closedness flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TCompound_Closed(self, *args)


    def Infinite(self, *args):
        """
        Infinite(Handle_TopoDS_TCompound self) -> Standard_Boolean
        Infinite(Handle_TopoDS_TCompound self, Standard_Boolean const C)

        Sets the infinity flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TCompound_Infinite(self, *args)


    def Convex(self, *args):
        """
        Convex(Handle_TopoDS_TCompound self) -> Standard_Boolean
        Convex(Handle_TopoDS_TCompound self, Standard_Boolean const C)

        Sets the convexness flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TCompound_Convex(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TopoDS_TCompound self)

        Memory deallocator for transient classes


        """
        return _TopoDS.Handle_TopoDS_TCompound_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopoDS_TCompound self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopoDS_TCompound self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.Handle_TopoDS_TCompound_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopoDS_TCompound self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopoDS_TCompound self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.Handle_TopoDS_TCompound_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopoDS_TCompound self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopoDS.Handle_TopoDS_TCompound_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopoDS_TCompound self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopoDS.Handle_TopoDS_TCompound_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopoDS_TCompound self)

        Increments the reference counter of this object


        """
        return _TopoDS.Handle_TopoDS_TCompound_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopoDS_TCompound self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopoDS.Handle_TopoDS_TCompound_DecrementRefCounter(self, *args)

Handle_TopoDS_TCompound_swigregister = _TopoDS.Handle_TopoDS_TCompound_swigregister
Handle_TopoDS_TCompound_swigregister(Handle_TopoDS_TCompound)

def Handle_TopoDS_TCompound_DownCast(thing):
    return _TopoDS.Handle_TopoDS_TCompound_DownCast(thing)
Handle_TopoDS_TCompound_DownCast = _TopoDS.Handle_TopoDS_TCompound_DownCast

class Handle_TopoDS_LockedShape(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopoDS_LockedShape self)

        Nullify the handle


        """
        return _TopoDS.Handle_TopoDS_LockedShape_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopoDS_LockedShape self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopoDS.Handle_TopoDS_LockedShape_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopoDS_LockedShape self, TopoDS_LockedShape thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopoDS.Handle_TopoDS_LockedShape_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopoDS_LockedShape self, Handle_TopoDS_LockedShape theHandle) -> Handle_TopoDS_LockedShape
        assign(Handle_TopoDS_LockedShape self, TopoDS_LockedShape thePtr) -> Handle_TopoDS_LockedShape
        assign(Handle_TopoDS_LockedShape self, Handle_TopoDS_LockedShape theHandle) -> Handle_TopoDS_LockedShape

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopoDS.Handle_TopoDS_LockedShape_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopoDS_LockedShape self) -> TopoDS_LockedShape

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopoDS.Handle_TopoDS_LockedShape_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopoDS_LockedShape self) -> TopoDS_LockedShape

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopoDS.Handle_TopoDS_LockedShape___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopoDS_LockedShape self) -> TopoDS_LockedShape

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopoDS.Handle_TopoDS_LockedShape___ref__(self, *args)


    def __hash__(self):
        return _TopoDS.Handle_TopoDS_LockedShape___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopoDS.Handle_TopoDS_LockedShape___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopoDS.new_Handle_TopoDS_LockedShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopoDS.Handle_TopoDS_LockedShape_DownCast)
    __swig_destroy__ = _TopoDS.delete_Handle_TopoDS_LockedShape

    def NewInstance(self, *args):
        """
        NewInstance(Handle_TopoDS_LockedShape self, Standard_CString const theMessage) -> Handle_TopoDS_LockedShape

        :type theMessage: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_LockedShape

        """
        return _TopoDS.Handle_TopoDS_LockedShape_NewInstance(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopoDS_LockedShape self) -> char const *

        :rtype: const char *

        """
        return _TopoDS.Handle_TopoDS_LockedShape_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.Handle_TopoDS_LockedShape_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.Handle_TopoDS_LockedShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Print(self, *args):
        """
        Print(Handle_TopoDS_LockedShape self, Standard_OStream & s)

        Prints on the stream <s> the exception name followed by
        the error message.
        Level: Advanced
        Warning:
        The operator "OStream& operator<< (Standard_OStream&,
        Handle(Standard_Failure)&)"
        is implemented. (This operator uses the method Print)

        :type s: OCC.wrapper.Standard.Standard_OStream

        """
        return _TopoDS.Handle_TopoDS_LockedShape_Print(self, *args)


    def GetMessageString(self, *args):
        """
        GetMessageString(Handle_TopoDS_LockedShape self) -> Standard_CString

        Returns error message

        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _TopoDS.Handle_TopoDS_LockedShape_GetMessageString(self, *args)


    def SetMessageString(self, *args):
        """
        SetMessageString(Handle_TopoDS_LockedShape self, Standard_CString const aMessage)

        Sets error message

        :type aMessage: OCC.wrapper.Standard.Standard_CString

        """
        return _TopoDS.Handle_TopoDS_LockedShape_SetMessageString(self, *args)


    def Reraise(self, *args):
        """
        Reraise(Handle_TopoDS_LockedShape self)
        Reraise(Handle_TopoDS_LockedShape self, Standard_CString const aMessage)
        Reraise(Handle_TopoDS_LockedShape self, Standard_SStream const & aReason)

        Reraises a caught exception and changes its error message.

        :type aReason: OCC.wrapper.Standard.Standard_SStream

        """
        return _TopoDS.Handle_TopoDS_LockedShape_Reraise(self, *args)


    def Jump(self, *args):
        """
        Jump(Handle_TopoDS_LockedShape self)

        Used to throw CASCADE exception from C signal handler.
        On platforms that do not allow throwing C++ exceptions
        from this handler (e.g. Linux), uses longjump to get to
        the current active signal handler, and only then is
        converted to C++ exception.


        """
        return _TopoDS.Handle_TopoDS_LockedShape_Jump(self, *args)


    def Caught(self, *args):
        """
        Caught(Handle_TopoDS_LockedShape self) -> Handle_Standard_Failure

        Returns the last caught exception.
        Needed when exceptions are emulated by C longjumps,
        in other cases is also provided for compatibility.

        :rtype: OCC.wrapper.Standard.Handle_Standard_Failure

        """
        return _TopoDS.Handle_TopoDS_LockedShape_Caught(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TopoDS_LockedShape self)

        Memory deallocator for transient classes


        """
        return _TopoDS.Handle_TopoDS_LockedShape_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopoDS_LockedShape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopoDS_LockedShape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.Handle_TopoDS_LockedShape_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopoDS_LockedShape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopoDS_LockedShape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.Handle_TopoDS_LockedShape_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopoDS_LockedShape self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopoDS.Handle_TopoDS_LockedShape_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopoDS_LockedShape self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopoDS.Handle_TopoDS_LockedShape_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopoDS_LockedShape self)

        Increments the reference counter of this object


        """
        return _TopoDS.Handle_TopoDS_LockedShape_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopoDS_LockedShape self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopoDS.Handle_TopoDS_LockedShape_DecrementRefCounter(self, *args)

Handle_TopoDS_LockedShape_swigregister = _TopoDS.Handle_TopoDS_LockedShape_swigregister
Handle_TopoDS_LockedShape_swigregister(Handle_TopoDS_LockedShape)

def Handle_TopoDS_LockedShape_DownCast(thing):
    return _TopoDS.Handle_TopoDS_LockedShape_DownCast(thing)
Handle_TopoDS_LockedShape_DownCast = _TopoDS.Handle_TopoDS_LockedShape_DownCast

class TopoDS_Compound(TopoDS_Shape):
    """
    Describes a compound which
    - references an underlying compound with the
    potential to be given a location and an orientation
    - has a location for the underlying compound, giving
    its placement in the local coordinate system
    - has an orientation for the underlying compound, in
    terms of its geometry (as opposed to orientation in
    relation to other shapes).
    Casts shape S to the more specialized return type, Compound.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopoDS_Compound self) -> TopoDS_Compound

        Constructs an Undefined Compound.


        """
        this = _TopoDS.new_TopoDS_Compound(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopoDS.delete_TopoDS_Compound
TopoDS_Compound_swigregister = _TopoDS.TopoDS_Compound_swigregister
TopoDS_Compound_swigregister(TopoDS_Compound)

class TopoDS_HShape(Standard.Standard_Transient):
    """Class to manipulate a Shape with  handle."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopoDS_HShape
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopoDS_HShape(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TopoDS_HShape self) -> TopoDS_HShape
        __init__(TopoDS_HShape self, TopoDS_Shape aShape) -> TopoDS_HShape

        Constructs a shape object defined by the shape aShape.

        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _TopoDS.new_TopoDS_HShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Shape(self, *args):
        """
        Returns a reference to a constant TopoDS_Shape based on this shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopoDS.TopoDS_HShape_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeShape(self, *args):
        """
        ChangeShape(TopoDS_HShape self) -> TopoDS_Shape

        Exchanges the TopoDS_Shape object defining this
        shape for another one referencing the same underlying shape
        Accesses the list of shapes within the underlying
        shape referenced by the TopoDS_Shape object.
        Returns a reference to a TopoDS_Shape based on
        this shape. The TopoDS_Shape can be modified.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopoDS.TopoDS_HShape_ChangeShape(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopoDS.TopoDS_HShape_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopoDS.TopoDS_HShape_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.TopoDS_HShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopoDS.delete_TopoDS_HShape
TopoDS_HShape_swigregister = _TopoDS.TopoDS_HShape_swigregister
TopoDS_HShape_swigregister(TopoDS_HShape)

def TopoDS_HShape_get_type_name(*args):
    """
    TopoDS_HShape_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopoDS.TopoDS_HShape_get_type_name(*args)

def TopoDS_HShape_get_type_descriptor(*args):
    """
    TopoDS_HShape_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopoDS.TopoDS_HShape_get_type_descriptor(*args)

class TopoDS_(object):
    """
    Provides methods to cast objects of class
    TopoDS_Shape to be onjects of more specialized
    sub-classes. Types are verified, thus in the example
    below, the first two blocks are correct but the third is
    rejected by the compiler.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Vertex(*args):
        """
        Vertex(TopoDS_Shape S) -> TopoDS_Vertex
        Vertex(TopoDS_Shape arg1) -> TopoDS_Vertex

        :type : OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _TopoDS.TopoDS__Vertex(*args)

    Vertex = staticmethod(Vertex)

    def Edge(*args):
        """
        Edge(TopoDS_Shape S) -> TopoDS_Edge
        Edge(TopoDS_Shape arg1) -> TopoDS_Edge

        :type : OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _TopoDS.TopoDS__Edge(*args)

    Edge = staticmethod(Edge)

    def Wire(*args):
        """
        Wire(TopoDS_Shape S) -> TopoDS_Wire
        Wire(TopoDS_Shape arg1) -> TopoDS_Wire

        :type : OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _TopoDS.TopoDS__Wire(*args)

    Wire = staticmethod(Wire)

    def Face(*args):
        """
        Face(TopoDS_Shape S) -> TopoDS_Face
        Face(TopoDS_Shape arg1) -> TopoDS_Face

        :type : OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _TopoDS.TopoDS__Face(*args)

    Face = staticmethod(Face)

    def Shell(*args):
        """
        Shell(TopoDS_Shape S) -> TopoDS_Shell
        Shell(TopoDS_Shape arg1) -> TopoDS_Shell

        :type : OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shell

        """
        return _TopoDS.TopoDS__Shell(*args)

    Shell = staticmethod(Shell)

    def Solid(*args):
        """
        Solid(TopoDS_Shape S) -> TopoDS_Solid
        Solid(TopoDS_Shape arg1) -> TopoDS_Solid

        :type : OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Solid

        """
        return _TopoDS.TopoDS__Solid(*args)

    Solid = staticmethod(Solid)

    def CompSolid(*args):
        """
        CompSolid(TopoDS_Shape S) -> TopoDS_CompSolid
        CompSolid(TopoDS_Shape arg1) -> TopoDS_CompSolid

        :type : OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_CompSolid

        """
        return _TopoDS.TopoDS__CompSolid(*args)

    CompSolid = staticmethod(CompSolid)

    def Compound(*args):
        """
        Compound(TopoDS_Shape S) -> TopoDS_Compound
        Compound(TopoDS_Shape arg1) -> TopoDS_Compound

        :type : OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Compound

        """
        return _TopoDS.TopoDS__Compound(*args)

    Compound = staticmethod(Compound)

    def __init__(self):
        """
        Provides methods to cast objects of class
        TopoDS_Shape to be onjects of more specialized
        sub-classes. Types are verified, thus in the example
        below, the first two blocks are correct but the third is
        rejected by the compiler.
        """
        this = _TopoDS.new_TopoDS_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopoDS.delete_TopoDS_
TopoDS__swigregister = _TopoDS.TopoDS__swigregister
TopoDS__swigregister(TopoDS_)

def TopoDS__Vertex(*args):
    """
    Vertex(TopoDS_Shape S) -> TopoDS_Vertex
    TopoDS__Vertex(TopoDS_Shape arg2) -> TopoDS_Vertex

    :type : OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

    """
    return _TopoDS.TopoDS__Vertex(*args)

def TopoDS__Edge(*args):
    """
    Edge(TopoDS_Shape S) -> TopoDS_Edge
    TopoDS__Edge(TopoDS_Shape arg2) -> TopoDS_Edge

    :type : OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

    """
    return _TopoDS.TopoDS__Edge(*args)

def TopoDS__Wire(*args):
    """
    Wire(TopoDS_Shape S) -> TopoDS_Wire
    TopoDS__Wire(TopoDS_Shape arg2) -> TopoDS_Wire

    :type : OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

    """
    return _TopoDS.TopoDS__Wire(*args)

def TopoDS__Face(*args):
    """
    Face(TopoDS_Shape S) -> TopoDS_Face
    TopoDS__Face(TopoDS_Shape arg2) -> TopoDS_Face

    :type : OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.TopoDS.TopoDS_Face

    """
    return _TopoDS.TopoDS__Face(*args)

def TopoDS__Shell(*args):
    """
    Shell(TopoDS_Shape S) -> TopoDS_Shell
    TopoDS__Shell(TopoDS_Shape arg2) -> TopoDS_Shell

    :type : OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.TopoDS.TopoDS_Shell

    """
    return _TopoDS.TopoDS__Shell(*args)

def TopoDS__Solid(*args):
    """
    Solid(TopoDS_Shape S) -> TopoDS_Solid
    TopoDS__Solid(TopoDS_Shape arg2) -> TopoDS_Solid

    :type : OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.TopoDS.TopoDS_Solid

    """
    return _TopoDS.TopoDS__Solid(*args)

def TopoDS__CompSolid(*args):
    """
    CompSolid(TopoDS_Shape S) -> TopoDS_CompSolid
    TopoDS__CompSolid(TopoDS_Shape arg2) -> TopoDS_CompSolid

    :type : OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.TopoDS.TopoDS_CompSolid

    """
    return _TopoDS.TopoDS__CompSolid(*args)

def TopoDS__Compound(*args):
    """
    Compound(TopoDS_Shape S) -> TopoDS_Compound
    TopoDS__Compound(TopoDS_Shape arg2) -> TopoDS_Compound

    :type : OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.TopoDS.TopoDS_Compound

    """
    return _TopoDS.TopoDS__Compound(*args)

class NCollection_List_TopoDS_Shape(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_TopoDS_Shape self) -> NCollection_List< TopoDS_Shape >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _TopoDS.NCollection_List_TopoDS_Shape_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_TopoDS_Shape self) -> NCollection_List< TopoDS_Shape >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _TopoDS.NCollection_List_TopoDS_Shape_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_TopoDS_Shape self) -> NCollection_List< TopoDS_Shape >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _TopoDS.NCollection_List_TopoDS_Shape_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_TopoDS_Shape self) -> NCollection_List< TopoDS_Shape >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _TopoDS.NCollection_List_TopoDS_Shape_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _TopoDS.new_NCollection_List_TopoDS_Shape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_TopoDS_Shape self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopoDS.NCollection_List_TopoDS_Shape_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_TopoDS_Shape self, NCollection_List_TopoDS_Shape theOther) -> NCollection_List_TopoDS_Shape

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _TopoDS.NCollection_List_TopoDS_Shape_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_TopoDS_Shape self, NCollection_List_TopoDS_Shape theOther) -> NCollection_List_TopoDS_Shape

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _TopoDS.NCollection_List_TopoDS_Shape_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_TopoDS_Shape self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopoDS.NCollection_List_TopoDS_Shape_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _TopoDS.NCollection_List_TopoDS_Shape_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _TopoDS.NCollection_List_TopoDS_Shape_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_TopoDS_Shape self, TopoDS_Shape theItem) -> TopoDS_Shape
        Append(NCollection_List_TopoDS_Shape self, TopoDS_Shape theItem, NCollection_List< TopoDS_Shape >::Iterator & theIter)
        Append(NCollection_List_TopoDS_Shape self, NCollection_List_TopoDS_Shape theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _TopoDS.NCollection_List_TopoDS_Shape_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_TopoDS_Shape self, TopoDS_Shape theItem) -> TopoDS_Shape
        Prepend(NCollection_List_TopoDS_Shape self, NCollection_List_TopoDS_Shape theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _TopoDS.NCollection_List_TopoDS_Shape_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_TopoDS_Shape self)

        RemoveFirst item


        """
        return _TopoDS.NCollection_List_TopoDS_Shape_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_TopoDS_Shape self, NCollection_List< TopoDS_Shape >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _TopoDS.NCollection_List_TopoDS_Shape_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_TopoDS_Shape self, TopoDS_Shape theItem, NCollection_List< TopoDS_Shape >::Iterator & theIter) -> TopoDS_Shape
        InsertBefore(NCollection_List_TopoDS_Shape self, NCollection_List_TopoDS_Shape theOther, NCollection_List< TopoDS_Shape >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _TopoDS.NCollection_List_TopoDS_Shape_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_TopoDS_Shape self, TopoDS_Shape theItem, NCollection_List< TopoDS_Shape >::Iterator & theIter) -> TopoDS_Shape
        InsertAfter(NCollection_List_TopoDS_Shape self, NCollection_List_TopoDS_Shape theOther, NCollection_List< TopoDS_Shape >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _TopoDS.NCollection_List_TopoDS_Shape_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_TopoDS_Shape self)

        Reverse the list


        """
        return _TopoDS.NCollection_List_TopoDS_Shape_Reverse(self, *args)


    def __iter__(self):
        return _TopoDS.NCollection_List_TopoDS_Shape___iter__(self)
    __swig_destroy__ = _TopoDS.delete_NCollection_List_TopoDS_Shape
NCollection_List_TopoDS_Shape_swigregister = _TopoDS.NCollection_List_TopoDS_Shape_swigregister
NCollection_List_TopoDS_Shape_swigregister(NCollection_List_TopoDS_Shape)

class NCollection_List_TopoDS_Shape_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopoDS.new_NCollection_List_TopoDS_Shape_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopoDS.delete_NCollection_List_TopoDS_Shape_IteratorHelper

    def __next__(self):
        return _TopoDS.NCollection_List_TopoDS_Shape_IteratorHelper___next__(self)
NCollection_List_TopoDS_Shape_IteratorHelper_swigregister = _TopoDS.NCollection_List_TopoDS_Shape_IteratorHelper_swigregister
NCollection_List_TopoDS_Shape_IteratorHelper_swigregister(NCollection_List_TopoDS_Shape_IteratorHelper)


try:
	TopoDS_ListOfShape = NCollection_List_TopoDS_Shape
except NameError:
	pass # does not exist, probably ignored

class TopoDS_CompSolid(TopoDS_Shape):
    """
    Describes a composite solid which
    - references an underlying composite solid with the
    potential to be given a location and an orientation
    - has a location for the underlying composite solid,
    giving its placement in the local coordinate system
    - has an orientation for the underlying composite
    solid, in terms of its geometry (as opposed to
    orientation in relation to other shapes).
    Casts shape S to the more specialized return type, CompSolid.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopoDS_CompSolid self) -> TopoDS_CompSolid

        Constructs an Undefined CompSolid.


        """
        this = _TopoDS.new_TopoDS_CompSolid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopoDS.delete_TopoDS_CompSolid
TopoDS_CompSolid_swigregister = _TopoDS.TopoDS_CompSolid_swigregister
TopoDS_CompSolid_swigregister(TopoDS_CompSolid)

class TopoDS_TFace(TopoDS_TShape):
    """
    A  topological part  of a surface   or  of the  2D
    space.  The  boundary  is  a   set of  wires   and
    vertices.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopoDS_TFace
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopoDS_TFace(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TopoDS_TFace self) -> TopoDS_TFace

        Creates an empty TFace.


        """
        this = _TopoDS.new_TopoDS_TFace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ShapeType(self, *args):
        """
        ShapeType(TopoDS_TFace self) -> TopAbs_ShapeEnum

        returns FACE.

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopoDS.TopoDS_TFace_ShapeType(self, *args)


    def EmptyCopy(self, *args):
        """
        EmptyCopy(TopoDS_TFace self) -> Handle_TopoDS_TShape

        Returns an empty TFace.

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        return _TopoDS.TopoDS_TFace_EmptyCopy(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopoDS.TopoDS_TFace_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopoDS.TopoDS_TFace_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.TopoDS_TFace_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopoDS.delete_TopoDS_TFace
TopoDS_TFace_swigregister = _TopoDS.TopoDS_TFace_swigregister
TopoDS_TFace_swigregister(TopoDS_TFace)

def TopoDS_TFace_get_type_name(*args):
    """
    TopoDS_TFace_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopoDS.TopoDS_TFace_get_type_name(*args)

def TopoDS_TFace_get_type_descriptor(*args):
    """
    TopoDS_TFace_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopoDS.TopoDS_TFace_get_type_descriptor(*args)

class Handle_TopoDS_HShape(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopoDS_HShape self)

        Nullify the handle


        """
        return _TopoDS.Handle_TopoDS_HShape_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopoDS_HShape self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopoDS.Handle_TopoDS_HShape_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopoDS_HShape self, TopoDS_HShape thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopoDS.Handle_TopoDS_HShape_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopoDS_HShape self, Handle_TopoDS_HShape theHandle) -> Handle_TopoDS_HShape
        assign(Handle_TopoDS_HShape self, TopoDS_HShape thePtr) -> Handle_TopoDS_HShape
        assign(Handle_TopoDS_HShape self, Handle_TopoDS_HShape theHandle) -> Handle_TopoDS_HShape

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopoDS.Handle_TopoDS_HShape_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopoDS_HShape self) -> TopoDS_HShape

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopoDS.Handle_TopoDS_HShape_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopoDS_HShape self) -> TopoDS_HShape

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopoDS.Handle_TopoDS_HShape___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopoDS_HShape self) -> TopoDS_HShape

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopoDS.Handle_TopoDS_HShape___ref__(self, *args)


    def __hash__(self):
        return _TopoDS.Handle_TopoDS_HShape___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopoDS.Handle_TopoDS_HShape___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopoDS.new_Handle_TopoDS_HShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopoDS.Handle_TopoDS_HShape_DownCast)
    __swig_destroy__ = _TopoDS.delete_Handle_TopoDS_HShape

    def Shape(self, *args):
        """
        Returns a reference to a constant TopoDS_Shape based on this shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopoDS.Handle_TopoDS_HShape_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeShape(self, *args):
        """
        ChangeShape(Handle_TopoDS_HShape self) -> TopoDS_Shape

        Exchanges the TopoDS_Shape object defining this
        shape for another one referencing the same underlying shape
        Accesses the list of shapes within the underlying
        shape referenced by the TopoDS_Shape object.
        Returns a reference to a TopoDS_Shape based on
        this shape. The TopoDS_Shape can be modified.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopoDS.Handle_TopoDS_HShape_ChangeShape(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopoDS_HShape self) -> char const *

        :rtype: const char *

        """
        return _TopoDS.Handle_TopoDS_HShape_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.Handle_TopoDS_HShape_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.Handle_TopoDS_HShape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TopoDS_HShape self)

        Memory deallocator for transient classes


        """
        return _TopoDS.Handle_TopoDS_HShape_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopoDS_HShape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopoDS_HShape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.Handle_TopoDS_HShape_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopoDS_HShape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopoDS_HShape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.Handle_TopoDS_HShape_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopoDS_HShape self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopoDS.Handle_TopoDS_HShape_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopoDS_HShape self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopoDS.Handle_TopoDS_HShape_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopoDS_HShape self)

        Increments the reference counter of this object


        """
        return _TopoDS.Handle_TopoDS_HShape_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopoDS_HShape self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopoDS.Handle_TopoDS_HShape_DecrementRefCounter(self, *args)

Handle_TopoDS_HShape_swigregister = _TopoDS.Handle_TopoDS_HShape_swigregister
Handle_TopoDS_HShape_swigregister(Handle_TopoDS_HShape)

def Handle_TopoDS_HShape_DownCast(thing):
    return _TopoDS.Handle_TopoDS_HShape_DownCast(thing)
Handle_TopoDS_HShape_DownCast = _TopoDS.Handle_TopoDS_HShape_DownCast

class Handle_TopoDS_TFace(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopoDS_TFace self)

        Nullify the handle


        """
        return _TopoDS.Handle_TopoDS_TFace_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopoDS_TFace self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopoDS.Handle_TopoDS_TFace_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopoDS_TFace self, TopoDS_TFace thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopoDS.Handle_TopoDS_TFace_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopoDS_TFace self, Handle_TopoDS_TFace theHandle) -> Handle_TopoDS_TFace
        assign(Handle_TopoDS_TFace self, TopoDS_TFace thePtr) -> Handle_TopoDS_TFace
        assign(Handle_TopoDS_TFace self, Handle_TopoDS_TFace theHandle) -> Handle_TopoDS_TFace

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopoDS.Handle_TopoDS_TFace_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopoDS_TFace self) -> TopoDS_TFace

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopoDS.Handle_TopoDS_TFace_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopoDS_TFace self) -> TopoDS_TFace

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopoDS.Handle_TopoDS_TFace___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopoDS_TFace self) -> TopoDS_TFace

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopoDS.Handle_TopoDS_TFace___ref__(self, *args)


    def __hash__(self):
        return _TopoDS.Handle_TopoDS_TFace___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopoDS.Handle_TopoDS_TFace___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopoDS.new_Handle_TopoDS_TFace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopoDS.Handle_TopoDS_TFace_DownCast)
    __swig_destroy__ = _TopoDS.delete_Handle_TopoDS_TFace

    def ShapeType(self, *args):
        """
        ShapeType(Handle_TopoDS_TFace self) -> TopAbs_ShapeEnum

        returns FACE.

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopoDS.Handle_TopoDS_TFace_ShapeType(self, *args)


    def EmptyCopy(self, *args):
        """
        EmptyCopy(Handle_TopoDS_TFace self) -> Handle_TopoDS_TShape

        Returns an empty TFace.

        :rtype: OCC.wrapper.TopoDS.Handle_TopoDS_TShape

        """
        return _TopoDS.Handle_TopoDS_TFace_EmptyCopy(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopoDS_TFace self) -> char const *

        :rtype: const char *

        """
        return _TopoDS.Handle_TopoDS_TFace_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.Handle_TopoDS_TFace_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopoDS.Handle_TopoDS_TFace_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Free(self, *args):
        """
        Free(Handle_TopoDS_TFace self) -> Standard_Boolean
        Free(Handle_TopoDS_TFace self, Standard_Boolean const F)

        Sets the free flag.

        :type F: bool

        """
        return _TopoDS.Handle_TopoDS_TFace_Free(self, *args)


    def Locked(self, *args):
        """
        Locked(Handle_TopoDS_TFace self) -> Standard_Boolean
        Locked(Handle_TopoDS_TFace self, Standard_Boolean const F)

        Sets the locked flag.

        :type F: bool

        """
        return _TopoDS.Handle_TopoDS_TFace_Locked(self, *args)


    def Modified(self, *args):
        """
        Modified(Handle_TopoDS_TFace self) -> Standard_Boolean
        Modified(Handle_TopoDS_TFace self, Standard_Boolean const M)

        Sets the modification flag.

        :type M: bool

        """
        return _TopoDS.Handle_TopoDS_TFace_Modified(self, *args)


    def Checked(self, *args):
        """
        Checked(Handle_TopoDS_TFace self) -> Standard_Boolean
        Checked(Handle_TopoDS_TFace self, Standard_Boolean const C)

        Sets the checked flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TFace_Checked(self, *args)


    def Orientable(self, *args):
        """
        Orientable(Handle_TopoDS_TFace self) -> Standard_Boolean
        Orientable(Handle_TopoDS_TFace self, Standard_Boolean const C)

        Sets the orientability flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TFace_Orientable(self, *args)


    def Closed(self, *args):
        """
        Closed(Handle_TopoDS_TFace self) -> Standard_Boolean
        Closed(Handle_TopoDS_TFace self, Standard_Boolean const C)

        Sets the closedness flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TFace_Closed(self, *args)


    def Infinite(self, *args):
        """
        Infinite(Handle_TopoDS_TFace self) -> Standard_Boolean
        Infinite(Handle_TopoDS_TFace self, Standard_Boolean const C)

        Sets the infinity flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TFace_Infinite(self, *args)


    def Convex(self, *args):
        """
        Convex(Handle_TopoDS_TFace self) -> Standard_Boolean
        Convex(Handle_TopoDS_TFace self, Standard_Boolean const C)

        Sets the convexness flag.

        :type C: bool

        """
        return _TopoDS.Handle_TopoDS_TFace_Convex(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TopoDS_TFace self)

        Memory deallocator for transient classes


        """
        return _TopoDS.Handle_TopoDS_TFace_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopoDS_TFace self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopoDS_TFace self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.Handle_TopoDS_TFace_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopoDS_TFace self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopoDS_TFace self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopoDS.Handle_TopoDS_TFace_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopoDS_TFace self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopoDS.Handle_TopoDS_TFace_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopoDS_TFace self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopoDS.Handle_TopoDS_TFace_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopoDS_TFace self)

        Increments the reference counter of this object


        """
        return _TopoDS.Handle_TopoDS_TFace_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopoDS_TFace self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopoDS.Handle_TopoDS_TFace_DecrementRefCounter(self, *args)

Handle_TopoDS_TFace_swigregister = _TopoDS.Handle_TopoDS_TFace_swigregister
Handle_TopoDS_TFace_swigregister(Handle_TopoDS_TFace)

def Handle_TopoDS_TFace_DownCast(thing):
    return _TopoDS.Handle_TopoDS_TFace_DownCast(thing)
Handle_TopoDS_TFace_DownCast = _TopoDS.Handle_TopoDS_TFace_DownCast

class TopoDS_Builder(object):
    """
    A  Builder is used   to  create  Topological  Data
    Structures.It is the root of the Builder class hierarchy.

    There are three groups of methods in the Builder :

    The Make methods create Shapes.

    The Add method includes a Shape in another Shape.

    The Remove  method  removes a  Shape from an other
    Shape.

    The methods in Builder are not static. They can be
    redefined in inherited builders.

    This   Builder does not  provide   methods to Make
    Vertices,  Edges, Faces,  Shells  or Solids. These
    methods are  provided  in  the inherited  Builders
    as they must provide the geometry.

    The Add method check for the following rules :

    - Any SHAPE can be added in a COMPOUND.

    - Only SOLID can be added in a COMPSOLID.

    - Only SHELL, EDGE and VERTEX can be added in a SOLID.
    EDGE and VERTEX as to be INTERNAL or EXTERNAL.

    - Only FACE can be added in a SHELL.

    - Only WIRE and VERTEX can be added in a FACE.
    VERTEX as to be INTERNAL or EXTERNAL.

    - Only EDGE can be added in a WIRE.

    - Only VERTEX can be added in an EDGE.

    - Nothing can be added in a VERTEX.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def MakeWire(self, *args):
        """
        MakeWire(TopoDS_Builder self, TopoDS_Wire W)

        Make an empty Wire.

        :type W: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _TopoDS.TopoDS_Builder_MakeWire(self, *args)


    def MakeShell(self, *args):
        """
        MakeShell(TopoDS_Builder self, TopoDS_Shell S)

        Make an empty Shell.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shell

        """
        return _TopoDS.TopoDS_Builder_MakeShell(self, *args)


    def MakeSolid(self, *args):
        """
        MakeSolid(TopoDS_Builder self, TopoDS_Solid S)

        Make a Solid covering the whole 3D space.

        :type S: OCC.wrapper.TopoDS.TopoDS_Solid

        """
        return _TopoDS.TopoDS_Builder_MakeSolid(self, *args)


    def MakeCompSolid(self, *args):
        """
        MakeCompSolid(TopoDS_Builder self, TopoDS_CompSolid C)

        Make an empty Composite Solid.

        :type C: OCC.wrapper.TopoDS.TopoDS_CompSolid

        """
        return _TopoDS.TopoDS_Builder_MakeCompSolid(self, *args)


    def MakeCompound(self, *args):
        """
        MakeCompound(TopoDS_Builder self, TopoDS_Compound C)

        Make an empty Compound.

        :type C: OCC.wrapper.TopoDS.TopoDS_Compound

        """
        return _TopoDS.TopoDS_Builder_MakeCompound(self, *args)


    def Add(self, *args):
        """
        Add(TopoDS_Builder self, TopoDS_Shape S, TopoDS_Shape C)

        Add the Shape C in the Shape S.
        Exceptions
        - TopoDS_FrozenShape if S is not free and cannot be modified.
        - TopoDS__UnCompatibleShapes if S and C are not compatible.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type C: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopoDS.TopoDS_Builder_Add(self, *args)


    def Remove(self, *args):
        """
        Remove(TopoDS_Builder self, TopoDS_Shape S, TopoDS_Shape C)

        Remove the Shape C from the Shape S.
        Exceptions
        TopoDS_FrozenShape if S is frozen and cannot be modified.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type C: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopoDS.TopoDS_Builder_Remove(self, *args)


    def __init__(self):
        """
        A  Builder is used   to  create  Topological  Data
        Structures.It is the root of the Builder class hierarchy.

        There are three groups of methods in the Builder :

        The Make methods create Shapes.

        The Add method includes a Shape in another Shape.

        The Remove  method  removes a  Shape from an other
        Shape.

        The methods in Builder are not static. They can be
        redefined in inherited builders.

        This   Builder does not  provide   methods to Make
        Vertices,  Edges, Faces,  Shells  or Solids. These
        methods are  provided  in  the inherited  Builders
        as they must provide the geometry.

        The Add method check for the following rules :

        - Any SHAPE can be added in a COMPOUND.

        - Only SOLID can be added in a COMPSOLID.

        - Only SHELL, EDGE and VERTEX can be added in a SOLID.
        EDGE and VERTEX as to be INTERNAL or EXTERNAL.

        - Only FACE can be added in a SHELL.

        - Only WIRE and VERTEX can be added in a FACE.
        VERTEX as to be INTERNAL or EXTERNAL.

        - Only EDGE can be added in a WIRE.

        - Only VERTEX can be added in an EDGE.

        - Nothing can be added in a VERTEX.
        """
        this = _TopoDS.new_TopoDS_Builder()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopoDS.delete_TopoDS_Builder
TopoDS_Builder_swigregister = _TopoDS.TopoDS_Builder_swigregister
TopoDS_Builder_swigregister(TopoDS_Builder)




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_TopOpeBRepDS')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_TopOpeBRepDS')
    _TopOpeBRepDS = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_TopOpeBRepDS', [dirname(__file__)])
        except ImportError:
            import _TopOpeBRepDS
            return _TopOpeBRepDS
        try:
            _mod = imp.load_module('_TopOpeBRepDS', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _TopOpeBRepDS = swig_import_helper()
    del swig_import_helper
else:
    import _TopOpeBRepDS
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _TopOpeBRepDS.delete_SwigPyIterator

    def value(self):
        return _TopOpeBRepDS.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _TopOpeBRepDS.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _TopOpeBRepDS.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _TopOpeBRepDS.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _TopOpeBRepDS.SwigPyIterator_equal(self, x)

    def copy(self):
        return _TopOpeBRepDS.SwigPyIterator_copy(self)

    def next(self):
        return _TopOpeBRepDS.SwigPyIterator_next(self)

    def __next__(self):
        return _TopOpeBRepDS.SwigPyIterator___next__(self)

    def previous(self):
        return _TopOpeBRepDS.SwigPyIterator_previous(self)

    def advance(self, n):
        return _TopOpeBRepDS.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _TopOpeBRepDS.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _TopOpeBRepDS.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _TopOpeBRepDS.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _TopOpeBRepDS.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _TopOpeBRepDS.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _TopOpeBRepDS.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _TopOpeBRepDS.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _TopOpeBRepDS.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_TopOpeBRepDS.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _TopOpeBRepDS.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _TopOpeBRepDS.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepDS.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _TopOpeBRepDS.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _TopOpeBRepDS.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _TopOpeBRepDS.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _TopOpeBRepDS.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_TopOpeBRepDS.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _TopOpeBRepDS.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _TopOpeBRepDS.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepDS.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _TopOpeBRepDS.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _TopOpeBRepDS.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _TopOpeBRepDS.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _TopOpeBRepDS.ptr_to_number(item)
ptr_to_number = _TopOpeBRepDS.ptr_to_number

def HashCode(*args):
    return _TopOpeBRepDS.HashCode(*args)
HashCode = _TopOpeBRepDS.HashCode

def ptr_equal(a, b):
    return _TopOpeBRepDS.ptr_equal(a, b)
ptr_equal = _TopOpeBRepDS.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopOpeBRepTool
else:
    import TopOpeBRepTool
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopExp
else:
    import TopExp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepClass3d
else:
    import BRepClass3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurveSurface
else:
    import IntCurveSurface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Intf
else:
    import Intf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntAna
else:
    import IntAna
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntSurf
else:
    import IntSurf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurvesFace
else:
    import IntCurvesFace
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepAdaptor
else:
    import BRepAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dAdaptor
else:
    import Geom2dAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
TopOpeBRepDS_POINT = _TopOpeBRepDS.TopOpeBRepDS_POINT
TopOpeBRepDS_CURVE = _TopOpeBRepDS.TopOpeBRepDS_CURVE
TopOpeBRepDS_SURFACE = _TopOpeBRepDS.TopOpeBRepDS_SURFACE
TopOpeBRepDS_VERTEX = _TopOpeBRepDS.TopOpeBRepDS_VERTEX
TopOpeBRepDS_EDGE = _TopOpeBRepDS.TopOpeBRepDS_EDGE
TopOpeBRepDS_WIRE = _TopOpeBRepDS.TopOpeBRepDS_WIRE
TopOpeBRepDS_FACE = _TopOpeBRepDS.TopOpeBRepDS_FACE
TopOpeBRepDS_SHELL = _TopOpeBRepDS.TopOpeBRepDS_SHELL
TopOpeBRepDS_SOLID = _TopOpeBRepDS.TopOpeBRepDS_SOLID
TopOpeBRepDS_COMPSOLID = _TopOpeBRepDS.TopOpeBRepDS_COMPSOLID
TopOpeBRepDS_COMPOUND = _TopOpeBRepDS.TopOpeBRepDS_COMPOUND
TopOpeBRepDS_UNKNOWN = _TopOpeBRepDS.TopOpeBRepDS_UNKNOWN
TopOpeBRepDS_UNSHGEOMETRY = _TopOpeBRepDS.TopOpeBRepDS_UNSHGEOMETRY
TopOpeBRepDS_SAMEORIENTED = _TopOpeBRepDS.TopOpeBRepDS_SAMEORIENTED
TopOpeBRepDS_DIFFORIENTED = _TopOpeBRepDS.TopOpeBRepDS_DIFFORIENTED
TopOpeBRepDS_OK = _TopOpeBRepDS.TopOpeBRepDS_OK
TopOpeBRepDS_NOK = _TopOpeBRepDS.TopOpeBRepDS_NOK
class TopOpeBRepDS_Interference(Standard.Standard_Transient):
    """
    An interference    is   the   description  of  the
    attachment of  a new  geometry on a  geometry. For
    example an intersection point  on an Edge or on  a
    Curve.

    The Interference contains the following data :

    - Transition :  How the interference  separates the
    existing geometry in INSIDE and OUTSIDE.

    - SupportType : Type of  the object supporting the
    interference. (FACE, EDGE, VERTEX, SURFACE, CURVE).

    - Support :  Index  in the data  structure  of the
    object supporting the interference.

    - GeometryType  :   Type  of the  geometry of  the
    interference (SURFACE, CURVE, POINT).

    - Geometry : Index  in the data structure  of the
    geometry.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopOpeBRepDS_Interference
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopOpeBRepDS_Interference(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_Interference self) -> TopOpeBRepDS_Interference
        __init__(TopOpeBRepDS_Interference self, TopOpeBRepDS_Transition Transition, TopOpeBRepDS_Kind const SupportType, Standard_Integer const Support, TopOpeBRepDS_Kind const GeometryType, Standard_Integer const Geometry) -> TopOpeBRepDS_Interference
        __init__(TopOpeBRepDS_Interference self, Handle_TopOpeBRepDS_Interference I) -> TopOpeBRepDS_Interference

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_Interference(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ChangeTransition(self, *args):
        """
        ChangeTransition(TopOpeBRepDS_Interference self) -> TopOpeBRepDS_Transition

        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Interference_ChangeTransition(self, *args)


    def Transition(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_Interference_Transition(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GKGSKS(self, *args):
        """
        GKGSKS(TopOpeBRepDS_Interference self)

        return GeometryType + Geometry + SupportType + Support

        :type GK: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type G: int
        :type SK: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type S: int

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Interference_GKGSKS(self, *args)


    def SetGeometry(self, *args):
        """
        SetGeometry(TopOpeBRepDS_Interference self, Standard_Integer const GI)

        :type GI: int

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Interference_SetGeometry(self, *args)


    def SupportType(self, *args):
        """
        SupportType(TopOpeBRepDS_Interference self) -> TopOpeBRepDS_Kind
        SupportType(TopOpeBRepDS_Interference self, TopOpeBRepDS_Kind const ST)

        :type ST: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Interference_SupportType(self, *args)


    def Support(self, *args):
        """
        Support(TopOpeBRepDS_Interference self) -> Standard_Integer
        Support(TopOpeBRepDS_Interference self, Standard_Integer const S)

        :type S: int

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Interference_Support(self, *args)


    def GeometryType(self, *args):
        """
        GeometryType(TopOpeBRepDS_Interference self) -> TopOpeBRepDS_Kind
        GeometryType(TopOpeBRepDS_Interference self, TopOpeBRepDS_Kind const GT)

        :type GT: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Interference_GeometryType(self, *args)


    def Geometry(self, *args):
        """
        Geometry(TopOpeBRepDS_Interference self) -> Standard_Integer
        Geometry(TopOpeBRepDS_Interference self, Standard_Integer const G)

        :type G: int

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Interference_Geometry(self, *args)


    def HasSameSupport(self, *args):
        """
        HasSameSupport(TopOpeBRepDS_Interference self, Handle_TopOpeBRepDS_Interference Other) -> Standard_Boolean

        :type Other: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Interference_HasSameSupport(self, *args)


    def HasSameGeometry(self, *args):
        """
        HasSameGeometry(TopOpeBRepDS_Interference self, Handle_TopOpeBRepDS_Interference Other) -> Standard_Boolean

        :type Other: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Interference_HasSameGeometry(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Interference_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Interference_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_Interference_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_Interference
TopOpeBRepDS_Interference_swigregister = _TopOpeBRepDS.TopOpeBRepDS_Interference_swigregister
TopOpeBRepDS_Interference_swigregister(TopOpeBRepDS_Interference)

def TopOpeBRepDS_Interference_get_type_name(*args):
    """
    TopOpeBRepDS_Interference_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopOpeBRepDS.TopOpeBRepDS_Interference_get_type_name(*args)

def TopOpeBRepDS_Interference_get_type_descriptor(*args):
    """
    TopOpeBRepDS_Interference_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopOpeBRepDS.TopOpeBRepDS_Interference_get_type_descriptor(*args)

class TopOpeBRepDS_ShapeShapeInterference(TopOpeBRepDS_Interference):
    """Interference"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopOpeBRepDS_ShapeShapeInterference
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopOpeBRepDS_ShapeShapeInterference(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_ShapeShapeInterference self, TopOpeBRepDS_Transition T, TopOpeBRepDS_Kind const ST, Standard_Integer const S, TopOpeBRepDS_Kind const GT, Standard_Integer const G, Standard_Boolean const GBound, TopOpeBRepDS_Config const C) -> TopOpeBRepDS_ShapeShapeInterference

        a shape interfers on shape <G> with shape <S>.
        examples :
        create a ShapeShapeInterference describing :
        vertex V of edge E1 found on edge E2 :
        ST,S,GT,G = TopOpeBRepDS_EDGE,E2,TopOpeBRepDS_VERTEX,V

        create a ShapeShapeInterference describing
        vertex V of edge E found on face F :
        ST,S,GT,G = TopOpeBRepDS_FACE,F,TopOpeBRepDS_VERTEX,V

        <GBound> indicates if shape <G> is a bound of shape <S>.

        <SCC> :
        UNSH_GEOMETRY :
        <S> and <Ancestor> have any types,
        <S> and <Ancestor> don't share the same geometry
        SAME_ORIENTED :
        <S> and <Ancestor> have identical types,
        <S> and <Ancestor> orientations are IDENTICAL.
        DIFF_ORIENTED :
        <S> and <Ancestor> have identical types,
        <S> and <Ancestor> orientations are DIFFERENT.

        :type T: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition
        :type ST: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type S: int
        :type GT: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type G: int
        :type GBound: bool
        :type C: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Config

        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_ShapeShapeInterference(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Config(self, *args):
        """
        Config(TopOpeBRepDS_ShapeShapeInterference self) -> TopOpeBRepDS_Config

        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Config

        """
        return _TopOpeBRepDS.TopOpeBRepDS_ShapeShapeInterference_Config(self, *args)


    def GBound(self, *args):
        """
        GBound(TopOpeBRepDS_ShapeShapeInterference self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_ShapeShapeInterference_GBound(self, *args)


    def SetGBound(self, *args):
        """
        SetGBound(TopOpeBRepDS_ShapeShapeInterference self, Standard_Boolean const b)

        :type b: bool

        """
        return _TopOpeBRepDS.TopOpeBRepDS_ShapeShapeInterference_SetGBound(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopOpeBRepDS.TopOpeBRepDS_ShapeShapeInterference_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopOpeBRepDS.TopOpeBRepDS_ShapeShapeInterference_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_ShapeShapeInterference_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_ShapeShapeInterference
TopOpeBRepDS_ShapeShapeInterference_swigregister = _TopOpeBRepDS.TopOpeBRepDS_ShapeShapeInterference_swigregister
TopOpeBRepDS_ShapeShapeInterference_swigregister(TopOpeBRepDS_ShapeShapeInterference)

def TopOpeBRepDS_ShapeShapeInterference_get_type_name(*args):
    """
    TopOpeBRepDS_ShapeShapeInterference_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopOpeBRepDS.TopOpeBRepDS_ShapeShapeInterference_get_type_name(*args)

def TopOpeBRepDS_ShapeShapeInterference_get_type_descriptor(*args):
    """
    TopOpeBRepDS_ShapeShapeInterference_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopOpeBRepDS.TopOpeBRepDS_ShapeShapeInterference_get_type_descriptor(*args)

class TopOpeBRepDS_GeometryData(object):
    """mother-class of SurfaceData, CurveData, PointData"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_GeometryData self) -> TopOpeBRepDS_GeometryData
        __init__(TopOpeBRepDS_GeometryData self, TopOpeBRepDS_GeometryData Other) -> TopOpeBRepDS_GeometryData

        :type Other: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_GeometryData

        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_GeometryData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Assign(self, *args):
        """
        Assign(TopOpeBRepDS_GeometryData self, TopOpeBRepDS_GeometryData Other)

        :type Other: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_GeometryData

        """
        return _TopOpeBRepDS.TopOpeBRepDS_GeometryData_Assign(self, *args)


    def assign(self, *args):
        """
        assign(TopOpeBRepDS_GeometryData self, TopOpeBRepDS_GeometryData Other)

        :type Other: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_GeometryData

        """
        return _TopOpeBRepDS.TopOpeBRepDS_GeometryData_assign(self, *args)


    def Interferences(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_GeometryData_Interferences(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeInterferences(self, *args):
        """
        ChangeInterferences(TopOpeBRepDS_GeometryData self) -> NCollection_List_Handle_TopOpeBRepDS_Interference

        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_GeometryData_ChangeInterferences(self, *args)


    def AddInterference(self, *args):
        """
        AddInterference(TopOpeBRepDS_GeometryData self, Handle_TopOpeBRepDS_Interference I)

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_GeometryData_AddInterference(self, *args)

    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_GeometryData
TopOpeBRepDS_GeometryData_swigregister = _TopOpeBRepDS.TopOpeBRepDS_GeometryData_swigregister
TopOpeBRepDS_GeometryData_swigregister(TopOpeBRepDS_GeometryData)

class TopOpeBRepDS_GapTool(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopOpeBRepDS_GapTool
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopOpeBRepDS_GapTool(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_GapTool self) -> TopOpeBRepDS_GapTool
        __init__(TopOpeBRepDS_GapTool self, Handle_TopOpeBRepDS_HDataStructure HDS) -> TopOpeBRepDS_GapTool

        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure

        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_GapTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(TopOpeBRepDS_GapTool self, Handle_TopOpeBRepDS_HDataStructure HDS)

        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure

        """
        return _TopOpeBRepDS.TopOpeBRepDS_GapTool_Init(self, *args)


    def Interferences(self, *args):
        """
        :type IndexPoint: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_GapTool_Interferences(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SameInterferences(self, *args):
        """
        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_GapTool_SameInterferences(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSameInterferences(self, *args):
        """
        ChangeSameInterferences(TopOpeBRepDS_GapTool self, Handle_TopOpeBRepDS_Interference I) -> NCollection_List_Handle_TopOpeBRepDS_Interference

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_GapTool_ChangeSameInterferences(self, *args)


    def Curve(self, *args):
        """
        Curve(TopOpeBRepDS_GapTool self, Handle_TopOpeBRepDS_Interference I, TopOpeBRepDS_Curve C) -> Standard_Boolean

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :type C: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Curve
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_GapTool_Curve(self, *args)


    def EdgeSupport(self, *args):
        """
        EdgeSupport(TopOpeBRepDS_GapTool self, Handle_TopOpeBRepDS_Interference I, TopoDS_Shape E) -> Standard_Boolean

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :type E: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_GapTool_EdgeSupport(self, *args)


    def FacesSupport(self, *args):
        """
        FacesSupport(TopOpeBRepDS_GapTool self, Handle_TopOpeBRepDS_Interference I, TopoDS_Shape F1, TopoDS_Shape F2) -> Standard_Boolean

        Return les faces qui  ont genere la section origine
        de I

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :type F1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type F2: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_GapTool_FacesSupport(self, *args)


    def ParameterOnEdge(self, *args):
        """
        ParameterOnEdge(TopOpeBRepDS_GapTool self, Handle_TopOpeBRepDS_Interference I, TopoDS_Shape E) -> Standard_Boolean

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :type E: OCC.wrapper.TopoDS.TopoDS_Shape
        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_GapTool_ParameterOnEdge(self, *args)


    def SetPoint(self, *args):
        """
        SetPoint(TopOpeBRepDS_GapTool self, Handle_TopOpeBRepDS_Interference I, Standard_Integer const IndexPoint)

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :type IndexPoint: int

        """
        return _TopOpeBRepDS.TopOpeBRepDS_GapTool_SetPoint(self, *args)


    def SetParameterOnEdge(self, *args):
        """
        SetParameterOnEdge(TopOpeBRepDS_GapTool self, Handle_TopOpeBRepDS_Interference I, TopoDS_Shape E, Standard_Real const U)

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :type E: OCC.wrapper.TopoDS.TopoDS_Shape
        :type U: float

        """
        return _TopOpeBRepDS.TopOpeBRepDS_GapTool_SetParameterOnEdge(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopOpeBRepDS.TopOpeBRepDS_GapTool_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopOpeBRepDS.TopOpeBRepDS_GapTool_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_GapTool_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_GapTool
TopOpeBRepDS_GapTool_swigregister = _TopOpeBRepDS.TopOpeBRepDS_GapTool_swigregister
TopOpeBRepDS_GapTool_swigregister(TopOpeBRepDS_GapTool)

def TopOpeBRepDS_GapTool_get_type_name(*args):
    """
    TopOpeBRepDS_GapTool_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopOpeBRepDS.TopOpeBRepDS_GapTool_get_type_name(*args)

def TopOpeBRepDS_GapTool_get_type_descriptor(*args):
    """
    TopOpeBRepDS_GapTool_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopOpeBRepDS.TopOpeBRepDS_GapTool_get_type_descriptor(*args)

class TopOpeBRepDS_Point(object):
    """A Geom point and a tolerance."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_Point self) -> TopOpeBRepDS_Point
        __init__(TopOpeBRepDS_Point self, gp_Pnt P, Standard_Real const T) -> TopOpeBRepDS_Point
        __init__(TopOpeBRepDS_Point self, TopoDS_Shape S) -> TopOpeBRepDS_Point

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_Point(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsEqual(self, *args):
        """
        IsEqual(TopOpeBRepDS_Point self, TopOpeBRepDS_Point other) -> Standard_Boolean

        :type other: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Point
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Point_IsEqual(self, *args)


    def Point(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_Point_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangePoint(self, *args):
        """
        ChangePoint(TopOpeBRepDS_Point self) -> gp_Pnt

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Point_ChangePoint(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(TopOpeBRepDS_Point self) -> Standard_Real
        Tolerance(TopOpeBRepDS_Point self, Standard_Real const Tol)

        :type Tol: float

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Point_Tolerance(self, *args)


    def Keep(self, *args):
        """
        Keep(TopOpeBRepDS_Point self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Point_Keep(self, *args)


    def ChangeKeep(self, *args):
        """
        ChangeKeep(TopOpeBRepDS_Point self, Standard_Boolean const B)

        :type B: bool

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Point_ChangeKeep(self, *args)

    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_Point
TopOpeBRepDS_Point_swigregister = _TopOpeBRepDS.TopOpeBRepDS_Point_swigregister
TopOpeBRepDS_Point_swigregister(TopOpeBRepDS_Point)

class TopOpeBRepDS_EdgeVertexInterference(TopOpeBRepDS_ShapeShapeInterference):
    """An interference with a parameter (ShapeShapeInterference)."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopOpeBRepDS_EdgeVertexInterference
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopOpeBRepDS_EdgeVertexInterference(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_EdgeVertexInterference self, TopOpeBRepDS_Transition T, TopOpeBRepDS_Kind const ST, Standard_Integer const S, Standard_Integer const G, Standard_Boolean const GIsBound, TopOpeBRepDS_Config const C, Standard_Real const P) -> TopOpeBRepDS_EdgeVertexInterference
        __init__(TopOpeBRepDS_EdgeVertexInterference self, TopOpeBRepDS_Transition T, Standard_Integer const S, Standard_Integer const G, Standard_Boolean const GIsBound, TopOpeBRepDS_Config const C, Standard_Real const P) -> TopOpeBRepDS_EdgeVertexInterference

        Create an interference of VERTEX <G> on crossed EDGE <S>.

        <T> is the transition along the edge, crossing the crossed edge.
        <S> is the crossed edge.
        <GIsBound> indicates if <G> is a bound of the edge.
        <C> indicates the geometric configuration between
        the edge and the crossed edge.
        <P> is the parameter of <G> on the edge.

        interference is stored in the list of interfs of the edge.

        :type T: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition
        :type S: int
        :type G: int
        :type GIsBound: bool
        :type C: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Config
        :type P: float

        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_EdgeVertexInterference(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Parameter(self, *args):
        """
        Parameter(TopOpeBRepDS_EdgeVertexInterference self) -> Standard_Real
        Parameter(TopOpeBRepDS_EdgeVertexInterference self, Standard_Real const P)

        :type P: float

        """
        return _TopOpeBRepDS.TopOpeBRepDS_EdgeVertexInterference_Parameter(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopOpeBRepDS.TopOpeBRepDS_EdgeVertexInterference_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopOpeBRepDS.TopOpeBRepDS_EdgeVertexInterference_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_EdgeVertexInterference_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_EdgeVertexInterference
TopOpeBRepDS_EdgeVertexInterference_swigregister = _TopOpeBRepDS.TopOpeBRepDS_EdgeVertexInterference_swigregister
TopOpeBRepDS_EdgeVertexInterference_swigregister(TopOpeBRepDS_EdgeVertexInterference)

def TopOpeBRepDS_EdgeVertexInterference_get_type_name(*args):
    """
    TopOpeBRepDS_EdgeVertexInterference_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopOpeBRepDS.TopOpeBRepDS_EdgeVertexInterference_get_type_name(*args)

def TopOpeBRepDS_EdgeVertexInterference_get_type_descriptor(*args):
    """
    TopOpeBRepDS_EdgeVertexInterference_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopOpeBRepDS.TopOpeBRepDS_EdgeVertexInterference_get_type_descriptor(*args)

class TopOpeBRepDS_PointData(TopOpeBRepDS_GeometryData):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_PointData self) -> TopOpeBRepDS_PointData
        __init__(TopOpeBRepDS_PointData self, TopOpeBRepDS_Point P) -> TopOpeBRepDS_PointData
        __init__(TopOpeBRepDS_PointData self, TopOpeBRepDS_Point P, Standard_Integer const I1, Standard_Integer const I2) -> TopOpeBRepDS_PointData

        :type P: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Point
        :type I1: int
        :type I2: int

        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_PointData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetShapes(self, *args):
        """
        SetShapes(TopOpeBRepDS_PointData self, Standard_Integer const I1, Standard_Integer const I2)

        :type I1: int
        :type I2: int

        """
        return _TopOpeBRepDS.TopOpeBRepDS_PointData_SetShapes(self, *args)


    def GetShapes(self, *args):
        """
        GetShapes(TopOpeBRepDS_PointData self)

        :type I1: int
        :type I2: int

        """
        return _TopOpeBRepDS.TopOpeBRepDS_PointData_GetShapes(self, *args)

    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_PointData
TopOpeBRepDS_PointData_swigregister = _TopOpeBRepDS.TopOpeBRepDS_PointData_swigregister
TopOpeBRepDS_PointData_swigregister(TopOpeBRepDS_PointData)

class TopOpeBRepDS_SurfaceData(TopOpeBRepDS_GeometryData):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_SurfaceData self) -> TopOpeBRepDS_SurfaceData
        __init__(TopOpeBRepDS_SurfaceData self, TopOpeBRepDS_Surface S) -> TopOpeBRepDS_SurfaceData

        :type S: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Surface

        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_SurfaceData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_SurfaceData
TopOpeBRepDS_SurfaceData_swigregister = _TopOpeBRepDS.TopOpeBRepDS_SurfaceData_swigregister
TopOpeBRepDS_SurfaceData_swigregister(TopOpeBRepDS_SurfaceData)

class TopOpeBRepDS_ListOfShapeOn1State(object):
    """represent a list of shape"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_ListOfShapeOn1State self) -> TopOpeBRepDS_ListOfShapeOn1State

        represent a list of shape
        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_ListOfShapeOn1State(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ListOnState(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_ListOfShapeOn1State_ListOnState(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeListOnState(self, *args):
        """
        ChangeListOnState(TopOpeBRepDS_ListOfShapeOn1State self) -> NCollection_List_TopoDS_Shape

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _TopOpeBRepDS.TopOpeBRepDS_ListOfShapeOn1State_ChangeListOnState(self, *args)


    def IsSplit(self, *args):
        """
        IsSplit(TopOpeBRepDS_ListOfShapeOn1State self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_ListOfShapeOn1State_IsSplit(self, *args)


    def Split(self, *args):
        """
        Split(TopOpeBRepDS_ListOfShapeOn1State self, Standard_Boolean const B)

        :type B: bool

        """
        return _TopOpeBRepDS.TopOpeBRepDS_ListOfShapeOn1State_Split(self, *args)


    def Clear(self, *args):
        """Clear(TopOpeBRepDS_ListOfShapeOn1State self)"""
        return _TopOpeBRepDS.TopOpeBRepDS_ListOfShapeOn1State_Clear(self, *args)

    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_ListOfShapeOn1State
TopOpeBRepDS_ListOfShapeOn1State_swigregister = _TopOpeBRepDS.TopOpeBRepDS_ListOfShapeOn1State_swigregister
TopOpeBRepDS_ListOfShapeOn1State_swigregister(TopOpeBRepDS_ListOfShapeOn1State)

class TopOpeBRepDS_InterferenceIterator(object):
    """
    Iterate  on  interferences  of  a  list,  matching
    conditions  on   interferences.
    Nota   :
    inheritance  of   ListIteratorOfListOfInterference  from
    TopOpeBRepDS  has  not   been  done   because  of  the
    impossibility of naming  the classical  More, Next
    methods  which are declared as static in
    TCollection_ListIteratorOfList ... . ListIteratorOfList
    has benn placed as a field of InterferenceIterator.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_InterferenceIterator self) -> TopOpeBRepDS_InterferenceIterator
        __init__(TopOpeBRepDS_InterferenceIterator self, NCollection_List_Handle_TopOpeBRepDS_Interference L) -> TopOpeBRepDS_InterferenceIterator

        Creates an iterator on the Interference of list <L>.

        :type L: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_InterferenceIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(TopOpeBRepDS_InterferenceIterator self, NCollection_List_Handle_TopOpeBRepDS_Interference L)

        re-initialize  interference iteration  process  on
        the list of interference <L>.
        Conditions are not modified.

        :type L: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_InterferenceIterator_Init(self, *args)


    def GeometryKind(self, *args):
        """
        GeometryKind(TopOpeBRepDS_InterferenceIterator self, TopOpeBRepDS_Kind const GK)

        define a condition on interference iteration process.
        Interference must match the Geometry Kind <ST>

        :type GK: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind

        """
        return _TopOpeBRepDS.TopOpeBRepDS_InterferenceIterator_GeometryKind(self, *args)


    def Geometry(self, *args):
        """
        Geometry(TopOpeBRepDS_InterferenceIterator self, Standard_Integer const G)

        define a condition on interference iteration process.
        Interference must match the Geometry <G>

        :type G: int

        """
        return _TopOpeBRepDS.TopOpeBRepDS_InterferenceIterator_Geometry(self, *args)


    def SupportKind(self, *args):
        """
        SupportKind(TopOpeBRepDS_InterferenceIterator self, TopOpeBRepDS_Kind const ST)

        define a condition on interference iteration process.
        Interference must match the Support Kind <ST>

        :type ST: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind

        """
        return _TopOpeBRepDS.TopOpeBRepDS_InterferenceIterator_SupportKind(self, *args)


    def Support(self, *args):
        """
        Support(TopOpeBRepDS_InterferenceIterator self, Standard_Integer const S)

        define a condition on interference iteration process.
        Interference must match the Support <S>

        :type S: int

        """
        return _TopOpeBRepDS.TopOpeBRepDS_InterferenceIterator_Support(self, *args)


    def Match(self, *args):
        """
        Match(TopOpeBRepDS_InterferenceIterator self)

        reach for an interference  matching the conditions
        (if  defined).


        """
        return _TopOpeBRepDS.TopOpeBRepDS_InterferenceIterator_Match(self, *args)


    def MatchInterference(self, *args):
        """
        MatchInterference(TopOpeBRepDS_InterferenceIterator self, Handle_TopOpeBRepDS_Interference I) -> Standard_Boolean

        Returns  True if the Interference <I>  matches the
        conditions (if defined).
        If no conditions defined, returns True.

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_InterferenceIterator_MatchInterference(self, *args)


    def More(self, *args):
        """
        More(TopOpeBRepDS_InterferenceIterator self) -> Standard_Boolean

        Returns True if there is a current Interference in
        the iteration.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_InterferenceIterator_More(self, *args)


    def Next(self, *args):
        """
        Next(TopOpeBRepDS_InterferenceIterator self)

        Move to the next Interference.


        """
        return _TopOpeBRepDS.TopOpeBRepDS_InterferenceIterator_Next(self, *args)


    def Value(self, *args):
        """
        Returns   the   current   Interference,   matching   the
        conditions  (if defined).

        :rtype: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_InterferenceIterator_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeIterator(self, *args):
        """
        ChangeIterator(TopOpeBRepDS_InterferenceIterator self) -> TopOpeBRepDS_ListIteratorOfListOfInterference &

        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListIteratorOfListOfInterference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_InterferenceIterator_ChangeIterator(self, *args)

    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_InterferenceIterator
TopOpeBRepDS_InterferenceIterator_swigregister = _TopOpeBRepDS.TopOpeBRepDS_InterferenceIterator_swigregister
TopOpeBRepDS_InterferenceIterator_swigregister(TopOpeBRepDS_InterferenceIterator)

class TopOpeBRepDS_Association(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopOpeBRepDS_Association
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopOpeBRepDS_Association(self) 
            return h


    def __init__(self, *args):
        """__init__(TopOpeBRepDS_Association self) -> TopOpeBRepDS_Association"""
        this = _TopOpeBRepDS.new_TopOpeBRepDS_Association(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Associate(self, *args):
        """
        Associate(TopOpeBRepDS_Association self, Handle_TopOpeBRepDS_Interference I, Handle_TopOpeBRepDS_Interference K)
        Associate(TopOpeBRepDS_Association self, Handle_TopOpeBRepDS_Interference I, NCollection_List_Handle_TopOpeBRepDS_Interference LI)

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :type LI: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Association_Associate(self, *args)


    def HasAssociation(self, *args):
        """
        HasAssociation(TopOpeBRepDS_Association self, Handle_TopOpeBRepDS_Interference I) -> Standard_Boolean

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Association_HasAssociation(self, *args)


    def Associated(self, *args):
        """
        Associated(TopOpeBRepDS_Association self, Handle_TopOpeBRepDS_Interference I) -> NCollection_List_Handle_TopOpeBRepDS_Interference

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Association_Associated(self, *args)


    def AreAssociated(self, *args):
        """
        AreAssociated(TopOpeBRepDS_Association self, Handle_TopOpeBRepDS_Interference I, Handle_TopOpeBRepDS_Interference K) -> Standard_Boolean

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :type K: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Association_AreAssociated(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Association_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Association_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_Association_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_Association
TopOpeBRepDS_Association_swigregister = _TopOpeBRepDS.TopOpeBRepDS_Association_swigregister
TopOpeBRepDS_Association_swigregister(TopOpeBRepDS_Association)

def TopOpeBRepDS_Association_get_type_name(*args):
    """
    TopOpeBRepDS_Association_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopOpeBRepDS.TopOpeBRepDS_Association_get_type_name(*args)

def TopOpeBRepDS_Association_get_type_descriptor(*args):
    """
    TopOpeBRepDS_Association_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopOpeBRepDS.TopOpeBRepDS_Association_get_type_descriptor(*args)

class TopOpeBRepDS_ShapeData(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(TopOpeBRepDS_ShapeData self) -> TopOpeBRepDS_ShapeData"""
        this = _TopOpeBRepDS.new_TopOpeBRepDS_ShapeData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Interferences(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_ShapeData_Interferences(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeInterferences(self, *args):
        """
        ChangeInterferences(TopOpeBRepDS_ShapeData self) -> NCollection_List_Handle_TopOpeBRepDS_Interference

        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_ShapeData_ChangeInterferences(self, *args)


    def Keep(self, *args):
        """
        Keep(TopOpeBRepDS_ShapeData self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_ShapeData_Keep(self, *args)


    def ChangeKeep(self, *args):
        """
        ChangeKeep(TopOpeBRepDS_ShapeData self, Standard_Boolean const B)

        :type B: bool

        """
        return _TopOpeBRepDS.TopOpeBRepDS_ShapeData_ChangeKeep(self, *args)

    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_ShapeData
TopOpeBRepDS_ShapeData_swigregister = _TopOpeBRepDS.TopOpeBRepDS_ShapeData_swigregister
TopOpeBRepDS_ShapeData_swigregister(TopOpeBRepDS_ShapeData)

class TopOpeBRepDS_HDataStructure(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopOpeBRepDS_HDataStructure
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopOpeBRepDS_HDataStructure(self) 
            return h


    def __init__(self, *args):
        """__init__(TopOpeBRepDS_HDataStructure self) -> TopOpeBRepDS_HDataStructure"""
        this = _TopOpeBRepDS.new_TopOpeBRepDS_HDataStructure(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def AddAncestors(self, *args):
        """
        AddAncestors(TopOpeBRepDS_HDataStructure self, TopoDS_Shape S)
        AddAncestors(TopOpeBRepDS_HDataStructure self, TopoDS_Shape S, TopAbs_ShapeEnum const T1, TopAbs_ShapeEnum const T2)

        Update  the data structure with  shapes of type T1
        containing a subshape of type T2 which is stored
        in the DS.
        Used by the previous one.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type T1: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type T2: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_AddAncestors(self, *args)


    def ChkIntg(self, *args):
        """
        ChkIntg(TopOpeBRepDS_HDataStructure self)

        Check the integrity of the DS


        """
        return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_ChkIntg(self, *args)


    def DS(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_DataStructure

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_DS(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeDS(self, *args):
        """
        ChangeDS(TopOpeBRepDS_HDataStructure self) -> TopOpeBRepDS_DataStructure

        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_DataStructure

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_ChangeDS(self, *args)


    def NbSurfaces(self, *args):
        """
        NbSurfaces(TopOpeBRepDS_HDataStructure self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_NbSurfaces(self, *args)


    def NbCurves(self, *args):
        """
        NbCurves(TopOpeBRepDS_HDataStructure self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_NbCurves(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(TopOpeBRepDS_HDataStructure self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_NbPoints(self, *args)


    def Surface(self, *args):
        """
        Returns the surface of index <I>.

        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Surface

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SurfaceCurves(self, *args):
        """
        SurfaceCurves(TopOpeBRepDS_HDataStructure self, Standard_Integer const I) -> TopOpeBRepDS_CurveIterator

        Returns an iterator  on the curves on  the surface
        <I>.

        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_CurveIterator

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_SurfaceCurves(self, *args)


    def Curve(self, *args):
        """
        Returns the Curve of index <I>.

        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Curve

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeCurve(self, *args):
        """
        ChangeCurve(TopOpeBRepDS_HDataStructure self, Standard_Integer const I) -> TopOpeBRepDS_Curve

        Returns the Curve of index <I>.

        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Curve

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_ChangeCurve(self, *args)


    def CurvePoints(self, *args):
        """
        CurvePoints(TopOpeBRepDS_HDataStructure self, Standard_Integer const I) -> TopOpeBRepDS_PointIterator

        Returns an iterator   on the points on  the  curve
        <I>.

        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_PointIterator

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_CurvePoints(self, *args)


    def Point(self, *args):
        """
        Returns the point of index <I>.

        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Point

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbShapes(self, *args):
        """
        NbShapes(TopOpeBRepDS_HDataStructure self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_NbShapes(self, *args)


    def Shape(self, *args):
        """
        Returns the shape of index <I> in the DS

        :type I: int
        :type FindKeep: bool
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasGeometry(self, *args):
        """
        HasGeometry(TopOpeBRepDS_HDataStructure self, TopoDS_Shape S) -> Standard_Boolean

        Returns True if <S> has new geometries.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_HasGeometry(self, *args)


    def HasShape(self, *args):
        """
        HasShape(TopOpeBRepDS_HDataStructure self, TopoDS_Shape S, Standard_Boolean const FindKeep) -> Standard_Boolean

        Returns True if <S> has new geometries (SOLID,FACE,EDGE)
        or if <S> (SHELL,WIRE) has sub-shape (FACE,EDGE)
        with new geometries

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type FindKeep: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_HasShape(self, *args)


    def HasSameDomain(self, *args):
        """
        HasSameDomain(TopOpeBRepDS_HDataStructure self, TopoDS_Shape S, Standard_Boolean const FindKeep) -> Standard_Boolean

        Returns True if <S> share a geometrical domain with
        some other shapes.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type FindKeep: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_HasSameDomain(self, *args)


    def SameDomain(self, *args):
        """
        SameDomain(TopOpeBRepDS_HDataStructure self, TopoDS_Shape S) -> TopTools_ListIteratorOfListOfShape

        Returns an iterator on the SameDomain shapes attached
        to the shape <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListIteratorOfListOfShape

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_SameDomain(self, *args)


    def SameDomainOrientation(self, *args):
        """
        SameDomainOrientation(TopOpeBRepDS_HDataStructure self, TopoDS_Shape S) -> TopOpeBRepDS_Config

        Returns orientation of shape <S> compared with its
        reference shape

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Config

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_SameDomainOrientation(self, *args)


    def SameDomainReference(self, *args):
        """
        SameDomainReference(TopOpeBRepDS_HDataStructure self, TopoDS_Shape S) -> Standard_Integer

        Returns orientation of shape <S> compared with its
        reference shape

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_SameDomainReference(self, *args)


    def SolidSurfaces(self, *args):
        """
        SolidSurfaces(TopOpeBRepDS_HDataStructure self, TopoDS_Shape S) -> TopOpeBRepDS_SurfaceIterator
        SolidSurfaces(TopOpeBRepDS_HDataStructure self, Standard_Integer const I) -> TopOpeBRepDS_SurfaceIterator

        Returns an iterator on the  surfaces attached to the
        solid <I>.

        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_SurfaceIterator

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_SolidSurfaces(self, *args)


    def FaceCurves(self, *args):
        """
        FaceCurves(TopOpeBRepDS_HDataStructure self, TopoDS_Shape F) -> TopOpeBRepDS_CurveIterator
        FaceCurves(TopOpeBRepDS_HDataStructure self, Standard_Integer const I) -> TopOpeBRepDS_CurveIterator

        Returns an iterator on the  curves attached to the
        face <I>.

        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_CurveIterator

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_FaceCurves(self, *args)


    def EdgePoints(self, *args):
        """
        EdgePoints(TopOpeBRepDS_HDataStructure self, TopoDS_Shape E) -> TopOpeBRepDS_PointIterator

        Returns an iterator on the points  attached to the
        edge <E>.

        :type E: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_PointIterator

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_EdgePoints(self, *args)


    def MakeCurve(self, *args):
        """
        MakeCurve(TopOpeBRepDS_HDataStructure self, TopOpeBRepDS_Curve C1, TopOpeBRepDS_Curve C2) -> Standard_Integer

        :type C1: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Curve
        :type C2: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Curve
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_MakeCurve(self, *args)


    def RemoveCurve(self, *args):
        """
        RemoveCurve(TopOpeBRepDS_HDataStructure self, Standard_Integer const iC)

        :type iC: int

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_RemoveCurve(self, *args)


    def NbGeometry(self, *args):
        """
        NbGeometry(TopOpeBRepDS_HDataStructure self, TopOpeBRepDS_Kind const K) -> Standard_Integer

        :type K: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_NbGeometry(self, *args)


    def NbTopology(self, *args):
        """
        NbTopology(TopOpeBRepDS_HDataStructure self, TopOpeBRepDS_Kind const K) -> Standard_Integer
        NbTopology(TopOpeBRepDS_HDataStructure self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_NbTopology(self, *args)


    def EdgesSameParameter(self, *args):
        """
        EdgesSameParameter(TopOpeBRepDS_HDataStructure self) -> Standard_Boolean

        returns True if all the edges stored as shapes in the DS
        are SameParameter, otherwise False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_EdgesSameParameter(self, *args)


    def SortOnParameter(self, *args):
        """
        SortOnParameter(TopOpeBRepDS_HDataStructure self, NCollection_List_Handle_TopOpeBRepDS_Interference L1, NCollection_List_Handle_TopOpeBRepDS_Interference L2)
        SortOnParameter(TopOpeBRepDS_HDataStructure self, NCollection_List_Handle_TopOpeBRepDS_Interference L)

        :type L: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_SortOnParameter(self, *args)


    def MinMaxOnParameter(self, *args):
        """
        MinMaxOnParameter(TopOpeBRepDS_HDataStructure self, NCollection_List_Handle_TopOpeBRepDS_Interference L)

        :type L: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference
        :type Min: float
        :type Max: float

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_MinMaxOnParameter(self, *args)


    def ScanInterfList(self, *args):
        """
        ScanInterfList(TopOpeBRepDS_HDataStructure self, TopOpeBRepDS_ListIteratorOfListOfInterference & IT, TopOpeBRepDS_Point PDS) -> Standard_Boolean

        Search, among a list of interferences accessed by the iterator
        <IT>, a geometry <G> whose 3D point is identical to the 3D point
        of the TheDSPoint <PDS>.
        returns True if such an interference has been found, False else.
        if True, iterator It points (by the Value() method) on the first
        interference accessing an identical 3D point.

        :type IT: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListIteratorOfListOfInterference
        :type PDS: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Point
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_ScanInterfList(self, *args)


    def GetGeometry(self, *args):
        """
        GetGeometry(TopOpeBRepDS_HDataStructure self, TopOpeBRepDS_ListIteratorOfListOfInterference & IT, TopOpeBRepDS_Point PDS) -> Standard_Boolean

        Get the geometry of a DS point <PDS>.
        Search for it with ScanInterfList (previous method).
        if found, set <G,K> to the geometry,kind of the interference found.
        returns the value of ScanInterfList().

        :type IT: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListIteratorOfListOfInterference
        :type PDS: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Point
        :type G: int
        :type K: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_GetGeometry(self, *args)


    def StoreInterference(self, *args):
        """
        StoreInterference(TopOpeBRepDS_HDataStructure self, Handle_TopOpeBRepDS_Interference I, NCollection_List_Handle_TopOpeBRepDS_Interference LI, TCollection_AsciiString str)
        StoreInterference(TopOpeBRepDS_HDataStructure self, Handle_TopOpeBRepDS_Interference I, TopoDS_Shape S, TCollection_AsciiString str)
        StoreInterference(TopOpeBRepDS_HDataStructure self, Handle_TopOpeBRepDS_Interference I, Standard_Integer const IS, TCollection_AsciiString str)

        Add interference <I> to list of interference of shape <IS>.

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :type IS: int
        :type str: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_StoreInterference(self, *args)


    def StoreInterferences(self, *args):
        """
        StoreInterferences(TopOpeBRepDS_HDataStructure self, NCollection_List_Handle_TopOpeBRepDS_Interference LI, TopoDS_Shape S, TCollection_AsciiString str)
        StoreInterferences(TopOpeBRepDS_HDataStructure self, NCollection_List_Handle_TopOpeBRepDS_Interference LI, Standard_Integer const IS, TCollection_AsciiString str)

        :type LI: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference
        :type IS: int
        :type str: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_StoreInterferences(self, *args)


    def ClearStoreInterferences(self, *args):
        """
        ClearStoreInterferences(TopOpeBRepDS_HDataStructure self, NCollection_List_Handle_TopOpeBRepDS_Interference LI, TopoDS_Shape S, TCollection_AsciiString str)
        ClearStoreInterferences(TopOpeBRepDS_HDataStructure self, NCollection_List_Handle_TopOpeBRepDS_Interference LI, Standard_Integer const IS, TCollection_AsciiString str)

        :type LI: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference
        :type IS: int
        :type str: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_ClearStoreInterferences(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_HDataStructure
TopOpeBRepDS_HDataStructure_swigregister = _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_swigregister
TopOpeBRepDS_HDataStructure_swigregister(TopOpeBRepDS_HDataStructure)

def TopOpeBRepDS_HDataStructure_get_type_name(*args):
    """
    TopOpeBRepDS_HDataStructure_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_get_type_name(*args)

def TopOpeBRepDS_HDataStructure_get_type_descriptor(*args):
    """
    TopOpeBRepDS_HDataStructure_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopOpeBRepDS.TopOpeBRepDS_HDataStructure_get_type_descriptor(*args)

class TopOpeBRepDS_SolidSurfaceInterference(TopOpeBRepDS_Interference):
    """Interference"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopOpeBRepDS_SolidSurfaceInterference
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopOpeBRepDS_SolidSurfaceInterference(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_SolidSurfaceInterference self, TopOpeBRepDS_Transition Transition, TopOpeBRepDS_Kind const SupportType, Standard_Integer const Support, TopOpeBRepDS_Kind const GeometryType, Standard_Integer const Geometry) -> TopOpeBRepDS_SolidSurfaceInterference

        :type Transition: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition
        :type SupportType: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type Support: int
        :type GeometryType: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type Geometry: int

        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_SolidSurfaceInterference(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopOpeBRepDS.TopOpeBRepDS_SolidSurfaceInterference_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopOpeBRepDS.TopOpeBRepDS_SolidSurfaceInterference_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_SolidSurfaceInterference_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_SolidSurfaceInterference
TopOpeBRepDS_SolidSurfaceInterference_swigregister = _TopOpeBRepDS.TopOpeBRepDS_SolidSurfaceInterference_swigregister
TopOpeBRepDS_SolidSurfaceInterference_swigregister(TopOpeBRepDS_SolidSurfaceInterference)

def TopOpeBRepDS_SolidSurfaceInterference_get_type_name(*args):
    """
    TopOpeBRepDS_SolidSurfaceInterference_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopOpeBRepDS.TopOpeBRepDS_SolidSurfaceInterference_get_type_name(*args)

def TopOpeBRepDS_SolidSurfaceInterference_get_type_descriptor(*args):
    """
    TopOpeBRepDS_SolidSurfaceInterference_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopOpeBRepDS.TopOpeBRepDS_SolidSurfaceInterference_get_type_descriptor(*args)

class TopOpeBRepDS_Check(Standard.Standard_Transient):
    """a tool verifing integrity and structure of DS"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopOpeBRepDS_Check
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopOpeBRepDS_Check(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_Check self) -> TopOpeBRepDS_Check
        __init__(TopOpeBRepDS_Check self, Handle_TopOpeBRepDS_HDataStructure HDS) -> TopOpeBRepDS_Check

        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure

        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_Check(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ChkIntg(self, *args):
        """
        ChkIntg(TopOpeBRepDS_Check self) -> Standard_Boolean

        Check integrition of DS

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Check_ChkIntg(self, *args)


    def ChkIntgInterf(self, *args):
        """
        ChkIntgInterf(TopOpeBRepDS_Check self, NCollection_List_Handle_TopOpeBRepDS_Interference LI) -> Standard_Boolean

        Check integrition of interferences
        (les supports et les geometries de LI)

        :type LI: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Check_ChkIntgInterf(self, *args)


    def CheckDS(self, *args):
        """
        CheckDS(TopOpeBRepDS_Check self, Standard_Integer const i, TopOpeBRepDS_Kind const K) -> Standard_Boolean

        Verifie que le ieme element de la DS existe, et
        pour un K de type topologique, verifie qu'il est du
        bon type (VERTEX, EDGE, WIRE, FACE, SHELL ou SOLID)

        :type i: int
        :type K: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Check_CheckDS(self, *args)


    def ChkIntgSamDom(self, *args):
        """
        ChkIntgSamDom(TopOpeBRepDS_Check self) -> Standard_Boolean

        Check integrition des champs SameDomain de la DS

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Check_ChkIntgSamDom(self, *args)


    def CheckShapes(self, *args):
        """
        CheckShapes(TopOpeBRepDS_Check self, NCollection_List_TopoDS_Shape LS) -> Standard_Boolean

        Verifie que les Shapes existent bien dans la DS
        Utile pour les Shapes SameDomain
        si la liste est vide, renvoie vrai

        :type LS: OCC.wrapper.TopTools.TopTools_ListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Check_CheckShapes(self, *args)


    def OneVertexOnPnt(self, *args):
        """
        OneVertexOnPnt(TopOpeBRepDS_Check self) -> Standard_Boolean

        Verifie que les Vertex   non   SameDomain sont bien
        nonSameDomain, que  les  vertex sameDomain sont  bien
        SameDomain,  que    les  Points sont  non    confondus
        ni entre eux, ni avec des Vertex.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Check_OneVertexOnPnt(self, *args)


    def HDS(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_Check_HDS(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeHDS(self, *args):
        """
        ChangeHDS(TopOpeBRepDS_Check self) -> Handle_TopOpeBRepDS_HDataStructure

        :rtype: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Check_ChangeHDS(self, *args)


    def PrintIntg(self, *args):
        """
        PrintIntg(TopOpeBRepDS_Check self, Standard_OStream & S) -> Standard_OStream &

        :type S: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Check_PrintIntg(self, *args)


    def Print(self, *args):
        """
        Print(TopOpeBRepDS_Check self, TopOpeBRepDS_CheckStatus const stat, Standard_OStream & S) -> Standard_OStream &

        Prints the name  of CheckStatus  <stat>  as  a String

        :type stat: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_CheckStatus
        :type S: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Check_Print(self, *args)


    def PrintShape(self, *args):
        """
        PrintShape(TopOpeBRepDS_Check self, TopAbs_ShapeEnum const SE, Standard_OStream & S) -> Standard_OStream
        PrintShape(TopOpeBRepDS_Check self, Standard_Integer const index, Standard_OStream & S) -> Standard_OStream &

        Prints the name  of CheckStatus  <stat>  as  a String

        :type index: int
        :type S: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Check_PrintShape(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Check_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Check_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_Check_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_Check
TopOpeBRepDS_Check_swigregister = _TopOpeBRepDS.TopOpeBRepDS_Check_swigregister
TopOpeBRepDS_Check_swigregister(TopOpeBRepDS_Check)

def TopOpeBRepDS_Check_get_type_name(*args):
    """
    TopOpeBRepDS_Check_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopOpeBRepDS.TopOpeBRepDS_Check_get_type_name(*args)

def TopOpeBRepDS_Check_get_type_descriptor(*args):
    """
    TopOpeBRepDS_Check_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopOpeBRepDS.TopOpeBRepDS_Check_get_type_descriptor(*args)

class TopOpeBRepDS_Explorer(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_Explorer self) -> TopOpeBRepDS_Explorer
        __init__(TopOpeBRepDS_Explorer self, Handle_TopOpeBRepDS_HDataStructure HDS, TopAbs_ShapeEnum const T=TopAbs_SHAPE, Standard_Boolean const findkeep) -> TopOpeBRepDS_Explorer

        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure
        :type T: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type findkeep: bool

        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_Explorer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(TopOpeBRepDS_Explorer self, Handle_TopOpeBRepDS_HDataStructure HDS, TopAbs_ShapeEnum const T=TopAbs_SHAPE, Standard_Boolean const findkeep)

        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure
        :type T: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type findkeep: bool

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Explorer_Init(self, *args)


    def Type(self, *args):
        """
        Type(TopOpeBRepDS_Explorer self) -> TopAbs_ShapeEnum

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Explorer_Type(self, *args)


    def More(self, *args):
        """
        More(TopOpeBRepDS_Explorer self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Explorer_More(self, *args)


    def Next(self, *args):
        """Next(TopOpeBRepDS_Explorer self)"""
        return _TopOpeBRepDS.TopOpeBRepDS_Explorer_Next(self, *args)


    def Current(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_Explorer_Current(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Index(self, *args):
        """
        Index(TopOpeBRepDS_Explorer self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Explorer_Index(self, *args)


    def Face(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_Explorer_Face(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Edge(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_Explorer_Edge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Vertex(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_Explorer_Vertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_Explorer
TopOpeBRepDS_Explorer_swigregister = _TopOpeBRepDS.TopOpeBRepDS_Explorer_swigregister
TopOpeBRepDS_Explorer_swigregister(TopOpeBRepDS_Explorer)

class TopOpeBRepDS_Filter(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_Filter self, Handle_TopOpeBRepDS_HDataStructure HDS, TopOpeBRepTool_ShapeClassifier pClassif=0) -> TopOpeBRepDS_Filter

        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure
        :type pClassif: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_PShapeClassifier

        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_Filter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ProcessInterferences(self, *args):
        """ProcessInterferences(TopOpeBRepDS_Filter self)"""
        return _TopOpeBRepDS.TopOpeBRepDS_Filter_ProcessInterferences(self, *args)


    def ProcessFaceInterferences(self, *args):
        """
        ProcessFaceInterferences(TopOpeBRepDS_Filter self, NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher MEsp)
        ProcessFaceInterferences(TopOpeBRepDS_Filter self, Standard_Integer const I, NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher MEsp)

        :type I: int
        :type MEsp: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_DataMapOfShapeListOfShapeOn1State

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Filter_ProcessFaceInterferences(self, *args)


    def ProcessEdgeInterferences(self, *args):
        """
        ProcessEdgeInterferences(TopOpeBRepDS_Filter self)
        ProcessEdgeInterferences(TopOpeBRepDS_Filter self, Standard_Integer const I)

        :type I: int

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Filter_ProcessEdgeInterferences(self, *args)


    def ProcessCurveInterferences(self, *args):
        """
        ProcessCurveInterferences(TopOpeBRepDS_Filter self)
        ProcessCurveInterferences(TopOpeBRepDS_Filter self, Standard_Integer const I)

        :type I: int

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Filter_ProcessCurveInterferences(self, *args)

    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_Filter
TopOpeBRepDS_Filter_swigregister = _TopOpeBRepDS.TopOpeBRepDS_Filter_swigregister
TopOpeBRepDS_Filter_swigregister(TopOpeBRepDS_Filter)

class Handle_TopOpeBRepDS_GapTool(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopOpeBRepDS_GapTool self)

        Nullify the handle


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_GapTool_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopOpeBRepDS_GapTool self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_GapTool_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopOpeBRepDS_GapTool self, TopOpeBRepDS_GapTool thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_GapTool_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopOpeBRepDS_GapTool self, Handle_TopOpeBRepDS_GapTool theHandle) -> Handle_TopOpeBRepDS_GapTool
        assign(Handle_TopOpeBRepDS_GapTool self, TopOpeBRepDS_GapTool thePtr) -> Handle_TopOpeBRepDS_GapTool
        assign(Handle_TopOpeBRepDS_GapTool self, Handle_TopOpeBRepDS_GapTool theHandle) -> Handle_TopOpeBRepDS_GapTool

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_GapTool_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopOpeBRepDS_GapTool self) -> TopOpeBRepDS_GapTool

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_GapTool_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopOpeBRepDS_GapTool self) -> TopOpeBRepDS_GapTool

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_GapTool___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopOpeBRepDS_GapTool self) -> TopOpeBRepDS_GapTool

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_GapTool___ref__(self, *args)


    def __hash__(self):
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_GapTool___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopOpeBRepDS.Handle_TopOpeBRepDS_GapTool___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopOpeBRepDS.new_Handle_TopOpeBRepDS_GapTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopOpeBRepDS.Handle_TopOpeBRepDS_GapTool_DownCast)
    __swig_destroy__ = _TopOpeBRepDS.delete_Handle_TopOpeBRepDS_GapTool

    def Init(self, *args):
        """
        Init(Handle_TopOpeBRepDS_GapTool self, Handle_TopOpeBRepDS_HDataStructure HDS)

        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_GapTool_Init(self, *args)


    def Interferences(self, *args):
        """
        :type IndexPoint: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_GapTool_Interferences(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SameInterferences(self, *args):
        """
        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_GapTool_SameInterferences(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSameInterferences(self, *args):
        """
        ChangeSameInterferences(Handle_TopOpeBRepDS_GapTool self, Handle_TopOpeBRepDS_Interference I) -> NCollection_List_Handle_TopOpeBRepDS_Interference

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_GapTool_ChangeSameInterferences(self, *args)


    def Curve(self, *args):
        """
        Curve(Handle_TopOpeBRepDS_GapTool self, Handle_TopOpeBRepDS_Interference I, TopOpeBRepDS_Curve C) -> Standard_Boolean

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :type C: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Curve
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_GapTool_Curve(self, *args)


    def EdgeSupport(self, *args):
        """
        EdgeSupport(Handle_TopOpeBRepDS_GapTool self, Handle_TopOpeBRepDS_Interference I, TopoDS_Shape E) -> Standard_Boolean

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :type E: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_GapTool_EdgeSupport(self, *args)


    def FacesSupport(self, *args):
        """
        FacesSupport(Handle_TopOpeBRepDS_GapTool self, Handle_TopOpeBRepDS_Interference I, TopoDS_Shape F1, TopoDS_Shape F2) -> Standard_Boolean

        Return les faces qui  ont genere la section origine
        de I

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :type F1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type F2: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_GapTool_FacesSupport(self, *args)


    def ParameterOnEdge(self, *args):
        """
        ParameterOnEdge(Handle_TopOpeBRepDS_GapTool self, Handle_TopOpeBRepDS_Interference I, TopoDS_Shape E) -> Standard_Boolean

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :type E: OCC.wrapper.TopoDS.TopoDS_Shape
        :type U: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_GapTool_ParameterOnEdge(self, *args)


    def SetPoint(self, *args):
        """
        SetPoint(Handle_TopOpeBRepDS_GapTool self, Handle_TopOpeBRepDS_Interference I, Standard_Integer const IndexPoint)

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :type IndexPoint: int

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_GapTool_SetPoint(self, *args)


    def SetParameterOnEdge(self, *args):
        """
        SetParameterOnEdge(Handle_TopOpeBRepDS_GapTool self, Handle_TopOpeBRepDS_Interference I, TopoDS_Shape E, Standard_Real const U)

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :type E: OCC.wrapper.TopoDS.TopoDS_Shape
        :type U: float

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_GapTool_SetParameterOnEdge(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopOpeBRepDS_GapTool self) -> char const *

        :rtype: const char *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_GapTool_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_GapTool_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_GapTool_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TopOpeBRepDS_GapTool self)

        Memory deallocator for transient classes


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_GapTool_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopOpeBRepDS_GapTool self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopOpeBRepDS_GapTool self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_GapTool_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopOpeBRepDS_GapTool self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopOpeBRepDS_GapTool self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_GapTool_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopOpeBRepDS_GapTool self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_GapTool_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopOpeBRepDS_GapTool self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_GapTool_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopOpeBRepDS_GapTool self)

        Increments the reference counter of this object


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_GapTool_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopOpeBRepDS_GapTool self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_GapTool_DecrementRefCounter(self, *args)

Handle_TopOpeBRepDS_GapTool_swigregister = _TopOpeBRepDS.Handle_TopOpeBRepDS_GapTool_swigregister
Handle_TopOpeBRepDS_GapTool_swigregister(Handle_TopOpeBRepDS_GapTool)

def Handle_TopOpeBRepDS_GapTool_DownCast(thing):
    return _TopOpeBRepDS.Handle_TopOpeBRepDS_GapTool_DownCast(thing)
Handle_TopOpeBRepDS_GapTool_DownCast = _TopOpeBRepDS.Handle_TopOpeBRepDS_GapTool_DownCast

class TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference self, Standard_Integer const theLower, Standard_Integer const theUpper) -> TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference
        __init__(TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference self, Standard_Integer const theLower, Standard_Integer const theUpper, NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher theValue) -> TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference
        __init__(TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference self, NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference theOther) -> TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference

        :type theOther: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Array1OfDataMapOfIntegerListOfInterference

        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Array1OfDataMapOfIntegerListOfInterference

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference self) -> NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference

        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Array1OfDataMapOfIntegerListOfInterference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopOpeBRepDS.TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference
TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_swigregister = _TopOpeBRepDS.TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_swigregister
TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_swigregister(TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference)

def TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_get_type_name(*args):
    """
    TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopOpeBRepDS.TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_get_type_name(*args)

def TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_get_type_descriptor(*args):
    """
    TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopOpeBRepDS.TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_get_type_descriptor(*args)

class NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference self) -> NCollection_Array1< TopOpeBRepDS_DataMapOfIntegerListOfInterference >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _TopOpeBRepDS.NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference self) -> NCollection_Array1< TopOpeBRepDS_DataMapOfIntegerListOfInterference >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _TopOpeBRepDS.NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference self) -> NCollection_Array1< TopOpeBRepDS_DataMapOfIntegerListOfInterference >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _TopOpeBRepDS.NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference self) -> NCollection_Array1< TopOpeBRepDS_DataMapOfIntegerListOfInterference >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _TopOpeBRepDS.NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _TopOpeBRepDS.new_NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference self, NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _TopOpeBRepDS.NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference self, NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference theOther) -> NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TopOpeBRepDS.NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference self, NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference theOther) -> NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TopOpeBRepDS.NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference self, NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference theOther) -> NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference
        assign(NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference self, NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference theOther) -> NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TopOpeBRepDS.NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference self) -> NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher

        @return first element

        :rtype: TheItemType &

        """
        return _TopOpeBRepDS.NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference self) -> NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher

        @return last element

        :rtype: TheItemType &

        """
        return _TopOpeBRepDS.NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference self, Standard_Integer const theIndex) -> NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TopOpeBRepDS.NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference self, Standard_Integer const theIndex, NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TopOpeBRepDS.NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _TopOpeBRepDS.NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference_Resize(self, *args)

    __swig_destroy__ = _TopOpeBRepDS.delete_NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference
NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference_swigregister = _TopOpeBRepDS.NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference_swigregister
NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference_swigregister(NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference)


try:
	TopOpeBRepDS_Array1OfDataMapOfIntegerListOfInterference = NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference
except NameError:
	pass # does not exist, probably ignored

class NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopOpeBRepDS_Point,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopOpeBRepDS_Point,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopOpeBRepDS_Point,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopOpeBRepDS_Point,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _TopOpeBRepDS.new_NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1, TopOpeBRepDS_Point theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher self, Standard_Integer const theIndex, TopoDS_Shape theKey1, TopOpeBRepDS_Point theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher self)

        RemoveLast


        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher self, Standard_Integer const theIndex) -> TopOpeBRepDS_Point

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> TopOpeBRepDS_Point

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> TopOpeBRepDS_Point

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> TopOpeBRepDS_Point

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _TopOpeBRepDS.delete_NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher
NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_swigregister = _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher)

class NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopOpeBRepDS.new_NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepDS.delete_NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher_IteratorHelper)


try:
	TopOpeBRepDS_IndexedDataMapOfVertexPoint = NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_Point_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class TopOpeBRepDS_Marker(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopOpeBRepDS_Marker
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopOpeBRepDS_Marker(self) 
            return h


    def __init__(self, *args):
        """__init__(TopOpeBRepDS_Marker self) -> TopOpeBRepDS_Marker"""
        this = _TopOpeBRepDS.new_TopOpeBRepDS_Marker(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Reset(self, *args):
        """Reset(TopOpeBRepDS_Marker self)"""
        return _TopOpeBRepDS.TopOpeBRepDS_Marker_Reset(self, *args)


    def Set(self, *args):
        """
        Set(TopOpeBRepDS_Marker self, Standard_Integer const i, Standard_Boolean const b)
        Set(TopOpeBRepDS_Marker self, Standard_Boolean const b, Standard_Integer const n, Standard_Address const a)

        :type b: bool
        :type n: int
        :type a: OCC.wrapper.Standard.Standard_Address

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Marker_Set(self, *args)


    def GetI(self, *args):
        """
        GetI(TopOpeBRepDS_Marker self, Standard_Integer const i) -> Standard_Boolean

        :type i: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Marker_GetI(self, *args)


    def Allocate(self, *args):
        """
        Allocate(TopOpeBRepDS_Marker self, Standard_Integer const n)

        :type n: int

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Marker_Allocate(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Marker_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Marker_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_Marker_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_Marker
TopOpeBRepDS_Marker_swigregister = _TopOpeBRepDS.TopOpeBRepDS_Marker_swigregister
TopOpeBRepDS_Marker_swigregister(TopOpeBRepDS_Marker)

def TopOpeBRepDS_Marker_get_type_name(*args):
    """
    TopOpeBRepDS_Marker_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopOpeBRepDS.TopOpeBRepDS_Marker_get_type_name(*args)

def TopOpeBRepDS_Marker_get_type_descriptor(*args):
    """
    TopOpeBRepDS_Marker_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopOpeBRepDS.TopOpeBRepDS_Marker_get_type_descriptor(*args)


try:
	TColStd_MapIntegerHasher = TColStd.NCollection_DefaultHasher_Standard_Integer
except AttributeError:
	pass # does not exist, probably ignored

class NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TopOpeBRepDS_PointData,TColStd_MapIntegerHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TopOpeBRepDS_PointData,TColStd_MapIntegerHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TopOpeBRepDS_PointData,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TopOpeBRepDS_PointData,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TopOpeBRepDS.new_NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher self, int const & theKey, TopOpeBRepDS_PointData theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher self, int const & theKey, TopOpeBRepDS_PointData theItem) -> TopOpeBRepDS_PointData

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher self, int const & theKey) -> TopOpeBRepDS_PointData

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher self, int const & theKey) -> TopOpeBRepDS_PointData

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher self, int const & theKey) -> TopOpeBRepDS_PointData

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher_Size(self, *args)


    def __iter__(self):
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher___iter__(self)
    __swig_destroy__ = _TopOpeBRepDS.delete_NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher
NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher_swigregister = _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher_swigregister
NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher_swigregister(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher)

class NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopOpeBRepDS.new_NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepDS.delete_NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher_IteratorHelper

    def __next__(self):
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher_IteratorHelper___next__(self)
NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher_IteratorHelper_swigregister = _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher_IteratorHelper_swigregister
NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher_IteratorHelper_swigregister(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher_IteratorHelper)


try:
	TopOpeBRepDS_MapOfPoint = NCollection_DataMap_Standard_Integer_TopOpeBRepDS_PointData_TColStd_MapIntegerHasher
except NameError:
	pass # does not exist, probably ignored

class TopOpeBRepDS_FaceEdgeInterference(TopOpeBRepDS_ShapeShapeInterference):
    """ShapeShapeInterference"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopOpeBRepDS_FaceEdgeInterference
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopOpeBRepDS_FaceEdgeInterference(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_FaceEdgeInterference self, TopOpeBRepDS_Transition T, Standard_Integer const S, Standard_Integer const G, Standard_Boolean const GIsBound, TopOpeBRepDS_Config const C) -> TopOpeBRepDS_FaceEdgeInterference

        Create an interference of EDGE <G> on FACE <S>.

        :type T: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition
        :type S: int
        :type G: int
        :type GIsBound: bool
        :type C: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Config

        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_FaceEdgeInterference(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopOpeBRepDS.TopOpeBRepDS_FaceEdgeInterference_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopOpeBRepDS.TopOpeBRepDS_FaceEdgeInterference_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_FaceEdgeInterference_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_FaceEdgeInterference
TopOpeBRepDS_FaceEdgeInterference_swigregister = _TopOpeBRepDS.TopOpeBRepDS_FaceEdgeInterference_swigregister
TopOpeBRepDS_FaceEdgeInterference_swigregister(TopOpeBRepDS_FaceEdgeInterference)

def TopOpeBRepDS_FaceEdgeInterference_get_type_name(*args):
    """
    TopOpeBRepDS_FaceEdgeInterference_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopOpeBRepDS.TopOpeBRepDS_FaceEdgeInterference_get_type_name(*args)

def TopOpeBRepDS_FaceEdgeInterference_get_type_descriptor(*args):
    """
    TopOpeBRepDS_FaceEdgeInterference_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopOpeBRepDS.TopOpeBRepDS_FaceEdgeInterference_get_type_descriptor(*args)

class NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< Geom_Surface >,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< Geom_Surface >,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< Geom_Surface >,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< Geom_Surface >,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TopOpeBRepDS.new_NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, Handle_Geom_Surface theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, Handle_Geom_Surface theItem) -> Handle_Geom_Surface

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Handle_Geom_Surface

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Handle_Geom_Surface

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Handle_Geom_Surface

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _TopOpeBRepDS.delete_NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher_swigregister = _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopOpeBRepDS.new_NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepDS.delete_NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher_IteratorHelper)


try:
	TopOpeBRepDS_ShapeSurface = NCollection_DataMap_TopoDS_Shape_Handle_Geom_Surface_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class TopOpeBRepDS_Surface(object):
    """A Geom surface and a tolerance."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_Surface self) -> TopOpeBRepDS_Surface
        __init__(TopOpeBRepDS_Surface self, Handle_Geom_Surface P, Standard_Real const T) -> TopOpeBRepDS_Surface
        __init__(TopOpeBRepDS_Surface self, TopOpeBRepDS_Surface Other) -> TopOpeBRepDS_Surface

        :type Other: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Surface

        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_Surface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Assign(self, *args):
        """
        Assign(TopOpeBRepDS_Surface self, TopOpeBRepDS_Surface Other)

        :type Other: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Surface

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Surface_Assign(self, *args)


    def assign(self, *args):
        """
        assign(TopOpeBRepDS_Surface self, TopOpeBRepDS_Surface Other)

        :type Other: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Surface

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Surface_assign(self, *args)


    def Surface(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_Surface_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tolerance(self, *args):
        """
        Tolerance(TopOpeBRepDS_Surface self) -> Standard_Real
        Tolerance(TopOpeBRepDS_Surface self, Standard_Real const tol)

        Update the tolerance

        :type tol: float

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Surface_Tolerance(self, *args)


    def Keep(self, *args):
        """
        Keep(TopOpeBRepDS_Surface self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Surface_Keep(self, *args)


    def ChangeKeep(self, *args):
        """
        ChangeKeep(TopOpeBRepDS_Surface self, Standard_Boolean const B)

        :type B: bool

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Surface_ChangeKeep(self, *args)

    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_Surface
TopOpeBRepDS_Surface_swigregister = _TopOpeBRepDS.TopOpeBRepDS_Surface_swigregister
TopOpeBRepDS_Surface_swigregister(TopOpeBRepDS_Surface)

class TopOpeBRepDS_CurvePointInterference(TopOpeBRepDS_Interference):
    """An interference with a parameter."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopOpeBRepDS_CurvePointInterference
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopOpeBRepDS_CurvePointInterference(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_CurvePointInterference self, TopOpeBRepDS_Transition T, TopOpeBRepDS_Kind const ST, Standard_Integer const S, TopOpeBRepDS_Kind const GT, Standard_Integer const G, Standard_Real const P) -> TopOpeBRepDS_CurvePointInterference

        :type T: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition
        :type ST: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type S: int
        :type GT: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type G: int
        :type P: float

        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_CurvePointInterference(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Parameter(self, *args):
        """
        Parameter(TopOpeBRepDS_CurvePointInterference self) -> Standard_Real
        Parameter(TopOpeBRepDS_CurvePointInterference self, Standard_Real const P)

        :type P: float

        """
        return _TopOpeBRepDS.TopOpeBRepDS_CurvePointInterference_Parameter(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopOpeBRepDS.TopOpeBRepDS_CurvePointInterference_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopOpeBRepDS.TopOpeBRepDS_CurvePointInterference_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_CurvePointInterference_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_CurvePointInterference
TopOpeBRepDS_CurvePointInterference_swigregister = _TopOpeBRepDS.TopOpeBRepDS_CurvePointInterference_swigregister
TopOpeBRepDS_CurvePointInterference_swigregister(TopOpeBRepDS_CurvePointInterference)

def TopOpeBRepDS_CurvePointInterference_get_type_name(*args):
    """
    TopOpeBRepDS_CurvePointInterference_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopOpeBRepDS.TopOpeBRepDS_CurvePointInterference_get_type_name(*args)

def TopOpeBRepDS_CurvePointInterference_get_type_descriptor(*args):
    """
    TopOpeBRepDS_CurvePointInterference_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopOpeBRepDS.TopOpeBRepDS_CurvePointInterference_get_type_descriptor(*args)

class NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TopOpeBRepDS_ListOfInterference,TColStd_MapIntegerHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TopOpeBRepDS_ListOfInterference,TColStd_MapIntegerHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TopOpeBRepDS_ListOfInterference,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TopOpeBRepDS_ListOfInterference,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TopOpeBRepDS.new_NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher self, int const & theKey, NCollection_List_Handle_TopOpeBRepDS_Interference theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher self, int const & theKey, NCollection_List_Handle_TopOpeBRepDS_Interference theItem) -> NCollection_List_Handle_TopOpeBRepDS_Interference

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher self, int const & theKey) -> NCollection_List_Handle_TopOpeBRepDS_Interference

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher self, int const & theKey) -> NCollection_List_Handle_TopOpeBRepDS_Interference

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher self, int const & theKey) -> NCollection_List_Handle_TopOpeBRepDS_Interference

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher_Size(self, *args)


    def __iter__(self):
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher___iter__(self)
    __swig_destroy__ = _TopOpeBRepDS.delete_NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher
NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher_swigregister = _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher_swigregister
NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher_swigregister(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher)

class NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopOpeBRepDS.new_NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepDS.delete_NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher_IteratorHelper

    def __next__(self):
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher_IteratorHelper___next__(self)
NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher_IteratorHelper_swigregister = _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher_IteratorHelper_swigregister
NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher_IteratorHelper_swigregister(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher_IteratorHelper)


try:
	TopOpeBRepDS_DataMapOfIntegerListOfInterference = NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ListOfInterference_TColStd_MapIntegerHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< TopOpeBRepDS_Interference >,TopOpeBRepDS_ListOfInterference,TColStd_MapTransientHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< TopOpeBRepDS_Interference >,TopOpeBRepDS_ListOfInterference,TColStd_MapTransientHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< TopOpeBRepDS_Interference >,TopOpeBRepDS_ListOfInterference,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< TopOpeBRepDS_Interference >,TopOpeBRepDS_ListOfInterference,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TopOpeBRepDS.new_NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher self, Handle_TopOpeBRepDS_Interference theKey, NCollection_List_Handle_TopOpeBRepDS_Interference theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher self, Handle_TopOpeBRepDS_Interference theKey, NCollection_List_Handle_TopOpeBRepDS_Interference theItem) -> NCollection_List_Handle_TopOpeBRepDS_Interference

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher self, Handle_TopOpeBRepDS_Interference theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher self, Handle_TopOpeBRepDS_Interference theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher self, Handle_TopOpeBRepDS_Interference theKey) -> NCollection_List_Handle_TopOpeBRepDS_Interference

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher self, Handle_TopOpeBRepDS_Interference theKey) -> NCollection_List_Handle_TopOpeBRepDS_Interference

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher self, Handle_TopOpeBRepDS_Interference theKey) -> NCollection_List_Handle_TopOpeBRepDS_Interference

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher_Size(self, *args)


    def __iter__(self):
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher___iter__(self)
    __swig_destroy__ = _TopOpeBRepDS.delete_NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher
NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher_swigregister = _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher_swigregister
NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher_swigregister(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher)

class NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopOpeBRepDS.new_NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepDS.delete_NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher_IteratorHelper

    def __next__(self):
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher_IteratorHelper___next__(self)
NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher_IteratorHelper_swigregister = _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher_IteratorHelper_swigregister
NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher_IteratorHelper_swigregister(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher_IteratorHelper)


try:
	TopOpeBRepDS_DataMapOfInterferenceListOfInterference = NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopOpeBRepDS_ListOfInterference_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored

class TopOpeBRepDS_SurfaceIterator(TopOpeBRepDS_InterferenceIterator):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_SurfaceIterator self, NCollection_List_Handle_TopOpeBRepDS_Interference L) -> TopOpeBRepDS_SurfaceIterator

        Creates an  iterator on the  Surfaces on solid
        described by the interferences in <L>.

        :type L: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_SurfaceIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Current(self, *args):
        """
        Current(TopOpeBRepDS_SurfaceIterator self) -> Standard_Integer

        Index of the surface in the data structure.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_SurfaceIterator_Current(self, *args)


    def Orientation(self, *args):
        """
        Orientation(TopOpeBRepDS_SurfaceIterator self, TopAbs_State const S) -> TopAbs_Orientation

        :type S: OCC.wrapper.TopAbs.TopAbs_State
        :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _TopOpeBRepDS.TopOpeBRepDS_SurfaceIterator_Orientation(self, *args)

    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_SurfaceIterator
TopOpeBRepDS_SurfaceIterator_swigregister = _TopOpeBRepDS.TopOpeBRepDS_SurfaceIterator_swigregister
TopOpeBRepDS_SurfaceIterator_swigregister(TopOpeBRepDS_SurfaceIterator)

class NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopOpeBRepDS_ShapeData,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopOpeBRepDS_ShapeData,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopOpeBRepDS_ShapeData,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopOpeBRepDS_ShapeData,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _TopOpeBRepDS.new_NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1, TopOpeBRepDS_ShapeData theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher self, Standard_Integer const theIndex, TopoDS_Shape theKey1, TopOpeBRepDS_ShapeData theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher self)

        RemoveLast


        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher self, Standard_Integer const theIndex) -> TopOpeBRepDS_ShapeData

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> TopOpeBRepDS_ShapeData

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> TopOpeBRepDS_ShapeData

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> TopOpeBRepDS_ShapeData

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _TopOpeBRepDS.delete_NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher
NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_swigregister = _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher)

class NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopOpeBRepDS.new_NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepDS.delete_NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher_IteratorHelper)


try:
	TopOpeBRepDS_MapOfShapeData = NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class TopOpeBRepDS_Transition(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_Transition self) -> TopOpeBRepDS_Transition
        __init__(TopOpeBRepDS_Transition self, TopAbs_State const StateBefore, TopAbs_State const StateAfter, TopAbs_ShapeEnum const ShapeBefore=TopAbs_FACE, TopAbs_ShapeEnum const ShapeAfter=TopAbs_FACE) -> TopOpeBRepDS_Transition
        __init__(TopOpeBRepDS_Transition self, TopAbs_Orientation const O) -> TopOpeBRepDS_Transition

        :type O: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_Transition(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def StateBefore(self, *args):
        """
        StateBefore(TopOpeBRepDS_Transition self, TopAbs_State const S)

        :type S: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Transition_StateBefore(self, *args)


    def StateAfter(self, *args):
        """
        StateAfter(TopOpeBRepDS_Transition self, TopAbs_State const S)

        :type S: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Transition_StateAfter(self, *args)


    def Before(self, *args):
        """
        Before(TopOpeBRepDS_Transition self, TopAbs_State const S, TopAbs_ShapeEnum const ShapeBefore=TopAbs_FACE)
        Before(TopOpeBRepDS_Transition self) -> TopAbs_State

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Transition_Before(self, *args)


    def ONBefore(self, *args):
        """
        ONBefore(TopOpeBRepDS_Transition self) -> TopAbs_ShapeEnum

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Transition_ONBefore(self, *args)


    def After(self, *args):
        """
        After(TopOpeBRepDS_Transition self, TopAbs_State const S, TopAbs_ShapeEnum const ShapeAfter=TopAbs_FACE)
        After(TopOpeBRepDS_Transition self) -> TopAbs_State

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Transition_After(self, *args)


    def ONAfter(self, *args):
        """
        ONAfter(TopOpeBRepDS_Transition self) -> TopAbs_ShapeEnum

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Transition_ONAfter(self, *args)


    def ShapeBefore(self, *args):
        """
        ShapeBefore(TopOpeBRepDS_Transition self, TopAbs_ShapeEnum const SE)
        ShapeBefore(TopOpeBRepDS_Transition self) -> TopAbs_ShapeEnum

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Transition_ShapeBefore(self, *args)


    def ShapeAfter(self, *args):
        """
        ShapeAfter(TopOpeBRepDS_Transition self, TopAbs_ShapeEnum const SE)
        ShapeAfter(TopOpeBRepDS_Transition self) -> TopAbs_ShapeEnum

        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Transition_ShapeAfter(self, *args)


    def Index(self, *args):
        """
        Index(TopOpeBRepDS_Transition self, Standard_Integer const I)
        Index(TopOpeBRepDS_Transition self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Transition_Index(self, *args)


    def IndexBefore(self, *args):
        """
        IndexBefore(TopOpeBRepDS_Transition self, Standard_Integer const I)
        IndexBefore(TopOpeBRepDS_Transition self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Transition_IndexBefore(self, *args)


    def IndexAfter(self, *args):
        """
        IndexAfter(TopOpeBRepDS_Transition self, Standard_Integer const I)
        IndexAfter(TopOpeBRepDS_Transition self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Transition_IndexAfter(self, *args)


    def Set(self, *args):
        """
        Set(TopOpeBRepDS_Transition self, TopAbs_State const StateBefore, TopAbs_State const StateAfter, TopAbs_ShapeEnum const ShapeBefore=TopAbs_FACE, TopAbs_ShapeEnum const ShapeAfter=TopAbs_FACE)
        Set(TopOpeBRepDS_Transition self, TopAbs_Orientation const O)

        set the transition corresponding to orientation <O>

        O       Before  After

        FORWARD       OUT    IN
        REVERSED      IN     OUT
        INTERNAL      IN     IN
        EXTERNAL      OUT    OUT

        :type O: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Transition_Set(self, *args)


    def Orientation(self, *args):
        """
        Orientation(TopOpeBRepDS_Transition self, TopAbs_State const S, TopAbs_ShapeEnum const T=TopAbs_FACE) -> TopAbs_Orientation

        returns the orientation corresponding to state <S>

        Before and After not equal TopAbs_ON :
        --------------------------------------
        Before  After   Computed orientation

        S      not S   REVERSED (we leave state S)
        not S  S       FORWARD  (we enter state S)
        S      S       INTERNAL (we stay in state S)
        not S  not S   EXTERNAL (we stay outside state S)

        :type S: OCC.wrapper.TopAbs.TopAbs_State
        :type T: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Transition_Orientation(self, *args)


    def Complement(self, *args):
        """
        Complement(TopOpeBRepDS_Transition self) -> TopOpeBRepDS_Transition

        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Transition_Complement(self, *args)


    def IsUnknown(self, *args):
        """
        IsUnknown(TopOpeBRepDS_Transition self) -> Standard_Boolean

        returns True if both states are UNKNOWN

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Transition_IsUnknown(self, *args)

    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_Transition
TopOpeBRepDS_Transition_swigregister = _TopOpeBRepDS.TopOpeBRepDS_Transition_swigregister
TopOpeBRepDS_Transition_swigregister(TopOpeBRepDS_Transition)

class NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TopOpeBRepDS_ShapeData,TColStd_MapIntegerHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TopOpeBRepDS_ShapeData,TColStd_MapIntegerHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TopOpeBRepDS_ShapeData,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TopOpeBRepDS_ShapeData,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TopOpeBRepDS.new_NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher self, int const & theKey, TopOpeBRepDS_ShapeData theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher self, int const & theKey, TopOpeBRepDS_ShapeData theItem) -> TopOpeBRepDS_ShapeData

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher self, int const & theKey) -> TopOpeBRepDS_ShapeData

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher self, int const & theKey) -> TopOpeBRepDS_ShapeData

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher self, int const & theKey) -> TopOpeBRepDS_ShapeData

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher_Size(self, *args)


    def __iter__(self):
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher___iter__(self)
    __swig_destroy__ = _TopOpeBRepDS.delete_NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher
NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher_swigregister = _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher_swigregister
NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher_swigregister(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher)

class NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopOpeBRepDS.new_NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepDS.delete_NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher_IteratorHelper

    def __next__(self):
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher_IteratorHelper___next__(self)
NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher_IteratorHelper_swigregister = _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher_IteratorHelper_swigregister
NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher_IteratorHelper_swigregister(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher_IteratorHelper)


try:
	TopOpeBRepDS_MapOfIntegerShapeData = NCollection_DataMap_Standard_Integer_TopOpeBRepDS_ShapeData_TColStd_MapIntegerHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_TopOpeBRepDS_EdgeVertexInterference(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopOpeBRepDS_EdgeVertexInterference self)

        Nullify the handle


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopOpeBRepDS_EdgeVertexInterference self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopOpeBRepDS_EdgeVertexInterference self, TopOpeBRepDS_EdgeVertexInterference thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopOpeBRepDS_EdgeVertexInterference self, Handle_TopOpeBRepDS_EdgeVertexInterference theHandle) -> Handle_TopOpeBRepDS_EdgeVertexInterference
        assign(Handle_TopOpeBRepDS_EdgeVertexInterference self, TopOpeBRepDS_EdgeVertexInterference thePtr) -> Handle_TopOpeBRepDS_EdgeVertexInterference
        assign(Handle_TopOpeBRepDS_EdgeVertexInterference self, Handle_TopOpeBRepDS_EdgeVertexInterference theHandle) -> Handle_TopOpeBRepDS_EdgeVertexInterference

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopOpeBRepDS_EdgeVertexInterference self) -> TopOpeBRepDS_EdgeVertexInterference

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopOpeBRepDS_EdgeVertexInterference self) -> TopOpeBRepDS_EdgeVertexInterference

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopOpeBRepDS_EdgeVertexInterference self) -> TopOpeBRepDS_EdgeVertexInterference

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference___ref__(self, *args)


    def __hash__(self):
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopOpeBRepDS.new_Handle_TopOpeBRepDS_EdgeVertexInterference(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference_DownCast)
    __swig_destroy__ = _TopOpeBRepDS.delete_Handle_TopOpeBRepDS_EdgeVertexInterference

    def Parameter(self, *args):
        """
        Parameter(Handle_TopOpeBRepDS_EdgeVertexInterference self) -> Standard_Real
        Parameter(Handle_TopOpeBRepDS_EdgeVertexInterference self, Standard_Real const P)

        :type P: float

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference_Parameter(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopOpeBRepDS_EdgeVertexInterference self) -> char const *

        :rtype: const char *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Config(self, *args):
        """
        Config(Handle_TopOpeBRepDS_EdgeVertexInterference self) -> TopOpeBRepDS_Config

        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Config

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference_Config(self, *args)


    def GBound(self, *args):
        """
        GBound(Handle_TopOpeBRepDS_EdgeVertexInterference self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference_GBound(self, *args)


    def SetGBound(self, *args):
        """
        SetGBound(Handle_TopOpeBRepDS_EdgeVertexInterference self, Standard_Boolean const b)

        :type b: bool

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference_SetGBound(self, *args)


    def Transition(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference_Transition(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeTransition(self, *args):
        """
        ChangeTransition(Handle_TopOpeBRepDS_EdgeVertexInterference self) -> TopOpeBRepDS_Transition

        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference_ChangeTransition(self, *args)


    def GKGSKS(self, *args):
        """
        GKGSKS(Handle_TopOpeBRepDS_EdgeVertexInterference self)

        return GeometryType + Geometry + SupportType + Support

        :type GK: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type G: int
        :type SK: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type S: int

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference_GKGSKS(self, *args)


    def SupportType(self, *args):
        """
        SupportType(Handle_TopOpeBRepDS_EdgeVertexInterference self) -> TopOpeBRepDS_Kind
        SupportType(Handle_TopOpeBRepDS_EdgeVertexInterference self, TopOpeBRepDS_Kind const ST)

        :type ST: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference_SupportType(self, *args)


    def Support(self, *args):
        """
        Support(Handle_TopOpeBRepDS_EdgeVertexInterference self) -> Standard_Integer
        Support(Handle_TopOpeBRepDS_EdgeVertexInterference self, Standard_Integer const S)

        :type S: int

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference_Support(self, *args)


    def GeometryType(self, *args):
        """
        GeometryType(Handle_TopOpeBRepDS_EdgeVertexInterference self) -> TopOpeBRepDS_Kind
        GeometryType(Handle_TopOpeBRepDS_EdgeVertexInterference self, TopOpeBRepDS_Kind const GT)

        :type GT: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference_GeometryType(self, *args)


    def Geometry(self, *args):
        """
        Geometry(Handle_TopOpeBRepDS_EdgeVertexInterference self) -> Standard_Integer
        Geometry(Handle_TopOpeBRepDS_EdgeVertexInterference self, Standard_Integer const G)

        :type G: int

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference_Geometry(self, *args)


    def SetGeometry(self, *args):
        """
        SetGeometry(Handle_TopOpeBRepDS_EdgeVertexInterference self, Standard_Integer const GI)

        :type GI: int

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference_SetGeometry(self, *args)


    def HasSameSupport(self, *args):
        """
        HasSameSupport(Handle_TopOpeBRepDS_EdgeVertexInterference self, Handle_TopOpeBRepDS_Interference Other) -> Standard_Boolean

        :type Other: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference_HasSameSupport(self, *args)


    def HasSameGeometry(self, *args):
        """
        HasSameGeometry(Handle_TopOpeBRepDS_EdgeVertexInterference self, Handle_TopOpeBRepDS_Interference Other) -> Standard_Boolean

        :type Other: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference_HasSameGeometry(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TopOpeBRepDS_EdgeVertexInterference self)

        Memory deallocator for transient classes


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopOpeBRepDS_EdgeVertexInterference self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopOpeBRepDS_EdgeVertexInterference self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopOpeBRepDS_EdgeVertexInterference self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopOpeBRepDS_EdgeVertexInterference self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopOpeBRepDS_EdgeVertexInterference self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopOpeBRepDS_EdgeVertexInterference self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopOpeBRepDS_EdgeVertexInterference self)

        Increments the reference counter of this object


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopOpeBRepDS_EdgeVertexInterference self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference_DecrementRefCounter(self, *args)

Handle_TopOpeBRepDS_EdgeVertexInterference_swigregister = _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference_swigregister
Handle_TopOpeBRepDS_EdgeVertexInterference_swigregister(Handle_TopOpeBRepDS_EdgeVertexInterference)

def Handle_TopOpeBRepDS_EdgeVertexInterference_DownCast(thing):
    return _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference_DownCast(thing)
Handle_TopOpeBRepDS_EdgeVertexInterference_DownCast = _TopOpeBRepDS.Handle_TopOpeBRepDS_EdgeVertexInterference_DownCast

class NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TopOpeBRepDS_SurfaceData,TColStd_MapIntegerHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TopOpeBRepDS_SurfaceData,TColStd_MapIntegerHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TopOpeBRepDS_SurfaceData,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TopOpeBRepDS_SurfaceData,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TopOpeBRepDS.new_NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher self, int const & theKey, TopOpeBRepDS_SurfaceData theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher self, int const & theKey, TopOpeBRepDS_SurfaceData theItem) -> TopOpeBRepDS_SurfaceData

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher self, int const & theKey) -> TopOpeBRepDS_SurfaceData

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher self, int const & theKey) -> TopOpeBRepDS_SurfaceData

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher self, int const & theKey) -> TopOpeBRepDS_SurfaceData

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher_Size(self, *args)


    def __iter__(self):
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher___iter__(self)
    __swig_destroy__ = _TopOpeBRepDS.delete_NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher
NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher_swigregister = _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher_swigregister
NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher_swigregister(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher)

class NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopOpeBRepDS.new_NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepDS.delete_NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher_IteratorHelper

    def __next__(self):
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher_IteratorHelper___next__(self)
NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher_IteratorHelper_swigregister = _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher_IteratorHelper_swigregister
NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher_IteratorHelper_swigregister(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher_IteratorHelper)


try:
	TopOpeBRepDS_MapOfSurface = NCollection_DataMap_Standard_Integer_TopOpeBRepDS_SurfaceData_TColStd_MapIntegerHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_TopOpeBRepDS_Association(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopOpeBRepDS_Association self)

        Nullify the handle


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Association_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopOpeBRepDS_Association self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Association_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopOpeBRepDS_Association self, TopOpeBRepDS_Association thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Association_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopOpeBRepDS_Association self, Handle_TopOpeBRepDS_Association theHandle) -> Handle_TopOpeBRepDS_Association
        assign(Handle_TopOpeBRepDS_Association self, TopOpeBRepDS_Association thePtr) -> Handle_TopOpeBRepDS_Association
        assign(Handle_TopOpeBRepDS_Association self, Handle_TopOpeBRepDS_Association theHandle) -> Handle_TopOpeBRepDS_Association

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Association_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopOpeBRepDS_Association self) -> TopOpeBRepDS_Association

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Association_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopOpeBRepDS_Association self) -> TopOpeBRepDS_Association

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Association___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopOpeBRepDS_Association self) -> TopOpeBRepDS_Association

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Association___ref__(self, *args)


    def __hash__(self):
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Association___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopOpeBRepDS.Handle_TopOpeBRepDS_Association___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopOpeBRepDS.new_Handle_TopOpeBRepDS_Association(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopOpeBRepDS.Handle_TopOpeBRepDS_Association_DownCast)
    __swig_destroy__ = _TopOpeBRepDS.delete_Handle_TopOpeBRepDS_Association

    def Associate(self, *args):
        """
        Associate(Handle_TopOpeBRepDS_Association self, Handle_TopOpeBRepDS_Interference I, Handle_TopOpeBRepDS_Interference K)
        Associate(Handle_TopOpeBRepDS_Association self, Handle_TopOpeBRepDS_Interference I, NCollection_List_Handle_TopOpeBRepDS_Interference LI)

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :type LI: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Association_Associate(self, *args)


    def HasAssociation(self, *args):
        """
        HasAssociation(Handle_TopOpeBRepDS_Association self, Handle_TopOpeBRepDS_Interference I) -> Standard_Boolean

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Association_HasAssociation(self, *args)


    def Associated(self, *args):
        """
        Associated(Handle_TopOpeBRepDS_Association self, Handle_TopOpeBRepDS_Interference I) -> NCollection_List_Handle_TopOpeBRepDS_Interference

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Association_Associated(self, *args)


    def AreAssociated(self, *args):
        """
        AreAssociated(Handle_TopOpeBRepDS_Association self, Handle_TopOpeBRepDS_Interference I, Handle_TopOpeBRepDS_Interference K) -> Standard_Boolean

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :type K: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Association_AreAssociated(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopOpeBRepDS_Association self) -> char const *

        :rtype: const char *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Association_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_Association_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_Association_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TopOpeBRepDS_Association self)

        Memory deallocator for transient classes


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Association_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopOpeBRepDS_Association self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopOpeBRepDS_Association self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Association_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopOpeBRepDS_Association self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopOpeBRepDS_Association self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Association_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopOpeBRepDS_Association self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Association_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopOpeBRepDS_Association self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Association_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopOpeBRepDS_Association self)

        Increments the reference counter of this object


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Association_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopOpeBRepDS_Association self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Association_DecrementRefCounter(self, *args)

Handle_TopOpeBRepDS_Association_swigregister = _TopOpeBRepDS.Handle_TopOpeBRepDS_Association_swigregister
Handle_TopOpeBRepDS_Association_swigregister(Handle_TopOpeBRepDS_Association)

def Handle_TopOpeBRepDS_Association_DownCast(thing):
    return _TopOpeBRepDS.Handle_TopOpeBRepDS_Association_DownCast(thing)
Handle_TopOpeBRepDS_Association_DownCast = _TopOpeBRepDS.Handle_TopOpeBRepDS_Association_DownCast

class TopOpeBRepDS_FIR(object):
    """FaceInterferenceReducer"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_FIR self, Handle_TopOpeBRepDS_HDataStructure HDS) -> TopOpeBRepDS_FIR

        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure

        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_FIR(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ProcessFaceInterferences(self, *args):
        """
        ProcessFaceInterferences(TopOpeBRepDS_FIR self, NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher M)
        ProcessFaceInterferences(TopOpeBRepDS_FIR self, Standard_Integer const I, NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher M)

        :type I: int
        :type M: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_DataMapOfShapeListOfShapeOn1State

        """
        return _TopOpeBRepDS.TopOpeBRepDS_FIR_ProcessFaceInterferences(self, *args)

    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_FIR
TopOpeBRepDS_FIR_swigregister = _TopOpeBRepDS.TopOpeBRepDS_FIR_swigregister
TopOpeBRepDS_FIR_swigregister(TopOpeBRepDS_FIR)

class NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopAbs_State,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopAbs_State,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopAbs_State,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopAbs_State,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TopOpeBRepDS.new_NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, TopAbs_State const & theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, TopAbs_State const & theItem) -> TopAbs_State *

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> TopAbs_State const *

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> TopAbs_State *

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> TopAbs_State &

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _TopOpeBRepDS.delete_NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_swigregister = _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopOpeBRepDS.new_NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepDS.delete_NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher_IteratorHelper)


try:
	TopOpeBRepDS_DataMapOfShapeState = NCollection_DataMap_TopoDS_Shape_TopAbs_State_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class TopOpeBRepDS_TKI(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(TopOpeBRepDS_TKI self) -> TopOpeBRepDS_TKI"""
        this = _TopOpeBRepDS.new_TopOpeBRepDS_TKI(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Clear(self, *args):
        """Clear(TopOpeBRepDS_TKI self)"""
        return _TopOpeBRepDS.TopOpeBRepDS_TKI_Clear(self, *args)


    def FillOnGeometry(self, *args):
        """
        FillOnGeometry(TopOpeBRepDS_TKI self, NCollection_List_Handle_TopOpeBRepDS_Interference L)

        :type L: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_TKI_FillOnGeometry(self, *args)


    def FillOnSupport(self, *args):
        """
        FillOnSupport(TopOpeBRepDS_TKI self, NCollection_List_Handle_TopOpeBRepDS_Interference L)

        :type L: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_TKI_FillOnSupport(self, *args)


    def IsBound(self, *args):
        """
        IsBound(TopOpeBRepDS_TKI self, TopOpeBRepDS_Kind const K, Standard_Integer const G) -> Standard_Boolean

        :type K: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type G: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_TKI_IsBound(self, *args)


    def Interferences(self, *args):
        """
        :type K: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type G: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_TKI_Interferences(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeInterferences(self, *args):
        """
        ChangeInterferences(TopOpeBRepDS_TKI self, TopOpeBRepDS_Kind const K, Standard_Integer const G) -> NCollection_List_Handle_TopOpeBRepDS_Interference

        :type K: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type G: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_TKI_ChangeInterferences(self, *args)


    def HasInterferences(self, *args):
        """
        HasInterferences(TopOpeBRepDS_TKI self, TopOpeBRepDS_Kind const K, Standard_Integer const G) -> Standard_Boolean

        :type K: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type G: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_TKI_HasInterferences(self, *args)


    def Add(self, *args):
        """
        Add(TopOpeBRepDS_TKI self, TopOpeBRepDS_Kind const K, Standard_Integer const G)
        Add(TopOpeBRepDS_TKI self, TopOpeBRepDS_Kind const K, Standard_Integer const G, Handle_TopOpeBRepDS_Interference HI)

        :type K: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type G: int
        :type HI: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_TKI_Add(self, *args)


    def DumpTKIIterator(self, *args):
        """
        DumpTKIIterator(TopOpeBRepDS_TKI self, TCollection_AsciiString s1, TCollection_AsciiString s2)

        :type s1: OCC.wrapper.TCollection.TCollection_AsciiString
        :type s2: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _TopOpeBRepDS.TopOpeBRepDS_TKI_DumpTKIIterator(self, *args)


    def Init(self, *args):
        """Init(TopOpeBRepDS_TKI self)"""
        return _TopOpeBRepDS.TopOpeBRepDS_TKI_Init(self, *args)


    def More(self, *args):
        """
        More(TopOpeBRepDS_TKI self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_TKI_More(self, *args)


    def Next(self, *args):
        """Next(TopOpeBRepDS_TKI self)"""
        return _TopOpeBRepDS.TopOpeBRepDS_TKI_Next(self, *args)


    def Value(self, *args):
        """
        :type K: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type G: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_TKI_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(TopOpeBRepDS_TKI self) -> NCollection_List_Handle_TopOpeBRepDS_Interference

        :type K: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type G: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_TKI_ChangeValue(self, *args)

    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_TKI
TopOpeBRepDS_TKI_swigregister = _TopOpeBRepDS.TopOpeBRepDS_TKI_swigregister
TopOpeBRepDS_TKI_swigregister(TopOpeBRepDS_TKI)

class NCollection_List_Handle_TopOpeBRepDS_Interference(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_Handle_TopOpeBRepDS_Interference self) -> NCollection_List< opencascade::handle< TopOpeBRepDS_Interference > >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _TopOpeBRepDS.NCollection_List_Handle_TopOpeBRepDS_Interference_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_Handle_TopOpeBRepDS_Interference self) -> NCollection_List< opencascade::handle< TopOpeBRepDS_Interference > >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _TopOpeBRepDS.NCollection_List_Handle_TopOpeBRepDS_Interference_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_Handle_TopOpeBRepDS_Interference self) -> NCollection_List< opencascade::handle< TopOpeBRepDS_Interference > >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _TopOpeBRepDS.NCollection_List_Handle_TopOpeBRepDS_Interference_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_Handle_TopOpeBRepDS_Interference self) -> NCollection_List< opencascade::handle< TopOpeBRepDS_Interference > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _TopOpeBRepDS.NCollection_List_Handle_TopOpeBRepDS_Interference_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _TopOpeBRepDS.new_NCollection_List_Handle_TopOpeBRepDS_Interference(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_Handle_TopOpeBRepDS_Interference self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.NCollection_List_Handle_TopOpeBRepDS_Interference_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_Handle_TopOpeBRepDS_Interference self, NCollection_List_Handle_TopOpeBRepDS_Interference theOther) -> NCollection_List_Handle_TopOpeBRepDS_Interference

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _TopOpeBRepDS.NCollection_List_Handle_TopOpeBRepDS_Interference_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_Handle_TopOpeBRepDS_Interference self, NCollection_List_Handle_TopOpeBRepDS_Interference theOther) -> NCollection_List_Handle_TopOpeBRepDS_Interference

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _TopOpeBRepDS.NCollection_List_Handle_TopOpeBRepDS_Interference_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_Handle_TopOpeBRepDS_Interference self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopOpeBRepDS.NCollection_List_Handle_TopOpeBRepDS_Interference_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_List_Handle_TopOpeBRepDS_Interference_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_List_Handle_TopOpeBRepDS_Interference_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_Handle_TopOpeBRepDS_Interference self, Handle_TopOpeBRepDS_Interference theItem) -> Handle_TopOpeBRepDS_Interference
        Append(NCollection_List_Handle_TopOpeBRepDS_Interference self, Handle_TopOpeBRepDS_Interference theItem, NCollection_List< opencascade::handle< TopOpeBRepDS_Interference > >::Iterator & theIter)
        Append(NCollection_List_Handle_TopOpeBRepDS_Interference self, NCollection_List_Handle_TopOpeBRepDS_Interference theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _TopOpeBRepDS.NCollection_List_Handle_TopOpeBRepDS_Interference_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_Handle_TopOpeBRepDS_Interference self, Handle_TopOpeBRepDS_Interference theItem) -> Handle_TopOpeBRepDS_Interference
        Prepend(NCollection_List_Handle_TopOpeBRepDS_Interference self, NCollection_List_Handle_TopOpeBRepDS_Interference theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _TopOpeBRepDS.NCollection_List_Handle_TopOpeBRepDS_Interference_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_Handle_TopOpeBRepDS_Interference self)

        RemoveFirst item


        """
        return _TopOpeBRepDS.NCollection_List_Handle_TopOpeBRepDS_Interference_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_Handle_TopOpeBRepDS_Interference self, NCollection_List< opencascade::handle< TopOpeBRepDS_Interference > >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _TopOpeBRepDS.NCollection_List_Handle_TopOpeBRepDS_Interference_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_Handle_TopOpeBRepDS_Interference self, Handle_TopOpeBRepDS_Interference theItem, NCollection_List< opencascade::handle< TopOpeBRepDS_Interference > >::Iterator & theIter) -> Handle_TopOpeBRepDS_Interference
        InsertBefore(NCollection_List_Handle_TopOpeBRepDS_Interference self, NCollection_List_Handle_TopOpeBRepDS_Interference theOther, NCollection_List< opencascade::handle< TopOpeBRepDS_Interference > >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _TopOpeBRepDS.NCollection_List_Handle_TopOpeBRepDS_Interference_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_Handle_TopOpeBRepDS_Interference self, Handle_TopOpeBRepDS_Interference theItem, NCollection_List< opencascade::handle< TopOpeBRepDS_Interference > >::Iterator & theIter) -> Handle_TopOpeBRepDS_Interference
        InsertAfter(NCollection_List_Handle_TopOpeBRepDS_Interference self, NCollection_List_Handle_TopOpeBRepDS_Interference theOther, NCollection_List< opencascade::handle< TopOpeBRepDS_Interference > >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _TopOpeBRepDS.NCollection_List_Handle_TopOpeBRepDS_Interference_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_Handle_TopOpeBRepDS_Interference self)

        Reverse the list


        """
        return _TopOpeBRepDS.NCollection_List_Handle_TopOpeBRepDS_Interference_Reverse(self, *args)


    def __iter__(self):
        return _TopOpeBRepDS.NCollection_List_Handle_TopOpeBRepDS_Interference___iter__(self)
    __swig_destroy__ = _TopOpeBRepDS.delete_NCollection_List_Handle_TopOpeBRepDS_Interference
NCollection_List_Handle_TopOpeBRepDS_Interference_swigregister = _TopOpeBRepDS.NCollection_List_Handle_TopOpeBRepDS_Interference_swigregister
NCollection_List_Handle_TopOpeBRepDS_Interference_swigregister(NCollection_List_Handle_TopOpeBRepDS_Interference)

class NCollection_List_Handle_TopOpeBRepDS_Interference_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopOpeBRepDS.new_NCollection_List_Handle_TopOpeBRepDS_Interference_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepDS.delete_NCollection_List_Handle_TopOpeBRepDS_Interference_IteratorHelper

    def __next__(self):
        return _TopOpeBRepDS.NCollection_List_Handle_TopOpeBRepDS_Interference_IteratorHelper___next__(self)
NCollection_List_Handle_TopOpeBRepDS_Interference_IteratorHelper_swigregister = _TopOpeBRepDS.NCollection_List_Handle_TopOpeBRepDS_Interference_IteratorHelper_swigregister
NCollection_List_Handle_TopOpeBRepDS_Interference_IteratorHelper_swigregister(NCollection_List_Handle_TopOpeBRepDS_Interference_IteratorHelper)


try:
	TopOpeBRepDS_ListOfInterference = NCollection_List_Handle_TopOpeBRepDS_Interference
except NameError:
	pass # does not exist, probably ignored

class Handle_TopOpeBRepDS_CurvePointInterference(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopOpeBRepDS_CurvePointInterference self)

        Nullify the handle


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_CurvePointInterference_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopOpeBRepDS_CurvePointInterference self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_CurvePointInterference_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopOpeBRepDS_CurvePointInterference self, TopOpeBRepDS_CurvePointInterference thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_CurvePointInterference_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopOpeBRepDS_CurvePointInterference self, Handle_TopOpeBRepDS_CurvePointInterference theHandle) -> Handle_TopOpeBRepDS_CurvePointInterference
        assign(Handle_TopOpeBRepDS_CurvePointInterference self, TopOpeBRepDS_CurvePointInterference thePtr) -> Handle_TopOpeBRepDS_CurvePointInterference
        assign(Handle_TopOpeBRepDS_CurvePointInterference self, Handle_TopOpeBRepDS_CurvePointInterference theHandle) -> Handle_TopOpeBRepDS_CurvePointInterference

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_CurvePointInterference_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopOpeBRepDS_CurvePointInterference self) -> TopOpeBRepDS_CurvePointInterference

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_CurvePointInterference_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopOpeBRepDS_CurvePointInterference self) -> TopOpeBRepDS_CurvePointInterference

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_CurvePointInterference___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopOpeBRepDS_CurvePointInterference self) -> TopOpeBRepDS_CurvePointInterference

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_CurvePointInterference___ref__(self, *args)


    def __hash__(self):
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_CurvePointInterference___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopOpeBRepDS.Handle_TopOpeBRepDS_CurvePointInterference___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopOpeBRepDS.new_Handle_TopOpeBRepDS_CurvePointInterference(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopOpeBRepDS.Handle_TopOpeBRepDS_CurvePointInterference_DownCast)
    __swig_destroy__ = _TopOpeBRepDS.delete_Handle_TopOpeBRepDS_CurvePointInterference

    def Parameter(self, *args):
        """
        Parameter(Handle_TopOpeBRepDS_CurvePointInterference self) -> Standard_Real
        Parameter(Handle_TopOpeBRepDS_CurvePointInterference self, Standard_Real const P)

        :type P: float

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_CurvePointInterference_Parameter(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopOpeBRepDS_CurvePointInterference self) -> char const *

        :rtype: const char *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_CurvePointInterference_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_CurvePointInterference_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_CurvePointInterference_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transition(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_CurvePointInterference_Transition(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeTransition(self, *args):
        """
        ChangeTransition(Handle_TopOpeBRepDS_CurvePointInterference self) -> TopOpeBRepDS_Transition

        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_CurvePointInterference_ChangeTransition(self, *args)


    def GKGSKS(self, *args):
        """
        GKGSKS(Handle_TopOpeBRepDS_CurvePointInterference self)

        return GeometryType + Geometry + SupportType + Support

        :type GK: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type G: int
        :type SK: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type S: int

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_CurvePointInterference_GKGSKS(self, *args)


    def SupportType(self, *args):
        """
        SupportType(Handle_TopOpeBRepDS_CurvePointInterference self) -> TopOpeBRepDS_Kind
        SupportType(Handle_TopOpeBRepDS_CurvePointInterference self, TopOpeBRepDS_Kind const ST)

        :type ST: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_CurvePointInterference_SupportType(self, *args)


    def Support(self, *args):
        """
        Support(Handle_TopOpeBRepDS_CurvePointInterference self) -> Standard_Integer
        Support(Handle_TopOpeBRepDS_CurvePointInterference self, Standard_Integer const S)

        :type S: int

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_CurvePointInterference_Support(self, *args)


    def GeometryType(self, *args):
        """
        GeometryType(Handle_TopOpeBRepDS_CurvePointInterference self) -> TopOpeBRepDS_Kind
        GeometryType(Handle_TopOpeBRepDS_CurvePointInterference self, TopOpeBRepDS_Kind const GT)

        :type GT: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_CurvePointInterference_GeometryType(self, *args)


    def Geometry(self, *args):
        """
        Geometry(Handle_TopOpeBRepDS_CurvePointInterference self) -> Standard_Integer
        Geometry(Handle_TopOpeBRepDS_CurvePointInterference self, Standard_Integer const G)

        :type G: int

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_CurvePointInterference_Geometry(self, *args)


    def SetGeometry(self, *args):
        """
        SetGeometry(Handle_TopOpeBRepDS_CurvePointInterference self, Standard_Integer const GI)

        :type GI: int

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_CurvePointInterference_SetGeometry(self, *args)


    def HasSameSupport(self, *args):
        """
        HasSameSupport(Handle_TopOpeBRepDS_CurvePointInterference self, Handle_TopOpeBRepDS_Interference Other) -> Standard_Boolean

        :type Other: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_CurvePointInterference_HasSameSupport(self, *args)


    def HasSameGeometry(self, *args):
        """
        HasSameGeometry(Handle_TopOpeBRepDS_CurvePointInterference self, Handle_TopOpeBRepDS_Interference Other) -> Standard_Boolean

        :type Other: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_CurvePointInterference_HasSameGeometry(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TopOpeBRepDS_CurvePointInterference self)

        Memory deallocator for transient classes


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_CurvePointInterference_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopOpeBRepDS_CurvePointInterference self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopOpeBRepDS_CurvePointInterference self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_CurvePointInterference_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopOpeBRepDS_CurvePointInterference self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopOpeBRepDS_CurvePointInterference self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_CurvePointInterference_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopOpeBRepDS_CurvePointInterference self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_CurvePointInterference_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopOpeBRepDS_CurvePointInterference self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_CurvePointInterference_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopOpeBRepDS_CurvePointInterference self)

        Increments the reference counter of this object


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_CurvePointInterference_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopOpeBRepDS_CurvePointInterference self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_CurvePointInterference_DecrementRefCounter(self, *args)

Handle_TopOpeBRepDS_CurvePointInterference_swigregister = _TopOpeBRepDS.Handle_TopOpeBRepDS_CurvePointInterference_swigregister
Handle_TopOpeBRepDS_CurvePointInterference_swigregister(Handle_TopOpeBRepDS_CurvePointInterference)

def Handle_TopOpeBRepDS_CurvePointInterference_DownCast(thing):
    return _TopOpeBRepDS.Handle_TopOpeBRepDS_CurvePointInterference_DownCast(thing)
Handle_TopOpeBRepDS_CurvePointInterference_DownCast = _TopOpeBRepDS.Handle_TopOpeBRepDS_CurvePointInterference_DownCast

class TopOpeBRepDS_FaceInterferenceTool(object):
    """a tool computing complex transition on Face."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_FaceInterferenceTool self, TopOpeBRepDS_DataStructure P) -> TopOpeBRepDS_FaceInterferenceTool

        :type P: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_PDataStructure

        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_FaceInterferenceTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(TopOpeBRepDS_FaceInterferenceTool self, TopoDS_Shape FI, TopoDS_Shape E, Standard_Boolean const Eisnew, Handle_TopOpeBRepDS_Interference I)

        Eisnew = true if E is a new edge built on edge I->Geometry()
        false if E is shape <=> I->Geometry()

        :type FI: OCC.wrapper.TopoDS.TopoDS_Shape
        :type E: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Eisnew: bool
        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_FaceInterferenceTool_Init(self, *args)


    def Add(self, *args):
        """
        Add(TopOpeBRepDS_FaceInterferenceTool self, TopoDS_Shape FI, TopoDS_Shape F, TopoDS_Shape E, Standard_Boolean const Eisnew, Handle_TopOpeBRepDS_Interference I)
        Add(TopOpeBRepDS_FaceInterferenceTool self, TopoDS_Shape E, TopOpeBRepDS_Curve C, Handle_TopOpeBRepDS_Interference I)

        :type E: OCC.wrapper.TopoDS.TopoDS_Shape
        :type C: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Curve
        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_FaceInterferenceTool_Add(self, *args)


    def SetEdgePntPar(self, *args):
        """
        SetEdgePntPar(TopOpeBRepDS_FaceInterferenceTool self, gp_Pnt P, Standard_Real const par)

        :type P: OCC.wrapper.gp.gp_Pnt
        :type par: float

        """
        return _TopOpeBRepDS.TopOpeBRepDS_FaceInterferenceTool_SetEdgePntPar(self, *args)


    def GetEdgePntPar(self, *args):
        """
        GetEdgePntPar(TopOpeBRepDS_FaceInterferenceTool self, gp_Pnt P)

        :type P: OCC.wrapper.gp.gp_Pnt
        :type par: float

        """
        return _TopOpeBRepDS.TopOpeBRepDS_FaceInterferenceTool_GetEdgePntPar(self, *args)


    def IsEdgePntParDef(self, *args):
        """
        IsEdgePntParDef(TopOpeBRepDS_FaceInterferenceTool self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_FaceInterferenceTool_IsEdgePntParDef(self, *args)


    def Transition(self, *args):
        """
        Transition(TopOpeBRepDS_FaceInterferenceTool self, Handle_TopOpeBRepDS_Interference I)

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_FaceInterferenceTool_Transition(self, *args)

    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_FaceInterferenceTool
TopOpeBRepDS_FaceInterferenceTool_swigregister = _TopOpeBRepDS.TopOpeBRepDS_FaceInterferenceTool_swigregister
TopOpeBRepDS_FaceInterferenceTool_swigregister(TopOpeBRepDS_FaceInterferenceTool)

class NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DoubleMap  is used to  bind  pairs (Key1,Key2)
    and retrieve them in linear time.

    See Map from NCollection for a discussion about the number
    of buckets
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Purpose:     The DoubleMap  is used to  bind  pairs (Key1,Key2)
        and retrieve them in linear time.

        See Map from NCollection for a discussion about the number
        of buckets
        """
        this = _TopOpeBRepDS.new_NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher self, NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DoubleMap

        """
        return _TopOpeBRepDS.NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher self, NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher theOther) -> NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DoubleMap
        :rtype: OCC.wrapper.NCollection.NCollection_DoubleMap

        """
        return _TopOpeBRepDS.NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher self, NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher theOther) -> NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DoubleMap
        :rtype: OCC.wrapper.NCollection.NCollection_DoubleMap

        """
        return _TopOpeBRepDS.NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopOpeBRepDS.NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher self, int const & theKey1, TopoDS_Shape theKey2)

        Bind

        :type theKey1: const TheKey1Type &
        :type theKey2: const TheKey2Type &

        """
        return _TopOpeBRepDS.NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher_Bind(self, *args)


    def AreBound(self, *args):
        """
        AreBound(NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher self, int const & theKey1, TopoDS_Shape theKey2) -> Standard_Boolean

        * AreBound

        :type theKey1: const TheKey1Type &
        :type theKey2: const TheKey2Type &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher_AreBound(self, *args)


    def IsBound1(self, *args):
        """
        IsBound1(NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher self, int const & theKey1) -> Standard_Boolean

        IsBound1

        :type theKey1: const TheKey1Type &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher_IsBound1(self, *args)


    def IsBound2(self, *args):
        """
        IsBound2(NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher self, TopoDS_Shape theKey2) -> Standard_Boolean

        IsBound2

        :type theKey2: const TheKey2Type &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher_IsBound2(self, *args)


    def UnBind1(self, *args):
        """
        UnBind1(NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher self, int const & theKey1) -> Standard_Boolean

        UnBind1

        :type theKey1: const TheKey1Type &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher_UnBind1(self, *args)


    def UnBind2(self, *args):
        """
        UnBind2(NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher self, TopoDS_Shape theKey2) -> Standard_Boolean

        UnBind2

        :type theKey2: const TheKey2Type &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher_UnBind2(self, *args)


    def Find1(self, *args):
        """
        Find1

        :type theKey1: const TheKey1Type &
        :rtype: const TheKey2Type &

        """
        res = _TopOpeBRepDS.NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher_Find1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Find2(self, *args):
        """
        Find2

        :type theKey2: const TheKey2Type &
        :rtype: const TheKey1Type &

        """
        res = _TopOpeBRepDS.NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher_Find2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopOpeBRepDS.NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher_Size(self, *args)

    __swig_destroy__ = _TopOpeBRepDS.delete_NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher
NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher_swigregister = _TopOpeBRepDS.NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher_swigregister
NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher_swigregister(NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher)


try:
	TopOpeBRepDS_DoubleMapOfIntegerShape = NCollection_DoubleMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class TopOpeBRepDS_PointExplorer(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_PointExplorer self) -> TopOpeBRepDS_PointExplorer
        __init__(TopOpeBRepDS_PointExplorer self, TopOpeBRepDS_DataStructure DS, Standard_Boolean const FindOnlyKeep) -> TopOpeBRepDS_PointExplorer

        :type DS: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_DataStructure
        :type FindOnlyKeep: bool

        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_PointExplorer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(TopOpeBRepDS_PointExplorer self, TopOpeBRepDS_DataStructure DS, Standard_Boolean const FindOnlyKeep)

        :type DS: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_DataStructure
        :type FindOnlyKeep: bool

        """
        return _TopOpeBRepDS.TopOpeBRepDS_PointExplorer_Init(self, *args)


    def More(self, *args):
        """
        More(TopOpeBRepDS_PointExplorer self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_PointExplorer_More(self, *args)


    def Next(self, *args):
        """Next(TopOpeBRepDS_PointExplorer self)"""
        return _TopOpeBRepDS.TopOpeBRepDS_PointExplorer_Next(self, *args)


    def IsPoint(self, *args):
        """
        IsPoint(TopOpeBRepDS_PointExplorer self, Standard_Integer const I) -> Standard_Boolean

        :type I: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_PointExplorer_IsPoint(self, *args)


    def IsPointKeep(self, *args):
        """
        IsPointKeep(TopOpeBRepDS_PointExplorer self, Standard_Integer const I) -> Standard_Boolean

        :type I: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_PointExplorer_IsPointKeep(self, *args)


    def Point(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Point

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_PointExplorer_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbPoint(self, *args):
        """
        NbPoint(TopOpeBRepDS_PointExplorer self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_PointExplorer_NbPoint(self, *args)


    def Index(self, *args):
        """
        Index(TopOpeBRepDS_PointExplorer self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_PointExplorer_Index(self, *args)

    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_PointExplorer
TopOpeBRepDS_PointExplorer_swigregister = _TopOpeBRepDS.TopOpeBRepDS_PointExplorer_swigregister
TopOpeBRepDS_PointExplorer_swigregister(TopOpeBRepDS_PointExplorer)

class TopOpeBRepDS_CurveData(TopOpeBRepDS_GeometryData):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_CurveData self) -> TopOpeBRepDS_CurveData
        __init__(TopOpeBRepDS_CurveData self, TopOpeBRepDS_Curve C) -> TopOpeBRepDS_CurveData

        :type C: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Curve

        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_CurveData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_CurveData
TopOpeBRepDS_CurveData_swigregister = _TopOpeBRepDS.TopOpeBRepDS_CurveData_swigregister
TopOpeBRepDS_CurveData_swigregister(TopOpeBRepDS_CurveData)

class TopOpeBRepDS_EIR(object):
    """EdgeInterferenceReducer"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_EIR self, Handle_TopOpeBRepDS_HDataStructure HDS) -> TopOpeBRepDS_EIR

        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure

        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_EIR(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ProcessEdgeInterferences(self, *args):
        """
        ProcessEdgeInterferences(TopOpeBRepDS_EIR self)
        ProcessEdgeInterferences(TopOpeBRepDS_EIR self, Standard_Integer const I)

        :type I: int

        """
        return _TopOpeBRepDS.TopOpeBRepDS_EIR_ProcessEdgeInterferences(self, *args)

    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_EIR
TopOpeBRepDS_EIR_swigregister = _TopOpeBRepDS.TopOpeBRepDS_EIR_swigregister
TopOpeBRepDS_EIR_swigregister(TopOpeBRepDS_EIR)

class TopOpeBRepDS_SurfaceCurveInterference(TopOpeBRepDS_Interference):
    """an interference with a 2d curve"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopOpeBRepDS_SurfaceCurveInterference
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopOpeBRepDS_SurfaceCurveInterference(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_SurfaceCurveInterference self) -> TopOpeBRepDS_SurfaceCurveInterference
        __init__(TopOpeBRepDS_SurfaceCurveInterference self, TopOpeBRepDS_Transition Transition, TopOpeBRepDS_Kind const SupportType, Standard_Integer const Support, TopOpeBRepDS_Kind const GeometryType, Standard_Integer const Geometry, Handle_Geom2d_Curve PC) -> TopOpeBRepDS_SurfaceCurveInterference
        __init__(TopOpeBRepDS_SurfaceCurveInterference self, Handle_TopOpeBRepDS_Interference I) -> TopOpeBRepDS_SurfaceCurveInterference

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_SurfaceCurveInterference(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def PCurve(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_SurfaceCurveInterference_PCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopOpeBRepDS.TopOpeBRepDS_SurfaceCurveInterference_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopOpeBRepDS.TopOpeBRepDS_SurfaceCurveInterference_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_SurfaceCurveInterference_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_SurfaceCurveInterference
TopOpeBRepDS_SurfaceCurveInterference_swigregister = _TopOpeBRepDS.TopOpeBRepDS_SurfaceCurveInterference_swigregister
TopOpeBRepDS_SurfaceCurveInterference_swigregister(TopOpeBRepDS_SurfaceCurveInterference)

def TopOpeBRepDS_SurfaceCurveInterference_get_type_name(*args):
    """
    TopOpeBRepDS_SurfaceCurveInterference_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopOpeBRepDS.TopOpeBRepDS_SurfaceCurveInterference_get_type_name(*args)

def TopOpeBRepDS_SurfaceCurveInterference_get_type_descriptor(*args):
    """
    TopOpeBRepDS_SurfaceCurveInterference_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopOpeBRepDS.TopOpeBRepDS_SurfaceCurveInterference_get_type_descriptor(*args)

class TopOpeBRepDS_PointIterator(TopOpeBRepDS_InterferenceIterator):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_PointIterator self, NCollection_List_Handle_TopOpeBRepDS_Interference L) -> TopOpeBRepDS_PointIterator

        Creates an  iterator on the  points on curves
        described by the interferences in <L>.

        :type L: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_PointIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def MatchInterference(self, *args):
        """
        MatchInterference(TopOpeBRepDS_PointIterator self, Handle_TopOpeBRepDS_Interference I) -> Standard_Boolean

        Returns  True if the Interference <I>  has a
        GeometryType() TopOpeBRepDS_POINT or TopOpeBRepDS_VERTEX
        returns False else.

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_PointIterator_MatchInterference(self, *args)


    def Current(self, *args):
        """
        Current(TopOpeBRepDS_PointIterator self) -> Standard_Integer

        Index of the point in the data structure.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_PointIterator_Current(self, *args)


    def Orientation(self, *args):
        """
        Orientation(TopOpeBRepDS_PointIterator self, TopAbs_State const S) -> TopAbs_Orientation

        :type S: OCC.wrapper.TopAbs.TopAbs_State
        :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _TopOpeBRepDS.TopOpeBRepDS_PointIterator_Orientation(self, *args)


    def Parameter(self, *args):
        """
        Parameter(TopOpeBRepDS_PointIterator self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TopOpeBRepDS.TopOpeBRepDS_PointIterator_Parameter(self, *args)


    def IsVertex(self, *args):
        """
        IsVertex(TopOpeBRepDS_PointIterator self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_PointIterator_IsVertex(self, *args)


    def IsPoint(self, *args):
        """
        IsPoint(TopOpeBRepDS_PointIterator self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_PointIterator_IsPoint(self, *args)


    def DiffOriented(self, *args):
        """
        DiffOriented(TopOpeBRepDS_PointIterator self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_PointIterator_DiffOriented(self, *args)


    def SameOriented(self, *args):
        """
        SameOriented(TopOpeBRepDS_PointIterator self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_PointIterator_SameOriented(self, *args)


    def Support(self, *args):
        """
        Support(TopOpeBRepDS_PointIterator self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_PointIterator_Support(self, *args)

    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_PointIterator
TopOpeBRepDS_PointIterator_swigregister = _TopOpeBRepDS.TopOpeBRepDS_PointIterator_swigregister
TopOpeBRepDS_PointIterator_swigregister(TopOpeBRepDS_PointIterator)

class TopOpeBRepDS_SurfaceExplorer(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_SurfaceExplorer self) -> TopOpeBRepDS_SurfaceExplorer
        __init__(TopOpeBRepDS_SurfaceExplorer self, TopOpeBRepDS_DataStructure DS, Standard_Boolean const FindOnlyKeep) -> TopOpeBRepDS_SurfaceExplorer

        :type DS: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_DataStructure
        :type FindOnlyKeep: bool

        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_SurfaceExplorer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(TopOpeBRepDS_SurfaceExplorer self, TopOpeBRepDS_DataStructure DS, Standard_Boolean const FindOnlyKeep)

        :type DS: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_DataStructure
        :type FindOnlyKeep: bool

        """
        return _TopOpeBRepDS.TopOpeBRepDS_SurfaceExplorer_Init(self, *args)


    def More(self, *args):
        """
        More(TopOpeBRepDS_SurfaceExplorer self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_SurfaceExplorer_More(self, *args)


    def Next(self, *args):
        """Next(TopOpeBRepDS_SurfaceExplorer self)"""
        return _TopOpeBRepDS.TopOpeBRepDS_SurfaceExplorer_Next(self, *args)


    def IsSurface(self, *args):
        """
        IsSurface(TopOpeBRepDS_SurfaceExplorer self, Standard_Integer const I) -> Standard_Boolean

        :type I: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_SurfaceExplorer_IsSurface(self, *args)


    def IsSurfaceKeep(self, *args):
        """
        IsSurfaceKeep(TopOpeBRepDS_SurfaceExplorer self, Standard_Integer const I) -> Standard_Boolean

        :type I: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_SurfaceExplorer_IsSurfaceKeep(self, *args)


    def Surface(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Surface

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_SurfaceExplorer_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbSurface(self, *args):
        """
        NbSurface(TopOpeBRepDS_SurfaceExplorer self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_SurfaceExplorer_NbSurface(self, *args)


    def Index(self, *args):
        """
        Index(TopOpeBRepDS_SurfaceExplorer self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_SurfaceExplorer_Index(self, *args)

    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_SurfaceExplorer
TopOpeBRepDS_SurfaceExplorer_swigregister = _TopOpeBRepDS.TopOpeBRepDS_SurfaceExplorer_swigregister
TopOpeBRepDS_SurfaceExplorer_swigregister(TopOpeBRepDS_SurfaceExplorer)

class Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference self)

        Nullify the handle


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference self, TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference self, Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference theHandle) -> Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference
        assign(Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference self, TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference thePtr) -> Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference
        assign(Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference self, Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference theHandle) -> Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference self) -> TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference self) -> TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference self) -> TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference___ref__(self, *args)


    def __hash__(self):
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopOpeBRepDS.Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopOpeBRepDS.new_Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopOpeBRepDS.Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_DownCast)
    __swig_destroy__ = _TopOpeBRepDS.delete_Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Array1OfDataMapOfIntegerListOfInterference

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference self) -> NCollection_Array1_TopOpeBRepDS_DataMapOfIntegerListOfInterference

        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Array1OfDataMapOfIntegerListOfInterference

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference self) -> char const *

        :rtype: const char *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference self)

        Memory deallocator for transient classes


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference self)

        Increments the reference counter of this object


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_DecrementRefCounter(self, *args)

Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_swigregister = _TopOpeBRepDS.Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_swigregister
Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_swigregister(Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference)

def Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_DownCast(thing):
    return _TopOpeBRepDS.Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_DownCast(thing)
Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_DownCast = _TopOpeBRepDS.Handle_TopOpeBRepDS_HArray1OfDataMapOfIntegerListOfInterference_DownCast

class NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TopOpeBRepDS_CurveData,TColStd_MapIntegerHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TopOpeBRepDS_CurveData,TColStd_MapIntegerHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TopOpeBRepDS_CurveData,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TopOpeBRepDS_CurveData,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TopOpeBRepDS.new_NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher self, int const & theKey, TopOpeBRepDS_CurveData theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher self, int const & theKey, TopOpeBRepDS_CurveData theItem) -> TopOpeBRepDS_CurveData

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher self, int const & theKey) -> TopOpeBRepDS_CurveData

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher self, int const & theKey) -> TopOpeBRepDS_CurveData

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher self, int const & theKey) -> TopOpeBRepDS_CurveData

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher_Size(self, *args)


    def __iter__(self):
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher___iter__(self)
    __swig_destroy__ = _TopOpeBRepDS.delete_NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher
NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher_swigregister = _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher_swigregister
NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher_swigregister(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher)

class NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopOpeBRepDS.new_NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepDS.delete_NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher_IteratorHelper

    def __next__(self):
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher_IteratorHelper___next__(self)
NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher_IteratorHelper_swigregister = _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher_IteratorHelper_swigregister
NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher_IteratorHelper_swigregister(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher_IteratorHelper)


try:
	TopOpeBRepDS_MapOfCurve = NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CurveData_TColStd_MapIntegerHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_TopOpeBRepDS_FaceEdgeInterference(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopOpeBRepDS_FaceEdgeInterference self)

        Nullify the handle


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopOpeBRepDS_FaceEdgeInterference self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopOpeBRepDS_FaceEdgeInterference self, TopOpeBRepDS_FaceEdgeInterference thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopOpeBRepDS_FaceEdgeInterference self, Handle_TopOpeBRepDS_FaceEdgeInterference theHandle) -> Handle_TopOpeBRepDS_FaceEdgeInterference
        assign(Handle_TopOpeBRepDS_FaceEdgeInterference self, TopOpeBRepDS_FaceEdgeInterference thePtr) -> Handle_TopOpeBRepDS_FaceEdgeInterference
        assign(Handle_TopOpeBRepDS_FaceEdgeInterference self, Handle_TopOpeBRepDS_FaceEdgeInterference theHandle) -> Handle_TopOpeBRepDS_FaceEdgeInterference

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopOpeBRepDS_FaceEdgeInterference self) -> TopOpeBRepDS_FaceEdgeInterference

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopOpeBRepDS_FaceEdgeInterference self) -> TopOpeBRepDS_FaceEdgeInterference

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopOpeBRepDS_FaceEdgeInterference self) -> TopOpeBRepDS_FaceEdgeInterference

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference___ref__(self, *args)


    def __hash__(self):
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopOpeBRepDS.new_Handle_TopOpeBRepDS_FaceEdgeInterference(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference_DownCast)
    __swig_destroy__ = _TopOpeBRepDS.delete_Handle_TopOpeBRepDS_FaceEdgeInterference

    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopOpeBRepDS_FaceEdgeInterference self) -> char const *

        :rtype: const char *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Config(self, *args):
        """
        Config(Handle_TopOpeBRepDS_FaceEdgeInterference self) -> TopOpeBRepDS_Config

        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Config

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference_Config(self, *args)


    def GBound(self, *args):
        """
        GBound(Handle_TopOpeBRepDS_FaceEdgeInterference self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference_GBound(self, *args)


    def SetGBound(self, *args):
        """
        SetGBound(Handle_TopOpeBRepDS_FaceEdgeInterference self, Standard_Boolean const b)

        :type b: bool

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference_SetGBound(self, *args)


    def Transition(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference_Transition(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeTransition(self, *args):
        """
        ChangeTransition(Handle_TopOpeBRepDS_FaceEdgeInterference self) -> TopOpeBRepDS_Transition

        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference_ChangeTransition(self, *args)


    def GKGSKS(self, *args):
        """
        GKGSKS(Handle_TopOpeBRepDS_FaceEdgeInterference self)

        return GeometryType + Geometry + SupportType + Support

        :type GK: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type G: int
        :type SK: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type S: int

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference_GKGSKS(self, *args)


    def SupportType(self, *args):
        """
        SupportType(Handle_TopOpeBRepDS_FaceEdgeInterference self) -> TopOpeBRepDS_Kind
        SupportType(Handle_TopOpeBRepDS_FaceEdgeInterference self, TopOpeBRepDS_Kind const ST)

        :type ST: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference_SupportType(self, *args)


    def Support(self, *args):
        """
        Support(Handle_TopOpeBRepDS_FaceEdgeInterference self) -> Standard_Integer
        Support(Handle_TopOpeBRepDS_FaceEdgeInterference self, Standard_Integer const S)

        :type S: int

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference_Support(self, *args)


    def GeometryType(self, *args):
        """
        GeometryType(Handle_TopOpeBRepDS_FaceEdgeInterference self) -> TopOpeBRepDS_Kind
        GeometryType(Handle_TopOpeBRepDS_FaceEdgeInterference self, TopOpeBRepDS_Kind const GT)

        :type GT: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference_GeometryType(self, *args)


    def Geometry(self, *args):
        """
        Geometry(Handle_TopOpeBRepDS_FaceEdgeInterference self) -> Standard_Integer
        Geometry(Handle_TopOpeBRepDS_FaceEdgeInterference self, Standard_Integer const G)

        :type G: int

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference_Geometry(self, *args)


    def SetGeometry(self, *args):
        """
        SetGeometry(Handle_TopOpeBRepDS_FaceEdgeInterference self, Standard_Integer const GI)

        :type GI: int

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference_SetGeometry(self, *args)


    def HasSameSupport(self, *args):
        """
        HasSameSupport(Handle_TopOpeBRepDS_FaceEdgeInterference self, Handle_TopOpeBRepDS_Interference Other) -> Standard_Boolean

        :type Other: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference_HasSameSupport(self, *args)


    def HasSameGeometry(self, *args):
        """
        HasSameGeometry(Handle_TopOpeBRepDS_FaceEdgeInterference self, Handle_TopOpeBRepDS_Interference Other) -> Standard_Boolean

        :type Other: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference_HasSameGeometry(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TopOpeBRepDS_FaceEdgeInterference self)

        Memory deallocator for transient classes


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopOpeBRepDS_FaceEdgeInterference self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopOpeBRepDS_FaceEdgeInterference self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopOpeBRepDS_FaceEdgeInterference self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopOpeBRepDS_FaceEdgeInterference self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopOpeBRepDS_FaceEdgeInterference self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopOpeBRepDS_FaceEdgeInterference self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopOpeBRepDS_FaceEdgeInterference self)

        Increments the reference counter of this object


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopOpeBRepDS_FaceEdgeInterference self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference_DecrementRefCounter(self, *args)

Handle_TopOpeBRepDS_FaceEdgeInterference_swigregister = _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference_swigregister
Handle_TopOpeBRepDS_FaceEdgeInterference_swigregister(Handle_TopOpeBRepDS_FaceEdgeInterference)

def Handle_TopOpeBRepDS_FaceEdgeInterference_DownCast(thing):
    return _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference_DownCast(thing)
Handle_TopOpeBRepDS_FaceEdgeInterference_DownCast = _TopOpeBRepDS.Handle_TopOpeBRepDS_FaceEdgeInterference_DownCast

class TopOpeBRepDS_CurveIterator(TopOpeBRepDS_InterferenceIterator):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_CurveIterator self, NCollection_List_Handle_TopOpeBRepDS_Interference L) -> TopOpeBRepDS_CurveIterator

        Creates an  iterator on the  curves on surface
        described by the interferences in <L>.

        :type L: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_CurveIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def MatchInterference(self, *args):
        """
        MatchInterference(TopOpeBRepDS_CurveIterator self, Handle_TopOpeBRepDS_Interference I) -> Standard_Boolean

        Returns  True if the Interference <I>  has a
        GeometryType() TopOpeBRepDS_CURVE
        returns False else.

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_CurveIterator_MatchInterference(self, *args)


    def Current(self, *args):
        """
        Current(TopOpeBRepDS_CurveIterator self) -> Standard_Integer

        Index of the curve in the data structure.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_CurveIterator_Current(self, *args)


    def Orientation(self, *args):
        """
        Orientation(TopOpeBRepDS_CurveIterator self, TopAbs_State const S) -> TopAbs_Orientation

        :type S: OCC.wrapper.TopAbs.TopAbs_State
        :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _TopOpeBRepDS.TopOpeBRepDS_CurveIterator_Orientation(self, *args)


    def PCurve(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_CurveIterator_PCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_CurveIterator
TopOpeBRepDS_CurveIterator_swigregister = _TopOpeBRepDS.TopOpeBRepDS_CurveIterator_swigregister
TopOpeBRepDS_CurveIterator_swigregister(TopOpeBRepDS_CurveIterator)

class TopOpeBRepDS_ShapeWithState(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(TopOpeBRepDS_ShapeWithState self) -> TopOpeBRepDS_ShapeWithState"""
        this = _TopOpeBRepDS.new_TopOpeBRepDS_ShapeWithState(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Part(self, *args):
        """
        :type aState: OCC.wrapper.TopAbs.TopAbs_State
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_ShapeWithState_Part(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AddPart(self, *args):
        """
        AddPart(TopOpeBRepDS_ShapeWithState self, TopoDS_Shape aShape, TopAbs_State const aState)

        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aState: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _TopOpeBRepDS.TopOpeBRepDS_ShapeWithState_AddPart(self, *args)


    def AddParts(self, *args):
        """
        AddParts(TopOpeBRepDS_ShapeWithState self, NCollection_List_TopoDS_Shape aListOfShape, TopAbs_State const aState)

        :type aListOfShape: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type aState: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _TopOpeBRepDS.TopOpeBRepDS_ShapeWithState_AddParts(self, *args)


    def SetState(self, *args):
        """
        SetState(TopOpeBRepDS_ShapeWithState self, TopAbs_State const aState)

        :type aState: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _TopOpeBRepDS.TopOpeBRepDS_ShapeWithState_SetState(self, *args)


    def State(self, *args):
        """
        State(TopOpeBRepDS_ShapeWithState self) -> TopAbs_State

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _TopOpeBRepDS.TopOpeBRepDS_ShapeWithState_State(self, *args)


    def SetIsSplitted(self, *args):
        """
        SetIsSplitted(TopOpeBRepDS_ShapeWithState self, Standard_Boolean const anIsSplitted)

        :type anIsSplitted: bool

        """
        return _TopOpeBRepDS.TopOpeBRepDS_ShapeWithState_SetIsSplitted(self, *args)


    def IsSplitted(self, *args):
        """
        IsSplitted(TopOpeBRepDS_ShapeWithState self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_ShapeWithState_IsSplitted(self, *args)

    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_ShapeWithState
TopOpeBRepDS_ShapeWithState_swigregister = _TopOpeBRepDS.TopOpeBRepDS_ShapeWithState_swigregister
TopOpeBRepDS_ShapeWithState_swigregister(TopOpeBRepDS_ShapeWithState)

class Handle_TopOpeBRepDS_Marker(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopOpeBRepDS_Marker self)

        Nullify the handle


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Marker_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopOpeBRepDS_Marker self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Marker_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopOpeBRepDS_Marker self, TopOpeBRepDS_Marker thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Marker_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopOpeBRepDS_Marker self, Handle_TopOpeBRepDS_Marker theHandle) -> Handle_TopOpeBRepDS_Marker
        assign(Handle_TopOpeBRepDS_Marker self, TopOpeBRepDS_Marker thePtr) -> Handle_TopOpeBRepDS_Marker
        assign(Handle_TopOpeBRepDS_Marker self, Handle_TopOpeBRepDS_Marker theHandle) -> Handle_TopOpeBRepDS_Marker

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Marker_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopOpeBRepDS_Marker self) -> TopOpeBRepDS_Marker

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Marker_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopOpeBRepDS_Marker self) -> TopOpeBRepDS_Marker

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Marker___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopOpeBRepDS_Marker self) -> TopOpeBRepDS_Marker

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Marker___ref__(self, *args)


    def __hash__(self):
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Marker___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopOpeBRepDS.Handle_TopOpeBRepDS_Marker___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopOpeBRepDS.new_Handle_TopOpeBRepDS_Marker(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopOpeBRepDS.Handle_TopOpeBRepDS_Marker_DownCast)
    __swig_destroy__ = _TopOpeBRepDS.delete_Handle_TopOpeBRepDS_Marker

    def Reset(self, *args):
        """Reset(Handle_TopOpeBRepDS_Marker self)"""
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Marker_Reset(self, *args)


    def Set(self, *args):
        """
        Set(Handle_TopOpeBRepDS_Marker self, Standard_Integer const i, Standard_Boolean const b)
        Set(Handle_TopOpeBRepDS_Marker self, Standard_Boolean const b, Standard_Integer const n, Standard_Address const a)

        :type b: bool
        :type n: int
        :type a: OCC.wrapper.Standard.Standard_Address

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Marker_Set(self, *args)


    def GetI(self, *args):
        """
        GetI(Handle_TopOpeBRepDS_Marker self, Standard_Integer const i) -> Standard_Boolean

        :type i: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Marker_GetI(self, *args)


    def Allocate(self, *args):
        """
        Allocate(Handle_TopOpeBRepDS_Marker self, Standard_Integer const n)

        :type n: int

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Marker_Allocate(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopOpeBRepDS_Marker self) -> char const *

        :rtype: const char *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Marker_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_Marker_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_Marker_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TopOpeBRepDS_Marker self)

        Memory deallocator for transient classes


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Marker_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopOpeBRepDS_Marker self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopOpeBRepDS_Marker self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Marker_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopOpeBRepDS_Marker self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopOpeBRepDS_Marker self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Marker_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopOpeBRepDS_Marker self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Marker_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopOpeBRepDS_Marker self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Marker_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopOpeBRepDS_Marker self)

        Increments the reference counter of this object


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Marker_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopOpeBRepDS_Marker self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Marker_DecrementRefCounter(self, *args)

Handle_TopOpeBRepDS_Marker_swigregister = _TopOpeBRepDS.Handle_TopOpeBRepDS_Marker_swigregister
Handle_TopOpeBRepDS_Marker_swigregister(Handle_TopOpeBRepDS_Marker)

def Handle_TopOpeBRepDS_Marker_DownCast(thing):
    return _TopOpeBRepDS.Handle_TopOpeBRepDS_Marker_DownCast(thing)
Handle_TopOpeBRepDS_Marker_DownCast = _TopOpeBRepDS.Handle_TopOpeBRepDS_Marker_DownCast

class TopOpeBRepDS_InterferenceTool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def MakeEdgeInterference(*args):
        """
        MakeEdgeInterference(TopOpeBRepDS_Transition T, TopOpeBRepDS_Kind const SK, Standard_Integer const SI, TopOpeBRepDS_Kind const GK, Standard_Integer const GI, Standard_Real const P) -> Handle_TopOpeBRepDS_Interference

        :type T: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition
        :type SK: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type SI: int
        :type GK: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type GI: int
        :type P: float
        :rtype: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_InterferenceTool_MakeEdgeInterference(*args)

    MakeEdgeInterference = staticmethod(MakeEdgeInterference)

    def MakeCurveInterference(*args):
        """
        MakeCurveInterference(TopOpeBRepDS_Transition T, TopOpeBRepDS_Kind const SK, Standard_Integer const SI, TopOpeBRepDS_Kind const GK, Standard_Integer const GI, Standard_Real const P) -> Handle_TopOpeBRepDS_Interference

        :type T: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition
        :type SK: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type SI: int
        :type GK: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type GI: int
        :type P: float
        :rtype: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_InterferenceTool_MakeCurveInterference(*args)

    MakeCurveInterference = staticmethod(MakeCurveInterference)

    def DuplicateCurvePointInterference(*args):
        """
        DuplicateCurvePointInterference(Handle_TopOpeBRepDS_Interference I) -> Handle_TopOpeBRepDS_Interference

        duplicate I in a new interference with Complement() transition.

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :rtype: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_InterferenceTool_DuplicateCurvePointInterference(*args)

    DuplicateCurvePointInterference = staticmethod(DuplicateCurvePointInterference)

    def MakeFaceCurveInterference(*args):
        """
        MakeFaceCurveInterference(TopOpeBRepDS_Transition Transition, Standard_Integer const FaceI, Standard_Integer const CurveI, Handle_Geom2d_Curve PC) -> Handle_TopOpeBRepDS_Interference

        :type Transition: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition
        :type FaceI: int
        :type CurveI: int
        :type PC: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :rtype: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_InterferenceTool_MakeFaceCurveInterference(*args)

    MakeFaceCurveInterference = staticmethod(MakeFaceCurveInterference)

    def MakeSolidSurfaceInterference(*args):
        """
        MakeSolidSurfaceInterference(TopOpeBRepDS_Transition Transition, Standard_Integer const SolidI, Standard_Integer const SurfaceI) -> Handle_TopOpeBRepDS_Interference

        :type Transition: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition
        :type SolidI: int
        :type SurfaceI: int
        :rtype: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_InterferenceTool_MakeSolidSurfaceInterference(*args)

    MakeSolidSurfaceInterference = staticmethod(MakeSolidSurfaceInterference)

    def MakeEdgeVertexInterference(*args):
        """
        MakeEdgeVertexInterference(TopOpeBRepDS_Transition Transition, Standard_Integer const EdgeI, Standard_Integer const VertexI, Standard_Boolean const VertexIsBound, TopOpeBRepDS_Config const Config, Standard_Real const param) -> Handle_TopOpeBRepDS_Interference

        :type Transition: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition
        :type EdgeI: int
        :type VertexI: int
        :type VertexIsBound: bool
        :type Config: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Config
        :type param: float
        :rtype: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_InterferenceTool_MakeEdgeVertexInterference(*args)

    MakeEdgeVertexInterference = staticmethod(MakeEdgeVertexInterference)

    def MakeFaceEdgeInterference(*args):
        """
        MakeFaceEdgeInterference(TopOpeBRepDS_Transition Transition, Standard_Integer const FaceI, Standard_Integer const EdgeI, Standard_Boolean const EdgeIsBound, TopOpeBRepDS_Config const Config) -> Handle_TopOpeBRepDS_Interference

        :type Transition: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition
        :type FaceI: int
        :type EdgeI: int
        :type EdgeIsBound: bool
        :type Config: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Config
        :rtype: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_InterferenceTool_MakeFaceEdgeInterference(*args)

    MakeFaceEdgeInterference = staticmethod(MakeFaceEdgeInterference)

    def Parameter(*args):
        """
        Parameter(Handle_TopOpeBRepDS_Interference CPI) -> Standard_Real
        Parameter(Handle_TopOpeBRepDS_Interference CPI, Standard_Real const Par)

        :type CPI: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :type Par: float

        """
        return _TopOpeBRepDS.TopOpeBRepDS_InterferenceTool_Parameter(*args)

    Parameter = staticmethod(Parameter)

    def __init__(self):
        this = _TopOpeBRepDS.new_TopOpeBRepDS_InterferenceTool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_InterferenceTool
TopOpeBRepDS_InterferenceTool_swigregister = _TopOpeBRepDS.TopOpeBRepDS_InterferenceTool_swigregister
TopOpeBRepDS_InterferenceTool_swigregister(TopOpeBRepDS_InterferenceTool)

def TopOpeBRepDS_InterferenceTool_MakeEdgeInterference(*args):
    """
    TopOpeBRepDS_InterferenceTool_MakeEdgeInterference(TopOpeBRepDS_Transition T, TopOpeBRepDS_Kind const SK, Standard_Integer const SI, TopOpeBRepDS_Kind const GK, Standard_Integer const GI, Standard_Real const P) -> Handle_TopOpeBRepDS_Interference

    :type T: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition
    :type SK: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
    :type SI: int
    :type GK: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
    :type GI: int
    :type P: float
    :rtype: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

    """
    return _TopOpeBRepDS.TopOpeBRepDS_InterferenceTool_MakeEdgeInterference(*args)

def TopOpeBRepDS_InterferenceTool_MakeCurveInterference(*args):
    """
    TopOpeBRepDS_InterferenceTool_MakeCurveInterference(TopOpeBRepDS_Transition T, TopOpeBRepDS_Kind const SK, Standard_Integer const SI, TopOpeBRepDS_Kind const GK, Standard_Integer const GI, Standard_Real const P) -> Handle_TopOpeBRepDS_Interference

    :type T: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition
    :type SK: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
    :type SI: int
    :type GK: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
    :type GI: int
    :type P: float
    :rtype: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

    """
    return _TopOpeBRepDS.TopOpeBRepDS_InterferenceTool_MakeCurveInterference(*args)

def TopOpeBRepDS_InterferenceTool_DuplicateCurvePointInterference(*args):
    """
    TopOpeBRepDS_InterferenceTool_DuplicateCurvePointInterference(Handle_TopOpeBRepDS_Interference I) -> Handle_TopOpeBRepDS_Interference

    duplicate I in a new interference with Complement() transition.

    :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
    :rtype: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

    """
    return _TopOpeBRepDS.TopOpeBRepDS_InterferenceTool_DuplicateCurvePointInterference(*args)

def TopOpeBRepDS_InterferenceTool_MakeFaceCurveInterference(*args):
    """
    TopOpeBRepDS_InterferenceTool_MakeFaceCurveInterference(TopOpeBRepDS_Transition Transition, Standard_Integer const FaceI, Standard_Integer const CurveI, Handle_Geom2d_Curve PC) -> Handle_TopOpeBRepDS_Interference

    :type Transition: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition
    :type FaceI: int
    :type CurveI: int
    :type PC: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
    :rtype: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

    """
    return _TopOpeBRepDS.TopOpeBRepDS_InterferenceTool_MakeFaceCurveInterference(*args)

def TopOpeBRepDS_InterferenceTool_MakeSolidSurfaceInterference(*args):
    """
    TopOpeBRepDS_InterferenceTool_MakeSolidSurfaceInterference(TopOpeBRepDS_Transition Transition, Standard_Integer const SolidI, Standard_Integer const SurfaceI) -> Handle_TopOpeBRepDS_Interference

    :type Transition: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition
    :type SolidI: int
    :type SurfaceI: int
    :rtype: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

    """
    return _TopOpeBRepDS.TopOpeBRepDS_InterferenceTool_MakeSolidSurfaceInterference(*args)

def TopOpeBRepDS_InterferenceTool_MakeEdgeVertexInterference(*args):
    """
    TopOpeBRepDS_InterferenceTool_MakeEdgeVertexInterference(TopOpeBRepDS_Transition Transition, Standard_Integer const EdgeI, Standard_Integer const VertexI, Standard_Boolean const VertexIsBound, TopOpeBRepDS_Config const Config, Standard_Real const param) -> Handle_TopOpeBRepDS_Interference

    :type Transition: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition
    :type EdgeI: int
    :type VertexI: int
    :type VertexIsBound: bool
    :type Config: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Config
    :type param: float
    :rtype: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

    """
    return _TopOpeBRepDS.TopOpeBRepDS_InterferenceTool_MakeEdgeVertexInterference(*args)

def TopOpeBRepDS_InterferenceTool_MakeFaceEdgeInterference(*args):
    """
    TopOpeBRepDS_InterferenceTool_MakeFaceEdgeInterference(TopOpeBRepDS_Transition Transition, Standard_Integer const FaceI, Standard_Integer const EdgeI, Standard_Boolean const EdgeIsBound, TopOpeBRepDS_Config const Config) -> Handle_TopOpeBRepDS_Interference

    :type Transition: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition
    :type FaceI: int
    :type EdgeI: int
    :type EdgeIsBound: bool
    :type Config: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Config
    :rtype: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

    """
    return _TopOpeBRepDS.TopOpeBRepDS_InterferenceTool_MakeFaceEdgeInterference(*args)

def TopOpeBRepDS_InterferenceTool_Parameter(*args):
    """
    Parameter(Handle_TopOpeBRepDS_Interference CPI) -> Standard_Real
    TopOpeBRepDS_InterferenceTool_Parameter(Handle_TopOpeBRepDS_Interference CPI, Standard_Real const Par)

    :type CPI: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
    :type Par: float

    """
    return _TopOpeBRepDS.TopOpeBRepDS_InterferenceTool_Parameter(*args)

class NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< TopOpeBRepDS_Interference >,TopoDS_Shape,TColStd_MapTransientHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< TopOpeBRepDS_Interference >,TopoDS_Shape,TColStd_MapTransientHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< TopOpeBRepDS_Interference >,TopoDS_Shape,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< TopOpeBRepDS_Interference >,TopoDS_Shape,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TopOpeBRepDS.new_NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_TopOpeBRepDS_Interference theKey, TopoDS_Shape theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_TopOpeBRepDS_Interference theKey, TopoDS_Shape theItem) -> TopoDS_Shape

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_TopOpeBRepDS_Interference theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_TopOpeBRepDS_Interference theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_TopOpeBRepDS_Interference theKey) -> TopoDS_Shape

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_TopOpeBRepDS_Interference theKey) -> TopoDS_Shape

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_TopOpeBRepDS_Interference theKey) -> TopoDS_Shape

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher_Size(self, *args)


    def __iter__(self):
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher___iter__(self)
    __swig_destroy__ = _TopOpeBRepDS.delete_NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher
NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher_swigregister = _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher_swigregister
NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher_swigregister(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher)

class NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopOpeBRepDS.new_NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepDS.delete_NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper

    def __next__(self):
        return _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper___next__(self)
NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper_swigregister = _TopOpeBRepDS.NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper_swigregister
NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper_swigregister(NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher_IteratorHelper)


try:
	TopOpeBRepDS_DataMapOfInterferenceShape = NCollection_DataMap_Handle_TopOpeBRepDS_Interference_TopoDS_Shape_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored

class TopOpeBRepDS_Reducer(object):
    """
    reduce interferences of a data structure (HDS)
    used in topological operations.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_Reducer self, Handle_TopOpeBRepDS_HDataStructure HDS) -> TopOpeBRepDS_Reducer

        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure

        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_Reducer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ProcessFaceInterferences(self, *args):
        """
        ProcessFaceInterferences(TopOpeBRepDS_Reducer self, NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher M)

        :type M: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_DataMapOfShapeListOfShapeOn1State

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Reducer_ProcessFaceInterferences(self, *args)


    def ProcessEdgeInterferences(self, *args):
        """ProcessEdgeInterferences(TopOpeBRepDS_Reducer self)"""
        return _TopOpeBRepDS.TopOpeBRepDS_Reducer_ProcessEdgeInterferences(self, *args)

    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_Reducer
TopOpeBRepDS_Reducer_swigregister = _TopOpeBRepDS.TopOpeBRepDS_Reducer_swigregister
TopOpeBRepDS_Reducer_swigregister(TopOpeBRepDS_Reducer)

class NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TopOpeBRepDS_CheckStatus,TColStd_MapIntegerHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TopOpeBRepDS_CheckStatus,TColStd_MapIntegerHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TopOpeBRepDS_CheckStatus,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TopOpeBRepDS_CheckStatus,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TopOpeBRepDS.new_NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher self, int const & theKey, TopOpeBRepDS_CheckStatus const & theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher self, int const & theKey, TopOpeBRepDS_CheckStatus const & theItem) -> TopOpeBRepDS_CheckStatus *

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher self, int const & theKey) -> TopOpeBRepDS_CheckStatus const *

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher self, int const & theKey) -> TopOpeBRepDS_CheckStatus *

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher self, int const & theKey) -> TopOpeBRepDS_CheckStatus &

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher_Size(self, *args)


    def __iter__(self):
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher___iter__(self)
    __swig_destroy__ = _TopOpeBRepDS.delete_NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher
NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher_swigregister = _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher_swigregister
NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher_swigregister(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher)

class NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopOpeBRepDS.new_NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepDS.delete_NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher_IteratorHelper

    def __next__(self):
        return _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher_IteratorHelper___next__(self)
NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher_IteratorHelper_swigregister = _TopOpeBRepDS.NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher_IteratorHelper_swigregister
NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher_IteratorHelper_swigregister(NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher_IteratorHelper)


try:
	TopOpeBRepDS_DataMapOfCheckStatus = NCollection_DataMap_Standard_Integer_TopOpeBRepDS_CheckStatus_TColStd_MapIntegerHasher
except NameError:
	pass # does not exist, probably ignored

class TopOpeBRepDS_BuildTool(object):
    """
    Provides  a  Tool  to  build  topologies. Used  to
    instantiate the Builder algorithm.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_BuildTool self) -> TopOpeBRepDS_BuildTool
        __init__(TopOpeBRepDS_BuildTool self, TopOpeBRepTool_OutCurveType const OutCurveType) -> TopOpeBRepDS_BuildTool
        __init__(TopOpeBRepDS_BuildTool self, TopOpeBRepTool_GeomTool GT) -> TopOpeBRepDS_BuildTool

        :type GT: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_GeomTool

        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_BuildTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetGeomTool(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_GeomTool

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_BuildTool_GetGeomTool(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeGeomTool(self, *args):
        """
        ChangeGeomTool(TopOpeBRepDS_BuildTool self) -> TopOpeBRepTool_GeomTool

        :rtype: OCC.wrapper.TopOpeBRepTool.TopOpeBRepTool_GeomTool

        """
        return _TopOpeBRepDS.TopOpeBRepDS_BuildTool_ChangeGeomTool(self, *args)


    def MakeVertex(self, *args):
        """
        MakeVertex(TopOpeBRepDS_BuildTool self, TopoDS_Shape V, TopOpeBRepDS_Point P)

        :type V: OCC.wrapper.TopoDS.TopoDS_Shape
        :type P: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Point

        """
        return _TopOpeBRepDS.TopOpeBRepDS_BuildTool_MakeVertex(self, *args)


    def MakeEdge(self, *args):
        """
        MakeEdge(TopOpeBRepDS_BuildTool self, TopoDS_Shape E, TopOpeBRepDS_Curve C)
        MakeEdge(TopOpeBRepDS_BuildTool self, TopoDS_Shape E, TopOpeBRepDS_Curve C, TopOpeBRepDS_DataStructure DS)
        MakeEdge(TopOpeBRepDS_BuildTool self, TopoDS_Shape E, Handle_Geom_Curve C, Standard_Real const Tol)
        MakeEdge(TopOpeBRepDS_BuildTool self, TopoDS_Shape E)

        :type E: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopOpeBRepDS.TopOpeBRepDS_BuildTool_MakeEdge(self, *args)


    def MakeWire(self, *args):
        """
        MakeWire(TopOpeBRepDS_BuildTool self, TopoDS_Shape W)

        :type W: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopOpeBRepDS.TopOpeBRepDS_BuildTool_MakeWire(self, *args)


    def MakeFace(self, *args):
        """
        MakeFace(TopOpeBRepDS_BuildTool self, TopoDS_Shape F, TopOpeBRepDS_Surface S)

        :type F: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Surface

        """
        return _TopOpeBRepDS.TopOpeBRepDS_BuildTool_MakeFace(self, *args)


    def MakeShell(self, *args):
        """
        MakeShell(TopOpeBRepDS_BuildTool self, TopoDS_Shape Sh)

        :type Sh: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopOpeBRepDS.TopOpeBRepDS_BuildTool_MakeShell(self, *args)


    def MakeSolid(self, *args):
        """
        MakeSolid(TopOpeBRepDS_BuildTool self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopOpeBRepDS.TopOpeBRepDS_BuildTool_MakeSolid(self, *args)


    def CopyEdge(self, *args):
        """
        CopyEdge(TopOpeBRepDS_BuildTool self, TopoDS_Shape Ein, TopoDS_Shape Eou)

        Make an edge <Eou> with the curve of the edge <Ein>

        :type Ein: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Eou: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopOpeBRepDS.TopOpeBRepDS_BuildTool_CopyEdge(self, *args)


    def GetOrientedEdgeVertices(self, *args):
        """
        GetOrientedEdgeVertices(TopOpeBRepDS_BuildTool self, TopoDS_Edge E, TopoDS_Vertex Vmin, TopoDS_Vertex Vmax)

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type Vmin: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type Vmax: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type Parmin: float
        :type Parmax: float

        """
        return _TopOpeBRepDS.TopOpeBRepDS_BuildTool_GetOrientedEdgeVertices(self, *args)


    def UpdateEdgeCurveTol(self, *args):
        """
        UpdateEdgeCurveTol(TopOpeBRepDS_BuildTool self, TopoDS_Face F1, TopoDS_Face F2, TopoDS_Edge E, Handle_Geom_Curve C3Dnew, Standard_Real const tol3d, Standard_Real const tol2d1, Standard_Real const tol2d2)

        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C3Dnew: OCC.wrapper.Geom.Handle_Geom_Curve
        :type tol3d: float
        :type tol2d1: float
        :type tol2d2: float
        :type newtol: float
        :type newparmin: float
        :type newparmax: float

        """
        return _TopOpeBRepDS.TopOpeBRepDS_BuildTool_UpdateEdgeCurveTol(self, *args)


    def ApproxCurves(self, *args):
        """
        ApproxCurves(TopOpeBRepDS_BuildTool self, TopOpeBRepDS_Curve C, TopoDS_Edge E, Handle_TopOpeBRepDS_HDataStructure HDS)

        :type C: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Curve
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type inewC: int
        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure

        """
        return _TopOpeBRepDS.TopOpeBRepDS_BuildTool_ApproxCurves(self, *args)


    def ComputePCurves(self, *args):
        """
        ComputePCurves(TopOpeBRepDS_BuildTool self, TopOpeBRepDS_Curve C, TopoDS_Edge E, TopOpeBRepDS_Curve newC, Standard_Boolean const CompPC1, Standard_Boolean const CompPC2, Standard_Boolean const CompC3D)

        :type C: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Curve
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type newC: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Curve
        :type CompPC1: bool
        :type CompPC2: bool
        :type CompC3D: bool

        """
        return _TopOpeBRepDS.TopOpeBRepDS_BuildTool_ComputePCurves(self, *args)


    def PutPCurves(self, *args):
        """
        PutPCurves(TopOpeBRepDS_BuildTool self, TopOpeBRepDS_Curve newC, TopoDS_Edge E, Standard_Boolean const CompPC1, Standard_Boolean const CompPC2)

        :type newC: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Curve
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type CompPC1: bool
        :type CompPC2: bool

        """
        return _TopOpeBRepDS.TopOpeBRepDS_BuildTool_PutPCurves(self, *args)


    def RecomputeCurves(self, *args):
        """
        RecomputeCurves(TopOpeBRepDS_BuildTool self, TopOpeBRepDS_Curve C, TopoDS_Edge oldE, TopoDS_Edge E, Handle_TopOpeBRepDS_HDataStructure HDS)

        :type C: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Curve
        :type oldE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type inewC: int
        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure

        """
        return _TopOpeBRepDS.TopOpeBRepDS_BuildTool_RecomputeCurves(self, *args)


    def CopyFace(self, *args):
        """
        CopyFace(TopOpeBRepDS_BuildTool self, TopoDS_Shape Fin, TopoDS_Shape Fou)

        Make a face <Fou> with the surface of the face <Fin>

        :type Fin: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Fou: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopOpeBRepDS.TopOpeBRepDS_BuildTool_CopyFace(self, *args)


    def AddEdgeVertex(self, *args):
        """
        AddEdgeVertex(TopOpeBRepDS_BuildTool self, TopoDS_Shape Ein, TopoDS_Shape Eou, TopoDS_Shape V)
        AddEdgeVertex(TopOpeBRepDS_BuildTool self, TopoDS_Shape E, TopoDS_Shape V)

        :type E: OCC.wrapper.TopoDS.TopoDS_Shape
        :type V: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopOpeBRepDS.TopOpeBRepDS_BuildTool_AddEdgeVertex(self, *args)


    def AddWireEdge(self, *args):
        """
        AddWireEdge(TopOpeBRepDS_BuildTool self, TopoDS_Shape W, TopoDS_Shape E)

        :type W: OCC.wrapper.TopoDS.TopoDS_Shape
        :type E: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopOpeBRepDS.TopOpeBRepDS_BuildTool_AddWireEdge(self, *args)


    def AddFaceWire(self, *args):
        """
        AddFaceWire(TopOpeBRepDS_BuildTool self, TopoDS_Shape F, TopoDS_Shape W)

        :type F: OCC.wrapper.TopoDS.TopoDS_Shape
        :type W: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopOpeBRepDS.TopOpeBRepDS_BuildTool_AddFaceWire(self, *args)


    def AddShellFace(self, *args):
        """
        AddShellFace(TopOpeBRepDS_BuildTool self, TopoDS_Shape Sh, TopoDS_Shape F)

        :type Sh: OCC.wrapper.TopoDS.TopoDS_Shape
        :type F: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopOpeBRepDS.TopOpeBRepDS_BuildTool_AddShellFace(self, *args)


    def AddSolidShell(self, *args):
        """
        AddSolidShell(TopOpeBRepDS_BuildTool self, TopoDS_Shape S, TopoDS_Shape Sh)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Sh: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopOpeBRepDS.TopOpeBRepDS_BuildTool_AddSolidShell(self, *args)


    def Range(self, *args):
        """
        Range(TopOpeBRepDS_BuildTool self, TopoDS_Shape E, Standard_Real const first, Standard_Real const last)

        Sets the range of edge <E>.

        :type E: OCC.wrapper.TopoDS.TopoDS_Shape
        :type first: float
        :type last: float

        """
        return _TopOpeBRepDS.TopOpeBRepDS_BuildTool_Range(self, *args)


    def UpdateEdge(self, *args):
        """
        UpdateEdge(TopOpeBRepDS_BuildTool self, TopoDS_Shape Ein, TopoDS_Shape Eou)

        Sets the range of edge <Eou> from <Ein>
        only when <Ein> has a closed geometry.

        :type Ein: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Eou: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopOpeBRepDS.TopOpeBRepDS_BuildTool_UpdateEdge(self, *args)


    def Parameter(self, *args):
        """
        Parameter(TopOpeBRepDS_BuildTool self, TopoDS_Shape E, TopoDS_Shape V, Standard_Real const P)
        Parameter(TopOpeBRepDS_BuildTool self, TopOpeBRepDS_Curve C, TopoDS_Shape E, TopoDS_Shape V)

        Compute the parameter of  the vertex <V>, supported
        by   the edge <E>, on the curve  <C>.

        :type C: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Curve
        :type E: OCC.wrapper.TopoDS.TopoDS_Shape
        :type V: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopOpeBRepDS.TopOpeBRepDS_BuildTool_Parameter(self, *args)


    def Curve3D(self, *args):
        """
        Curve3D(TopOpeBRepDS_BuildTool self, TopoDS_Shape E, Handle_Geom_Curve C, Standard_Real const Tol)

        Sets the  curve <C> for the edge  <E>

        :type E: OCC.wrapper.TopoDS.TopoDS_Shape
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type Tol: float

        """
        return _TopOpeBRepDS.TopOpeBRepDS_BuildTool_Curve3D(self, *args)


    def PCurve(self, *args):
        """
        PCurve(TopOpeBRepDS_BuildTool self, TopoDS_Shape F, TopoDS_Shape E, Handle_Geom2d_Curve C)
        PCurve(TopOpeBRepDS_BuildTool self, TopoDS_Shape F, TopoDS_Shape E, TopOpeBRepDS_Curve CDS, Handle_Geom2d_Curve C)

        :type F: OCC.wrapper.TopoDS.TopoDS_Shape
        :type E: OCC.wrapper.TopoDS.TopoDS_Shape
        :type CDS: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Curve
        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _TopOpeBRepDS.TopOpeBRepDS_BuildTool_PCurve(self, *args)


    def Orientation(self, *args):
        """
        Orientation(TopOpeBRepDS_BuildTool self, TopoDS_Shape S, TopAbs_Orientation const O)
        Orientation(TopOpeBRepDS_BuildTool self, TopoDS_Shape S) -> TopAbs_Orientation

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _TopOpeBRepDS.TopOpeBRepDS_BuildTool_Orientation(self, *args)


    def Closed(self, *args):
        """
        Closed(TopOpeBRepDS_BuildTool self, TopoDS_Shape S, Standard_Boolean const B)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type B: bool

        """
        return _TopOpeBRepDS.TopOpeBRepDS_BuildTool_Closed(self, *args)


    def Approximation(self, *args):
        """
        Approximation(TopOpeBRepDS_BuildTool self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_BuildTool_Approximation(self, *args)


    def UpdateSurface(self, *args):
        """
        UpdateSurface(TopOpeBRepDS_BuildTool self, TopoDS_Shape F, Handle_Geom_Surface SU)
        UpdateSurface(TopOpeBRepDS_BuildTool self, TopoDS_Shape E, TopoDS_Shape oldF, TopoDS_Shape newF)

        :type E: OCC.wrapper.TopoDS.TopoDS_Shape
        :type oldF: OCC.wrapper.TopoDS.TopoDS_Shape
        :type newF: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopOpeBRepDS.TopOpeBRepDS_BuildTool_UpdateSurface(self, *args)


    def OverWrite(self, *args):
        """
        OverWrite(TopOpeBRepDS_BuildTool self) -> Standard_Boolean
        OverWrite(TopOpeBRepDS_BuildTool self, Standard_Boolean const O)

        :type O: bool

        """
        return _TopOpeBRepDS.TopOpeBRepDS_BuildTool_OverWrite(self, *args)


    def Translate(self, *args):
        """
        Translate(TopOpeBRepDS_BuildTool self) -> Standard_Boolean
        Translate(TopOpeBRepDS_BuildTool self, Standard_Boolean const T)

        :type T: bool

        """
        return _TopOpeBRepDS.TopOpeBRepDS_BuildTool_Translate(self, *args)

    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_BuildTool
TopOpeBRepDS_BuildTool_swigregister = _TopOpeBRepDS.TopOpeBRepDS_BuildTool_swigregister
TopOpeBRepDS_BuildTool_swigregister(TopOpeBRepDS_BuildTool)

class NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopOpeBRepDS_ListOfShapeOn1State,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopOpeBRepDS_ListOfShapeOn1State,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopOpeBRepDS_ListOfShapeOn1State,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,TopOpeBRepDS_ListOfShapeOn1State,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TopOpeBRepDS.new_NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, TopOpeBRepDS_ListOfShapeOn1State theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, TopOpeBRepDS_ListOfShapeOn1State theItem) -> TopOpeBRepDS_ListOfShapeOn1State

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> TopOpeBRepDS_ListOfShapeOn1State

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> TopOpeBRepDS_ListOfShapeOn1State

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> TopOpeBRepDS_ListOfShapeOn1State

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _TopOpeBRepDS.delete_NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher_swigregister = _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopOpeBRepDS.new_NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepDS.delete_NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _TopOpeBRepDS.NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher_IteratorHelper)


try:
	TopOpeBRepDS_DataMapOfShapeListOfShapeOn1State = NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class TopOpeBRepDS_CurveExplorer(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_CurveExplorer self) -> TopOpeBRepDS_CurveExplorer
        __init__(TopOpeBRepDS_CurveExplorer self, TopOpeBRepDS_DataStructure DS, Standard_Boolean const FindOnlyKeep) -> TopOpeBRepDS_CurveExplorer

        :type DS: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_DataStructure
        :type FindOnlyKeep: bool

        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_CurveExplorer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(TopOpeBRepDS_CurveExplorer self, TopOpeBRepDS_DataStructure DS, Standard_Boolean const FindOnlyKeep)

        :type DS: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_DataStructure
        :type FindOnlyKeep: bool

        """
        return _TopOpeBRepDS.TopOpeBRepDS_CurveExplorer_Init(self, *args)


    def More(self, *args):
        """
        More(TopOpeBRepDS_CurveExplorer self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_CurveExplorer_More(self, *args)


    def Next(self, *args):
        """Next(TopOpeBRepDS_CurveExplorer self)"""
        return _TopOpeBRepDS.TopOpeBRepDS_CurveExplorer_Next(self, *args)


    def IsCurve(self, *args):
        """
        IsCurve(TopOpeBRepDS_CurveExplorer self, Standard_Integer const I) -> Standard_Boolean

        :type I: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_CurveExplorer_IsCurve(self, *args)


    def IsCurveKeep(self, *args):
        """
        IsCurveKeep(TopOpeBRepDS_CurveExplorer self, Standard_Integer const I) -> Standard_Boolean

        :type I: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_CurveExplorer_IsCurveKeep(self, *args)


    def Curve(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Curve

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_CurveExplorer_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbCurve(self, *args):
        """
        NbCurve(TopOpeBRepDS_CurveExplorer self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_CurveExplorer_NbCurve(self, *args)


    def Index(self, *args):
        """
        Index(TopOpeBRepDS_CurveExplorer self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_CurveExplorer_Index(self, *args)

    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_CurveExplorer
TopOpeBRepDS_CurveExplorer_swigregister = _TopOpeBRepDS.TopOpeBRepDS_CurveExplorer_swigregister
TopOpeBRepDS_CurveExplorer_swigregister(TopOpeBRepDS_CurveExplorer)

class Handle_TopOpeBRepDS_Interference(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopOpeBRepDS_Interference self)

        Nullify the handle


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Interference_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopOpeBRepDS_Interference self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Interference_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopOpeBRepDS_Interference self, TopOpeBRepDS_Interference thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Interference_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopOpeBRepDS_Interference self, Handle_TopOpeBRepDS_Interference theHandle) -> Handle_TopOpeBRepDS_Interference
        assign(Handle_TopOpeBRepDS_Interference self, TopOpeBRepDS_Interference thePtr) -> Handle_TopOpeBRepDS_Interference
        assign(Handle_TopOpeBRepDS_Interference self, Handle_TopOpeBRepDS_Interference theHandle) -> Handle_TopOpeBRepDS_Interference

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Interference_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopOpeBRepDS_Interference self) -> TopOpeBRepDS_Interference

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Interference_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopOpeBRepDS_Interference self) -> TopOpeBRepDS_Interference

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Interference___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopOpeBRepDS_Interference self) -> TopOpeBRepDS_Interference

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Interference___ref__(self, *args)


    def __hash__(self):
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Interference___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopOpeBRepDS.Handle_TopOpeBRepDS_Interference___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopOpeBRepDS.new_Handle_TopOpeBRepDS_Interference(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopOpeBRepDS.Handle_TopOpeBRepDS_Interference_DownCast)
    __swig_destroy__ = _TopOpeBRepDS.delete_Handle_TopOpeBRepDS_Interference

    def Transition(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_Interference_Transition(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeTransition(self, *args):
        """
        ChangeTransition(Handle_TopOpeBRepDS_Interference self) -> TopOpeBRepDS_Transition

        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Interference_ChangeTransition(self, *args)


    def GKGSKS(self, *args):
        """
        GKGSKS(Handle_TopOpeBRepDS_Interference self)

        return GeometryType + Geometry + SupportType + Support

        :type GK: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type G: int
        :type SK: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type S: int

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Interference_GKGSKS(self, *args)


    def SupportType(self, *args):
        """
        SupportType(Handle_TopOpeBRepDS_Interference self) -> TopOpeBRepDS_Kind
        SupportType(Handle_TopOpeBRepDS_Interference self, TopOpeBRepDS_Kind const ST)

        :type ST: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Interference_SupportType(self, *args)


    def Support(self, *args):
        """
        Support(Handle_TopOpeBRepDS_Interference self) -> Standard_Integer
        Support(Handle_TopOpeBRepDS_Interference self, Standard_Integer const S)

        :type S: int

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Interference_Support(self, *args)


    def GeometryType(self, *args):
        """
        GeometryType(Handle_TopOpeBRepDS_Interference self) -> TopOpeBRepDS_Kind
        GeometryType(Handle_TopOpeBRepDS_Interference self, TopOpeBRepDS_Kind const GT)

        :type GT: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Interference_GeometryType(self, *args)


    def Geometry(self, *args):
        """
        Geometry(Handle_TopOpeBRepDS_Interference self) -> Standard_Integer
        Geometry(Handle_TopOpeBRepDS_Interference self, Standard_Integer const G)

        :type G: int

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Interference_Geometry(self, *args)


    def SetGeometry(self, *args):
        """
        SetGeometry(Handle_TopOpeBRepDS_Interference self, Standard_Integer const GI)

        :type GI: int

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Interference_SetGeometry(self, *args)


    def HasSameSupport(self, *args):
        """
        HasSameSupport(Handle_TopOpeBRepDS_Interference self, Handle_TopOpeBRepDS_Interference Other) -> Standard_Boolean

        :type Other: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Interference_HasSameSupport(self, *args)


    def HasSameGeometry(self, *args):
        """
        HasSameGeometry(Handle_TopOpeBRepDS_Interference self, Handle_TopOpeBRepDS_Interference Other) -> Standard_Boolean

        :type Other: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Interference_HasSameGeometry(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopOpeBRepDS_Interference self) -> char const *

        :rtype: const char *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Interference_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_Interference_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_Interference_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TopOpeBRepDS_Interference self)

        Memory deallocator for transient classes


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Interference_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopOpeBRepDS_Interference self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopOpeBRepDS_Interference self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Interference_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopOpeBRepDS_Interference self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopOpeBRepDS_Interference self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Interference_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopOpeBRepDS_Interference self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Interference_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopOpeBRepDS_Interference self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Interference_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopOpeBRepDS_Interference self)

        Increments the reference counter of this object


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Interference_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopOpeBRepDS_Interference self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Interference_DecrementRefCounter(self, *args)

Handle_TopOpeBRepDS_Interference_swigregister = _TopOpeBRepDS.Handle_TopOpeBRepDS_Interference_swigregister
Handle_TopOpeBRepDS_Interference_swigregister(Handle_TopOpeBRepDS_Interference)

def Handle_TopOpeBRepDS_Interference_DownCast(thing):
    return _TopOpeBRepDS.Handle_TopOpeBRepDS_Interference_DownCast(thing)
Handle_TopOpeBRepDS_Interference_DownCast = _TopOpeBRepDS.Handle_TopOpeBRepDS_Interference_DownCast

class TopOpeBRepDS_Curve(object):
    """A Geom curve and a tolerance."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_Curve self) -> TopOpeBRepDS_Curve
        __init__(TopOpeBRepDS_Curve self, Handle_Geom_Curve P, Standard_Real const T, Standard_Boolean const IsWalk) -> TopOpeBRepDS_Curve

        :type P: OCC.wrapper.Geom.Handle_Geom_Curve
        :type T: float
        :type IsWalk: bool

        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_Curve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def DefineCurve(self, *args):
        """
        DefineCurve(TopOpeBRepDS_Curve self, Handle_Geom_Curve P, Standard_Real const T, Standard_Boolean const IsWalk)

        :type P: OCC.wrapper.Geom.Handle_Geom_Curve
        :type T: float
        :type IsWalk: bool

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Curve_DefineCurve(self, *args)


    def SetSCI(self, *args):
        """
        SetSCI(TopOpeBRepDS_Curve self, Handle_TopOpeBRepDS_Interference I1, Handle_TopOpeBRepDS_Interference I2)

        define the interferences face/curve.

        :type I1: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :type I2: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Curve_SetSCI(self, *args)


    def GetSCI1(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_Curve_GetSCI1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetSCI2(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_Curve_GetSCI2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetSCI(self, *args):
        """
        GetSCI(TopOpeBRepDS_Curve self, Handle_TopOpeBRepDS_Interference I1, Handle_TopOpeBRepDS_Interference I2)

        :type I1: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :type I2: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Curve_GetSCI(self, *args)


    def SetShapes(self, *args):
        """
        SetShapes(TopOpeBRepDS_Curve self, TopoDS_Shape S1, TopoDS_Shape S2)

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Curve_SetShapes(self, *args)


    def GetShapes(self, *args):
        """
        GetShapes(TopOpeBRepDS_Curve self, TopoDS_Shape S1, TopoDS_Shape S2)

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Curve_GetShapes(self, *args)


    def Shape1(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_Curve_Shape1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeShape1(self, *args):
        """
        ChangeShape1(TopOpeBRepDS_Curve self) -> TopoDS_Shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Curve_ChangeShape1(self, *args)


    def Shape2(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_Curve_Shape2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeShape2(self, *args):
        """
        ChangeShape2(TopOpeBRepDS_Curve self) -> TopoDS_Shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Curve_ChangeShape2(self, *args)


    def SetRange(self, *args):
        """
        SetRange(TopOpeBRepDS_Curve self, Standard_Real const First, Standard_Real const Last)

        :type First: float
        :type Last: float

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Curve_SetRange(self, *args)


    def Range(self, *args):
        """
        Range(TopOpeBRepDS_Curve self) -> Standard_Boolean

        :type First: float
        :type Last: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Curve_Range(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(TopOpeBRepDS_Curve self, Standard_Real const tol)
        Tolerance(TopOpeBRepDS_Curve self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Curve_Tolerance(self, *args)


    def ChangeCurve(self, *args):
        """
        ChangeCurve(TopOpeBRepDS_Curve self) -> Handle_Geom_Curve

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Curve_ChangeCurve(self, *args)


    def Curve(self, *args):
        """
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_Curve_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Curve1(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_Curve_Curve1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Curve2(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_Curve_Curve2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsWalk(self, *args):
        """
        IsWalk(TopOpeBRepDS_Curve self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Curve_IsWalk(self, *args)


    def ChangeIsWalk(self, *args):
        """
        ChangeIsWalk(TopOpeBRepDS_Curve self, Standard_Boolean const B)

        :type B: bool

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Curve_ChangeIsWalk(self, *args)


    def Keep(self, *args):
        """
        Keep(TopOpeBRepDS_Curve self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Curve_Keep(self, *args)


    def ChangeKeep(self, *args):
        """
        ChangeKeep(TopOpeBRepDS_Curve self, Standard_Boolean const B)

        :type B: bool

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Curve_ChangeKeep(self, *args)


    def Mother(self, *args):
        """
        Mother(TopOpeBRepDS_Curve self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Curve_Mother(self, *args)


    def ChangeMother(self, *args):
        """
        ChangeMother(TopOpeBRepDS_Curve self, Standard_Integer const I)

        :type I: int

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Curve_ChangeMother(self, *args)


    def DSIndex(self, *args):
        """
        DSIndex(TopOpeBRepDS_Curve self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Curve_DSIndex(self, *args)


    def ChangeDSIndex(self, *args):
        """
        ChangeDSIndex(TopOpeBRepDS_Curve self, Standard_Integer const I)

        :type I: int

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Curve_ChangeDSIndex(self, *args)

    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_Curve
TopOpeBRepDS_Curve_swigregister = _TopOpeBRepDS.TopOpeBRepDS_Curve_swigregister
TopOpeBRepDS_Curve_swigregister(TopOpeBRepDS_Curve)

class Handle_TopOpeBRepDS_Check(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopOpeBRepDS_Check self)

        Nullify the handle


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Check_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopOpeBRepDS_Check self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Check_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopOpeBRepDS_Check self, TopOpeBRepDS_Check thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Check_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopOpeBRepDS_Check self, Handle_TopOpeBRepDS_Check theHandle) -> Handle_TopOpeBRepDS_Check
        assign(Handle_TopOpeBRepDS_Check self, TopOpeBRepDS_Check thePtr) -> Handle_TopOpeBRepDS_Check
        assign(Handle_TopOpeBRepDS_Check self, Handle_TopOpeBRepDS_Check theHandle) -> Handle_TopOpeBRepDS_Check

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Check_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopOpeBRepDS_Check self) -> TopOpeBRepDS_Check

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Check_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopOpeBRepDS_Check self) -> TopOpeBRepDS_Check

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Check___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopOpeBRepDS_Check self) -> TopOpeBRepDS_Check

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Check___ref__(self, *args)


    def __hash__(self):
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Check___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopOpeBRepDS.Handle_TopOpeBRepDS_Check___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopOpeBRepDS.new_Handle_TopOpeBRepDS_Check(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopOpeBRepDS.Handle_TopOpeBRepDS_Check_DownCast)
    __swig_destroy__ = _TopOpeBRepDS.delete_Handle_TopOpeBRepDS_Check

    def ChkIntg(self, *args):
        """
        ChkIntg(Handle_TopOpeBRepDS_Check self) -> Standard_Boolean

        Check integrition of DS

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Check_ChkIntg(self, *args)


    def ChkIntgInterf(self, *args):
        """
        ChkIntgInterf(Handle_TopOpeBRepDS_Check self, NCollection_List_Handle_TopOpeBRepDS_Interference LI) -> Standard_Boolean

        Check integrition of interferences
        (les supports et les geometries de LI)

        :type LI: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Check_ChkIntgInterf(self, *args)


    def CheckDS(self, *args):
        """
        CheckDS(Handle_TopOpeBRepDS_Check self, Standard_Integer const i, TopOpeBRepDS_Kind const K) -> Standard_Boolean

        Verifie que le ieme element de la DS existe, et
        pour un K de type topologique, verifie qu'il est du
        bon type (VERTEX, EDGE, WIRE, FACE, SHELL ou SOLID)

        :type i: int
        :type K: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Check_CheckDS(self, *args)


    def ChkIntgSamDom(self, *args):
        """
        ChkIntgSamDom(Handle_TopOpeBRepDS_Check self) -> Standard_Boolean

        Check integrition des champs SameDomain de la DS

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Check_ChkIntgSamDom(self, *args)


    def CheckShapes(self, *args):
        """
        CheckShapes(Handle_TopOpeBRepDS_Check self, NCollection_List_TopoDS_Shape LS) -> Standard_Boolean

        Verifie que les Shapes existent bien dans la DS
        Utile pour les Shapes SameDomain
        si la liste est vide, renvoie vrai

        :type LS: OCC.wrapper.TopTools.TopTools_ListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Check_CheckShapes(self, *args)


    def OneVertexOnPnt(self, *args):
        """
        OneVertexOnPnt(Handle_TopOpeBRepDS_Check self) -> Standard_Boolean

        Verifie que les Vertex   non   SameDomain sont bien
        nonSameDomain, que  les  vertex sameDomain sont  bien
        SameDomain,  que    les  Points sont  non    confondus
        ni entre eux, ni avec des Vertex.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Check_OneVertexOnPnt(self, *args)


    def HDS(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_Check_HDS(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeHDS(self, *args):
        """
        ChangeHDS(Handle_TopOpeBRepDS_Check self) -> Handle_TopOpeBRepDS_HDataStructure

        :rtype: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Check_ChangeHDS(self, *args)


    def PrintIntg(self, *args):
        """
        PrintIntg(Handle_TopOpeBRepDS_Check self, Standard_OStream & S) -> Standard_OStream &

        :type S: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Check_PrintIntg(self, *args)


    def Print(self, *args):
        """
        Print(Handle_TopOpeBRepDS_Check self, TopOpeBRepDS_CheckStatus const stat, Standard_OStream & S) -> Standard_OStream &

        Prints the name  of CheckStatus  <stat>  as  a String

        :type stat: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_CheckStatus
        :type S: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Check_Print(self, *args)


    def PrintShape(self, *args):
        """
        PrintShape(Handle_TopOpeBRepDS_Check self, TopAbs_ShapeEnum const SE, Standard_OStream & S) -> Standard_OStream
        PrintShape(Handle_TopOpeBRepDS_Check self, Standard_Integer const index, Standard_OStream & S) -> Standard_OStream &

        Prints the name  of CheckStatus  <stat>  as  a String

        :type index: int
        :type S: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Check_PrintShape(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopOpeBRepDS_Check self) -> char const *

        :rtype: const char *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Check_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_Check_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_Check_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TopOpeBRepDS_Check self)

        Memory deallocator for transient classes


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Check_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopOpeBRepDS_Check self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopOpeBRepDS_Check self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Check_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopOpeBRepDS_Check self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopOpeBRepDS_Check self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Check_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopOpeBRepDS_Check self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Check_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopOpeBRepDS_Check self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Check_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopOpeBRepDS_Check self)

        Increments the reference counter of this object


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Check_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopOpeBRepDS_Check self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_Check_DecrementRefCounter(self, *args)

Handle_TopOpeBRepDS_Check_swigregister = _TopOpeBRepDS.Handle_TopOpeBRepDS_Check_swigregister
Handle_TopOpeBRepDS_Check_swigregister(Handle_TopOpeBRepDS_Check)

def Handle_TopOpeBRepDS_Check_DownCast(thing):
    return _TopOpeBRepDS.Handle_TopOpeBRepDS_Check_DownCast(thing)
Handle_TopOpeBRepDS_Check_DownCast = _TopOpeBRepDS.Handle_TopOpeBRepDS_Check_DownCast

class TopOpeBRepDS_Edge3dInterferenceTool(object):
    """
    a tool computing edge / face complex transition,
    Interferences of edge reference are given by
    I = (T on face, G = point or vertex, S = edge)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_Edge3dInterferenceTool self) -> TopOpeBRepDS_Edge3dInterferenceTool

        a tool computing edge / face complex transition,
        Interferences of edge reference are given by
        I = (T on face, G = point or vertex, S = edge)
        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_Edge3dInterferenceTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def InitPointVertex(self, *args):
        """
        InitPointVertex(TopOpeBRepDS_Edge3dInterferenceTool self, Standard_Integer const IsVertex, TopoDS_Shape VonOO)

        :type IsVertex: int
        :type VonOO: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Edge3dInterferenceTool_InitPointVertex(self, *args)


    def Init(self, *args):
        """
        Init(TopOpeBRepDS_Edge3dInterferenceTool self, TopoDS_Shape Eref, TopoDS_Shape E, TopoDS_Shape F, Handle_TopOpeBRepDS_Interference I)

        :type Eref: OCC.wrapper.TopoDS.TopoDS_Shape
        :type E: OCC.wrapper.TopoDS.TopoDS_Shape
        :type F: OCC.wrapper.TopoDS.TopoDS_Shape
        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Edge3dInterferenceTool_Init(self, *args)


    def Add(self, *args):
        """
        Add(TopOpeBRepDS_Edge3dInterferenceTool self, TopoDS_Shape Eref, TopoDS_Shape E, TopoDS_Shape F, Handle_TopOpeBRepDS_Interference I)

        :type Eref: OCC.wrapper.TopoDS.TopoDS_Shape
        :type E: OCC.wrapper.TopoDS.TopoDS_Shape
        :type F: OCC.wrapper.TopoDS.TopoDS_Shape
        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Edge3dInterferenceTool_Add(self, *args)


    def Transition(self, *args):
        """
        Transition(TopOpeBRepDS_Edge3dInterferenceTool self, Handle_TopOpeBRepDS_Interference I)

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Edge3dInterferenceTool_Transition(self, *args)

    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_Edge3dInterferenceTool
TopOpeBRepDS_Edge3dInterferenceTool_swigregister = _TopOpeBRepDS.TopOpeBRepDS_Edge3dInterferenceTool_swigregister
TopOpeBRepDS_Edge3dInterferenceTool_swigregister(TopOpeBRepDS_Edge3dInterferenceTool)

class Handle_TopOpeBRepDS_SolidSurfaceInterference(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopOpeBRepDS_SolidSurfaceInterference self)

        Nullify the handle


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SolidSurfaceInterference_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopOpeBRepDS_SolidSurfaceInterference self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SolidSurfaceInterference_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopOpeBRepDS_SolidSurfaceInterference self, TopOpeBRepDS_SolidSurfaceInterference thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SolidSurfaceInterference_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopOpeBRepDS_SolidSurfaceInterference self, Handle_TopOpeBRepDS_SolidSurfaceInterference theHandle) -> Handle_TopOpeBRepDS_SolidSurfaceInterference
        assign(Handle_TopOpeBRepDS_SolidSurfaceInterference self, TopOpeBRepDS_SolidSurfaceInterference thePtr) -> Handle_TopOpeBRepDS_SolidSurfaceInterference
        assign(Handle_TopOpeBRepDS_SolidSurfaceInterference self, Handle_TopOpeBRepDS_SolidSurfaceInterference theHandle) -> Handle_TopOpeBRepDS_SolidSurfaceInterference

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SolidSurfaceInterference_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopOpeBRepDS_SolidSurfaceInterference self) -> TopOpeBRepDS_SolidSurfaceInterference

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SolidSurfaceInterference_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopOpeBRepDS_SolidSurfaceInterference self) -> TopOpeBRepDS_SolidSurfaceInterference

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SolidSurfaceInterference___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopOpeBRepDS_SolidSurfaceInterference self) -> TopOpeBRepDS_SolidSurfaceInterference

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SolidSurfaceInterference___ref__(self, *args)


    def __hash__(self):
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SolidSurfaceInterference___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopOpeBRepDS.Handle_TopOpeBRepDS_SolidSurfaceInterference___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopOpeBRepDS.new_Handle_TopOpeBRepDS_SolidSurfaceInterference(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopOpeBRepDS.Handle_TopOpeBRepDS_SolidSurfaceInterference_DownCast)
    __swig_destroy__ = _TopOpeBRepDS.delete_Handle_TopOpeBRepDS_SolidSurfaceInterference

    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopOpeBRepDS_SolidSurfaceInterference self) -> char const *

        :rtype: const char *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SolidSurfaceInterference_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_SolidSurfaceInterference_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_SolidSurfaceInterference_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transition(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_SolidSurfaceInterference_Transition(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeTransition(self, *args):
        """
        ChangeTransition(Handle_TopOpeBRepDS_SolidSurfaceInterference self) -> TopOpeBRepDS_Transition

        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SolidSurfaceInterference_ChangeTransition(self, *args)


    def GKGSKS(self, *args):
        """
        GKGSKS(Handle_TopOpeBRepDS_SolidSurfaceInterference self)

        return GeometryType + Geometry + SupportType + Support

        :type GK: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type G: int
        :type SK: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type S: int

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SolidSurfaceInterference_GKGSKS(self, *args)


    def SupportType(self, *args):
        """
        SupportType(Handle_TopOpeBRepDS_SolidSurfaceInterference self) -> TopOpeBRepDS_Kind
        SupportType(Handle_TopOpeBRepDS_SolidSurfaceInterference self, TopOpeBRepDS_Kind const ST)

        :type ST: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SolidSurfaceInterference_SupportType(self, *args)


    def Support(self, *args):
        """
        Support(Handle_TopOpeBRepDS_SolidSurfaceInterference self) -> Standard_Integer
        Support(Handle_TopOpeBRepDS_SolidSurfaceInterference self, Standard_Integer const S)

        :type S: int

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SolidSurfaceInterference_Support(self, *args)


    def GeometryType(self, *args):
        """
        GeometryType(Handle_TopOpeBRepDS_SolidSurfaceInterference self) -> TopOpeBRepDS_Kind
        GeometryType(Handle_TopOpeBRepDS_SolidSurfaceInterference self, TopOpeBRepDS_Kind const GT)

        :type GT: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SolidSurfaceInterference_GeometryType(self, *args)


    def Geometry(self, *args):
        """
        Geometry(Handle_TopOpeBRepDS_SolidSurfaceInterference self) -> Standard_Integer
        Geometry(Handle_TopOpeBRepDS_SolidSurfaceInterference self, Standard_Integer const G)

        :type G: int

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SolidSurfaceInterference_Geometry(self, *args)


    def SetGeometry(self, *args):
        """
        SetGeometry(Handle_TopOpeBRepDS_SolidSurfaceInterference self, Standard_Integer const GI)

        :type GI: int

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SolidSurfaceInterference_SetGeometry(self, *args)


    def HasSameSupport(self, *args):
        """
        HasSameSupport(Handle_TopOpeBRepDS_SolidSurfaceInterference self, Handle_TopOpeBRepDS_Interference Other) -> Standard_Boolean

        :type Other: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SolidSurfaceInterference_HasSameSupport(self, *args)


    def HasSameGeometry(self, *args):
        """
        HasSameGeometry(Handle_TopOpeBRepDS_SolidSurfaceInterference self, Handle_TopOpeBRepDS_Interference Other) -> Standard_Boolean

        :type Other: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SolidSurfaceInterference_HasSameGeometry(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TopOpeBRepDS_SolidSurfaceInterference self)

        Memory deallocator for transient classes


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SolidSurfaceInterference_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopOpeBRepDS_SolidSurfaceInterference self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopOpeBRepDS_SolidSurfaceInterference self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SolidSurfaceInterference_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopOpeBRepDS_SolidSurfaceInterference self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopOpeBRepDS_SolidSurfaceInterference self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SolidSurfaceInterference_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopOpeBRepDS_SolidSurfaceInterference self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SolidSurfaceInterference_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopOpeBRepDS_SolidSurfaceInterference self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SolidSurfaceInterference_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopOpeBRepDS_SolidSurfaceInterference self)

        Increments the reference counter of this object


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SolidSurfaceInterference_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopOpeBRepDS_SolidSurfaceInterference self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SolidSurfaceInterference_DecrementRefCounter(self, *args)

Handle_TopOpeBRepDS_SolidSurfaceInterference_swigregister = _TopOpeBRepDS.Handle_TopOpeBRepDS_SolidSurfaceInterference_swigregister
Handle_TopOpeBRepDS_SolidSurfaceInterference_swigregister(Handle_TopOpeBRepDS_SolidSurfaceInterference)

def Handle_TopOpeBRepDS_SolidSurfaceInterference_DownCast(thing):
    return _TopOpeBRepDS.Handle_TopOpeBRepDS_SolidSurfaceInterference_DownCast(thing)
Handle_TopOpeBRepDS_SolidSurfaceInterference_DownCast = _TopOpeBRepDS.Handle_TopOpeBRepDS_SolidSurfaceInterference_DownCast

class TopOpeBRepDS_GapFiller(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_GapFiller self, Handle_TopOpeBRepDS_HDataStructure HDS) -> TopOpeBRepDS_GapFiller

        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure

        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_GapFiller(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """Perform(TopOpeBRepDS_GapFiller self)"""
        return _TopOpeBRepDS.TopOpeBRepDS_GapFiller_Perform(self, *args)


    def FindAssociatedPoints(self, *args):
        """
        FindAssociatedPoints(TopOpeBRepDS_GapFiller self, Handle_TopOpeBRepDS_Interference I, NCollection_List_Handle_TopOpeBRepDS_Interference LI)

        Recherche parmi  l'ensemble  des points  d'Interference
        la Liste <LI> des points qui correspondent au point d'indice <Index>

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :type LI: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_GapFiller_FindAssociatedPoints(self, *args)


    def CheckConnexity(self, *args):
        """
        CheckConnexity(TopOpeBRepDS_GapFiller self, NCollection_List_Handle_TopOpeBRepDS_Interference LI) -> Standard_Boolean

        Enchaine les sections   via  les points d'Interferences  deja
        associe; Renvoit  dans   <L> les points extremites des Lignes.
        Methodes pour  construire la liste des Points qui
        peuvent correspondre a une Point donne.

        :type LI: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_GapFiller_CheckConnexity(self, *args)


    def AddPointsOnShape(self, *args):
        """
        AddPointsOnShape(TopOpeBRepDS_GapFiller self, TopoDS_Shape S, NCollection_List_Handle_TopOpeBRepDS_Interference LI)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type LI: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_GapFiller_AddPointsOnShape(self, *args)


    def AddPointsOnConnexShape(self, *args):
        """
        AddPointsOnConnexShape(TopOpeBRepDS_GapFiller self, TopoDS_Shape F, NCollection_List_Handle_TopOpeBRepDS_Interference LI)

        Methodes pour  reduire la liste des Points qui
        peuvent correspondre a une Point donne.

        :type F: OCC.wrapper.TopoDS.TopoDS_Shape
        :type LI: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_GapFiller_AddPointsOnConnexShape(self, *args)


    def FilterByFace(self, *args):
        """
        FilterByFace(TopOpeBRepDS_GapFiller self, TopoDS_Face F, NCollection_List_Handle_TopOpeBRepDS_Interference LI)

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type LI: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_GapFiller_FilterByFace(self, *args)


    def FilterByEdge(self, *args):
        """
        FilterByEdge(TopOpeBRepDS_GapFiller self, TopoDS_Edge E, NCollection_List_Handle_TopOpeBRepDS_Interference LI)

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type LI: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_GapFiller_FilterByEdge(self, *args)


    def FilterByIncidentDistance(self, *args):
        """
        FilterByIncidentDistance(TopOpeBRepDS_GapFiller self, TopoDS_Face F, Handle_TopOpeBRepDS_Interference I, NCollection_List_Handle_TopOpeBRepDS_Interference LI)

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :type LI: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_GapFiller_FilterByIncidentDistance(self, *args)


    def IsOnFace(self, *args):
        """
        IsOnFace(TopOpeBRepDS_GapFiller self, Handle_TopOpeBRepDS_Interference I, TopoDS_Face F) -> Standard_Boolean

        Return TRUE si I a ete obtenu par une intersection
        avec <F>.

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_GapFiller_IsOnFace(self, *args)


    def IsOnEdge(self, *args):
        """
        IsOnEdge(TopOpeBRepDS_GapFiller self, Handle_TopOpeBRepDS_Interference I, TopoDS_Edge E) -> Standard_Boolean

        Return TRUE  si I ou une  de  ses representaions a
        pour support <E>.
        Methodes de  reconstructions des  geometries des point
        et des courbes de section

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_GapFiller_IsOnEdge(self, *args)


    def BuildNewGeometries(self, *args):
        """BuildNewGeometries(TopOpeBRepDS_GapFiller self)"""
        return _TopOpeBRepDS.TopOpeBRepDS_GapFiller_BuildNewGeometries(self, *args)


    def ReBuildGeom(self, *args):
        """
        ReBuildGeom(TopOpeBRepDS_GapFiller self, Handle_TopOpeBRepDS_Interference I1, NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher Done)

        :type I1: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :type Done: OCC.wrapper.TColStd.TColStd_MapOfInteger

        """
        return _TopOpeBRepDS.TopOpeBRepDS_GapFiller_ReBuildGeom(self, *args)

    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_GapFiller
TopOpeBRepDS_GapFiller_swigregister = _TopOpeBRepDS.TopOpeBRepDS_GapFiller_swigregister
TopOpeBRepDS_GapFiller_swigregister(TopOpeBRepDS_GapFiller)

class TopOpeBRepDS_DataStructure(object):
    """
    The DataStructure stores :

    New geometries : points, curves, and surfaces.
    Topological shapes : vertices, edges, faces.
    The new geometries and the topological shapes have interferences.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_DataStructure self) -> TopOpeBRepDS_DataStructure

        The DataStructure stores :

        New geometries : points, curves, and surfaces.
        Topological shapes : vertices, edges, faces.
        The new geometries and the topological shapes have interferences.
        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_DataStructure(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(TopOpeBRepDS_DataStructure self)

        reset the data structure


        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_Init(self, *args)


    def AddSurface(self, *args):
        """
        AddSurface(TopOpeBRepDS_DataStructure self, TopOpeBRepDS_Surface S) -> Standard_Integer

        Insert a new surface. Returns the index.

        :type S: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Surface
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_AddSurface(self, *args)


    def RemoveSurface(self, *args):
        """
        RemoveSurface(TopOpeBRepDS_DataStructure self, Standard_Integer const I)

        :type I: int

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_RemoveSurface(self, *args)


    def KeepSurface(self, *args):
        """
        KeepSurface(TopOpeBRepDS_DataStructure self, Standard_Integer const I) -> Standard_Boolean
        KeepSurface(TopOpeBRepDS_DataStructure self, TopOpeBRepDS_Surface S) -> Standard_Boolean

        :type S: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Surface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_KeepSurface(self, *args)


    def ChangeKeepSurface(self, *args):
        """
        ChangeKeepSurface(TopOpeBRepDS_DataStructure self, Standard_Integer const I, Standard_Boolean const FindKeep)
        ChangeKeepSurface(TopOpeBRepDS_DataStructure self, TopOpeBRepDS_Surface S, Standard_Boolean const FindKeep)

        :type S: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Surface
        :type FindKeep: bool

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_ChangeKeepSurface(self, *args)


    def AddCurve(self, *args):
        """
        AddCurve(TopOpeBRepDS_DataStructure self, TopOpeBRepDS_Curve S) -> Standard_Integer

        Insert a new curve. Returns the index.

        :type S: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Curve
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_AddCurve(self, *args)


    def RemoveCurve(self, *args):
        """
        RemoveCurve(TopOpeBRepDS_DataStructure self, Standard_Integer const I)

        :type I: int

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_RemoveCurve(self, *args)


    def KeepCurve(self, *args):
        """
        KeepCurve(TopOpeBRepDS_DataStructure self, Standard_Integer const I) -> Standard_Boolean
        KeepCurve(TopOpeBRepDS_DataStructure self, TopOpeBRepDS_Curve C) -> Standard_Boolean

        :type C: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Curve
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_KeepCurve(self, *args)


    def ChangeKeepCurve(self, *args):
        """
        ChangeKeepCurve(TopOpeBRepDS_DataStructure self, Standard_Integer const I, Standard_Boolean const FindKeep)
        ChangeKeepCurve(TopOpeBRepDS_DataStructure self, TopOpeBRepDS_Curve C, Standard_Boolean const FindKeep)

        :type C: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Curve
        :type FindKeep: bool

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_ChangeKeepCurve(self, *args)


    def AddPoint(self, *args):
        """
        AddPoint(TopOpeBRepDS_DataStructure self, TopOpeBRepDS_Point PDS) -> Standard_Integer

        Insert a new point. Returns the index.

        :type PDS: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Point
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_AddPoint(self, *args)


    def AddPointSS(self, *args):
        """
        AddPointSS(TopOpeBRepDS_DataStructure self, TopOpeBRepDS_Point PDS, TopoDS_Shape S1, TopoDS_Shape S2) -> Standard_Integer

        Insert a new point. Returns the index.

        :type PDS: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Point
        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_AddPointSS(self, *args)


    def RemovePoint(self, *args):
        """
        RemovePoint(TopOpeBRepDS_DataStructure self, Standard_Integer const I)

        :type I: int

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_RemovePoint(self, *args)


    def KeepPoint(self, *args):
        """
        KeepPoint(TopOpeBRepDS_DataStructure self, Standard_Integer const I) -> Standard_Boolean
        KeepPoint(TopOpeBRepDS_DataStructure self, TopOpeBRepDS_Point P) -> Standard_Boolean

        :type P: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Point
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_KeepPoint(self, *args)


    def ChangeKeepPoint(self, *args):
        """
        ChangeKeepPoint(TopOpeBRepDS_DataStructure self, Standard_Integer const I, Standard_Boolean const FindKeep)
        ChangeKeepPoint(TopOpeBRepDS_DataStructure self, TopOpeBRepDS_Point P, Standard_Boolean const FindKeep)

        :type P: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Point
        :type FindKeep: bool

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_ChangeKeepPoint(self, *args)


    def AddShape(self, *args):
        """
        AddShape(TopOpeBRepDS_DataStructure self, TopoDS_Shape S) -> Standard_Integer
        AddShape(TopOpeBRepDS_DataStructure self, TopoDS_Shape S, Standard_Integer const I) -> Standard_Integer

        Insert a shape S which ancestor is I = 1 or 2. Returns the index.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type I: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_AddShape(self, *args)


    def KeepShape(self, *args):
        """
        KeepShape(TopOpeBRepDS_DataStructure self, Standard_Integer const I, Standard_Boolean const FindKeep) -> Standard_Boolean
        KeepShape(TopOpeBRepDS_DataStructure self, TopoDS_Shape S, Standard_Boolean const FindKeep) -> Standard_Boolean

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type FindKeep: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_KeepShape(self, *args)


    def ChangeKeepShape(self, *args):
        """
        ChangeKeepShape(TopOpeBRepDS_DataStructure self, Standard_Integer const I, Standard_Boolean const FindKeep)
        ChangeKeepShape(TopOpeBRepDS_DataStructure self, TopoDS_Shape S, Standard_Boolean const FindKeep)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type FindKeep: bool

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_ChangeKeepShape(self, *args)


    def InitSectionEdges(self, *args):
        """InitSectionEdges(TopOpeBRepDS_DataStructure self)"""
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_InitSectionEdges(self, *args)


    def AddSectionEdge(self, *args):
        """
        AddSectionEdge(TopOpeBRepDS_DataStructure self, TopoDS_Edge E) -> Standard_Integer

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_AddSectionEdge(self, *args)


    def SurfaceInterferences(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_DataStructure_SurfaceInterferences(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSurfaceInterferences(self, *args):
        """
        ChangeSurfaceInterferences(TopOpeBRepDS_DataStructure self, Standard_Integer const I) -> NCollection_List_Handle_TopOpeBRepDS_Interference

        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_ChangeSurfaceInterferences(self, *args)


    def CurveInterferences(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_DataStructure_CurveInterferences(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeCurveInterferences(self, *args):
        """
        ChangeCurveInterferences(TopOpeBRepDS_DataStructure self, Standard_Integer const I) -> NCollection_List_Handle_TopOpeBRepDS_Interference

        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_ChangeCurveInterferences(self, *args)


    def PointInterferences(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_DataStructure_PointInterferences(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangePointInterferences(self, *args):
        """
        ChangePointInterferences(TopOpeBRepDS_DataStructure self, Standard_Integer const I) -> NCollection_List_Handle_TopOpeBRepDS_Interference

        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_ChangePointInterferences(self, *args)


    def ShapeInterferences(self, *args):
        """
        :type I: int
        :type FindKeep: bool
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_DataStructure_ShapeInterferences(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeShapeInterferences(self, *args):
        """
        ChangeShapeInterferences(TopOpeBRepDS_DataStructure self, TopoDS_Shape S) -> NCollection_List_Handle_TopOpeBRepDS_Interference
        ChangeShapeInterferences(TopOpeBRepDS_DataStructure self, Standard_Integer const I) -> NCollection_List_Handle_TopOpeBRepDS_Interference

        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_ChangeShapeInterferences(self, *args)


    def ShapeSameDomain(self, *args):
        """
        :type I: int
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_DataStructure_ShapeSameDomain(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeShapeSameDomain(self, *args):
        """
        ChangeShapeSameDomain(TopOpeBRepDS_DataStructure self, TopoDS_Shape S) -> NCollection_List_TopoDS_Shape
        ChangeShapeSameDomain(TopOpeBRepDS_DataStructure self, Standard_Integer const I) -> NCollection_List_TopoDS_Shape

        :type I: int
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_ChangeShapeSameDomain(self, *args)


    def ChangeShapes(self, *args):
        """
        ChangeShapes(TopOpeBRepDS_DataStructure self) -> NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeData_TopTools_ShapeMapHasher

        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_MapOfShapeData

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_ChangeShapes(self, *args)


    def AddShapeSameDomain(self, *args):
        """
        AddShapeSameDomain(TopOpeBRepDS_DataStructure self, TopoDS_Shape S, TopoDS_Shape SSD)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type SSD: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_AddShapeSameDomain(self, *args)


    def RemoveShapeSameDomain(self, *args):
        """
        RemoveShapeSameDomain(TopOpeBRepDS_DataStructure self, TopoDS_Shape S, TopoDS_Shape SSD)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type SSD: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_RemoveShapeSameDomain(self, *args)


    def SameDomainRef(self, *args):
        """
        SameDomainRef(TopOpeBRepDS_DataStructure self, Standard_Integer const I) -> Standard_Integer
        SameDomainRef(TopOpeBRepDS_DataStructure self, TopoDS_Shape S) -> Standard_Integer
        SameDomainRef(TopOpeBRepDS_DataStructure self, Standard_Integer const I, Standard_Integer const Ref)
        SameDomainRef(TopOpeBRepDS_DataStructure self, TopoDS_Shape S, Standard_Integer const Ref)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Ref: int

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_SameDomainRef(self, *args)


    def SameDomainOri(self, *args):
        """
        SameDomainOri(TopOpeBRepDS_DataStructure self, Standard_Integer const I) -> TopOpeBRepDS_Config
        SameDomainOri(TopOpeBRepDS_DataStructure self, TopoDS_Shape S) -> TopOpeBRepDS_Config
        SameDomainOri(TopOpeBRepDS_DataStructure self, Standard_Integer const I, TopOpeBRepDS_Config const Ori)
        SameDomainOri(TopOpeBRepDS_DataStructure self, TopoDS_Shape S, TopOpeBRepDS_Config const Ori)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Ori: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Config

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_SameDomainOri(self, *args)


    def SameDomainInd(self, *args):
        """
        SameDomainInd(TopOpeBRepDS_DataStructure self, Standard_Integer const I) -> Standard_Integer
        SameDomainInd(TopOpeBRepDS_DataStructure self, TopoDS_Shape S) -> Standard_Integer
        SameDomainInd(TopOpeBRepDS_DataStructure self, Standard_Integer const I, Standard_Integer const Ind)
        SameDomainInd(TopOpeBRepDS_DataStructure self, TopoDS_Shape S, Standard_Integer const Ind)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Ind: int

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_SameDomainInd(self, *args)


    def AncestorRank(self, *args):
        """
        AncestorRank(TopOpeBRepDS_DataStructure self, Standard_Integer const I) -> Standard_Integer
        AncestorRank(TopOpeBRepDS_DataStructure self, TopoDS_Shape S) -> Standard_Integer
        AncestorRank(TopOpeBRepDS_DataStructure self, Standard_Integer const I, Standard_Integer const Ianc)
        AncestorRank(TopOpeBRepDS_DataStructure self, TopoDS_Shape S, Standard_Integer const Ianc)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Ianc: int

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_AncestorRank(self, *args)


    def AddShapeInterference(self, *args):
        """
        AddShapeInterference(TopOpeBRepDS_DataStructure self, TopoDS_Shape S, Handle_TopOpeBRepDS_Interference I)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_AddShapeInterference(self, *args)


    def RemoveShapeInterference(self, *args):
        """
        RemoveShapeInterference(TopOpeBRepDS_DataStructure self, TopoDS_Shape S, Handle_TopOpeBRepDS_Interference I)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_RemoveShapeInterference(self, *args)


    def FillShapesSameDomain(self, *args):
        """
        FillShapesSameDomain(TopOpeBRepDS_DataStructure self, TopoDS_Shape S1, TopoDS_Shape S2, Standard_Boolean const refFirst)
        FillShapesSameDomain(TopOpeBRepDS_DataStructure self, TopoDS_Shape S1, TopoDS_Shape S2, TopOpeBRepDS_Config const c1, TopOpeBRepDS_Config const c2, Standard_Boolean const refFirst)

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type c1: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Config
        :type c2: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Config
        :type refFirst: bool

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_FillShapesSameDomain(self, *args)


    def UnfillShapesSameDomain(self, *args):
        """
        UnfillShapesSameDomain(TopOpeBRepDS_DataStructure self, TopoDS_Shape S1, TopoDS_Shape S2)

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_UnfillShapesSameDomain(self, *args)


    def NbSurfaces(self, *args):
        """
        NbSurfaces(TopOpeBRepDS_DataStructure self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_NbSurfaces(self, *args)


    def NbCurves(self, *args):
        """
        NbCurves(TopOpeBRepDS_DataStructure self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_NbCurves(self, *args)


    def ChangeNbCurves(self, *args):
        """
        ChangeNbCurves(TopOpeBRepDS_DataStructure self, Standard_Integer const N)

        :type N: int

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_ChangeNbCurves(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(TopOpeBRepDS_DataStructure self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_NbPoints(self, *args)


    def NbShapes(self, *args):
        """
        NbShapes(TopOpeBRepDS_DataStructure self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_NbShapes(self, *args)


    def NbSectionEdges(self, *args):
        """
        NbSectionEdges(TopOpeBRepDS_DataStructure self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_NbSectionEdges(self, *args)


    def Surface(self, *args):
        """
        Returns the surface of index <I>.

        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Surface

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_DataStructure_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSurface(self, *args):
        """
        ChangeSurface(TopOpeBRepDS_DataStructure self, Standard_Integer const I) -> TopOpeBRepDS_Surface

        Returns the surface of index <I>.

        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Surface

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_ChangeSurface(self, *args)


    def Curve(self, *args):
        """
        Returns the Curve of index <I>.

        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Curve

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_DataStructure_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeCurve(self, *args):
        """
        ChangeCurve(TopOpeBRepDS_DataStructure self, Standard_Integer const I) -> TopOpeBRepDS_Curve

        Returns the Curve of index <I>.

        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Curve

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_ChangeCurve(self, *args)


    def Point(self, *args):
        """
        Returns the point of index <I>.

        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Point

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_DataStructure_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangePoint(self, *args):
        """
        ChangePoint(TopOpeBRepDS_DataStructure self, Standard_Integer const I) -> TopOpeBRepDS_Point

        Returns the point of index <I>.

        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Point

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_ChangePoint(self, *args)


    def Shape(self, *args):
        """
        returns the shape of index I stored in
        the map myShapes, accessing a list of interference.

        :type I: int
        :type FindKeep: bool
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_DataStructure_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SectionEdge(self, *args):
        """
        :type I: int
        :type FindKeep: bool
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_DataStructure_SectionEdge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsSectionEdge(self, *args):
        """
        IsSectionEdge(TopOpeBRepDS_DataStructure self, TopoDS_Edge E, Standard_Boolean const FindKeep) -> Standard_Boolean

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type FindKeep: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_IsSectionEdge(self, *args)


    def HasGeometry(self, *args):
        """
        HasGeometry(TopOpeBRepDS_DataStructure self, TopoDS_Shape S) -> Standard_Boolean

        Returns True if <S> has new geometries, i.e :
        True si :
        HasShape(S) True
        S a une liste d'interferences non vide.
        S = SOLID, FACE, EDGE : true/false
        S = SHELL, WIRE, VERTEX : false.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_HasGeometry(self, *args)


    def HasShape(self, *args):
        """
        HasShape(TopOpeBRepDS_DataStructure self, TopoDS_Shape S, Standard_Boolean const FindKeep) -> Standard_Boolean

        Returns True if <S> est dans myShapes

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type FindKeep: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_HasShape(self, *args)


    def SetNewSurface(self, *args):
        """
        SetNewSurface(TopOpeBRepDS_DataStructure self, TopoDS_Shape F, Handle_Geom_Surface S)

        :type F: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_SetNewSurface(self, *args)


    def HasNewSurface(self, *args):
        """
        HasNewSurface(TopOpeBRepDS_DataStructure self, TopoDS_Shape F) -> Standard_Boolean

        :type F: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_HasNewSurface(self, *args)


    def NewSurface(self, *args):
        """
        :type F: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_DataStructure_NewSurface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Isfafa(self, *args):
        """
        Isfafa(TopOpeBRepDS_DataStructure self, Standard_Boolean const isfafa)
        Isfafa(TopOpeBRepDS_DataStructure self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_Isfafa(self, *args)


    def ChangeMapOfShapeWithStateObj(self, *args):
        """
        ChangeMapOfShapeWithStateObj(TopOpeBRepDS_DataStructure self) -> NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher

        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_IndexedDataMapOfShapeWithState

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_ChangeMapOfShapeWithStateObj(self, *args)


    def ChangeMapOfShapeWithStateTool(self, *args):
        """
        ChangeMapOfShapeWithStateTool(TopOpeBRepDS_DataStructure self) -> NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher

        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_IndexedDataMapOfShapeWithState

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_ChangeMapOfShapeWithStateTool(self, *args)


    def ChangeMapOfShapeWithState(self, *args):
        """
        ChangeMapOfShapeWithState(TopOpeBRepDS_DataStructure self, TopoDS_Shape aShape) -> NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher

        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aFlag: bool
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_IndexedDataMapOfShapeWithState

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_ChangeMapOfShapeWithState(self, *args)


    def GetShapeWithState(self, *args):
        """
        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ShapeWithState

        """
        res = _TopOpeBRepDS.TopOpeBRepDS_DataStructure_GetShapeWithState(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeMapOfRejectedShapesObj(self, *args):
        """
        ChangeMapOfRejectedShapesObj(TopOpeBRepDS_DataStructure self) -> NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher

        :rtype: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_ChangeMapOfRejectedShapesObj(self, *args)


    def ChangeMapOfRejectedShapesTool(self, *args):
        """
        ChangeMapOfRejectedShapesTool(TopOpeBRepDS_DataStructure self) -> NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher

        :rtype: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape

        """
        return _TopOpeBRepDS.TopOpeBRepDS_DataStructure_ChangeMapOfRejectedShapesTool(self, *args)

    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_DataStructure
TopOpeBRepDS_DataStructure_swigregister = _TopOpeBRepDS.TopOpeBRepDS_DataStructure_swigregister
TopOpeBRepDS_DataStructure_swigregister(TopOpeBRepDS_DataStructure)

class TopOpeBRepDS_(object):
    """
    This package provides services used by the TopOpeBRepBuild
    package performing topological operations on the BRep
    data structure.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def SPrint(*args):
        """
        SPrint(TopAbs_State const S) -> TCollection_AsciiString
        SPrint(TopOpeBRepDS_Kind const K) -> TCollection_AsciiString
        SPrint(TopOpeBRepDS_Kind const K, Standard_Integer const I, TCollection_AsciiString B, TCollection_AsciiString A) -> TCollection_AsciiString
        SPrint(TopAbs_ShapeEnum const T) -> TCollection_AsciiString
        SPrint(TopAbs_ShapeEnum const T, Standard_Integer const I) -> TCollection_AsciiString
        SPrint(TopAbs_Orientation const O) -> TCollection_AsciiString
        SPrint(TopOpeBRepDS_Config const C) -> TCollection_AsciiString

        :type C: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Config
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _TopOpeBRepDS.TopOpeBRepDS__SPrint(*args)

    SPrint = staticmethod(SPrint)

    def Print(*args):
        """
        Print(TopAbs_State const S, Standard_OStream & OS) -> Standard_OStream
        Print(TopOpeBRepDS_Kind const K, Standard_OStream & S) -> Standard_OStream
        Print(TopOpeBRepDS_Kind const K, Standard_Integer const I, Standard_OStream & S, TCollection_AsciiString B, TCollection_AsciiString A) -> Standard_OStream
        Print(TopAbs_ShapeEnum const T, Standard_Integer const I, Standard_OStream & S) -> Standard_OStream
        Print(TopOpeBRepDS_Config const C, Standard_OStream & S) -> Standard_OStream &

        :type C: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Config
        :type S: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TopOpeBRepDS.TopOpeBRepDS__Print(*args)

    Print = staticmethod(Print)

    def IsGeometry(*args):
        """
        IsGeometry(TopOpeBRepDS_Kind const K) -> Standard_Boolean

        :type K: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS__IsGeometry(*args)

    IsGeometry = staticmethod(IsGeometry)

    def IsTopology(*args):
        """
        IsTopology(TopOpeBRepDS_Kind const K) -> Standard_Boolean

        :type K: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS__IsTopology(*args)

    IsTopology = staticmethod(IsTopology)

    def KindToShape(*args):
        """
        KindToShape(TopOpeBRepDS_Kind const K) -> TopAbs_ShapeEnum

        :type K: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopOpeBRepDS.TopOpeBRepDS__KindToShape(*args)

    KindToShape = staticmethod(KindToShape)

    def ShapeToKind(*args):
        """
        ShapeToKind(TopAbs_ShapeEnum const S) -> TopOpeBRepDS_Kind

        :type S: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind

        """
        return _TopOpeBRepDS.TopOpeBRepDS__ShapeToKind(*args)

    ShapeToKind = staticmethod(ShapeToKind)

    def __init__(self):
        """
        This package provides services used by the TopOpeBRepBuild
        package performing topological operations on the BRep
        data structure.
        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_
TopOpeBRepDS__swigregister = _TopOpeBRepDS.TopOpeBRepDS__swigregister
TopOpeBRepDS__swigregister(TopOpeBRepDS_)

def TopOpeBRepDS__SPrint(*args):
    """
    SPrint(TopAbs_State const S) -> TCollection_AsciiString
    SPrint(TopOpeBRepDS_Kind const K) -> TCollection_AsciiString
    SPrint(TopOpeBRepDS_Kind const K, Standard_Integer const I, TCollection_AsciiString B, TCollection_AsciiString A) -> TCollection_AsciiString
    SPrint(TopAbs_ShapeEnum const T) -> TCollection_AsciiString
    SPrint(TopAbs_ShapeEnum const T, Standard_Integer const I) -> TCollection_AsciiString
    SPrint(TopAbs_Orientation const O) -> TCollection_AsciiString
    TopOpeBRepDS__SPrint(TopOpeBRepDS_Config const C) -> TCollection_AsciiString

    :type C: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Config
    :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

    """
    return _TopOpeBRepDS.TopOpeBRepDS__SPrint(*args)

def TopOpeBRepDS__Print(*args):
    """
    Print(TopAbs_State const S, Standard_OStream & OS) -> Standard_OStream
    Print(TopOpeBRepDS_Kind const K, Standard_OStream & S) -> Standard_OStream
    Print(TopOpeBRepDS_Kind const K, Standard_Integer const I, Standard_OStream & S, TCollection_AsciiString B, TCollection_AsciiString A) -> Standard_OStream
    Print(TopAbs_ShapeEnum const T, Standard_Integer const I, Standard_OStream & S) -> Standard_OStream
    TopOpeBRepDS__Print(TopOpeBRepDS_Config const C, Standard_OStream & S) -> Standard_OStream &

    :type C: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Config
    :type S: OCC.wrapper.Standard.Standard_OStream
    :rtype: OCC.wrapper.Standard.Standard_OStream

    """
    return _TopOpeBRepDS.TopOpeBRepDS__Print(*args)

def TopOpeBRepDS__IsGeometry(*args):
    """
    TopOpeBRepDS__IsGeometry(TopOpeBRepDS_Kind const K) -> Standard_Boolean

    :type K: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepDS.TopOpeBRepDS__IsGeometry(*args)

def TopOpeBRepDS__IsTopology(*args):
    """
    TopOpeBRepDS__IsTopology(TopOpeBRepDS_Kind const K) -> Standard_Boolean

    :type K: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepDS.TopOpeBRepDS__IsTopology(*args)

def TopOpeBRepDS__KindToShape(*args):
    """
    TopOpeBRepDS__KindToShape(TopOpeBRepDS_Kind const K) -> TopAbs_ShapeEnum

    :type K: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
    :rtype: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

    """
    return _TopOpeBRepDS.TopOpeBRepDS__KindToShape(*args)

def TopOpeBRepDS__ShapeToKind(*args):
    """
    TopOpeBRepDS__ShapeToKind(TopAbs_ShapeEnum const S) -> TopOpeBRepDS_Kind

    :type S: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
    :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind

    """
    return _TopOpeBRepDS.TopOpeBRepDS__ShapeToKind(*args)

class Handle_TopOpeBRepDS_SurfaceCurveInterference(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopOpeBRepDS_SurfaceCurveInterference self)

        Nullify the handle


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SurfaceCurveInterference_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopOpeBRepDS_SurfaceCurveInterference self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SurfaceCurveInterference_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopOpeBRepDS_SurfaceCurveInterference self, TopOpeBRepDS_SurfaceCurveInterference thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SurfaceCurveInterference_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopOpeBRepDS_SurfaceCurveInterference self, Handle_TopOpeBRepDS_SurfaceCurveInterference theHandle) -> Handle_TopOpeBRepDS_SurfaceCurveInterference
        assign(Handle_TopOpeBRepDS_SurfaceCurveInterference self, TopOpeBRepDS_SurfaceCurveInterference thePtr) -> Handle_TopOpeBRepDS_SurfaceCurveInterference
        assign(Handle_TopOpeBRepDS_SurfaceCurveInterference self, Handle_TopOpeBRepDS_SurfaceCurveInterference theHandle) -> Handle_TopOpeBRepDS_SurfaceCurveInterference

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SurfaceCurveInterference_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopOpeBRepDS_SurfaceCurveInterference self) -> TopOpeBRepDS_SurfaceCurveInterference

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SurfaceCurveInterference_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopOpeBRepDS_SurfaceCurveInterference self) -> TopOpeBRepDS_SurfaceCurveInterference

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SurfaceCurveInterference___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopOpeBRepDS_SurfaceCurveInterference self) -> TopOpeBRepDS_SurfaceCurveInterference

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SurfaceCurveInterference___ref__(self, *args)


    def __hash__(self):
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SurfaceCurveInterference___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopOpeBRepDS.Handle_TopOpeBRepDS_SurfaceCurveInterference___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopOpeBRepDS.new_Handle_TopOpeBRepDS_SurfaceCurveInterference(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopOpeBRepDS.Handle_TopOpeBRepDS_SurfaceCurveInterference_DownCast)
    __swig_destroy__ = _TopOpeBRepDS.delete_Handle_TopOpeBRepDS_SurfaceCurveInterference

    def PCurve(self, *args):
        """
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_SurfaceCurveInterference_PCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopOpeBRepDS_SurfaceCurveInterference self) -> char const *

        :rtype: const char *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SurfaceCurveInterference_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_SurfaceCurveInterference_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_SurfaceCurveInterference_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transition(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_SurfaceCurveInterference_Transition(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeTransition(self, *args):
        """
        ChangeTransition(Handle_TopOpeBRepDS_SurfaceCurveInterference self) -> TopOpeBRepDS_Transition

        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SurfaceCurveInterference_ChangeTransition(self, *args)


    def GKGSKS(self, *args):
        """
        GKGSKS(Handle_TopOpeBRepDS_SurfaceCurveInterference self)

        return GeometryType + Geometry + SupportType + Support

        :type GK: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type G: int
        :type SK: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type S: int

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SurfaceCurveInterference_GKGSKS(self, *args)


    def SupportType(self, *args):
        """
        SupportType(Handle_TopOpeBRepDS_SurfaceCurveInterference self) -> TopOpeBRepDS_Kind
        SupportType(Handle_TopOpeBRepDS_SurfaceCurveInterference self, TopOpeBRepDS_Kind const ST)

        :type ST: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SurfaceCurveInterference_SupportType(self, *args)


    def Support(self, *args):
        """
        Support(Handle_TopOpeBRepDS_SurfaceCurveInterference self) -> Standard_Integer
        Support(Handle_TopOpeBRepDS_SurfaceCurveInterference self, Standard_Integer const S)

        :type S: int

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SurfaceCurveInterference_Support(self, *args)


    def GeometryType(self, *args):
        """
        GeometryType(Handle_TopOpeBRepDS_SurfaceCurveInterference self) -> TopOpeBRepDS_Kind
        GeometryType(Handle_TopOpeBRepDS_SurfaceCurveInterference self, TopOpeBRepDS_Kind const GT)

        :type GT: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SurfaceCurveInterference_GeometryType(self, *args)


    def Geometry(self, *args):
        """
        Geometry(Handle_TopOpeBRepDS_SurfaceCurveInterference self) -> Standard_Integer
        Geometry(Handle_TopOpeBRepDS_SurfaceCurveInterference self, Standard_Integer const G)

        :type G: int

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SurfaceCurveInterference_Geometry(self, *args)


    def SetGeometry(self, *args):
        """
        SetGeometry(Handle_TopOpeBRepDS_SurfaceCurveInterference self, Standard_Integer const GI)

        :type GI: int

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SurfaceCurveInterference_SetGeometry(self, *args)


    def HasSameSupport(self, *args):
        """
        HasSameSupport(Handle_TopOpeBRepDS_SurfaceCurveInterference self, Handle_TopOpeBRepDS_Interference Other) -> Standard_Boolean

        :type Other: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SurfaceCurveInterference_HasSameSupport(self, *args)


    def HasSameGeometry(self, *args):
        """
        HasSameGeometry(Handle_TopOpeBRepDS_SurfaceCurveInterference self, Handle_TopOpeBRepDS_Interference Other) -> Standard_Boolean

        :type Other: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SurfaceCurveInterference_HasSameGeometry(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TopOpeBRepDS_SurfaceCurveInterference self)

        Memory deallocator for transient classes


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SurfaceCurveInterference_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopOpeBRepDS_SurfaceCurveInterference self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopOpeBRepDS_SurfaceCurveInterference self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SurfaceCurveInterference_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopOpeBRepDS_SurfaceCurveInterference self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopOpeBRepDS_SurfaceCurveInterference self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SurfaceCurveInterference_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopOpeBRepDS_SurfaceCurveInterference self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SurfaceCurveInterference_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopOpeBRepDS_SurfaceCurveInterference self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SurfaceCurveInterference_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopOpeBRepDS_SurfaceCurveInterference self)

        Increments the reference counter of this object


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SurfaceCurveInterference_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopOpeBRepDS_SurfaceCurveInterference self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_SurfaceCurveInterference_DecrementRefCounter(self, *args)

Handle_TopOpeBRepDS_SurfaceCurveInterference_swigregister = _TopOpeBRepDS.Handle_TopOpeBRepDS_SurfaceCurveInterference_swigregister
Handle_TopOpeBRepDS_SurfaceCurveInterference_swigregister(Handle_TopOpeBRepDS_SurfaceCurveInterference)

def Handle_TopOpeBRepDS_SurfaceCurveInterference_DownCast(thing):
    return _TopOpeBRepDS.Handle_TopOpeBRepDS_SurfaceCurveInterference_DownCast(thing)
Handle_TopOpeBRepDS_SurfaceCurveInterference_DownCast = _TopOpeBRepDS.Handle_TopOpeBRepDS_SurfaceCurveInterference_DownCast

class TopOpeBRepDS_TOOL(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def EShareG(*args):
        """
        EShareG(Handle_TopOpeBRepDS_HDataStructure HDS, TopoDS_Edge E, NCollection_List_TopoDS_Shape lEsd) -> Standard_Integer

        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type lEsd: OCC.wrapper.TopTools.TopTools_ListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.TopOpeBRepDS_TOOL_EShareG(*args)

    EShareG = staticmethod(EShareG)

    def ShareG(*args):
        """
        ShareG(Handle_TopOpeBRepDS_HDataStructure HDS, Standard_Integer const is1, Standard_Integer const is2) -> Standard_Boolean

        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure
        :type is1: int
        :type is2: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_TOOL_ShareG(*args)

    ShareG = staticmethod(ShareG)

    def GetEsd(*args):
        """
        GetEsd(Handle_TopOpeBRepDS_HDataStructure HDS, TopoDS_Shape S, Standard_Integer const ie) -> Standard_Boolean

        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure
        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type ie: int
        :type iesd: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_TOOL_GetEsd(*args)

    GetEsd = staticmethod(GetEsd)

    def ShareSplitON(*args):
        """
        ShareSplitON(Handle_TopOpeBRepDS_HDataStructure HDS, NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher MspON, Standard_Integer const i1, Standard_Integer const i2, TopoDS_Shape spON) -> Standard_Boolean

        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure
        :type MspON: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_DataMapOfShapeListOfShapeOn1State
        :type i1: int
        :type i2: int
        :type spON: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_TOOL_ShareSplitON(*args)

    ShareSplitON = staticmethod(ShareSplitON)

    def GetConfig(*args):
        """
        GetConfig(Handle_TopOpeBRepDS_HDataStructure HDS, NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher MEspON, Standard_Integer const ie, Standard_Integer const iesd) -> Standard_Boolean

        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure
        :type MEspON: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_DataMapOfShapeListOfShapeOn1State
        :type ie: int
        :type iesd: int
        :type conf: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.TopOpeBRepDS_TOOL_GetConfig(*args)

    GetConfig = staticmethod(GetConfig)

    def __init__(self):
        this = _TopOpeBRepDS.new_TopOpeBRepDS_TOOL()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_TOOL
TopOpeBRepDS_TOOL_swigregister = _TopOpeBRepDS.TopOpeBRepDS_TOOL_swigregister
TopOpeBRepDS_TOOL_swigregister(TopOpeBRepDS_TOOL)

def TopOpeBRepDS_TOOL_EShareG(*args):
    """
    TopOpeBRepDS_TOOL_EShareG(Handle_TopOpeBRepDS_HDataStructure HDS, TopoDS_Edge E, NCollection_List_TopoDS_Shape lEsd) -> Standard_Integer

    :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure
    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type lEsd: OCC.wrapper.TopTools.TopTools_ListOfShape
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _TopOpeBRepDS.TopOpeBRepDS_TOOL_EShareG(*args)

def TopOpeBRepDS_TOOL_ShareG(*args):
    """
    TopOpeBRepDS_TOOL_ShareG(Handle_TopOpeBRepDS_HDataStructure HDS, Standard_Integer const is1, Standard_Integer const is2) -> Standard_Boolean

    :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure
    :type is1: int
    :type is2: int
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepDS.TopOpeBRepDS_TOOL_ShareG(*args)

def TopOpeBRepDS_TOOL_GetEsd(*args):
    """
    TopOpeBRepDS_TOOL_GetEsd(Handle_TopOpeBRepDS_HDataStructure HDS, TopoDS_Shape S, Standard_Integer const ie) -> Standard_Boolean

    :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure
    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type ie: int
    :type iesd: int
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepDS.TopOpeBRepDS_TOOL_GetEsd(*args)

def TopOpeBRepDS_TOOL_ShareSplitON(*args):
    """
    TopOpeBRepDS_TOOL_ShareSplitON(Handle_TopOpeBRepDS_HDataStructure HDS, NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher MspON, Standard_Integer const i1, Standard_Integer const i2, TopoDS_Shape spON) -> Standard_Boolean

    :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure
    :type MspON: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_DataMapOfShapeListOfShapeOn1State
    :type i1: int
    :type i2: int
    :type spON: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepDS.TopOpeBRepDS_TOOL_ShareSplitON(*args)

def TopOpeBRepDS_TOOL_GetConfig(*args):
    """
    TopOpeBRepDS_TOOL_GetConfig(Handle_TopOpeBRepDS_HDataStructure HDS, NCollection_DataMap_TopoDS_Shape_TopOpeBRepDS_ListOfShapeOn1State_TopTools_ShapeMapHasher MEspON, Standard_Integer const ie, Standard_Integer const iesd) -> Standard_Boolean

    :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure
    :type MEspON: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_DataMapOfShapeListOfShapeOn1State
    :type ie: int
    :type iesd: int
    :type conf: int
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopOpeBRepDS.TopOpeBRepDS_TOOL_GetConfig(*args)

class Handle_TopOpeBRepDS_HDataStructure(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopOpeBRepDS_HDataStructure self)

        Nullify the handle


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopOpeBRepDS_HDataStructure self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopOpeBRepDS_HDataStructure self, TopOpeBRepDS_HDataStructure thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopOpeBRepDS_HDataStructure self, Handle_TopOpeBRepDS_HDataStructure theHandle) -> Handle_TopOpeBRepDS_HDataStructure
        assign(Handle_TopOpeBRepDS_HDataStructure self, TopOpeBRepDS_HDataStructure thePtr) -> Handle_TopOpeBRepDS_HDataStructure
        assign(Handle_TopOpeBRepDS_HDataStructure self, Handle_TopOpeBRepDS_HDataStructure theHandle) -> Handle_TopOpeBRepDS_HDataStructure

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopOpeBRepDS_HDataStructure self) -> TopOpeBRepDS_HDataStructure

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopOpeBRepDS_HDataStructure self) -> TopOpeBRepDS_HDataStructure

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopOpeBRepDS_HDataStructure self) -> TopOpeBRepDS_HDataStructure

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure___ref__(self, *args)


    def __hash__(self):
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopOpeBRepDS.new_Handle_TopOpeBRepDS_HDataStructure(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_DownCast)
    __swig_destroy__ = _TopOpeBRepDS.delete_Handle_TopOpeBRepDS_HDataStructure

    def AddAncestors(self, *args):
        """
        AddAncestors(Handle_TopOpeBRepDS_HDataStructure self, TopoDS_Shape S)
        AddAncestors(Handle_TopOpeBRepDS_HDataStructure self, TopoDS_Shape S, TopAbs_ShapeEnum const T1, TopAbs_ShapeEnum const T2)

        Update  the data structure with  shapes of type T1
        containing a subshape of type T2 which is stored
        in the DS.
        Used by the previous one.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type T1: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :type T2: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_AddAncestors(self, *args)


    def ChkIntg(self, *args):
        """
        ChkIntg(Handle_TopOpeBRepDS_HDataStructure self)

        Check the integrity of the DS


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_ChkIntg(self, *args)


    def DS(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_DataStructure

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_DS(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeDS(self, *args):
        """
        ChangeDS(Handle_TopOpeBRepDS_HDataStructure self) -> TopOpeBRepDS_DataStructure

        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_DataStructure

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_ChangeDS(self, *args)


    def NbSurfaces(self, *args):
        """
        NbSurfaces(Handle_TopOpeBRepDS_HDataStructure self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_NbSurfaces(self, *args)


    def NbCurves(self, *args):
        """
        NbCurves(Handle_TopOpeBRepDS_HDataStructure self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_NbCurves(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(Handle_TopOpeBRepDS_HDataStructure self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_NbPoints(self, *args)


    def Surface(self, *args):
        """
        Returns the surface of index <I>.

        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Surface

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SurfaceCurves(self, *args):
        """
        SurfaceCurves(Handle_TopOpeBRepDS_HDataStructure self, Standard_Integer const I) -> TopOpeBRepDS_CurveIterator

        Returns an iterator  on the curves on  the surface
        <I>.

        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_CurveIterator

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_SurfaceCurves(self, *args)


    def Curve(self, *args):
        """
        Returns the Curve of index <I>.

        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Curve

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeCurve(self, *args):
        """
        ChangeCurve(Handle_TopOpeBRepDS_HDataStructure self, Standard_Integer const I) -> TopOpeBRepDS_Curve

        Returns the Curve of index <I>.

        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Curve

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_ChangeCurve(self, *args)


    def CurvePoints(self, *args):
        """
        CurvePoints(Handle_TopOpeBRepDS_HDataStructure self, Standard_Integer const I) -> TopOpeBRepDS_PointIterator

        Returns an iterator   on the points on  the  curve
        <I>.

        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_PointIterator

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_CurvePoints(self, *args)


    def Point(self, *args):
        """
        Returns the point of index <I>.

        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Point

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbShapes(self, *args):
        """
        NbShapes(Handle_TopOpeBRepDS_HDataStructure self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_NbShapes(self, *args)


    def Shape(self, *args):
        """
        Returns the shape of index <I> in the DS

        :type I: int
        :type FindKeep: bool
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasGeometry(self, *args):
        """
        HasGeometry(Handle_TopOpeBRepDS_HDataStructure self, TopoDS_Shape S) -> Standard_Boolean

        Returns True if <S> has new geometries.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_HasGeometry(self, *args)


    def HasShape(self, *args):
        """
        HasShape(Handle_TopOpeBRepDS_HDataStructure self, TopoDS_Shape S, Standard_Boolean const FindKeep) -> Standard_Boolean

        Returns True if <S> has new geometries (SOLID,FACE,EDGE)
        or if <S> (SHELL,WIRE) has sub-shape (FACE,EDGE)
        with new geometries

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type FindKeep: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_HasShape(self, *args)


    def HasSameDomain(self, *args):
        """
        HasSameDomain(Handle_TopOpeBRepDS_HDataStructure self, TopoDS_Shape S, Standard_Boolean const FindKeep) -> Standard_Boolean

        Returns True if <S> share a geometrical domain with
        some other shapes.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type FindKeep: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_HasSameDomain(self, *args)


    def SameDomain(self, *args):
        """
        SameDomain(Handle_TopOpeBRepDS_HDataStructure self, TopoDS_Shape S) -> TopTools_ListIteratorOfListOfShape

        Returns an iterator on the SameDomain shapes attached
        to the shape <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListIteratorOfListOfShape

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_SameDomain(self, *args)


    def SameDomainOrientation(self, *args):
        """
        SameDomainOrientation(Handle_TopOpeBRepDS_HDataStructure self, TopoDS_Shape S) -> TopOpeBRepDS_Config

        Returns orientation of shape <S> compared with its
        reference shape

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Config

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_SameDomainOrientation(self, *args)


    def SameDomainReference(self, *args):
        """
        SameDomainReference(Handle_TopOpeBRepDS_HDataStructure self, TopoDS_Shape S) -> Standard_Integer

        Returns orientation of shape <S> compared with its
        reference shape

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_SameDomainReference(self, *args)


    def SolidSurfaces(self, *args):
        """
        SolidSurfaces(Handle_TopOpeBRepDS_HDataStructure self, TopoDS_Shape S) -> TopOpeBRepDS_SurfaceIterator
        SolidSurfaces(Handle_TopOpeBRepDS_HDataStructure self, Standard_Integer const I) -> TopOpeBRepDS_SurfaceIterator

        Returns an iterator on the  surfaces attached to the
        solid <I>.

        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_SurfaceIterator

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_SolidSurfaces(self, *args)


    def FaceCurves(self, *args):
        """
        FaceCurves(Handle_TopOpeBRepDS_HDataStructure self, TopoDS_Shape F) -> TopOpeBRepDS_CurveIterator
        FaceCurves(Handle_TopOpeBRepDS_HDataStructure self, Standard_Integer const I) -> TopOpeBRepDS_CurveIterator

        Returns an iterator on the  curves attached to the
        face <I>.

        :type I: int
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_CurveIterator

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_FaceCurves(self, *args)


    def EdgePoints(self, *args):
        """
        EdgePoints(Handle_TopOpeBRepDS_HDataStructure self, TopoDS_Shape E) -> TopOpeBRepDS_PointIterator

        Returns an iterator on the points  attached to the
        edge <E>.

        :type E: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_PointIterator

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_EdgePoints(self, *args)


    def MakeCurve(self, *args):
        """
        MakeCurve(Handle_TopOpeBRepDS_HDataStructure self, TopOpeBRepDS_Curve C1, TopOpeBRepDS_Curve C2) -> Standard_Integer

        :type C1: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Curve
        :type C2: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Curve
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_MakeCurve(self, *args)


    def RemoveCurve(self, *args):
        """
        RemoveCurve(Handle_TopOpeBRepDS_HDataStructure self, Standard_Integer const iC)

        :type iC: int

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_RemoveCurve(self, *args)


    def NbGeometry(self, *args):
        """
        NbGeometry(Handle_TopOpeBRepDS_HDataStructure self, TopOpeBRepDS_Kind const K) -> Standard_Integer

        :type K: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_NbGeometry(self, *args)


    def NbTopology(self, *args):
        """
        NbTopology(Handle_TopOpeBRepDS_HDataStructure self, TopOpeBRepDS_Kind const K) -> Standard_Integer
        NbTopology(Handle_TopOpeBRepDS_HDataStructure self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_NbTopology(self, *args)


    def EdgesSameParameter(self, *args):
        """
        EdgesSameParameter(Handle_TopOpeBRepDS_HDataStructure self) -> Standard_Boolean

        returns True if all the edges stored as shapes in the DS
        are SameParameter, otherwise False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_EdgesSameParameter(self, *args)


    def SortOnParameter(self, *args):
        """
        SortOnParameter(Handle_TopOpeBRepDS_HDataStructure self, NCollection_List_Handle_TopOpeBRepDS_Interference L1, NCollection_List_Handle_TopOpeBRepDS_Interference L2)
        SortOnParameter(Handle_TopOpeBRepDS_HDataStructure self, NCollection_List_Handle_TopOpeBRepDS_Interference L)

        :type L: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_SortOnParameter(self, *args)


    def MinMaxOnParameter(self, *args):
        """
        MinMaxOnParameter(Handle_TopOpeBRepDS_HDataStructure self, NCollection_List_Handle_TopOpeBRepDS_Interference L)

        :type L: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference
        :type Min: float
        :type Max: float

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_MinMaxOnParameter(self, *args)


    def ScanInterfList(self, *args):
        """
        ScanInterfList(Handle_TopOpeBRepDS_HDataStructure self, TopOpeBRepDS_ListIteratorOfListOfInterference & IT, TopOpeBRepDS_Point PDS) -> Standard_Boolean

        Search, among a list of interferences accessed by the iterator
        <IT>, a geometry <G> whose 3D point is identical to the 3D point
        of the TheDSPoint <PDS>.
        returns True if such an interference has been found, False else.
        if True, iterator It points (by the Value() method) on the first
        interference accessing an identical 3D point.

        :type IT: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListIteratorOfListOfInterference
        :type PDS: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Point
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_ScanInterfList(self, *args)


    def GetGeometry(self, *args):
        """
        GetGeometry(Handle_TopOpeBRepDS_HDataStructure self, TopOpeBRepDS_ListIteratorOfListOfInterference & IT, TopOpeBRepDS_Point PDS) -> Standard_Boolean

        Get the geometry of a DS point <PDS>.
        Search for it with ScanInterfList (previous method).
        if found, set <G,K> to the geometry,kind of the interference found.
        returns the value of ScanInterfList().

        :type IT: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListIteratorOfListOfInterference
        :type PDS: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Point
        :type G: int
        :type K: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_GetGeometry(self, *args)


    def StoreInterference(self, *args):
        """
        StoreInterference(Handle_TopOpeBRepDS_HDataStructure self, Handle_TopOpeBRepDS_Interference I, NCollection_List_Handle_TopOpeBRepDS_Interference LI, TCollection_AsciiString str)
        StoreInterference(Handle_TopOpeBRepDS_HDataStructure self, Handle_TopOpeBRepDS_Interference I, TopoDS_Shape S, TCollection_AsciiString str)
        StoreInterference(Handle_TopOpeBRepDS_HDataStructure self, Handle_TopOpeBRepDS_Interference I, Standard_Integer const IS, TCollection_AsciiString str)

        Add interference <I> to list of interference of shape <IS>.

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :type IS: int
        :type str: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_StoreInterference(self, *args)


    def StoreInterferences(self, *args):
        """
        StoreInterferences(Handle_TopOpeBRepDS_HDataStructure self, NCollection_List_Handle_TopOpeBRepDS_Interference LI, TopoDS_Shape S, TCollection_AsciiString str)
        StoreInterferences(Handle_TopOpeBRepDS_HDataStructure self, NCollection_List_Handle_TopOpeBRepDS_Interference LI, Standard_Integer const IS, TCollection_AsciiString str)

        :type LI: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference
        :type IS: int
        :type str: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_StoreInterferences(self, *args)


    def ClearStoreInterferences(self, *args):
        """
        ClearStoreInterferences(Handle_TopOpeBRepDS_HDataStructure self, NCollection_List_Handle_TopOpeBRepDS_Interference LI, TopoDS_Shape S, TCollection_AsciiString str)
        ClearStoreInterferences(Handle_TopOpeBRepDS_HDataStructure self, NCollection_List_Handle_TopOpeBRepDS_Interference LI, Standard_Integer const IS, TCollection_AsciiString str)

        :type LI: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_ListOfInterference
        :type IS: int
        :type str: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_ClearStoreInterferences(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopOpeBRepDS_HDataStructure self) -> char const *

        :rtype: const char *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TopOpeBRepDS_HDataStructure self)

        Memory deallocator for transient classes


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopOpeBRepDS_HDataStructure self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopOpeBRepDS_HDataStructure self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopOpeBRepDS_HDataStructure self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopOpeBRepDS_HDataStructure self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopOpeBRepDS_HDataStructure self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopOpeBRepDS_HDataStructure self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopOpeBRepDS_HDataStructure self)

        Increments the reference counter of this object


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopOpeBRepDS_HDataStructure self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_DecrementRefCounter(self, *args)

Handle_TopOpeBRepDS_HDataStructure_swigregister = _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_swigregister
Handle_TopOpeBRepDS_HDataStructure_swigregister(Handle_TopOpeBRepDS_HDataStructure)

def Handle_TopOpeBRepDS_HDataStructure_DownCast(thing):
    return _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_DownCast(thing)
Handle_TopOpeBRepDS_HDataStructure_DownCast = _TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure_DownCast


try:
	TColStd_MapTransientHasher = TColStd.NCollection_DefaultHasher_Handle_Standard_Transient
except AttributeError:
	pass # does not exist, probably ignored

class Handle_TopOpeBRepDS_ShapeShapeInterference(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopOpeBRepDS_ShapeShapeInterference self)

        Nullify the handle


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopOpeBRepDS_ShapeShapeInterference self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopOpeBRepDS_ShapeShapeInterference self, TopOpeBRepDS_ShapeShapeInterference thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopOpeBRepDS_ShapeShapeInterference self, Handle_TopOpeBRepDS_ShapeShapeInterference theHandle) -> Handle_TopOpeBRepDS_ShapeShapeInterference
        assign(Handle_TopOpeBRepDS_ShapeShapeInterference self, TopOpeBRepDS_ShapeShapeInterference thePtr) -> Handle_TopOpeBRepDS_ShapeShapeInterference
        assign(Handle_TopOpeBRepDS_ShapeShapeInterference self, Handle_TopOpeBRepDS_ShapeShapeInterference theHandle) -> Handle_TopOpeBRepDS_ShapeShapeInterference

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopOpeBRepDS_ShapeShapeInterference self) -> TopOpeBRepDS_ShapeShapeInterference

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopOpeBRepDS_ShapeShapeInterference self) -> TopOpeBRepDS_ShapeShapeInterference

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopOpeBRepDS_ShapeShapeInterference self) -> TopOpeBRepDS_ShapeShapeInterference

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference___ref__(self, *args)


    def __hash__(self):
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopOpeBRepDS.new_Handle_TopOpeBRepDS_ShapeShapeInterference(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference_DownCast)
    __swig_destroy__ = _TopOpeBRepDS.delete_Handle_TopOpeBRepDS_ShapeShapeInterference

    def Config(self, *args):
        """
        Config(Handle_TopOpeBRepDS_ShapeShapeInterference self) -> TopOpeBRepDS_Config

        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Config

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference_Config(self, *args)


    def GBound(self, *args):
        """
        GBound(Handle_TopOpeBRepDS_ShapeShapeInterference self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference_GBound(self, *args)


    def SetGBound(self, *args):
        """
        SetGBound(Handle_TopOpeBRepDS_ShapeShapeInterference self, Standard_Boolean const b)

        :type b: bool

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference_SetGBound(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopOpeBRepDS_ShapeShapeInterference self) -> char const *

        :rtype: const char *

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transition(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition

        """
        res = _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference_Transition(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeTransition(self, *args):
        """
        ChangeTransition(Handle_TopOpeBRepDS_ShapeShapeInterference self) -> TopOpeBRepDS_Transition

        :rtype: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Transition

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference_ChangeTransition(self, *args)


    def GKGSKS(self, *args):
        """
        GKGSKS(Handle_TopOpeBRepDS_ShapeShapeInterference self)

        return GeometryType + Geometry + SupportType + Support

        :type GK: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type G: int
        :type SK: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind
        :type S: int

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference_GKGSKS(self, *args)


    def SupportType(self, *args):
        """
        SupportType(Handle_TopOpeBRepDS_ShapeShapeInterference self) -> TopOpeBRepDS_Kind
        SupportType(Handle_TopOpeBRepDS_ShapeShapeInterference self, TopOpeBRepDS_Kind const ST)

        :type ST: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference_SupportType(self, *args)


    def Support(self, *args):
        """
        Support(Handle_TopOpeBRepDS_ShapeShapeInterference self) -> Standard_Integer
        Support(Handle_TopOpeBRepDS_ShapeShapeInterference self, Standard_Integer const S)

        :type S: int

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference_Support(self, *args)


    def GeometryType(self, *args):
        """
        GeometryType(Handle_TopOpeBRepDS_ShapeShapeInterference self) -> TopOpeBRepDS_Kind
        GeometryType(Handle_TopOpeBRepDS_ShapeShapeInterference self, TopOpeBRepDS_Kind const GT)

        :type GT: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Kind

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference_GeometryType(self, *args)


    def Geometry(self, *args):
        """
        Geometry(Handle_TopOpeBRepDS_ShapeShapeInterference self) -> Standard_Integer
        Geometry(Handle_TopOpeBRepDS_ShapeShapeInterference self, Standard_Integer const G)

        :type G: int

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference_Geometry(self, *args)


    def SetGeometry(self, *args):
        """
        SetGeometry(Handle_TopOpeBRepDS_ShapeShapeInterference self, Standard_Integer const GI)

        :type GI: int

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference_SetGeometry(self, *args)


    def HasSameSupport(self, *args):
        """
        HasSameSupport(Handle_TopOpeBRepDS_ShapeShapeInterference self, Handle_TopOpeBRepDS_Interference Other) -> Standard_Boolean

        :type Other: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference_HasSameSupport(self, *args)


    def HasSameGeometry(self, *args):
        """
        HasSameGeometry(Handle_TopOpeBRepDS_ShapeShapeInterference self, Handle_TopOpeBRepDS_Interference Other) -> Standard_Boolean

        :type Other: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference_HasSameGeometry(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TopOpeBRepDS_ShapeShapeInterference self)

        Memory deallocator for transient classes


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopOpeBRepDS_ShapeShapeInterference self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopOpeBRepDS_ShapeShapeInterference self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopOpeBRepDS_ShapeShapeInterference self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopOpeBRepDS_ShapeShapeInterference self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopOpeBRepDS_ShapeShapeInterference self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopOpeBRepDS_ShapeShapeInterference self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopOpeBRepDS_ShapeShapeInterference self)

        Increments the reference counter of this object


        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopOpeBRepDS_ShapeShapeInterference self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference_DecrementRefCounter(self, *args)

Handle_TopOpeBRepDS_ShapeShapeInterference_swigregister = _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference_swigregister
Handle_TopOpeBRepDS_ShapeShapeInterference_swigregister(Handle_TopOpeBRepDS_ShapeShapeInterference)

def Handle_TopOpeBRepDS_ShapeShapeInterference_DownCast(thing):
    return _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference_DownCast(thing)
Handle_TopOpeBRepDS_ShapeShapeInterference_DownCast = _TopOpeBRepDS.Handle_TopOpeBRepDS_ShapeShapeInterference_DownCast

class TopOpeBRepDS_Dumper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_Dumper self, Handle_TopOpeBRepDS_HDataStructure HDS) -> TopOpeBRepDS_Dumper

        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure

        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_Dumper(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SDumpRefOri(self, *args):
        """
        SDumpRefOri(TopOpeBRepDS_Dumper self, TopOpeBRepDS_Kind const K, Standard_Integer const I) -> TCollection_AsciiString
        SDumpRefOri(TopOpeBRepDS_Dumper self, TopoDS_Shape S) -> TCollection_AsciiString

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Dumper_SDumpRefOri(self, *args)


    def SPrintShape(self, *args):
        """
        SPrintShape(TopOpeBRepDS_Dumper self, Standard_Integer const I) -> TCollection_AsciiString
        SPrintShape(TopOpeBRepDS_Dumper self, TopoDS_Shape S) -> TCollection_AsciiString

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Dumper_SPrintShape(self, *args)


    def SPrintShapeRefOri(self, *args):
        """
        SPrintShapeRefOri(TopOpeBRepDS_Dumper self, TopoDS_Shape S, TCollection_AsciiString B) -> TCollection_AsciiString
        SPrintShapeRefOri(TopOpeBRepDS_Dumper self, NCollection_List_TopoDS_Shape L, TCollection_AsciiString B) -> TCollection_AsciiString

        :type L: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type B: OCC.wrapper.TCollection.TCollection_AsciiString
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _TopOpeBRepDS.TopOpeBRepDS_Dumper_SPrintShapeRefOri(self, *args)

    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_Dumper
TopOpeBRepDS_Dumper_swigregister = _TopOpeBRepDS.TopOpeBRepDS_Dumper_swigregister
TopOpeBRepDS_Dumper_swigregister(TopOpeBRepDS_Dumper)

class TopOpeBRepDS_EdgeInterferenceTool(object):
    """a tool computing complex transition on Edge."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopOpeBRepDS_EdgeInterferenceTool self) -> TopOpeBRepDS_EdgeInterferenceTool

        a tool computing complex transition on Edge.
        """
        this = _TopOpeBRepDS.new_TopOpeBRepDS_EdgeInterferenceTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(TopOpeBRepDS_EdgeInterferenceTool self, TopoDS_Shape E, Handle_TopOpeBRepDS_Interference I)

        :type E: OCC.wrapper.TopoDS.TopoDS_Shape
        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_EdgeInterferenceTool_Init(self, *args)


    def Add(self, *args):
        """
        Add(TopOpeBRepDS_EdgeInterferenceTool self, TopoDS_Shape E, TopoDS_Shape V, Handle_TopOpeBRepDS_Interference I)
        Add(TopOpeBRepDS_EdgeInterferenceTool self, TopoDS_Shape E, TopOpeBRepDS_Point P, Handle_TopOpeBRepDS_Interference I)

        :type E: OCC.wrapper.TopoDS.TopoDS_Shape
        :type P: OCC.wrapper.TopOpeBRepDS.TopOpeBRepDS_Point
        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_EdgeInterferenceTool_Add(self, *args)


    def Transition(self, *args):
        """
        Transition(TopOpeBRepDS_EdgeInterferenceTool self, Handle_TopOpeBRepDS_Interference I)

        :type I: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_Interference

        """
        return _TopOpeBRepDS.TopOpeBRepDS_EdgeInterferenceTool_Transition(self, *args)

    __swig_destroy__ = _TopOpeBRepDS.delete_TopOpeBRepDS_EdgeInterferenceTool
TopOpeBRepDS_EdgeInterferenceTool_swigregister = _TopOpeBRepDS.TopOpeBRepDS_EdgeInterferenceTool_swigregister
TopOpeBRepDS_EdgeInterferenceTool_swigregister(TopOpeBRepDS_EdgeInterferenceTool)

class NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopOpeBRepDS_ShapeWithState,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopOpeBRepDS_ShapeWithState,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopOpeBRepDS_ShapeWithState,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher self) -> NCollection_IndexedDataMap< TopoDS_Shape,TopOpeBRepDS_ShapeWithState,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _TopOpeBRepDS.new_NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher self, NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher theOther) -> NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1, TopOpeBRepDS_ShapeWithState theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher self, Standard_Integer const theIndex, TopoDS_Shape theKey1, TopOpeBRepDS_ShapeWithState theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher self)

        RemoveLast


        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher self, Standard_Integer const theIndex) -> TopOpeBRepDS_ShapeWithState

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> TopOpeBRepDS_ShapeWithState

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> TopOpeBRepDS_ShapeWithState

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher self, TopoDS_Shape theKey1) -> TopOpeBRepDS_ShapeWithState

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _TopOpeBRepDS.delete_NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher
NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_swigregister = _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher)

class NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopOpeBRepDS.new_NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopOpeBRepDS.delete_NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _TopOpeBRepDS.NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher_IteratorHelper)


try:
	TopOpeBRepDS_IndexedDataMapOfShapeWithState = NCollection_IndexedDataMap_TopoDS_Shape_TopOpeBRepDS_ShapeWithState_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored




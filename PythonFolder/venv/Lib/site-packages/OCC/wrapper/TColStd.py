# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_TColStd')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_TColStd')
    _TColStd = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_TColStd', [dirname(__file__)])
        except ImportError:
            import _TColStd
            return _TColStd
        try:
            _mod = imp.load_module('_TColStd', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _TColStd = swig_import_helper()
    del swig_import_helper
else:
    import _TColStd
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _TColStd.delete_SwigPyIterator

    def value(self):
        return _TColStd.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _TColStd.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _TColStd.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _TColStd.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _TColStd.SwigPyIterator_equal(self, x)

    def copy(self):
        return _TColStd.SwigPyIterator_copy(self)

    def next(self):
        return _TColStd.SwigPyIterator_next(self)

    def __next__(self):
        return _TColStd.SwigPyIterator___next__(self)

    def previous(self):
        return _TColStd.SwigPyIterator_previous(self)

    def advance(self, n):
        return _TColStd.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _TColStd.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _TColStd.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _TColStd.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _TColStd.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _TColStd.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _TColStd.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _TColStd.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _TColStd.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_TColStd.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _TColStd.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _TColStd.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TColStd.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _TColStd.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _TColStd.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _TColStd.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _TColStd.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_TColStd.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _TColStd.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _TColStd.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TColStd.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _TColStd.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _TColStd.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _TColStd.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _TColStd.ptr_to_number(item)
ptr_to_number = _TColStd.ptr_to_number

def HashCode(*args):
    return _TColStd.HashCode(*args)
HashCode = _TColStd.HashCode

def ptr_equal(a, b):
    return _TColStd.ptr_equal(a, b)
ptr_equal = _TColStd.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
class TColStd_HArray2OfCharacter(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TColStd_HArray2OfCharacter
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TColStd_HArray2OfCharacter(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TColStd_HArray2OfCharacter self, Standard_Integer const theRowLow, Standard_Integer const theRowUpp, Standard_Integer const theColLow, Standard_Integer const theColUpp) -> TColStd_HArray2OfCharacter
        __init__(TColStd_HArray2OfCharacter self, Standard_Integer const theRowLow, Standard_Integer const theRowUpp, Standard_Integer const theColLow, Standard_Integer const theColUpp, TColStd_Array2OfCharacter::value_type const & theValue) -> TColStd_HArray2OfCharacter
        __init__(TColStd_HArray2OfCharacter self, NCollection_Array2_Standard_Character theOther) -> TColStd_HArray2OfCharacter

        :type theOther: OCC.wrapper.TColStd.TColStd_Array2OfCharacter

        """
        this = _TColStd.new_TColStd_HArray2OfCharacter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array2(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array2OfCharacter

        """
        res = _TColStd.TColStd_HArray2OfCharacter_Array2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray2(self, *args):
        """
        ChangeArray2(TColStd_HArray2OfCharacter self) -> NCollection_Array2_Standard_Character

        :rtype: OCC.wrapper.TColStd.TColStd_Array2OfCharacter

        """
        return _TColStd.TColStd_HArray2OfCharacter_ChangeArray2(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TColStd.TColStd_HArray2OfCharacter_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TColStd.TColStd_HArray2OfCharacter_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.TColStd_HArray2OfCharacter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TColStd.delete_TColStd_HArray2OfCharacter
TColStd_HArray2OfCharacter_swigregister = _TColStd.TColStd_HArray2OfCharacter_swigregister
TColStd_HArray2OfCharacter_swigregister(TColStd_HArray2OfCharacter)

def TColStd_HArray2OfCharacter_get_type_name(*args):
    """
    TColStd_HArray2OfCharacter_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TColStd.TColStd_HArray2OfCharacter_get_type_name(*args)

def TColStd_HArray2OfCharacter_get_type_descriptor(*args):
    """
    TColStd_HArray2OfCharacter_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TColStd.TColStd_HArray2OfCharacter_get_type_descriptor(*args)

class TColStd_HArray2OfInteger(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TColStd_HArray2OfInteger
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TColStd_HArray2OfInteger(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TColStd_HArray2OfInteger self, Standard_Integer const theRowLow, Standard_Integer const theRowUpp, Standard_Integer const theColLow, Standard_Integer const theColUpp) -> TColStd_HArray2OfInteger
        __init__(TColStd_HArray2OfInteger self, Standard_Integer const theRowLow, Standard_Integer const theRowUpp, Standard_Integer const theColLow, Standard_Integer const theColUpp, TColStd_Array2OfInteger::value_type const & theValue) -> TColStd_HArray2OfInteger
        __init__(TColStd_HArray2OfInteger self, NCollection_Array2_Standard_Integer theOther) -> TColStd_HArray2OfInteger

        :type theOther: OCC.wrapper.TColStd.TColStd_Array2OfInteger

        """
        this = _TColStd.new_TColStd_HArray2OfInteger(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array2(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array2OfInteger

        """
        res = _TColStd.TColStd_HArray2OfInteger_Array2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray2(self, *args):
        """
        ChangeArray2(TColStd_HArray2OfInteger self) -> NCollection_Array2_Standard_Integer

        :rtype: OCC.wrapper.TColStd.TColStd_Array2OfInteger

        """
        return _TColStd.TColStd_HArray2OfInteger_ChangeArray2(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TColStd.TColStd_HArray2OfInteger_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TColStd.TColStd_HArray2OfInteger_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.TColStd_HArray2OfInteger_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TColStd.delete_TColStd_HArray2OfInteger
TColStd_HArray2OfInteger_swigregister = _TColStd.TColStd_HArray2OfInteger_swigregister
TColStd_HArray2OfInteger_swigregister(TColStd_HArray2OfInteger)

def TColStd_HArray2OfInteger_get_type_name(*args):
    """
    TColStd_HArray2OfInteger_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TColStd.TColStd_HArray2OfInteger_get_type_name(*args)

def TColStd_HArray2OfInteger_get_type_descriptor(*args):
    """
    TColStd_HArray2OfInteger_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TColStd.TColStd_HArray2OfInteger_get_type_descriptor(*args)

class NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     Single hashed Map. This  Map is used  to store and
    retrieve keys in linear time.

    The ::Iterator class can be  used to explore  the
    content of the map. It is not  wise to iterate and
    modify a map in parallel.

    To compute  the hashcode of  the key the  function
    ::HashCode must be defined in the global namespace

    To compare two keys the function ::IsEqual must be
    defined in the global namespace.

    The performance of  a Map is conditionned  by  its
    number of buckets that  should be kept greater  to
    the number   of keys.  This  map has  an automatic
    management of the number of buckets. It is resized
    when  the number of Keys  becomes greater than the
    number of buckets.

    If you have a fair  idea of the number of  objects
    you  can save on automatic   resizing by giving  a
    number of buckets  at creation or using the ReSize
    method. This should be  consider only for  crucial
    optimisation issues.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def cbegin(self, *args):
        """
        cbegin(NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher self) -> NCollection_Map< Standard_Integer,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher self) -> NCollection_Map< Standard_Integer,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Single hashed Map. This  Map is used  to store and
        retrieve keys in linear time.

        The ::Iterator class can be  used to explore  the
        content of the map. It is not  wise to iterate and
        modify a map in parallel.

        To compute  the hashcode of  the key the  function
        ::HashCode must be defined in the global namespace

        To compare two keys the function ::IsEqual must be
        defined in the global namespace.

        The performance of  a Map is conditionned  by  its
        number of buckets that  should be kept greater  to
        the number   of keys.  This  map has  an automatic
        management of the number of buckets. It is resized
        when  the number of Keys  becomes greater than the
        number of buckets.

        If you have a fair  idea of the number of  objects
        you  can save on automatic   resizing by giving  a
        number of buckets  at creation or using the ReSize
        method. This should be  consider only for  crucial
        optimisation issues.
        """
        this = _TColStd.new_NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher self, NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TColStd.NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher self, NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher theOther) -> NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher

        Assign.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TColStd.NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher self, NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher theOther) -> NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher

        Assign operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TColStd.NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TColStd.NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher self, int const & K) -> Standard_Boolean

        Add

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher_Add(self, *args)


    def Added(self, *args):
        """
        Added: add a new key if not yet in the map, and return 
        reference to either newly added or previously existing object

        :type K: const TheKeyType &
        :rtype: const TheKeyType &

        """
        res = _TColStd.NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher_Added(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Remove(self, *args):
        """
        Remove(NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher self, int const & K) -> Standard_Boolean

        Remove

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher_Remove(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher_Size(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher self, NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher theOther) -> Standard_Boolean

        @return true if two maps contains exactly the same keys

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher_IsEqual(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher self, int const & K) -> Standard_Boolean
        Contains(NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher self, NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher theOther) -> Standard_Boolean

        @return true if this map contains ALL keys of another map.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher_Contains(self, *args)


    def Union(self, *args):
        """
        Union(NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher self, NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher theLeft, NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher theRight)

        Sets this Map to be the result of union (aka addition, fuse, merge, boolean OR) operation between two given Maps
        The new Map contains the values that are contained either in the first map or in the second map or in both.
        All previous content of this Map is cleared.
        This map (result of the boolean operation) can also be passed as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TColStd.NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher_Union(self, *args)


    def Unite(self, *args):
        """
        Unite(NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher self, NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher theOther) -> Standard_Boolean

        Apply to this Map the boolean operation union (aka addition, fuse, merge, boolean OR) with another (given) Map.
        The result contains the values that were previously contained in this map or contained in the given (operand) map.
        This algorithm is similar to method Union().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher_Unite(self, *args)


    def HasIntersection(self, *args):
        """
        HasIntersection(NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher self, NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher theMap) -> Standard_Boolean

        Returns true if this and theMap have common elements.

        :type theMap: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher_HasIntersection(self, *args)


    def Intersection(self, *args):
        """
        Intersection(NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher self, NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher theLeft, NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher theRight)

        Sets this Map to be the result of intersection (aka multiplication, common, boolean AND) operation between two given Maps.
        The new Map contains only the values that are contained in both map operands.
        All previous content of this Map is cleared.
        This same map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TColStd.NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher_Intersection(self, *args)


    def Intersect(self, *args):
        """
        Intersect(NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher self, NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher theOther) -> Standard_Boolean

        Apply to this Map the intersection operation (aka multiplication, common, boolean AND) with another (given) Map.
        The result contains only the values that are contained in both this and the given maps.
        This algorithm is similar to method Intersection().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher_Intersect(self, *args)


    def Subtraction(self, *args):
        """
        Subtraction(NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher self, NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher theLeft, NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher theRight)

        Sets this Map to be the result of subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation between two given Maps.
        The new Map contains only the values that are contained in the first map operands and not contained in the second one.
        All previous content of this Map is cleared.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TColStd.NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher_Subtraction(self, *args)


    def Subtract(self, *args):
        """
        Subtract(NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher self, NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher theOther) -> Standard_Boolean

        Apply to this Map the subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation with another (given) Map.
        The result contains only the values that were previously contained in this map and not contained in this map.
        This algorithm is similar to method Subtract() with two operands.
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher_Subtract(self, *args)


    def Difference(self, *args):
        """
        Difference(NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher self, NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher theLeft, NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher theRight)

        Sets this Map to be the result of symmetric difference (aka exclusive disjunction, boolean XOR) operation between two given Maps.
        The new Map contains the values that are contained only in the first or the second operand maps but not in both.
        All previous content of this Map is cleared. This map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TColStd.NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher_Difference(self, *args)


    def Differ(self, *args):
        """
        Differ(NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher self, NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher theOther) -> Standard_Boolean

        Apply to this Map the symmetric difference (aka exclusive disjunction, boolean XOR) operation with another (given) Map.
        The result contains the values that are contained only in this or the operand map, but not in both.
        This algorithm is similar to method Difference().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher_Differ(self, *args)


    def __iter__(self):
        return _TColStd.NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher___iter__(self)
    __swig_destroy__ = _TColStd.delete_NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher
NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher_swigregister = _TColStd.NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher_swigregister
NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher_swigregister(NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher)

class NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TColStd.new_NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TColStd.delete_NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher_IteratorHelper

    def __next__(self):
        return _TColStd.NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher_IteratorHelper___next__(self)
NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher_IteratorHelper_swigregister = _TColStd.NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher_IteratorHelper_swigregister
NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher_IteratorHelper_swigregister(NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher_IteratorHelper)


try:
	TColStd_MapOfInteger = NCollection_Map_Standard_Integer_TColStd_MapIntegerHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_TColStd_HArray2OfCharacter(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TColStd_HArray2OfCharacter self)

        Nullify the handle


        """
        return _TColStd.Handle_TColStd_HArray2OfCharacter_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TColStd_HArray2OfCharacter self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TColStd.Handle_TColStd_HArray2OfCharacter_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TColStd_HArray2OfCharacter self, TColStd_HArray2OfCharacter thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TColStd.Handle_TColStd_HArray2OfCharacter_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TColStd_HArray2OfCharacter self, Handle_TColStd_HArray2OfCharacter theHandle) -> Handle_TColStd_HArray2OfCharacter
        assign(Handle_TColStd_HArray2OfCharacter self, TColStd_HArray2OfCharacter thePtr) -> Handle_TColStd_HArray2OfCharacter
        assign(Handle_TColStd_HArray2OfCharacter self, Handle_TColStd_HArray2OfCharacter theHandle) -> Handle_TColStd_HArray2OfCharacter

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TColStd.Handle_TColStd_HArray2OfCharacter_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TColStd_HArray2OfCharacter self) -> TColStd_HArray2OfCharacter

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HArray2OfCharacter_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TColStd_HArray2OfCharacter self) -> TColStd_HArray2OfCharacter

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HArray2OfCharacter___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TColStd_HArray2OfCharacter self) -> TColStd_HArray2OfCharacter

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TColStd.Handle_TColStd_HArray2OfCharacter___ref__(self, *args)


    def __hash__(self):
        return _TColStd.Handle_TColStd_HArray2OfCharacter___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TColStd.Handle_TColStd_HArray2OfCharacter___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TColStd.new_Handle_TColStd_HArray2OfCharacter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TColStd.Handle_TColStd_HArray2OfCharacter_DownCast)
    __swig_destroy__ = _TColStd.delete_Handle_TColStd_HArray2OfCharacter

    def Array2(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array2OfCharacter

        """
        res = _TColStd.Handle_TColStd_HArray2OfCharacter_Array2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray2(self, *args):
        """
        ChangeArray2(Handle_TColStd_HArray2OfCharacter self) -> NCollection_Array2_Standard_Character

        :rtype: OCC.wrapper.TColStd.TColStd_Array2OfCharacter

        """
        return _TColStd.Handle_TColStd_HArray2OfCharacter_ChangeArray2(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TColStd_HArray2OfCharacter self) -> char const *

        :rtype: const char *

        """
        return _TColStd.Handle_TColStd_HArray2OfCharacter_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HArray2OfCharacter_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HArray2OfCharacter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TColStd_HArray2OfCharacter self)

        Memory deallocator for transient classes


        """
        return _TColStd.Handle_TColStd_HArray2OfCharacter_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TColStd_HArray2OfCharacter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TColStd_HArray2OfCharacter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HArray2OfCharacter_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TColStd_HArray2OfCharacter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TColStd_HArray2OfCharacter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HArray2OfCharacter_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TColStd_HArray2OfCharacter self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TColStd.Handle_TColStd_HArray2OfCharacter_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TColStd_HArray2OfCharacter self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray2OfCharacter_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TColStd_HArray2OfCharacter self)

        Increments the reference counter of this object


        """
        return _TColStd.Handle_TColStd_HArray2OfCharacter_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TColStd_HArray2OfCharacter self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray2OfCharacter_DecrementRefCounter(self, *args)

Handle_TColStd_HArray2OfCharacter_swigregister = _TColStd.Handle_TColStd_HArray2OfCharacter_swigregister
Handle_TColStd_HArray2OfCharacter_swigregister(Handle_TColStd_HArray2OfCharacter)

def Handle_TColStd_HArray2OfCharacter_DownCast(thing):
    return _TColStd.Handle_TColStd_HArray2OfCharacter_DownCast(thing)
Handle_TColStd_HArray2OfCharacter_DownCast = _TColStd.Handle_TColStd_HArray2OfCharacter_DownCast

class NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< Standard_Transient >,TColStd_MapIntegerHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< Standard_Transient >,TColStd_MapIntegerHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< Standard_Transient >,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,opencascade::handle< Standard_Transient >,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TColStd.new_NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher self, int const & theKey, Handle_Standard_Transient theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher self, int const & theKey, Handle_Standard_Transient theItem) -> Handle_Standard_Transient

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher self, int const & theKey) -> Handle_Standard_Transient

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher self, int const & theKey) -> Handle_Standard_Transient

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher self, int const & theKey) -> Handle_Standard_Transient

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher_Size(self, *args)


    def __iter__(self):
        return _TColStd.NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher___iter__(self)
    __swig_destroy__ = _TColStd.delete_NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher
NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher_swigregister = _TColStd.NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher_swigregister
NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher_swigregister(NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher)

class NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TColStd.new_NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TColStd.delete_NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher_IteratorHelper

    def __next__(self):
        return _TColStd.NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher_IteratorHelper___next__(self)
NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher_IteratorHelper_swigregister = _TColStd.NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher_IteratorHelper_swigregister
NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher_IteratorHelper_swigregister(NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher_IteratorHelper)


try:
	TColStd_DataMapOfIntegerTransient = NCollection_DataMap_Standard_Integer_Handle_Standard_Transient_TColStd_MapIntegerHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_DefaultHasher_Standard_Integer(object):
    """
    Purpose:     The  DefaultHasher  is a  Hasher  that is used by
    default in NCollection maps. 
    To compute the  hash code of the key  is used the
    global function HashCode.
    To compare two keys is used  the  global function 
    IsEqual.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def HashCode(*args):
        """
        HashCode(int const & theKey, Standard_Integer const Upper) -> Standard_Integer

        :type theKey: const TheKeyType &
        :type Upper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_DefaultHasher_Standard_Integer_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args):
        """
        IsEqual(int const & theKey1, int const & theKey2) -> Standard_Boolean

        :type theKey1: const TheKeyType &
        :type theKey2: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_DefaultHasher_Standard_Integer_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    def __init__(self):
        """
        Purpose:     The  DefaultHasher  is a  Hasher  that is used by
        default in NCollection maps. 
        To compute the  hash code of the key  is used the
        global function HashCode.
        To compare two keys is used  the  global function 
        IsEqual.
        """
        this = _TColStd.new_NCollection_DefaultHasher_Standard_Integer()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TColStd.delete_NCollection_DefaultHasher_Standard_Integer
NCollection_DefaultHasher_Standard_Integer_swigregister = _TColStd.NCollection_DefaultHasher_Standard_Integer_swigregister
NCollection_DefaultHasher_Standard_Integer_swigregister(NCollection_DefaultHasher_Standard_Integer)

def NCollection_DefaultHasher_Standard_Integer_HashCode(*args):
    """
    NCollection_DefaultHasher_Standard_Integer_HashCode(int const & theKey, Standard_Integer const Upper) -> Standard_Integer

    :type theKey: const TheKeyType &
    :type Upper: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _TColStd.NCollection_DefaultHasher_Standard_Integer_HashCode(*args)

def NCollection_DefaultHasher_Standard_Integer_IsEqual(*args):
    """
    NCollection_DefaultHasher_Standard_Integer_IsEqual(int const & theKey1, int const & theKey2) -> Standard_Boolean

    :type theKey1: const TheKeyType &
    :type theKey2: const TheKeyType &
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TColStd.NCollection_DefaultHasher_Standard_Integer_IsEqual(*args)


try:
	TColStd_MapIntegerHasher = NCollection_DefaultHasher_Standard_Integer
except NameError:
	pass # does not exist, probably ignored

class TColStd_PackedMapOfInteger(object):
    """Optimized Map of integer values. Each block of 32 integers is stored in 8 bytes in memory."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TColStd_PackedMapOfInteger self, Standard_Integer const NbBuckets=1) -> TColStd_PackedMapOfInteger
        __init__(TColStd_PackedMapOfInteger self, TColStd_PackedMapOfInteger theOther) -> TColStd_PackedMapOfInteger

        Copy constructor

        :type theOther: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        this = _TColStd.new_TColStd_PackedMapOfInteger(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def assign(self, *args):
        """
        assign(TColStd_PackedMapOfInteger self, TColStd_PackedMapOfInteger Other) -> TColStd_PackedMapOfInteger

        :type Other: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :rtype: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        return _TColStd.TColStd_PackedMapOfInteger_assign(self, *args)


    def Assign(self, *args):
        """
        Assign(TColStd_PackedMapOfInteger self, TColStd_PackedMapOfInteger arg2) -> TColStd_PackedMapOfInteger

        :type : OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :rtype: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        return _TColStd.TColStd_PackedMapOfInteger_Assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(TColStd_PackedMapOfInteger self, Standard_Integer const NbBuckets)

        :type NbBuckets: int

        """
        return _TColStd.TColStd_PackedMapOfInteger_ReSize(self, *args)


    def Clear(self, *args):
        """Clear(TColStd_PackedMapOfInteger self)"""
        return _TColStd.TColStd_PackedMapOfInteger_Clear(self, *args)


    def Add(self, *args):
        """
        Add(TColStd_PackedMapOfInteger self, Standard_Integer const aKey) -> Standard_Boolean

        :type aKey: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.TColStd_PackedMapOfInteger_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(TColStd_PackedMapOfInteger self, Standard_Integer const aKey) -> Standard_Boolean

        :type aKey: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.TColStd_PackedMapOfInteger_Contains(self, *args)


    def Remove(self, *args):
        """
        Remove(TColStd_PackedMapOfInteger self, Standard_Integer const aKey) -> Standard_Boolean

        :type aKey: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.TColStd_PackedMapOfInteger_Remove(self, *args)


    def NbBuckets(self, *args):
        """
        NbBuckets(TColStd_PackedMapOfInteger self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.TColStd_PackedMapOfInteger_NbBuckets(self, *args)


    def Extent(self, *args):
        """
        Extent(TColStd_PackedMapOfInteger self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.TColStd_PackedMapOfInteger_Extent(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(TColStd_PackedMapOfInteger self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.TColStd_PackedMapOfInteger_IsEmpty(self, *args)


    def Statistics(self, *args):
        """
        Statistics(TColStd_PackedMapOfInteger self, Standard_OStream & outStream)

        :type outStream: OCC.wrapper.Standard.Standard_OStream

        """
        return _TColStd.TColStd_PackedMapOfInteger_Statistics(self, *args)


    def GetMinimalMapped(self, *args):
        """
        GetMinimalMapped(TColStd_PackedMapOfInteger self) -> Standard_Integer

        Query the minimal contained key value.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.TColStd_PackedMapOfInteger_GetMinimalMapped(self, *args)


    def GetMaximalMapped(self, *args):
        """
        GetMaximalMapped(TColStd_PackedMapOfInteger self) -> Standard_Integer

        Query the maximal contained key value.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.TColStd_PackedMapOfInteger_GetMaximalMapped(self, *args)


    def Union(self, *args):
        """
        Union(TColStd_PackedMapOfInteger self, TColStd_PackedMapOfInteger arg2, TColStd_PackedMapOfInteger arg3)

        Sets this Map to be the result of union (aka addition, fuse, merge, boolean OR) operation between two given Maps.
        The new Map contains the values that are contained either in the first map or in the second map or in both.
        All previous contents of this Map is cleared. This map (result of the boolean operation) can also be passed as one of operands.

        :type : OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type : OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        return _TColStd.TColStd_PackedMapOfInteger_Union(self, *args)


    def Unite(self, *args):
        """
        Unite(TColStd_PackedMapOfInteger self, TColStd_PackedMapOfInteger arg2) -> Standard_Boolean

        Apply to this Map the boolean operation union (aka addition, fuse, merge, boolean OR) with another (given) Map.
        The result contains the values that were previously contained in this map or contained in the given (operand) map.
        This algorithm is similar to method Union().
        @return True if content of this map is changed

        :type : OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.TColStd_PackedMapOfInteger_Unite(self, *args)


    def __ior__(self, *args):
        """
        __ior__(TColStd_PackedMapOfInteger self, TColStd_PackedMapOfInteger MM) -> TColStd_PackedMapOfInteger

        Overloaded operator version of Unite().

        :type MM: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :rtype: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        return _TColStd.TColStd_PackedMapOfInteger___ior__(self, *args)


    def Intersection(self, *args):
        """
        Intersection(TColStd_PackedMapOfInteger self, TColStd_PackedMapOfInteger arg2, TColStd_PackedMapOfInteger arg3)

        Sets this Map to be the result of intersection (aka multiplication, common, boolean AND) operation between two given Maps.
        The new Map contains only the values that are contained in both map operands.
        All previous contents of this Map is cleared. This same map (result of the boolean operation) can also be used as one of operands.
        The order of operands makes no difference; the method minimizes internally the number of iterations using the smallest map for the loop.

        :type : OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type : OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        return _TColStd.TColStd_PackedMapOfInteger_Intersection(self, *args)


    def Intersect(self, *args):
        """
        Intersect(TColStd_PackedMapOfInteger self, TColStd_PackedMapOfInteger arg2) -> Standard_Boolean

        Apply to this Map the intersection operation (aka multiplication, common,  boolean AND) with another (given) Map.
        The result contains only the values that are contained in both this and the given maps.
        This algorithm is similar to method Intersection().
        @return True if content of this map is changed

        :type : OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.TColStd_PackedMapOfInteger_Intersect(self, *args)


    def __iand__(self, *args):
        """
        __iand__(TColStd_PackedMapOfInteger self, TColStd_PackedMapOfInteger MM) -> TColStd_PackedMapOfInteger

        Overloaded operator version of Intersect().

        :type MM: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :rtype: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        return _TColStd.TColStd_PackedMapOfInteger___iand__(self, *args)


    def Subtraction(self, *args):
        """
        Subtraction(TColStd_PackedMapOfInteger self, TColStd_PackedMapOfInteger arg2, TColStd_PackedMapOfInteger arg3)

        Sets this Map to be the result of subtraction
        (aka set-theoretic difference, relative complement, exclude, cut, boolean NOT) operation between two given Maps.
        The new Map contains only the values that are contained in the first map operands and not contained in the second one.
        All previous contents of this Map is cleared.
        This map (result of the boolean operation) can also be used as the first operand.

        :type : OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type : OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        return _TColStd.TColStd_PackedMapOfInteger_Subtraction(self, *args)


    def Subtract(self, *args):
        """
        Subtract(TColStd_PackedMapOfInteger self, TColStd_PackedMapOfInteger arg2) -> Standard_Boolean

        Apply to this Map the subtraction (aka set-theoretic difference, relative complement, exclude, cut, boolean NOT) operation with another (given) Map.
        The result contains only the values that were previously contained in this map and not contained in this map.
        This algorithm is similar to method Subtract() with two operands.
        @return True if contents of this map is changed

        :type : OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.TColStd_PackedMapOfInteger_Subtract(self, *args)


    def __isub__(self, *args):
        """
        __isub__(TColStd_PackedMapOfInteger self, TColStd_PackedMapOfInteger MM) -> TColStd_PackedMapOfInteger

        Overloaded operator version of Subtract().

        :type MM: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :rtype: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        return _TColStd.TColStd_PackedMapOfInteger___isub__(self, *args)


    def Difference(self, *args):
        """
        Difference(TColStd_PackedMapOfInteger self, TColStd_PackedMapOfInteger arg2, TColStd_PackedMapOfInteger arg3)

        Sets this Map to be the result of symmetric difference (aka exclusive disjunction, boolean XOR) operation between two given Maps.
        The new Map contains the values that are contained only in the first or the second operand maps but not in both.
        All previous contents of this Map is cleared.
        This map (result of the boolean operation) can also be used as one of operands.

        :type : OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :type : OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        return _TColStd.TColStd_PackedMapOfInteger_Difference(self, *args)


    def Differ(self, *args):
        """
        Differ(TColStd_PackedMapOfInteger self, TColStd_PackedMapOfInteger arg2) -> Standard_Boolean

        Apply to this Map the symmetric difference (aka exclusive disjunction, boolean XOR) operation with another (given) Map.
        The result contains the values that are contained only in this or the operand map, but not in both.
        This algorithm is similar to method Difference().
        @return True if contents of this map is changed

        :type : OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.TColStd_PackedMapOfInteger_Differ(self, *args)


    def __ixor__(self, *args):
        """
        __ixor__(TColStd_PackedMapOfInteger self, TColStd_PackedMapOfInteger MM) -> TColStd_PackedMapOfInteger

        Overloaded operator version of Differ().

        :type MM: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :rtype: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        return _TColStd.TColStd_PackedMapOfInteger___ixor__(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(TColStd_PackedMapOfInteger self, TColStd_PackedMapOfInteger arg2) -> Standard_Boolean

        Returns True if this map is equal to the given one, i.e. they contain the
        same sets of elements

        :type : OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.TColStd_PackedMapOfInteger_IsEqual(self, *args)


    def __eq__(self, *args):
        """
        __eq__(TColStd_PackedMapOfInteger self, TColStd_PackedMapOfInteger MM) -> Standard_Boolean

        Overloaded operator version of IsEqual().

        :type MM: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.TColStd_PackedMapOfInteger___eq__(self, *args)


    def IsSubset(self, *args):
        """
        IsSubset(TColStd_PackedMapOfInteger self, TColStd_PackedMapOfInteger arg2) -> Standard_Boolean

        Returns True if this map is subset of the given one, i.e. all elements 
        contained in this map is contained also in the operand map.
        if this map is empty that this method returns true for any operand map.

        :type : OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.TColStd_PackedMapOfInteger_IsSubset(self, *args)


    def __le__(self, *args):
        """
        __le__(TColStd_PackedMapOfInteger self, TColStd_PackedMapOfInteger MM) -> Standard_Boolean

        Overloaded operator version of IsSubset().

        :type MM: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.TColStd_PackedMapOfInteger___le__(self, *args)


    def HasIntersection(self, *args):
        """
        HasIntersection(TColStd_PackedMapOfInteger self, TColStd_PackedMapOfInteger arg2) -> Standard_Boolean

        Returns True if this map has common items with the given one.

        :type : OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.TColStd_PackedMapOfInteger_HasIntersection(self, *args)

    __swig_destroy__ = _TColStd.delete_TColStd_PackedMapOfInteger
TColStd_PackedMapOfInteger_swigregister = _TColStd.TColStd_PackedMapOfInteger_swigregister
TColStd_PackedMapOfInteger_swigregister(TColStd_PackedMapOfInteger)

class NCollection_List_Standard_Real(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_Standard_Real self) -> NCollection_List< Standard_Real >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _TColStd.NCollection_List_Standard_Real_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_Standard_Real self) -> NCollection_List< Standard_Real >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _TColStd.NCollection_List_Standard_Real_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_Standard_Real self) -> NCollection_List< Standard_Real >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_List_Standard_Real_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_Standard_Real self) -> NCollection_List< Standard_Real >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_List_Standard_Real_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _TColStd.new_NCollection_List_Standard_Real(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_Standard_Real self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_List_Standard_Real_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_Standard_Real self, NCollection_List_Standard_Real theOther) -> NCollection_List_Standard_Real

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _TColStd.NCollection_List_Standard_Real_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_Standard_Real self, NCollection_List_Standard_Real theOther) -> NCollection_List_Standard_Real

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _TColStd.NCollection_List_Standard_Real_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_Standard_Real self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_List_Standard_Real_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_List_Standard_Real_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_List_Standard_Real_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_Standard_Real self, double const & theItem) -> double
        Append(NCollection_List_Standard_Real self, double const & theItem, NCollection_List< Standard_Real >::Iterator & theIter)
        Append(NCollection_List_Standard_Real self, NCollection_List_Standard_Real theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _TColStd.NCollection_List_Standard_Real_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_Standard_Real self, double const & theItem) -> double
        Prepend(NCollection_List_Standard_Real self, NCollection_List_Standard_Real theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _TColStd.NCollection_List_Standard_Real_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_Standard_Real self)

        RemoveFirst item


        """
        return _TColStd.NCollection_List_Standard_Real_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_Standard_Real self, NCollection_List< Standard_Real >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _TColStd.NCollection_List_Standard_Real_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_Standard_Real self, double const & theItem, NCollection_List< Standard_Real >::Iterator & theIter) -> double
        InsertBefore(NCollection_List_Standard_Real self, NCollection_List_Standard_Real theOther, NCollection_List< Standard_Real >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _TColStd.NCollection_List_Standard_Real_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_Standard_Real self, double const & theItem, NCollection_List< Standard_Real >::Iterator & theIter) -> double
        InsertAfter(NCollection_List_Standard_Real self, NCollection_List_Standard_Real theOther, NCollection_List< Standard_Real >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _TColStd.NCollection_List_Standard_Real_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_Standard_Real self)

        Reverse the list


        """
        return _TColStd.NCollection_List_Standard_Real_Reverse(self, *args)


    def __iter__(self):
        return _TColStd.NCollection_List_Standard_Real___iter__(self)
    __swig_destroy__ = _TColStd.delete_NCollection_List_Standard_Real
NCollection_List_Standard_Real_swigregister = _TColStd.NCollection_List_Standard_Real_swigregister
NCollection_List_Standard_Real_swigregister(NCollection_List_Standard_Real)

class NCollection_List_Standard_Real_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TColStd.new_NCollection_List_Standard_Real_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TColStd.delete_NCollection_List_Standard_Real_IteratorHelper

    def __next__(self):
        return _TColStd.NCollection_List_Standard_Real_IteratorHelper___next__(self)
NCollection_List_Standard_Real_IteratorHelper_swigregister = _TColStd.NCollection_List_Standard_Real_IteratorHelper_swigregister
NCollection_List_Standard_Real_IteratorHelper_swigregister(NCollection_List_Standard_Real_IteratorHelper)


try:
	TColStd_ListOfReal = NCollection_List_Standard_Real
except NameError:
	pass # does not exist, probably ignored

class TColStd_HArray1OfAsciiString(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TColStd_HArray1OfAsciiString
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TColStd_HArray1OfAsciiString(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TColStd_HArray1OfAsciiString self, Standard_Integer const theLower, Standard_Integer const theUpper) -> TColStd_HArray1OfAsciiString
        __init__(TColStd_HArray1OfAsciiString self, Standard_Integer const theLower, Standard_Integer const theUpper, TCollection_AsciiString theValue) -> TColStd_HArray1OfAsciiString
        __init__(TColStd_HArray1OfAsciiString self, NCollection_Array1_TCollection_AsciiString theOther) -> TColStd_HArray1OfAsciiString

        :type theOther: OCC.wrapper.TColStd.TColStd_Array1OfAsciiString

        """
        this = _TColStd.new_TColStd_HArray1OfAsciiString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfAsciiString

        """
        res = _TColStd.TColStd_HArray1OfAsciiString_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(TColStd_HArray1OfAsciiString self) -> NCollection_Array1_TCollection_AsciiString

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfAsciiString

        """
        return _TColStd.TColStd_HArray1OfAsciiString_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TColStd.TColStd_HArray1OfAsciiString_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TColStd.TColStd_HArray1OfAsciiString_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.TColStd_HArray1OfAsciiString_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TColStd.delete_TColStd_HArray1OfAsciiString
TColStd_HArray1OfAsciiString_swigregister = _TColStd.TColStd_HArray1OfAsciiString_swigregister
TColStd_HArray1OfAsciiString_swigregister(TColStd_HArray1OfAsciiString)

def TColStd_HArray1OfAsciiString_get_type_name(*args):
    """
    TColStd_HArray1OfAsciiString_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TColStd.TColStd_HArray1OfAsciiString_get_type_name(*args)

def TColStd_HArray1OfAsciiString_get_type_descriptor(*args):
    """
    TColStd_HArray1OfAsciiString_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TColStd.TColStd_HArray1OfAsciiString_get_type_descriptor(*args)

class NCollection_Array1_Standard_Byte(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Standard_Byte self) -> NCollection_Array1< Standard_Byte >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _TColStd.NCollection_Array1_Standard_Byte_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Standard_Byte self) -> NCollection_Array1< Standard_Byte >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _TColStd.NCollection_Array1_Standard_Byte_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Standard_Byte self) -> NCollection_Array1< Standard_Byte >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Array1_Standard_Byte_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Standard_Byte self) -> NCollection_Array1< Standard_Byte >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Array1_Standard_Byte_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _TColStd.new_NCollection_Array1_Standard_Byte(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Standard_Byte self, unsigned char const & theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _TColStd.NCollection_Array1_Standard_Byte_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Standard_Byte self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_Standard_Byte_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Standard_Byte self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_Standard_Byte_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Standard_Byte self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Array1_Standard_Byte_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Standard_Byte self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_Standard_Byte_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Standard_Byte self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_Standard_Byte_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Standard_Byte self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Array1_Standard_Byte_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Standard_Byte self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Array1_Standard_Byte_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Standard_Byte self, NCollection_Array1_Standard_Byte theOther) -> NCollection_Array1_Standard_Byte

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TColStd.NCollection_Array1_Standard_Byte_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Standard_Byte self, NCollection_Array1_Standard_Byte theOther) -> NCollection_Array1_Standard_Byte

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TColStd.NCollection_Array1_Standard_Byte_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Standard_Byte self, NCollection_Array1_Standard_Byte theOther) -> NCollection_Array1_Standard_Byte
        assign(NCollection_Array1_Standard_Byte self, NCollection_Array1_Standard_Byte theOther) -> NCollection_Array1_Standard_Byte

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TColStd.NCollection_Array1_Standard_Byte_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_Standard_Byte_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Standard_Byte self) -> unsigned char &

        @return first element

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Array1_Standard_Byte_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_Standard_Byte_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Standard_Byte self) -> unsigned char &

        @return last element

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Array1_Standard_Byte_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_Standard_Byte_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Standard_Byte self, Standard_Integer const theIndex) -> unsigned char &

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Array1_Standard_Byte_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_Standard_Byte___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_Standard_Byte_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Standard_Byte self, Standard_Integer const theIndex, unsigned char const & theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TColStd.NCollection_Array1_Standard_Byte_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Standard_Byte self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _TColStd.NCollection_Array1_Standard_Byte_Resize(self, *args)

    __swig_destroy__ = _TColStd.delete_NCollection_Array1_Standard_Byte
NCollection_Array1_Standard_Byte_swigregister = _TColStd.NCollection_Array1_Standard_Byte_swigregister
NCollection_Array1_Standard_Byte_swigregister(NCollection_Array1_Standard_Byte)


try:
	TColStd_Array1OfByte = NCollection_Array1_Standard_Byte
except NameError:
	pass # does not exist, probably ignored

class NCollection_Map_Standard_Real_TColStd_MapRealHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     Single hashed Map. This  Map is used  to store and
    retrieve keys in linear time.

    The ::Iterator class can be  used to explore  the
    content of the map. It is not  wise to iterate and
    modify a map in parallel.

    To compute  the hashcode of  the key the  function
    ::HashCode must be defined in the global namespace

    To compare two keys the function ::IsEqual must be
    defined in the global namespace.

    The performance of  a Map is conditionned  by  its
    number of buckets that  should be kept greater  to
    the number   of keys.  This  map has  an automatic
    management of the number of buckets. It is resized
    when  the number of Keys  becomes greater than the
    number of buckets.

    If you have a fair  idea of the number of  objects
    you  can save on automatic   resizing by giving  a
    number of buckets  at creation or using the ReSize
    method. This should be  consider only for  crucial
    optimisation issues.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def cbegin(self, *args):
        """
        cbegin(NCollection_Map_Standard_Real_TColStd_MapRealHasher self) -> NCollection_Map< Standard_Real,TColStd_MapRealHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Map_Standard_Real_TColStd_MapRealHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Map_Standard_Real_TColStd_MapRealHasher self) -> NCollection_Map< Standard_Real,TColStd_MapRealHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Map_Standard_Real_TColStd_MapRealHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Single hashed Map. This  Map is used  to store and
        retrieve keys in linear time.

        The ::Iterator class can be  used to explore  the
        content of the map. It is not  wise to iterate and
        modify a map in parallel.

        To compute  the hashcode of  the key the  function
        ::HashCode must be defined in the global namespace

        To compare two keys the function ::IsEqual must be
        defined in the global namespace.

        The performance of  a Map is conditionned  by  its
        number of buckets that  should be kept greater  to
        the number   of keys.  This  map has  an automatic
        management of the number of buckets. It is resized
        when  the number of Keys  becomes greater than the
        number of buckets.

        If you have a fair  idea of the number of  objects
        you  can save on automatic   resizing by giving  a
        number of buckets  at creation or using the ReSize
        method. This should be  consider only for  crucial
        optimisation issues.
        """
        this = _TColStd.new_NCollection_Map_Standard_Real_TColStd_MapRealHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_Map_Standard_Real_TColStd_MapRealHasher self, NCollection_Map_Standard_Real_TColStd_MapRealHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TColStd.NCollection_Map_Standard_Real_TColStd_MapRealHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Map_Standard_Real_TColStd_MapRealHasher self, NCollection_Map_Standard_Real_TColStd_MapRealHasher theOther) -> NCollection_Map_Standard_Real_TColStd_MapRealHasher

        Assign.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TColStd.NCollection_Map_Standard_Real_TColStd_MapRealHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Map_Standard_Real_TColStd_MapRealHasher self, NCollection_Map_Standard_Real_TColStd_MapRealHasher theOther) -> NCollection_Map_Standard_Real_TColStd_MapRealHasher

        Assign operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TColStd.NCollection_Map_Standard_Real_TColStd_MapRealHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_Map_Standard_Real_TColStd_MapRealHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TColStd.NCollection_Map_Standard_Real_TColStd_MapRealHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_Map_Standard_Real_TColStd_MapRealHasher self, double const & K) -> Standard_Boolean

        Add

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_Standard_Real_TColStd_MapRealHasher_Add(self, *args)


    def Added(self, *args):
        """
        Added: add a new key if not yet in the map, and return 
        reference to either newly added or previously existing object

        :type K: const TheKeyType &
        :rtype: const TheKeyType &

        """
        res = _TColStd.NCollection_Map_Standard_Real_TColStd_MapRealHasher_Added(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Remove(self, *args):
        """
        Remove(NCollection_Map_Standard_Real_TColStd_MapRealHasher self, double const & K) -> Standard_Boolean

        Remove

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_Standard_Real_TColStd_MapRealHasher_Remove(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_Map_Standard_Real_TColStd_MapRealHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_Map_Standard_Real_TColStd_MapRealHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_Map_Standard_Real_TColStd_MapRealHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Map_Standard_Real_TColStd_MapRealHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Map_Standard_Real_TColStd_MapRealHasher_Size(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(NCollection_Map_Standard_Real_TColStd_MapRealHasher self, NCollection_Map_Standard_Real_TColStd_MapRealHasher theOther) -> Standard_Boolean

        @return true if two maps contains exactly the same keys

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_Standard_Real_TColStd_MapRealHasher_IsEqual(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_Map_Standard_Real_TColStd_MapRealHasher self, double const & K) -> Standard_Boolean
        Contains(NCollection_Map_Standard_Real_TColStd_MapRealHasher self, NCollection_Map_Standard_Real_TColStd_MapRealHasher theOther) -> Standard_Boolean

        @return true if this map contains ALL keys of another map.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_Standard_Real_TColStd_MapRealHasher_Contains(self, *args)


    def Union(self, *args):
        """
        Union(NCollection_Map_Standard_Real_TColStd_MapRealHasher self, NCollection_Map_Standard_Real_TColStd_MapRealHasher theLeft, NCollection_Map_Standard_Real_TColStd_MapRealHasher theRight)

        Sets this Map to be the result of union (aka addition, fuse, merge, boolean OR) operation between two given Maps
        The new Map contains the values that are contained either in the first map or in the second map or in both.
        All previous content of this Map is cleared.
        This map (result of the boolean operation) can also be passed as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TColStd.NCollection_Map_Standard_Real_TColStd_MapRealHasher_Union(self, *args)


    def Unite(self, *args):
        """
        Unite(NCollection_Map_Standard_Real_TColStd_MapRealHasher self, NCollection_Map_Standard_Real_TColStd_MapRealHasher theOther) -> Standard_Boolean

        Apply to this Map the boolean operation union (aka addition, fuse, merge, boolean OR) with another (given) Map.
        The result contains the values that were previously contained in this map or contained in the given (operand) map.
        This algorithm is similar to method Union().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_Standard_Real_TColStd_MapRealHasher_Unite(self, *args)


    def HasIntersection(self, *args):
        """
        HasIntersection(NCollection_Map_Standard_Real_TColStd_MapRealHasher self, NCollection_Map_Standard_Real_TColStd_MapRealHasher theMap) -> Standard_Boolean

        Returns true if this and theMap have common elements.

        :type theMap: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_Standard_Real_TColStd_MapRealHasher_HasIntersection(self, *args)


    def Intersection(self, *args):
        """
        Intersection(NCollection_Map_Standard_Real_TColStd_MapRealHasher self, NCollection_Map_Standard_Real_TColStd_MapRealHasher theLeft, NCollection_Map_Standard_Real_TColStd_MapRealHasher theRight)

        Sets this Map to be the result of intersection (aka multiplication, common, boolean AND) operation between two given Maps.
        The new Map contains only the values that are contained in both map operands.
        All previous content of this Map is cleared.
        This same map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TColStd.NCollection_Map_Standard_Real_TColStd_MapRealHasher_Intersection(self, *args)


    def Intersect(self, *args):
        """
        Intersect(NCollection_Map_Standard_Real_TColStd_MapRealHasher self, NCollection_Map_Standard_Real_TColStd_MapRealHasher theOther) -> Standard_Boolean

        Apply to this Map the intersection operation (aka multiplication, common, boolean AND) with another (given) Map.
        The result contains only the values that are contained in both this and the given maps.
        This algorithm is similar to method Intersection().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_Standard_Real_TColStd_MapRealHasher_Intersect(self, *args)


    def Subtraction(self, *args):
        """
        Subtraction(NCollection_Map_Standard_Real_TColStd_MapRealHasher self, NCollection_Map_Standard_Real_TColStd_MapRealHasher theLeft, NCollection_Map_Standard_Real_TColStd_MapRealHasher theRight)

        Sets this Map to be the result of subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation between two given Maps.
        The new Map contains only the values that are contained in the first map operands and not contained in the second one.
        All previous content of this Map is cleared.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TColStd.NCollection_Map_Standard_Real_TColStd_MapRealHasher_Subtraction(self, *args)


    def Subtract(self, *args):
        """
        Subtract(NCollection_Map_Standard_Real_TColStd_MapRealHasher self, NCollection_Map_Standard_Real_TColStd_MapRealHasher theOther) -> Standard_Boolean

        Apply to this Map the subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation with another (given) Map.
        The result contains only the values that were previously contained in this map and not contained in this map.
        This algorithm is similar to method Subtract() with two operands.
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_Standard_Real_TColStd_MapRealHasher_Subtract(self, *args)


    def Difference(self, *args):
        """
        Difference(NCollection_Map_Standard_Real_TColStd_MapRealHasher self, NCollection_Map_Standard_Real_TColStd_MapRealHasher theLeft, NCollection_Map_Standard_Real_TColStd_MapRealHasher theRight)

        Sets this Map to be the result of symmetric difference (aka exclusive disjunction, boolean XOR) operation between two given Maps.
        The new Map contains the values that are contained only in the first or the second operand maps but not in both.
        All previous content of this Map is cleared. This map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TColStd.NCollection_Map_Standard_Real_TColStd_MapRealHasher_Difference(self, *args)


    def Differ(self, *args):
        """
        Differ(NCollection_Map_Standard_Real_TColStd_MapRealHasher self, NCollection_Map_Standard_Real_TColStd_MapRealHasher theOther) -> Standard_Boolean

        Apply to this Map the symmetric difference (aka exclusive disjunction, boolean XOR) operation with another (given) Map.
        The result contains the values that are contained only in this or the operand map, but not in both.
        This algorithm is similar to method Difference().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_Standard_Real_TColStd_MapRealHasher_Differ(self, *args)


    def __iter__(self):
        return _TColStd.NCollection_Map_Standard_Real_TColStd_MapRealHasher___iter__(self)
    __swig_destroy__ = _TColStd.delete_NCollection_Map_Standard_Real_TColStd_MapRealHasher
NCollection_Map_Standard_Real_TColStd_MapRealHasher_swigregister = _TColStd.NCollection_Map_Standard_Real_TColStd_MapRealHasher_swigregister
NCollection_Map_Standard_Real_TColStd_MapRealHasher_swigregister(NCollection_Map_Standard_Real_TColStd_MapRealHasher)

class NCollection_Map_Standard_Real_TColStd_MapRealHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TColStd.new_NCollection_Map_Standard_Real_TColStd_MapRealHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TColStd.delete_NCollection_Map_Standard_Real_TColStd_MapRealHasher_IteratorHelper

    def __next__(self):
        return _TColStd.NCollection_Map_Standard_Real_TColStd_MapRealHasher_IteratorHelper___next__(self)
NCollection_Map_Standard_Real_TColStd_MapRealHasher_IteratorHelper_swigregister = _TColStd.NCollection_Map_Standard_Real_TColStd_MapRealHasher_IteratorHelper_swigregister
NCollection_Map_Standard_Real_TColStd_MapRealHasher_IteratorHelper_swigregister(NCollection_Map_Standard_Real_TColStd_MapRealHasher_IteratorHelper)


try:
	TColStd_MapOfReal = NCollection_Map_Standard_Real_TColStd_MapRealHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_TColStd_HArray2OfInteger(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TColStd_HArray2OfInteger self)

        Nullify the handle


        """
        return _TColStd.Handle_TColStd_HArray2OfInteger_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TColStd_HArray2OfInteger self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TColStd.Handle_TColStd_HArray2OfInteger_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TColStd_HArray2OfInteger self, TColStd_HArray2OfInteger thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TColStd.Handle_TColStd_HArray2OfInteger_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TColStd_HArray2OfInteger self, Handle_TColStd_HArray2OfInteger theHandle) -> Handle_TColStd_HArray2OfInteger
        assign(Handle_TColStd_HArray2OfInteger self, TColStd_HArray2OfInteger thePtr) -> Handle_TColStd_HArray2OfInteger
        assign(Handle_TColStd_HArray2OfInteger self, Handle_TColStd_HArray2OfInteger theHandle) -> Handle_TColStd_HArray2OfInteger

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TColStd.Handle_TColStd_HArray2OfInteger_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TColStd_HArray2OfInteger self) -> TColStd_HArray2OfInteger

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HArray2OfInteger_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TColStd_HArray2OfInteger self) -> TColStd_HArray2OfInteger

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HArray2OfInteger___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TColStd_HArray2OfInteger self) -> TColStd_HArray2OfInteger

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TColStd.Handle_TColStd_HArray2OfInteger___ref__(self, *args)


    def __hash__(self):
        return _TColStd.Handle_TColStd_HArray2OfInteger___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TColStd.Handle_TColStd_HArray2OfInteger___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TColStd.new_Handle_TColStd_HArray2OfInteger(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TColStd.Handle_TColStd_HArray2OfInteger_DownCast)
    __swig_destroy__ = _TColStd.delete_Handle_TColStd_HArray2OfInteger

    def Array2(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array2OfInteger

        """
        res = _TColStd.Handle_TColStd_HArray2OfInteger_Array2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray2(self, *args):
        """
        ChangeArray2(Handle_TColStd_HArray2OfInteger self) -> NCollection_Array2_Standard_Integer

        :rtype: OCC.wrapper.TColStd.TColStd_Array2OfInteger

        """
        return _TColStd.Handle_TColStd_HArray2OfInteger_ChangeArray2(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TColStd_HArray2OfInteger self) -> char const *

        :rtype: const char *

        """
        return _TColStd.Handle_TColStd_HArray2OfInteger_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HArray2OfInteger_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HArray2OfInteger_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TColStd_HArray2OfInteger self)

        Memory deallocator for transient classes


        """
        return _TColStd.Handle_TColStd_HArray2OfInteger_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TColStd_HArray2OfInteger self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TColStd_HArray2OfInteger self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HArray2OfInteger_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TColStd_HArray2OfInteger self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TColStd_HArray2OfInteger self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HArray2OfInteger_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TColStd_HArray2OfInteger self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TColStd.Handle_TColStd_HArray2OfInteger_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TColStd_HArray2OfInteger self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray2OfInteger_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TColStd_HArray2OfInteger self)

        Increments the reference counter of this object


        """
        return _TColStd.Handle_TColStd_HArray2OfInteger_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TColStd_HArray2OfInteger self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray2OfInteger_DecrementRefCounter(self, *args)

Handle_TColStd_HArray2OfInteger_swigregister = _TColStd.Handle_TColStd_HArray2OfInteger_swigregister
Handle_TColStd_HArray2OfInteger_swigregister(Handle_TColStd_HArray2OfInteger)

def Handle_TColStd_HArray2OfInteger_DownCast(thing):
    return _TColStd.Handle_TColStd_HArray2OfInteger_DownCast(thing)
Handle_TColStd_HArray2OfInteger_DownCast = _TColStd.Handle_TColStd_HArray2OfInteger_DownCast

class TColStd_HArray2OfReal(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TColStd_HArray2OfReal
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TColStd_HArray2OfReal(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TColStd_HArray2OfReal self, Standard_Integer const theRowLow, Standard_Integer const theRowUpp, Standard_Integer const theColLow, Standard_Integer const theColUpp) -> TColStd_HArray2OfReal
        __init__(TColStd_HArray2OfReal self, Standard_Integer const theRowLow, Standard_Integer const theRowUpp, Standard_Integer const theColLow, Standard_Integer const theColUpp, TColStd_Array2OfReal::value_type const & theValue) -> TColStd_HArray2OfReal
        __init__(TColStd_HArray2OfReal self, NCollection_Array2_Standard_Real theOther) -> TColStd_HArray2OfReal

        :type theOther: OCC.wrapper.TColStd.TColStd_Array2OfReal

        """
        this = _TColStd.new_TColStd_HArray2OfReal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array2(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array2OfReal

        """
        res = _TColStd.TColStd_HArray2OfReal_Array2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray2(self, *args):
        """
        ChangeArray2(TColStd_HArray2OfReal self) -> NCollection_Array2_Standard_Real

        :rtype: OCC.wrapper.TColStd.TColStd_Array2OfReal

        """
        return _TColStd.TColStd_HArray2OfReal_ChangeArray2(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TColStd.TColStd_HArray2OfReal_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TColStd.TColStd_HArray2OfReal_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.TColStd_HArray2OfReal_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TColStd.delete_TColStd_HArray2OfReal
TColStd_HArray2OfReal_swigregister = _TColStd.TColStd_HArray2OfReal_swigregister
TColStd_HArray2OfReal_swigregister(TColStd_HArray2OfReal)

def TColStd_HArray2OfReal_get_type_name(*args):
    """
    TColStd_HArray2OfReal_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TColStd.TColStd_HArray2OfReal_get_type_name(*args)

def TColStd_HArray2OfReal_get_type_descriptor(*args):
    """
    TColStd_HArray2OfReal_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TColStd.TColStd_HArray2OfReal_get_type_descriptor(*args)

class TColStd_HArray1OfByte(NCollection_Array1_Standard_Byte, Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TColStd_HArray1OfByte
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TColStd_HArray1OfByte(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TColStd_HArray1OfByte self, Standard_Integer const theLower, Standard_Integer const theUpper) -> TColStd_HArray1OfByte
        __init__(TColStd_HArray1OfByte self, Standard_Integer const theLower, Standard_Integer const theUpper, TColStd_Array1OfByte::value_type const & theValue) -> TColStd_HArray1OfByte
        __init__(TColStd_HArray1OfByte self, NCollection_Array1_Standard_Byte theOther) -> TColStd_HArray1OfByte

        :type theOther: OCC.wrapper.TColStd.TColStd_Array1OfByte

        """
        this = _TColStd.new_TColStd_HArray1OfByte(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfByte

        """
        res = _TColStd.TColStd_HArray1OfByte_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(TColStd_HArray1OfByte self) -> NCollection_Array1_Standard_Byte

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfByte

        """
        return _TColStd.TColStd_HArray1OfByte_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TColStd.TColStd_HArray1OfByte_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TColStd.TColStd_HArray1OfByte_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.TColStd_HArray1OfByte_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TColStd.delete_TColStd_HArray1OfByte
TColStd_HArray1OfByte_swigregister = _TColStd.TColStd_HArray1OfByte_swigregister
TColStd_HArray1OfByte_swigregister(TColStd_HArray1OfByte)

def TColStd_HArray1OfByte_get_type_name(*args):
    """
    TColStd_HArray1OfByte_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TColStd.TColStd_HArray1OfByte_get_type_name(*args)

def TColStd_HArray1OfByte_get_type_descriptor(*args):
    """
    TColStd_HArray1OfByte_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TColStd.TColStd_HArray1OfByte_get_type_descriptor(*args)

class NCollection_Array2_Handle_Standard_Transient(object):
    """
    Purpose:   The class Array2 represents bi-dimensional arrays 
    of fixed size known at run time. 
    The ranges of indices are user defined.

    Warning:   Programs clients of such class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.LowerRow(); i <= A.UpperRow(); i++)
    for (j = A.LowerCol(); j <= A.UpperCol(); j++)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Purpose:   The class Array2 represents bi-dimensional arrays 
        of fixed size known at run time. 
        The ranges of indices are user defined.

        Warning:   Programs clients of such class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.LowerRow(); i <= A.UpperRow(); i++)
        for (j = A.LowerCol(); j <= A.UpperCol(); j++)
        """
        this = _TColStd.new_NCollection_Array2_Handle_Standard_Transient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array2_Handle_Standard_Transient self, Handle_Standard_Transient theValue)

        Initialise the values

        :type theValue: const TheItemType &

        """
        return _TColStd.NCollection_Array2_Handle_Standard_Transient_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array2_Handle_Standard_Transient self) -> Standard_Integer

        Size (number of items)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Handle_Standard_Transient_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array2_Handle_Standard_Transient self) -> Standard_Integer

        Length (number of items)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Handle_Standard_Transient_Length(self, *args)


    def RowLength(self, *args):
        """
        RowLength(NCollection_Array2_Handle_Standard_Transient self) -> Standard_Integer

        Returns length of the row, i.e. number of columns

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Handle_Standard_Transient_RowLength(self, *args)


    def ColLength(self, *args):
        """
        ColLength(NCollection_Array2_Handle_Standard_Transient self) -> Standard_Integer

        Returns length of the column, i.e. number of rows

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Handle_Standard_Transient_ColLength(self, *args)


    def LowerRow(self, *args):
        """
        LowerRow(NCollection_Array2_Handle_Standard_Transient self) -> Standard_Integer

        LowerRow

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Handle_Standard_Transient_LowerRow(self, *args)


    def UpperRow(self, *args):
        """
        UpperRow(NCollection_Array2_Handle_Standard_Transient self) -> Standard_Integer

        UpperRow

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Handle_Standard_Transient_UpperRow(self, *args)


    def LowerCol(self, *args):
        """
        LowerCol(NCollection_Array2_Handle_Standard_Transient self) -> Standard_Integer

        LowerCol

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Handle_Standard_Transient_LowerCol(self, *args)


    def UpperCol(self, *args):
        """
        UpperCol(NCollection_Array2_Handle_Standard_Transient self) -> Standard_Integer

        UpperCol

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Handle_Standard_Transient_UpperCol(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array2_Handle_Standard_Transient self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Array2_Handle_Standard_Transient_IsDeletable(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array2_Handle_Standard_Transient self, NCollection_Array2_Handle_Standard_Transient theOther) -> NCollection_Array2_Handle_Standard_Transient

        Assignment

        :type theOther: OCC.wrapper.NCollection.NCollection_Array2
        :rtype: OCC.wrapper.NCollection.NCollection_Array2

        """
        return _TColStd.NCollection_Array2_Handle_Standard_Transient_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array2_Handle_Standard_Transient self, NCollection_Array2_Handle_Standard_Transient theOther) -> NCollection_Array2_Handle_Standard_Transient

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Array2
        :rtype: OCC.wrapper.NCollection.NCollection_Array2

        """
        return _TColStd.NCollection_Array2_Handle_Standard_Transient_assign(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theRow: int
        :type theCol: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array2_Handle_Standard_Transient_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array2_Handle_Standard_Transient self, Standard_Integer const theRow, Standard_Integer const theCol) -> Handle_Standard_Transient

        Variable value access

        :type theRow: int
        :type theCol: int
        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Array2_Handle_Standard_Transient_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to ChangeValue

        :type theRow: int
        :type theCol: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array2_Handle_Standard_Transient___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array2_Handle_Standard_Transient self, Standard_Integer const theRow, Standard_Integer const theCol, Handle_Standard_Transient theItem)

        SetValue

        :type theRow: int
        :type theCol: int
        :type theItem: const TheItemType &

        """
        return _TColStd.NCollection_Array2_Handle_Standard_Transient_SetValue(self, *args)

    __swig_destroy__ = _TColStd.delete_NCollection_Array2_Handle_Standard_Transient
NCollection_Array2_Handle_Standard_Transient_swigregister = _TColStd.NCollection_Array2_Handle_Standard_Transient_swigregister
NCollection_Array2_Handle_Standard_Transient_swigregister(NCollection_Array2_Handle_Standard_Transient)


try:
	TColStd_Array2OfTransient = NCollection_Array2_Handle_Standard_Transient
except NameError:
	pass # does not exist, probably ignored

class TColStd_HArray1OfExtendedString(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TColStd_HArray1OfExtendedString
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TColStd_HArray1OfExtendedString(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TColStd_HArray1OfExtendedString self, Standard_Integer const theLower, Standard_Integer const theUpper) -> TColStd_HArray1OfExtendedString
        __init__(TColStd_HArray1OfExtendedString self, Standard_Integer const theLower, Standard_Integer const theUpper, TCollection_ExtendedString theValue) -> TColStd_HArray1OfExtendedString
        __init__(TColStd_HArray1OfExtendedString self, NCollection_Array1_TCollection_ExtendedString theOther) -> TColStd_HArray1OfExtendedString

        :type theOther: OCC.wrapper.TColStd.TColStd_Array1OfExtendedString

        """
        this = _TColStd.new_TColStd_HArray1OfExtendedString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfExtendedString

        """
        res = _TColStd.TColStd_HArray1OfExtendedString_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(TColStd_HArray1OfExtendedString self) -> NCollection_Array1_TCollection_ExtendedString

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfExtendedString

        """
        return _TColStd.TColStd_HArray1OfExtendedString_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TColStd.TColStd_HArray1OfExtendedString_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TColStd.TColStd_HArray1OfExtendedString_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.TColStd_HArray1OfExtendedString_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TColStd.delete_TColStd_HArray1OfExtendedString
TColStd_HArray1OfExtendedString_swigregister = _TColStd.TColStd_HArray1OfExtendedString_swigregister
TColStd_HArray1OfExtendedString_swigregister(TColStd_HArray1OfExtendedString)

def TColStd_HArray1OfExtendedString_get_type_name(*args):
    """
    TColStd_HArray1OfExtendedString_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TColStd.TColStd_HArray1OfExtendedString_get_type_name(*args)

def TColStd_HArray1OfExtendedString_get_type_descriptor(*args):
    """
    TColStd_HArray1OfExtendedString_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TColStd.TColStd_HArray1OfExtendedString_get_type_descriptor(*args)

class NCollection_Sequence_TCollection_AsciiString(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_TCollection_AsciiString self) -> NCollection_Sequence< TCollection_AsciiString >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _TColStd.NCollection_Sequence_TCollection_AsciiString_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_TCollection_AsciiString self) -> NCollection_Sequence< TCollection_AsciiString >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _TColStd.NCollection_Sequence_TCollection_AsciiString_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_TCollection_AsciiString self) -> NCollection_Sequence< TCollection_AsciiString >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Sequence_TCollection_AsciiString_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_TCollection_AsciiString self) -> NCollection_Sequence< TCollection_AsciiString >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Sequence_TCollection_AsciiString_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _TColStd.new_NCollection_Sequence_TCollection_AsciiString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_TCollection_AsciiString self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_TCollection_AsciiString_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_TCollection_AsciiString self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_TCollection_AsciiString_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_TCollection_AsciiString self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_TCollection_AsciiString_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_TCollection_AsciiString self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_TCollection_AsciiString_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_TCollection_AsciiString self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Sequence_TCollection_AsciiString_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_TCollection_AsciiString self)

        Reverse sequence


        """
        return _TColStd.NCollection_Sequence_TCollection_AsciiString_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_TCollection_AsciiString self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _TColStd.NCollection_Sequence_TCollection_AsciiString_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_Sequence_TCollection_AsciiString_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_TCollection_AsciiString self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_Sequence_TCollection_AsciiString_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_TCollection_AsciiString self, NCollection_Sequence_TCollection_AsciiString theOther) -> NCollection_Sequence_TCollection_AsciiString

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_TCollection_AsciiString_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_TCollection_AsciiString self, NCollection_Sequence_TCollection_AsciiString theOther) -> NCollection_Sequence_TCollection_AsciiString

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_TCollection_AsciiString_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_TCollection_AsciiString self, NCollection_Sequence< TCollection_AsciiString >::Iterator & thePosition)
        Remove(NCollection_Sequence_TCollection_AsciiString self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_TCollection_AsciiString self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _TColStd.NCollection_Sequence_TCollection_AsciiString_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_TCollection_AsciiString self, TCollection_AsciiString theItem)
        Append(NCollection_Sequence_TCollection_AsciiString self, NCollection_Sequence_TCollection_AsciiString theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_TCollection_AsciiString_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_TCollection_AsciiString self, TCollection_AsciiString theItem)
        Prepend(NCollection_Sequence_TCollection_AsciiString self, NCollection_Sequence_TCollection_AsciiString theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_TCollection_AsciiString_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_TCollection_AsciiString self, Standard_Integer const theIndex, TCollection_AsciiString theItem)
        InsertBefore(NCollection_Sequence_TCollection_AsciiString self, Standard_Integer const theIndex, NCollection_Sequence_TCollection_AsciiString theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_TCollection_AsciiString_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_TCollection_AsciiString self, NCollection_Sequence< TCollection_AsciiString >::Iterator & thePosition, TCollection_AsciiString theItem)
        InsertAfter(NCollection_Sequence_TCollection_AsciiString self, Standard_Integer const theIndex, NCollection_Sequence_TCollection_AsciiString theSeq)
        InsertAfter(NCollection_Sequence_TCollection_AsciiString self, Standard_Integer const theIndex, TCollection_AsciiString theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TColStd.NCollection_Sequence_TCollection_AsciiString_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_TCollection_AsciiString self, Standard_Integer const theIndex, NCollection_Sequence_TCollection_AsciiString theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_TCollection_AsciiString_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_TCollection_AsciiString_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_TCollection_AsciiString self) -> TCollection_AsciiString

        First item access

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Sequence_TCollection_AsciiString_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_TCollection_AsciiString_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_TCollection_AsciiString self) -> TCollection_AsciiString

        Last item access

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Sequence_TCollection_AsciiString_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_TCollection_AsciiString_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_TCollection_AsciiString self, Standard_Integer const theIndex) -> TCollection_AsciiString

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Sequence_TCollection_AsciiString_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_TCollection_AsciiString___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_TCollection_AsciiString self, Standard_Integer const theIndex, TCollection_AsciiString theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TColStd.NCollection_Sequence_TCollection_AsciiString_SetValue(self, *args)


    def __iter__(self):
        return _TColStd.NCollection_Sequence_TCollection_AsciiString___iter__(self)
    __swig_destroy__ = _TColStd.delete_NCollection_Sequence_TCollection_AsciiString
NCollection_Sequence_TCollection_AsciiString_swigregister = _TColStd.NCollection_Sequence_TCollection_AsciiString_swigregister
NCollection_Sequence_TCollection_AsciiString_swigregister(NCollection_Sequence_TCollection_AsciiString)

def NCollection_Sequence_TCollection_AsciiString_delNode(*args):
    """
    NCollection_Sequence_TCollection_AsciiString_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _TColStd.NCollection_Sequence_TCollection_AsciiString_delNode(*args)

class NCollection_Sequence_TCollection_AsciiString_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TColStd.new_NCollection_Sequence_TCollection_AsciiString_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TColStd.delete_NCollection_Sequence_TCollection_AsciiString_IteratorHelper

    def __next__(self):
        return _TColStd.NCollection_Sequence_TCollection_AsciiString_IteratorHelper___next__(self)
NCollection_Sequence_TCollection_AsciiString_IteratorHelper_swigregister = _TColStd.NCollection_Sequence_TCollection_AsciiString_IteratorHelper_swigregister
NCollection_Sequence_TCollection_AsciiString_IteratorHelper_swigregister(NCollection_Sequence_TCollection_AsciiString_IteratorHelper)


try:
	TColStd_SequenceOfAsciiString = NCollection_Sequence_TCollection_AsciiString
except NameError:
	pass # does not exist, probably ignored

class TColStd_HPackedMapOfInteger(Standard.Standard_Transient):
    """Extension of TColStd_PackedMapOfInteger class to be manipulated by handle."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TColStd_HPackedMapOfInteger
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TColStd_HPackedMapOfInteger(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TColStd_HPackedMapOfInteger self, Standard_Integer const NbBuckets=1) -> TColStd_HPackedMapOfInteger
        __init__(TColStd_HPackedMapOfInteger self, TColStd_PackedMapOfInteger theOther) -> TColStd_HPackedMapOfInteger

        :type theOther: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        this = _TColStd.new_TColStd_HPackedMapOfInteger(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Map(self, *args):
        """
        Access to the map

        :rtype: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        res = _TColStd.TColStd_HPackedMapOfInteger_Map(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeMap(self, *args):
        """
        ChangeMap(TColStd_HPackedMapOfInteger self) -> TColStd_PackedMapOfInteger

        Access to the map for modification

        :rtype: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        return _TColStd.TColStd_HPackedMapOfInteger_ChangeMap(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TColStd.TColStd_HPackedMapOfInteger_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TColStd.TColStd_HPackedMapOfInteger_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.TColStd_HPackedMapOfInteger_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TColStd.delete_TColStd_HPackedMapOfInteger
TColStd_HPackedMapOfInteger_swigregister = _TColStd.TColStd_HPackedMapOfInteger_swigregister
TColStd_HPackedMapOfInteger_swigregister(TColStd_HPackedMapOfInteger)

def TColStd_HPackedMapOfInteger_get_type_name(*args):
    """
    TColStd_HPackedMapOfInteger_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TColStd.TColStd_HPackedMapOfInteger_get_type_name(*args)

def TColStd_HPackedMapOfInteger_get_type_descriptor(*args):
    """
    TColStd_HPackedMapOfInteger_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TColStd.TColStd_HPackedMapOfInteger_get_type_descriptor(*args)

class TColStd_HSequenceOfAsciiString(NCollection_Sequence_TCollection_AsciiString, Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TColStd_HSequenceOfAsciiString
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TColStd_HSequenceOfAsciiString(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TColStd_HSequenceOfAsciiString self) -> TColStd_HSequenceOfAsciiString
        __init__(TColStd_HSequenceOfAsciiString self, NCollection_Sequence_TCollection_AsciiString theOther) -> TColStd_HSequenceOfAsciiString

        :type theOther: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString

        """
        this = _TColStd.new_TColStd_HSequenceOfAsciiString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString

        """
        res = _TColStd.TColStd_HSequenceOfAsciiString_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(TColStd_HSequenceOfAsciiString self, TCollection_AsciiString theItem)
        Append(TColStd_HSequenceOfAsciiString self, NCollection_Sequence_TCollection_AsciiString theSequence)

        :type theSequence: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString

        """
        return _TColStd.TColStd_HSequenceOfAsciiString_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(TColStd_HSequenceOfAsciiString self) -> NCollection_Sequence_TCollection_AsciiString

        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString

        """
        return _TColStd.TColStd_HSequenceOfAsciiString_ChangeSequence(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TColStd.TColStd_HSequenceOfAsciiString_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TColStd.TColStd_HSequenceOfAsciiString_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.TColStd_HSequenceOfAsciiString_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TColStd.delete_TColStd_HSequenceOfAsciiString
TColStd_HSequenceOfAsciiString_swigregister = _TColStd.TColStd_HSequenceOfAsciiString_swigregister
TColStd_HSequenceOfAsciiString_swigregister(TColStd_HSequenceOfAsciiString)

def TColStd_HSequenceOfAsciiString_get_type_name(*args):
    """
    TColStd_HSequenceOfAsciiString_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TColStd.TColStd_HSequenceOfAsciiString_get_type_name(*args)

def TColStd_HSequenceOfAsciiString_get_type_descriptor(*args):
    """
    TColStd_HSequenceOfAsciiString_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TColStd.TColStd_HSequenceOfAsciiString_get_type_descriptor(*args)

class Handle_TColStd_HArray1OfByte(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TColStd_HArray1OfByte self)

        Nullify the handle


        """
        return _TColStd.Handle_TColStd_HArray1OfByte_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TColStd_HArray1OfByte self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TColStd.Handle_TColStd_HArray1OfByte_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TColStd_HArray1OfByte self, TColStd_HArray1OfByte thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TColStd.Handle_TColStd_HArray1OfByte_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TColStd_HArray1OfByte self, Handle_TColStd_HArray1OfByte theHandle) -> Handle_TColStd_HArray1OfByte
        assign(Handle_TColStd_HArray1OfByte self, TColStd_HArray1OfByte thePtr) -> Handle_TColStd_HArray1OfByte
        assign(Handle_TColStd_HArray1OfByte self, Handle_TColStd_HArray1OfByte theHandle) -> Handle_TColStd_HArray1OfByte

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TColStd.Handle_TColStd_HArray1OfByte_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TColStd_HArray1OfByte self) -> TColStd_HArray1OfByte

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HArray1OfByte_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TColStd_HArray1OfByte self) -> TColStd_HArray1OfByte

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HArray1OfByte___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TColStd_HArray1OfByte self) -> TColStd_HArray1OfByte

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TColStd.Handle_TColStd_HArray1OfByte___ref__(self, *args)


    def __hash__(self):
        return _TColStd.Handle_TColStd_HArray1OfByte___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TColStd.Handle_TColStd_HArray1OfByte___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TColStd.new_Handle_TColStd_HArray1OfByte(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TColStd.Handle_TColStd_HArray1OfByte_DownCast)
    __swig_destroy__ = _TColStd.delete_Handle_TColStd_HArray1OfByte

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfByte

        """
        res = _TColStd.Handle_TColStd_HArray1OfByte_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_TColStd_HArray1OfByte self) -> NCollection_Array1_Standard_Byte

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfByte

        """
        return _TColStd.Handle_TColStd_HArray1OfByte_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TColStd_HArray1OfByte self) -> char const *

        :rtype: const char *

        """
        return _TColStd.Handle_TColStd_HArray1OfByte_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HArray1OfByte_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HArray1OfByte_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def begin(self, *args):
        """
        begin(Handle_TColStd_HArray1OfByte self) -> NCollection_Array1< Standard_Byte >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _TColStd.Handle_TColStd_HArray1OfByte_begin(self, *args)


    def end(self, *args):
        """
        end(Handle_TColStd_HArray1OfByte self) -> NCollection_Array1< Standard_Byte >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _TColStd.Handle_TColStd_HArray1OfByte_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(Handle_TColStd_HArray1OfByte self) -> NCollection_Array1< Standard_Byte >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _TColStd.Handle_TColStd_HArray1OfByte_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(Handle_TColStd_HArray1OfByte self) -> NCollection_Array1< Standard_Byte >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _TColStd.Handle_TColStd_HArray1OfByte_cend(self, *args)


    def Init(self, *args):
        """
        Init(Handle_TColStd_HArray1OfByte self, unsigned char const & theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _TColStd.Handle_TColStd_HArray1OfByte_Init(self, *args)


    def Size(self, *args):
        """
        Size(Handle_TColStd_HArray1OfByte self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray1OfByte_Size(self, *args)


    def Length(self, *args):
        """
        Length(Handle_TColStd_HArray1OfByte self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray1OfByte_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_TColStd_HArray1OfByte self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HArray1OfByte_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(Handle_TColStd_HArray1OfByte self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray1OfByte_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(Handle_TColStd_HArray1OfByte self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray1OfByte_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(Handle_TColStd_HArray1OfByte self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HArray1OfByte_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(Handle_TColStd_HArray1OfByte self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HArray1OfByte_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(Handle_TColStd_HArray1OfByte self, NCollection_Array1_Standard_Byte theOther) -> NCollection_Array1_Standard_Byte

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TColStd.Handle_TColStd_HArray1OfByte_Assign(self, *args)


    def Move(self, *args):
        """
        Move(Handle_TColStd_HArray1OfByte self, NCollection_Array1_Standard_Byte theOther) -> NCollection_Array1_Standard_Byte

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TColStd.Handle_TColStd_HArray1OfByte_Move(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _TColStd.Handle_TColStd_HArray1OfByte_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(Handle_TColStd_HArray1OfByte self) -> unsigned char &

        @return first element

        :rtype: TheItemType &

        """
        return _TColStd.Handle_TColStd_HArray1OfByte_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _TColStd.Handle_TColStd_HArray1OfByte_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(Handle_TColStd_HArray1OfByte self) -> unsigned char &

        @return last element

        :rtype: TheItemType &

        """
        return _TColStd.Handle_TColStd_HArray1OfByte_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.Handle_TColStd_HArray1OfByte_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.Handle_TColStd_HArray1OfByte___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.Handle_TColStd_HArray1OfByte_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(Handle_TColStd_HArray1OfByte self, Standard_Integer const theIndex) -> unsigned char &

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TColStd.Handle_TColStd_HArray1OfByte_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_TColStd_HArray1OfByte self, Standard_Integer const theIndex, unsigned char const & theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TColStd.Handle_TColStd_HArray1OfByte_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(Handle_TColStd_HArray1OfByte self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _TColStd.Handle_TColStd_HArray1OfByte_Resize(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TColStd_HArray1OfByte self)

        Memory deallocator for transient classes


        """
        return _TColStd.Handle_TColStd_HArray1OfByte_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TColStd_HArray1OfByte self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TColStd_HArray1OfByte self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HArray1OfByte_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TColStd_HArray1OfByte self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TColStd_HArray1OfByte self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HArray1OfByte_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TColStd_HArray1OfByte self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TColStd.Handle_TColStd_HArray1OfByte_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TColStd_HArray1OfByte self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray1OfByte_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TColStd_HArray1OfByte self)

        Increments the reference counter of this object


        """
        return _TColStd.Handle_TColStd_HArray1OfByte_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TColStd_HArray1OfByte self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray1OfByte_DecrementRefCounter(self, *args)

Handle_TColStd_HArray1OfByte_swigregister = _TColStd.Handle_TColStd_HArray1OfByte_swigregister
Handle_TColStd_HArray1OfByte_swigregister(Handle_TColStd_HArray1OfByte)

def Handle_TColStd_HArray1OfByte_DownCast(thing):
    return _TColStd.Handle_TColStd_HArray1OfByte_DownCast(thing)
Handle_TColStd_HArray1OfByte_DownCast = _TColStd.Handle_TColStd_HArray1OfByte_DownCast

class TColStd_HArray1OfReal(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TColStd_HArray1OfReal
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TColStd_HArray1OfReal(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TColStd_HArray1OfReal self, Standard_Integer const theLower, Standard_Integer const theUpper) -> TColStd_HArray1OfReal
        __init__(TColStd_HArray1OfReal self, Standard_Integer const theLower, Standard_Integer const theUpper, TColStd_Array1OfReal::value_type const & theValue) -> TColStd_HArray1OfReal
        __init__(TColStd_HArray1OfReal self, NCollection_Array1_Standard_Real theOther) -> TColStd_HArray1OfReal

        :type theOther: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        this = _TColStd.new_TColStd_HArray1OfReal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _TColStd.TColStd_HArray1OfReal_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(TColStd_HArray1OfReal self) -> NCollection_Array1_Standard_Real

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _TColStd.TColStd_HArray1OfReal_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TColStd.TColStd_HArray1OfReal_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TColStd.TColStd_HArray1OfReal_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.TColStd_HArray1OfReal_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TColStd.delete_TColStd_HArray1OfReal
TColStd_HArray1OfReal_swigregister = _TColStd.TColStd_HArray1OfReal_swigregister
TColStd_HArray1OfReal_swigregister(TColStd_HArray1OfReal)

def TColStd_HArray1OfReal_get_type_name(*args):
    """
    TColStd_HArray1OfReal_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TColStd.TColStd_HArray1OfReal_get_type_name(*args)

def TColStd_HArray1OfReal_get_type_descriptor(*args):
    """
    TColStd_HArray1OfReal_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TColStd.TColStd_HArray1OfReal_get_type_descriptor(*args)

class NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self) -> NCollection_IndexedDataMap< opencascade::handle< Standard_Transient >,opencascade::handle< Standard_Transient >,TColStd_MapTransientHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TColStd.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self) -> NCollection_IndexedDataMap< opencascade::handle< Standard_Transient >,opencascade::handle< Standard_Transient >,TColStd_MapTransientHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TColStd.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self) -> NCollection_IndexedDataMap< opencascade::handle< Standard_Transient >,opencascade::handle< Standard_Transient >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self) -> NCollection_IndexedDataMap< opencascade::handle< Standard_Transient >,opencascade::handle< Standard_Transient >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _TColStd.new_NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self, NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TColStd.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self, NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher theOther) -> NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TColStd.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self, NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher theOther) -> NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TColStd.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TColStd.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey1, Handle_Standard_Transient theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self, Standard_Integer const theIndex, Handle_Standard_Transient theKey1, Handle_Standard_Transient theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _TColStd.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _TColStd.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self)

        RemoveLast


        """
        return _TColStd.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _TColStd.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _TColStd.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _TColStd.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self, Standard_Integer const theIndex) -> Handle_Standard_Transient

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TColStd.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey1) -> Handle_Standard_Transient

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TColStd.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey1) -> Handle_Standard_Transient

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TColStd.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey1) -> Handle_Standard_Transient

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TColStd.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_Size(self, *args)


    def __iter__(self):
        return _TColStd.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher___iter__(self)
    __swig_destroy__ = _TColStd.delete_NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher
NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_swigregister = _TColStd.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_swigregister
NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_swigregister(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher)

class NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TColStd.new_NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TColStd.delete_NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_IteratorHelper

    def __next__(self):
        return _TColStd.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_IteratorHelper___next__(self)
NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_IteratorHelper_swigregister = _TColStd.NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_IteratorHelper_swigregister
NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_IteratorHelper_swigregister(NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_IteratorHelper)


try:
	TColStd_IndexedDataMapOfTransientTransient = NCollection_IndexedDataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored

class TColStd_HArray1OfTransient(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TColStd_HArray1OfTransient
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TColStd_HArray1OfTransient(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TColStd_HArray1OfTransient self, Standard_Integer const theLower, Standard_Integer const theUpper) -> TColStd_HArray1OfTransient
        __init__(TColStd_HArray1OfTransient self, Standard_Integer const theLower, Standard_Integer const theUpper, Handle_Standard_Transient theValue) -> TColStd_HArray1OfTransient
        __init__(TColStd_HArray1OfTransient self, NCollection_Array1_Handle_Standard_Transient theOther) -> TColStd_HArray1OfTransient

        :type theOther: OCC.wrapper.TColStd.TColStd_Array1OfTransient

        """
        this = _TColStd.new_TColStd_HArray1OfTransient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfTransient

        """
        res = _TColStd.TColStd_HArray1OfTransient_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(TColStd_HArray1OfTransient self) -> NCollection_Array1_Handle_Standard_Transient

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfTransient

        """
        return _TColStd.TColStd_HArray1OfTransient_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TColStd.TColStd_HArray1OfTransient_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TColStd.TColStd_HArray1OfTransient_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.TColStd_HArray1OfTransient_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TColStd.delete_TColStd_HArray1OfTransient
TColStd_HArray1OfTransient_swigregister = _TColStd.TColStd_HArray1OfTransient_swigregister
TColStd_HArray1OfTransient_swigregister(TColStd_HArray1OfTransient)

def TColStd_HArray1OfTransient_get_type_name(*args):
    """
    TColStd_HArray1OfTransient_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TColStd.TColStd_HArray1OfTransient_get_type_name(*args)

def TColStd_HArray1OfTransient_get_type_descriptor(*args):
    """
    TColStd_HArray1OfTransient_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TColStd.TColStd_HArray1OfTransient_get_type_descriptor(*args)

class TColStd_HSequenceOfHExtendedString(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TColStd_HSequenceOfHExtendedString
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TColStd_HSequenceOfHExtendedString(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TColStd_HSequenceOfHExtendedString self) -> TColStd_HSequenceOfHExtendedString
        __init__(TColStd_HSequenceOfHExtendedString self, NCollection_Sequence_Handle_TCollection_HExtendedString theOther) -> TColStd_HSequenceOfHExtendedString

        :type theOther: OCC.wrapper.TColStd.TColStd_SequenceOfHExtendedString

        """
        this = _TColStd.new_TColStd_HSequenceOfHExtendedString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfHExtendedString

        """
        res = _TColStd.TColStd_HSequenceOfHExtendedString_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(TColStd_HSequenceOfHExtendedString self, Handle_TCollection_HExtendedString theItem)
        Append(TColStd_HSequenceOfHExtendedString self, NCollection_Sequence_Handle_TCollection_HExtendedString theSequence)

        :type theSequence: OCC.wrapper.TColStd.TColStd_SequenceOfHExtendedString

        """
        return _TColStd.TColStd_HSequenceOfHExtendedString_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(TColStd_HSequenceOfHExtendedString self) -> NCollection_Sequence_Handle_TCollection_HExtendedString

        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfHExtendedString

        """
        return _TColStd.TColStd_HSequenceOfHExtendedString_ChangeSequence(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TColStd.TColStd_HSequenceOfHExtendedString_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TColStd.TColStd_HSequenceOfHExtendedString_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.TColStd_HSequenceOfHExtendedString_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TColStd.delete_TColStd_HSequenceOfHExtendedString
TColStd_HSequenceOfHExtendedString_swigregister = _TColStd.TColStd_HSequenceOfHExtendedString_swigregister
TColStd_HSequenceOfHExtendedString_swigregister(TColStd_HSequenceOfHExtendedString)

def TColStd_HSequenceOfHExtendedString_get_type_name(*args):
    """
    TColStd_HSequenceOfHExtendedString_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TColStd.TColStd_HSequenceOfHExtendedString_get_type_name(*args)

def TColStd_HSequenceOfHExtendedString_get_type_descriptor(*args):
    """
    TColStd_HSequenceOfHExtendedString_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TColStd.TColStd_HSequenceOfHExtendedString_get_type_descriptor(*args)

class Handle_TColStd_HPackedMapOfInteger(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TColStd_HPackedMapOfInteger self)

        Nullify the handle


        """
        return _TColStd.Handle_TColStd_HPackedMapOfInteger_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TColStd_HPackedMapOfInteger self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TColStd.Handle_TColStd_HPackedMapOfInteger_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TColStd_HPackedMapOfInteger self, TColStd_HPackedMapOfInteger thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TColStd.Handle_TColStd_HPackedMapOfInteger_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TColStd_HPackedMapOfInteger self, Handle_TColStd_HPackedMapOfInteger theHandle) -> Handle_TColStd_HPackedMapOfInteger
        assign(Handle_TColStd_HPackedMapOfInteger self, TColStd_HPackedMapOfInteger thePtr) -> Handle_TColStd_HPackedMapOfInteger
        assign(Handle_TColStd_HPackedMapOfInteger self, Handle_TColStd_HPackedMapOfInteger theHandle) -> Handle_TColStd_HPackedMapOfInteger

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TColStd.Handle_TColStd_HPackedMapOfInteger_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TColStd_HPackedMapOfInteger self) -> TColStd_HPackedMapOfInteger

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HPackedMapOfInteger_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TColStd_HPackedMapOfInteger self) -> TColStd_HPackedMapOfInteger

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HPackedMapOfInteger___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TColStd_HPackedMapOfInteger self) -> TColStd_HPackedMapOfInteger

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TColStd.Handle_TColStd_HPackedMapOfInteger___ref__(self, *args)


    def __hash__(self):
        return _TColStd.Handle_TColStd_HPackedMapOfInteger___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TColStd.Handle_TColStd_HPackedMapOfInteger___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TColStd.new_Handle_TColStd_HPackedMapOfInteger(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TColStd.Handle_TColStd_HPackedMapOfInteger_DownCast)
    __swig_destroy__ = _TColStd.delete_Handle_TColStd_HPackedMapOfInteger

    def Map(self, *args):
        """
        Access to the map

        :rtype: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        res = _TColStd.Handle_TColStd_HPackedMapOfInteger_Map(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeMap(self, *args):
        """
        ChangeMap(Handle_TColStd_HPackedMapOfInteger self) -> TColStd_PackedMapOfInteger

        Access to the map for modification

        :rtype: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        return _TColStd.Handle_TColStd_HPackedMapOfInteger_ChangeMap(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TColStd_HPackedMapOfInteger self) -> char const *

        :rtype: const char *

        """
        return _TColStd.Handle_TColStd_HPackedMapOfInteger_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HPackedMapOfInteger_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HPackedMapOfInteger_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TColStd_HPackedMapOfInteger self)

        Memory deallocator for transient classes


        """
        return _TColStd.Handle_TColStd_HPackedMapOfInteger_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TColStd_HPackedMapOfInteger self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TColStd_HPackedMapOfInteger self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HPackedMapOfInteger_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TColStd_HPackedMapOfInteger self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TColStd_HPackedMapOfInteger self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HPackedMapOfInteger_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TColStd_HPackedMapOfInteger self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TColStd.Handle_TColStd_HPackedMapOfInteger_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TColStd_HPackedMapOfInteger self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HPackedMapOfInteger_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TColStd_HPackedMapOfInteger self)

        Increments the reference counter of this object


        """
        return _TColStd.Handle_TColStd_HPackedMapOfInteger_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TColStd_HPackedMapOfInteger self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HPackedMapOfInteger_DecrementRefCounter(self, *args)

Handle_TColStd_HPackedMapOfInteger_swigregister = _TColStd.Handle_TColStd_HPackedMapOfInteger_swigregister
Handle_TColStd_HPackedMapOfInteger_swigregister(Handle_TColStd_HPackedMapOfInteger)

def Handle_TColStd_HPackedMapOfInteger_DownCast(thing):
    return _TColStd.Handle_TColStd_HPackedMapOfInteger_DownCast(thing)
Handle_TColStd_HPackedMapOfInteger_DownCast = _TColStd.Handle_TColStd_HPackedMapOfInteger_DownCast

class TColStd_HSequenceOfTransient(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TColStd_HSequenceOfTransient
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TColStd_HSequenceOfTransient(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TColStd_HSequenceOfTransient self) -> TColStd_HSequenceOfTransient
        __init__(TColStd_HSequenceOfTransient self, NCollection_Sequence_Handle_Standard_Transient theOther) -> TColStd_HSequenceOfTransient

        :type theOther: OCC.wrapper.TColStd.TColStd_SequenceOfTransient

        """
        this = _TColStd.new_TColStd_HSequenceOfTransient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfTransient

        """
        res = _TColStd.TColStd_HSequenceOfTransient_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(TColStd_HSequenceOfTransient self, Handle_Standard_Transient theItem)
        Append(TColStd_HSequenceOfTransient self, NCollection_Sequence_Handle_Standard_Transient theSequence)

        :type theSequence: OCC.wrapper.TColStd.TColStd_SequenceOfTransient

        """
        return _TColStd.TColStd_HSequenceOfTransient_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(TColStd_HSequenceOfTransient self) -> NCollection_Sequence_Handle_Standard_Transient

        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfTransient

        """
        return _TColStd.TColStd_HSequenceOfTransient_ChangeSequence(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TColStd.TColStd_HSequenceOfTransient_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TColStd.TColStd_HSequenceOfTransient_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.TColStd_HSequenceOfTransient_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TColStd.delete_TColStd_HSequenceOfTransient
TColStd_HSequenceOfTransient_swigregister = _TColStd.TColStd_HSequenceOfTransient_swigregister
TColStd_HSequenceOfTransient_swigregister(TColStd_HSequenceOfTransient)

def TColStd_HSequenceOfTransient_get_type_name(*args):
    """
    TColStd_HSequenceOfTransient_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TColStd.TColStd_HSequenceOfTransient_get_type_name(*args)

def TColStd_HSequenceOfTransient_get_type_descriptor(*args):
    """
    TColStd_HSequenceOfTransient_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TColStd.TColStd_HSequenceOfTransient_get_type_descriptor(*args)

class TColStd_HSequenceOfHAsciiString(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TColStd_HSequenceOfHAsciiString
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TColStd_HSequenceOfHAsciiString(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TColStd_HSequenceOfHAsciiString self) -> TColStd_HSequenceOfHAsciiString
        __init__(TColStd_HSequenceOfHAsciiString self, NCollection_Sequence_Handle_TCollection_HAsciiString theOther) -> TColStd_HSequenceOfHAsciiString

        :type theOther: OCC.wrapper.TColStd.TColStd_SequenceOfHAsciiString

        """
        this = _TColStd.new_TColStd_HSequenceOfHAsciiString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfHAsciiString

        """
        res = _TColStd.TColStd_HSequenceOfHAsciiString_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(TColStd_HSequenceOfHAsciiString self, Handle_TCollection_HAsciiString theItem)
        Append(TColStd_HSequenceOfHAsciiString self, NCollection_Sequence_Handle_TCollection_HAsciiString theSequence)

        :type theSequence: OCC.wrapper.TColStd.TColStd_SequenceOfHAsciiString

        """
        return _TColStd.TColStd_HSequenceOfHAsciiString_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(TColStd_HSequenceOfHAsciiString self) -> NCollection_Sequence_Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfHAsciiString

        """
        return _TColStd.TColStd_HSequenceOfHAsciiString_ChangeSequence(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TColStd.TColStd_HSequenceOfHAsciiString_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TColStd.TColStd_HSequenceOfHAsciiString_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.TColStd_HSequenceOfHAsciiString_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TColStd.delete_TColStd_HSequenceOfHAsciiString
TColStd_HSequenceOfHAsciiString_swigregister = _TColStd.TColStd_HSequenceOfHAsciiString_swigregister
TColStd_HSequenceOfHAsciiString_swigregister(TColStd_HSequenceOfHAsciiString)

def TColStd_HSequenceOfHAsciiString_get_type_name(*args):
    """
    TColStd_HSequenceOfHAsciiString_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TColStd.TColStd_HSequenceOfHAsciiString_get_type_name(*args)

def TColStd_HSequenceOfHAsciiString_get_type_descriptor(*args):
    """
    TColStd_HSequenceOfHAsciiString_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TColStd.TColStd_HSequenceOfHAsciiString_get_type_descriptor(*args)

class TColStd_HArray2OfTransient(NCollection_Array2_Handle_Standard_Transient, Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TColStd_HArray2OfTransient
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TColStd_HArray2OfTransient(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TColStd_HArray2OfTransient self, Standard_Integer const theRowLow, Standard_Integer const theRowUpp, Standard_Integer const theColLow, Standard_Integer const theColUpp) -> TColStd_HArray2OfTransient
        __init__(TColStd_HArray2OfTransient self, Standard_Integer const theRowLow, Standard_Integer const theRowUpp, Standard_Integer const theColLow, Standard_Integer const theColUpp, Handle_Standard_Transient theValue) -> TColStd_HArray2OfTransient
        __init__(TColStd_HArray2OfTransient self, NCollection_Array2_Handle_Standard_Transient theOther) -> TColStd_HArray2OfTransient

        :type theOther: OCC.wrapper.TColStd.TColStd_Array2OfTransient

        """
        this = _TColStd.new_TColStd_HArray2OfTransient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array2(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array2OfTransient

        """
        res = _TColStd.TColStd_HArray2OfTransient_Array2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray2(self, *args):
        """
        ChangeArray2(TColStd_HArray2OfTransient self) -> NCollection_Array2_Handle_Standard_Transient

        :rtype: OCC.wrapper.TColStd.TColStd_Array2OfTransient

        """
        return _TColStd.TColStd_HArray2OfTransient_ChangeArray2(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TColStd.TColStd_HArray2OfTransient_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TColStd.TColStd_HArray2OfTransient_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.TColStd_HArray2OfTransient_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TColStd.delete_TColStd_HArray2OfTransient
TColStd_HArray2OfTransient_swigregister = _TColStd.TColStd_HArray2OfTransient_swigregister
TColStd_HArray2OfTransient_swigregister(TColStd_HArray2OfTransient)

def TColStd_HArray2OfTransient_get_type_name(*args):
    """
    TColStd_HArray2OfTransient_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TColStd.TColStd_HArray2OfTransient_get_type_name(*args)

def TColStd_HArray2OfTransient_get_type_descriptor(*args):
    """
    TColStd_HArray2OfTransient_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TColStd.TColStd_HArray2OfTransient_get_type_descriptor(*args)

class TColStd_HSequenceOfReal(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TColStd_HSequenceOfReal
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TColStd_HSequenceOfReal(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TColStd_HSequenceOfReal self) -> TColStd_HSequenceOfReal
        __init__(TColStd_HSequenceOfReal self, NCollection_Sequence_Standard_Real theOther) -> TColStd_HSequenceOfReal

        :type theOther: OCC.wrapper.TColStd.TColStd_SequenceOfReal

        """
        this = _TColStd.new_TColStd_HSequenceOfReal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfReal

        """
        res = _TColStd.TColStd_HSequenceOfReal_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(TColStd_HSequenceOfReal self, TColStd_SequenceOfReal::value_type const & theItem)
        Append(TColStd_HSequenceOfReal self, NCollection_Sequence_Standard_Real theSequence)

        :type theSequence: OCC.wrapper.TColStd.TColStd_SequenceOfReal

        """
        return _TColStd.TColStd_HSequenceOfReal_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(TColStd_HSequenceOfReal self) -> NCollection_Sequence_Standard_Real

        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfReal

        """
        return _TColStd.TColStd_HSequenceOfReal_ChangeSequence(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TColStd.TColStd_HSequenceOfReal_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TColStd.TColStd_HSequenceOfReal_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.TColStd_HSequenceOfReal_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TColStd.delete_TColStd_HSequenceOfReal
TColStd_HSequenceOfReal_swigregister = _TColStd.TColStd_HSequenceOfReal_swigregister
TColStd_HSequenceOfReal_swigregister(TColStd_HSequenceOfReal)

def TColStd_HSequenceOfReal_get_type_name(*args):
    """
    TColStd_HSequenceOfReal_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TColStd.TColStd_HSequenceOfReal_get_type_name(*args)

def TColStd_HSequenceOfReal_get_type_descriptor(*args):
    """
    TColStd_HSequenceOfReal_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TColStd.TColStd_HSequenceOfReal_get_type_descriptor(*args)

class TColStd_HArray2OfBoolean(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TColStd_HArray2OfBoolean
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TColStd_HArray2OfBoolean(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TColStd_HArray2OfBoolean self, Standard_Integer const theRowLow, Standard_Integer const theRowUpp, Standard_Integer const theColLow, Standard_Integer const theColUpp) -> TColStd_HArray2OfBoolean
        __init__(TColStd_HArray2OfBoolean self, Standard_Integer const theRowLow, Standard_Integer const theRowUpp, Standard_Integer const theColLow, Standard_Integer const theColUpp, TColStd_Array2OfBoolean::value_type const & theValue) -> TColStd_HArray2OfBoolean
        __init__(TColStd_HArray2OfBoolean self, NCollection_Array2_Standard_Boolean theOther) -> TColStd_HArray2OfBoolean

        :type theOther: OCC.wrapper.TColStd.TColStd_Array2OfBoolean

        """
        this = _TColStd.new_TColStd_HArray2OfBoolean(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array2(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array2OfBoolean

        """
        res = _TColStd.TColStd_HArray2OfBoolean_Array2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray2(self, *args):
        """
        ChangeArray2(TColStd_HArray2OfBoolean self) -> NCollection_Array2_Standard_Boolean

        :rtype: OCC.wrapper.TColStd.TColStd_Array2OfBoolean

        """
        return _TColStd.TColStd_HArray2OfBoolean_ChangeArray2(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TColStd.TColStd_HArray2OfBoolean_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TColStd.TColStd_HArray2OfBoolean_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.TColStd_HArray2OfBoolean_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TColStd.delete_TColStd_HArray2OfBoolean
TColStd_HArray2OfBoolean_swigregister = _TColStd.TColStd_HArray2OfBoolean_swigregister
TColStd_HArray2OfBoolean_swigregister(TColStd_HArray2OfBoolean)

def TColStd_HArray2OfBoolean_get_type_name(*args):
    """
    TColStd_HArray2OfBoolean_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TColStd.TColStd_HArray2OfBoolean_get_type_name(*args)

def TColStd_HArray2OfBoolean_get_type_descriptor(*args):
    """
    TColStd_HArray2OfBoolean_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TColStd.TColStd_HArray2OfBoolean_get_type_descriptor(*args)

class Handle_TColStd_HArray1OfReal(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TColStd_HArray1OfReal self)

        Nullify the handle


        """
        return _TColStd.Handle_TColStd_HArray1OfReal_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TColStd_HArray1OfReal self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TColStd.Handle_TColStd_HArray1OfReal_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TColStd_HArray1OfReal self, TColStd_HArray1OfReal thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TColStd.Handle_TColStd_HArray1OfReal_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TColStd_HArray1OfReal self, Handle_TColStd_HArray1OfReal theHandle) -> Handle_TColStd_HArray1OfReal
        assign(Handle_TColStd_HArray1OfReal self, TColStd_HArray1OfReal thePtr) -> Handle_TColStd_HArray1OfReal
        assign(Handle_TColStd_HArray1OfReal self, Handle_TColStd_HArray1OfReal theHandle) -> Handle_TColStd_HArray1OfReal

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TColStd.Handle_TColStd_HArray1OfReal_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TColStd_HArray1OfReal self) -> TColStd_HArray1OfReal

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HArray1OfReal_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TColStd_HArray1OfReal self) -> TColStd_HArray1OfReal

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HArray1OfReal___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TColStd_HArray1OfReal self) -> TColStd_HArray1OfReal

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TColStd.Handle_TColStd_HArray1OfReal___ref__(self, *args)


    def __hash__(self):
        return _TColStd.Handle_TColStd_HArray1OfReal___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TColStd.Handle_TColStd_HArray1OfReal___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TColStd.new_Handle_TColStd_HArray1OfReal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TColStd.Handle_TColStd_HArray1OfReal_DownCast)
    __swig_destroy__ = _TColStd.delete_Handle_TColStd_HArray1OfReal

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        res = _TColStd.Handle_TColStd_HArray1OfReal_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_TColStd_HArray1OfReal self) -> NCollection_Array1_Standard_Real

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _TColStd.Handle_TColStd_HArray1OfReal_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TColStd_HArray1OfReal self) -> char const *

        :rtype: const char *

        """
        return _TColStd.Handle_TColStd_HArray1OfReal_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HArray1OfReal_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HArray1OfReal_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TColStd_HArray1OfReal self)

        Memory deallocator for transient classes


        """
        return _TColStd.Handle_TColStd_HArray1OfReal_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TColStd_HArray1OfReal self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TColStd_HArray1OfReal self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HArray1OfReal_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TColStd_HArray1OfReal self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TColStd_HArray1OfReal self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HArray1OfReal_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TColStd_HArray1OfReal self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TColStd.Handle_TColStd_HArray1OfReal_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TColStd_HArray1OfReal self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray1OfReal_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TColStd_HArray1OfReal self)

        Increments the reference counter of this object


        """
        return _TColStd.Handle_TColStd_HArray1OfReal_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TColStd_HArray1OfReal self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray1OfReal_DecrementRefCounter(self, *args)

Handle_TColStd_HArray1OfReal_swigregister = _TColStd.Handle_TColStd_HArray1OfReal_swigregister
Handle_TColStd_HArray1OfReal_swigregister(Handle_TColStd_HArray1OfReal)

def Handle_TColStd_HArray1OfReal_DownCast(thing):
    return _TColStd.Handle_TColStd_HArray1OfReal_DownCast(thing)
Handle_TColStd_HArray1OfReal_DownCast = _TColStd.Handle_TColStd_HArray1OfReal_DownCast

class Handle_TColStd_HArray1OfExtendedString(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TColStd_HArray1OfExtendedString self)

        Nullify the handle


        """
        return _TColStd.Handle_TColStd_HArray1OfExtendedString_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TColStd_HArray1OfExtendedString self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TColStd.Handle_TColStd_HArray1OfExtendedString_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TColStd_HArray1OfExtendedString self, TColStd_HArray1OfExtendedString thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TColStd.Handle_TColStd_HArray1OfExtendedString_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TColStd_HArray1OfExtendedString self, Handle_TColStd_HArray1OfExtendedString theHandle) -> Handle_TColStd_HArray1OfExtendedString
        assign(Handle_TColStd_HArray1OfExtendedString self, TColStd_HArray1OfExtendedString thePtr) -> Handle_TColStd_HArray1OfExtendedString
        assign(Handle_TColStd_HArray1OfExtendedString self, Handle_TColStd_HArray1OfExtendedString theHandle) -> Handle_TColStd_HArray1OfExtendedString

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TColStd.Handle_TColStd_HArray1OfExtendedString_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TColStd_HArray1OfExtendedString self) -> TColStd_HArray1OfExtendedString

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HArray1OfExtendedString_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TColStd_HArray1OfExtendedString self) -> TColStd_HArray1OfExtendedString

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HArray1OfExtendedString___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TColStd_HArray1OfExtendedString self) -> TColStd_HArray1OfExtendedString

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TColStd.Handle_TColStd_HArray1OfExtendedString___ref__(self, *args)


    def __hash__(self):
        return _TColStd.Handle_TColStd_HArray1OfExtendedString___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TColStd.Handle_TColStd_HArray1OfExtendedString___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TColStd.new_Handle_TColStd_HArray1OfExtendedString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TColStd.Handle_TColStd_HArray1OfExtendedString_DownCast)
    __swig_destroy__ = _TColStd.delete_Handle_TColStd_HArray1OfExtendedString

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfExtendedString

        """
        res = _TColStd.Handle_TColStd_HArray1OfExtendedString_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_TColStd_HArray1OfExtendedString self) -> NCollection_Array1_TCollection_ExtendedString

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfExtendedString

        """
        return _TColStd.Handle_TColStd_HArray1OfExtendedString_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TColStd_HArray1OfExtendedString self) -> char const *

        :rtype: const char *

        """
        return _TColStd.Handle_TColStd_HArray1OfExtendedString_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HArray1OfExtendedString_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HArray1OfExtendedString_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TColStd_HArray1OfExtendedString self)

        Memory deallocator for transient classes


        """
        return _TColStd.Handle_TColStd_HArray1OfExtendedString_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TColStd_HArray1OfExtendedString self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TColStd_HArray1OfExtendedString self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HArray1OfExtendedString_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TColStd_HArray1OfExtendedString self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TColStd_HArray1OfExtendedString self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HArray1OfExtendedString_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TColStd_HArray1OfExtendedString self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TColStd.Handle_TColStd_HArray1OfExtendedString_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TColStd_HArray1OfExtendedString self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray1OfExtendedString_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TColStd_HArray1OfExtendedString self)

        Increments the reference counter of this object


        """
        return _TColStd.Handle_TColStd_HArray1OfExtendedString_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TColStd_HArray1OfExtendedString self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray1OfExtendedString_DecrementRefCounter(self, *args)

Handle_TColStd_HArray1OfExtendedString_swigregister = _TColStd.Handle_TColStd_HArray1OfExtendedString_swigregister
Handle_TColStd_HArray1OfExtendedString_swigregister(Handle_TColStd_HArray1OfExtendedString)

def Handle_TColStd_HArray1OfExtendedString_DownCast(thing):
    return _TColStd.Handle_TColStd_HArray1OfExtendedString_DownCast(thing)
Handle_TColStd_HArray1OfExtendedString_DownCast = _TColStd.Handle_TColStd_HArray1OfExtendedString_DownCast

class Handle_TColStd_HArray1OfTransient(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TColStd_HArray1OfTransient self)

        Nullify the handle


        """
        return _TColStd.Handle_TColStd_HArray1OfTransient_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TColStd_HArray1OfTransient self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TColStd.Handle_TColStd_HArray1OfTransient_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TColStd_HArray1OfTransient self, TColStd_HArray1OfTransient thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TColStd.Handle_TColStd_HArray1OfTransient_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TColStd_HArray1OfTransient self, Handle_TColStd_HArray1OfTransient theHandle) -> Handle_TColStd_HArray1OfTransient
        assign(Handle_TColStd_HArray1OfTransient self, TColStd_HArray1OfTransient thePtr) -> Handle_TColStd_HArray1OfTransient
        assign(Handle_TColStd_HArray1OfTransient self, Handle_TColStd_HArray1OfTransient theHandle) -> Handle_TColStd_HArray1OfTransient

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TColStd.Handle_TColStd_HArray1OfTransient_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TColStd_HArray1OfTransient self) -> TColStd_HArray1OfTransient

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HArray1OfTransient_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TColStd_HArray1OfTransient self) -> TColStd_HArray1OfTransient

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HArray1OfTransient___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TColStd_HArray1OfTransient self) -> TColStd_HArray1OfTransient

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TColStd.Handle_TColStd_HArray1OfTransient___ref__(self, *args)


    def __hash__(self):
        return _TColStd.Handle_TColStd_HArray1OfTransient___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TColStd.Handle_TColStd_HArray1OfTransient___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TColStd.new_Handle_TColStd_HArray1OfTransient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TColStd.Handle_TColStd_HArray1OfTransient_DownCast)
    __swig_destroy__ = _TColStd.delete_Handle_TColStd_HArray1OfTransient

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfTransient

        """
        res = _TColStd.Handle_TColStd_HArray1OfTransient_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_TColStd_HArray1OfTransient self) -> NCollection_Array1_Handle_Standard_Transient

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfTransient

        """
        return _TColStd.Handle_TColStd_HArray1OfTransient_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TColStd_HArray1OfTransient self) -> char const *

        :rtype: const char *

        """
        return _TColStd.Handle_TColStd_HArray1OfTransient_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HArray1OfTransient_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HArray1OfTransient_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TColStd_HArray1OfTransient self)

        Memory deallocator for transient classes


        """
        return _TColStd.Handle_TColStd_HArray1OfTransient_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TColStd_HArray1OfTransient self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TColStd_HArray1OfTransient self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HArray1OfTransient_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TColStd_HArray1OfTransient self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TColStd_HArray1OfTransient self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HArray1OfTransient_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TColStd_HArray1OfTransient self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TColStd.Handle_TColStd_HArray1OfTransient_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TColStd_HArray1OfTransient self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray1OfTransient_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TColStd_HArray1OfTransient self)

        Increments the reference counter of this object


        """
        return _TColStd.Handle_TColStd_HArray1OfTransient_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TColStd_HArray1OfTransient self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray1OfTransient_DecrementRefCounter(self, *args)

Handle_TColStd_HArray1OfTransient_swigregister = _TColStd.Handle_TColStd_HArray1OfTransient_swigregister
Handle_TColStd_HArray1OfTransient_swigregister(Handle_TColStd_HArray1OfTransient)

def Handle_TColStd_HArray1OfTransient_DownCast(thing):
    return _TColStd.Handle_TColStd_HArray1OfTransient_DownCast(thing)
Handle_TColStd_HArray1OfTransient_DownCast = _TColStd.Handle_TColStd_HArray1OfTransient_DownCast

class NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TColStd_ListOfInteger,TColStd_MapIntegerHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TColStd_ListOfInteger,TColStd_MapIntegerHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TColStd_ListOfInteger,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,TColStd_ListOfInteger,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TColStd.new_NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher self, int const & theKey, NCollection_List_Standard_Integer theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher self, int const & theKey, NCollection_List_Standard_Integer theItem) -> NCollection_List_Standard_Integer

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher self, int const & theKey) -> NCollection_List_Standard_Integer

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher self, int const & theKey) -> NCollection_List_Standard_Integer

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher self, int const & theKey) -> NCollection_List_Standard_Integer

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher_Size(self, *args)


    def __iter__(self):
        return _TColStd.NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher___iter__(self)
    __swig_destroy__ = _TColStd.delete_NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher
NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher_swigregister = _TColStd.NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher_swigregister
NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher_swigregister(NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher)

class NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TColStd.new_NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TColStd.delete_NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher_IteratorHelper

    def __next__(self):
        return _TColStd.NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher_IteratorHelper___next__(self)
NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher_IteratorHelper_swigregister = _TColStd.NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher_IteratorHelper_swigregister
NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher_IteratorHelper_swigregister(NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher_IteratorHelper)


try:
	TColStd_DataMapOfIntegerListOfInteger = NCollection_DataMap_Standard_Integer_TColStd_ListOfInteger_TColStd_MapIntegerHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_Array1_TCollection_ExtendedString(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_TCollection_ExtendedString self) -> NCollection_Array1< TCollection_ExtendedString >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _TColStd.NCollection_Array1_TCollection_ExtendedString_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_TCollection_ExtendedString self) -> NCollection_Array1< TCollection_ExtendedString >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _TColStd.NCollection_Array1_TCollection_ExtendedString_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_TCollection_ExtendedString self) -> NCollection_Array1< TCollection_ExtendedString >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Array1_TCollection_ExtendedString_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_TCollection_ExtendedString self) -> NCollection_Array1< TCollection_ExtendedString >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Array1_TCollection_ExtendedString_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _TColStd.new_NCollection_Array1_TCollection_ExtendedString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_TCollection_ExtendedString self, TCollection_ExtendedString theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _TColStd.NCollection_Array1_TCollection_ExtendedString_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_TCollection_ExtendedString self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_TCollection_ExtendedString_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_TCollection_ExtendedString self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_TCollection_ExtendedString_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_TCollection_ExtendedString self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Array1_TCollection_ExtendedString_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_TCollection_ExtendedString self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_TCollection_ExtendedString_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_TCollection_ExtendedString self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_TCollection_ExtendedString_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_TCollection_ExtendedString self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Array1_TCollection_ExtendedString_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_TCollection_ExtendedString self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Array1_TCollection_ExtendedString_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_TCollection_ExtendedString self, NCollection_Array1_TCollection_ExtendedString theOther) -> NCollection_Array1_TCollection_ExtendedString

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TColStd.NCollection_Array1_TCollection_ExtendedString_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_TCollection_ExtendedString self, NCollection_Array1_TCollection_ExtendedString theOther) -> NCollection_Array1_TCollection_ExtendedString

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TColStd.NCollection_Array1_TCollection_ExtendedString_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_TCollection_ExtendedString self, NCollection_Array1_TCollection_ExtendedString theOther) -> NCollection_Array1_TCollection_ExtendedString
        assign(NCollection_Array1_TCollection_ExtendedString self, NCollection_Array1_TCollection_ExtendedString theOther) -> NCollection_Array1_TCollection_ExtendedString

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TColStd.NCollection_Array1_TCollection_ExtendedString_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_TCollection_ExtendedString_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_TCollection_ExtendedString self) -> TCollection_ExtendedString

        @return first element

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Array1_TCollection_ExtendedString_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_TCollection_ExtendedString_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_TCollection_ExtendedString self) -> TCollection_ExtendedString

        @return last element

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Array1_TCollection_ExtendedString_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_TCollection_ExtendedString_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_TCollection_ExtendedString self, Standard_Integer const theIndex) -> TCollection_ExtendedString

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Array1_TCollection_ExtendedString_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_TCollection_ExtendedString___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_TCollection_ExtendedString_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_TCollection_ExtendedString self, Standard_Integer const theIndex, TCollection_ExtendedString theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TColStd.NCollection_Array1_TCollection_ExtendedString_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_TCollection_ExtendedString self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _TColStd.NCollection_Array1_TCollection_ExtendedString_Resize(self, *args)

    __swig_destroy__ = _TColStd.delete_NCollection_Array1_TCollection_ExtendedString
NCollection_Array1_TCollection_ExtendedString_swigregister = _TColStd.NCollection_Array1_TCollection_ExtendedString_swigregister
NCollection_Array1_TCollection_ExtendedString_swigregister(NCollection_Array1_TCollection_ExtendedString)


try:
	TColStd_Array1OfExtendedString = NCollection_Array1_TCollection_ExtendedString
except NameError:
	pass # does not exist, probably ignored

class TColStd_HSequenceOfInteger(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TColStd_HSequenceOfInteger
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TColStd_HSequenceOfInteger(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TColStd_HSequenceOfInteger self) -> TColStd_HSequenceOfInteger
        __init__(TColStd_HSequenceOfInteger self, NCollection_Sequence_Standard_Integer theOther) -> TColStd_HSequenceOfInteger

        :type theOther: OCC.wrapper.TColStd.TColStd_SequenceOfInteger

        """
        this = _TColStd.new_TColStd_HSequenceOfInteger(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfInteger

        """
        res = _TColStd.TColStd_HSequenceOfInteger_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(TColStd_HSequenceOfInteger self, TColStd_SequenceOfInteger::value_type const & theItem)
        Append(TColStd_HSequenceOfInteger self, NCollection_Sequence_Standard_Integer theSequence)

        :type theSequence: OCC.wrapper.TColStd.TColStd_SequenceOfInteger

        """
        return _TColStd.TColStd_HSequenceOfInteger_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(TColStd_HSequenceOfInteger self) -> NCollection_Sequence_Standard_Integer

        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfInteger

        """
        return _TColStd.TColStd_HSequenceOfInteger_ChangeSequence(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TColStd.TColStd_HSequenceOfInteger_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TColStd.TColStd_HSequenceOfInteger_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.TColStd_HSequenceOfInteger_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TColStd.delete_TColStd_HSequenceOfInteger
TColStd_HSequenceOfInteger_swigregister = _TColStd.TColStd_HSequenceOfInteger_swigregister
TColStd_HSequenceOfInteger_swigregister(TColStd_HSequenceOfInteger)

def TColStd_HSequenceOfInteger_get_type_name(*args):
    """
    TColStd_HSequenceOfInteger_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TColStd.TColStd_HSequenceOfInteger_get_type_name(*args)

def TColStd_HSequenceOfInteger_get_type_descriptor(*args):
    """
    TColStd_HSequenceOfInteger_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TColStd.TColStd_HSequenceOfInteger_get_type_descriptor(*args)

class NCollection_List_Handle_Standard_Transient(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_Handle_Standard_Transient self) -> NCollection_List< opencascade::handle< Standard_Transient > >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _TColStd.NCollection_List_Handle_Standard_Transient_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_Handle_Standard_Transient self) -> NCollection_List< opencascade::handle< Standard_Transient > >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _TColStd.NCollection_List_Handle_Standard_Transient_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_Handle_Standard_Transient self) -> NCollection_List< opencascade::handle< Standard_Transient > >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_List_Handle_Standard_Transient_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_Handle_Standard_Transient self) -> NCollection_List< opencascade::handle< Standard_Transient > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_List_Handle_Standard_Transient_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _TColStd.new_NCollection_List_Handle_Standard_Transient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_Handle_Standard_Transient self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_List_Handle_Standard_Transient_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_Handle_Standard_Transient self, NCollection_List_Handle_Standard_Transient theOther) -> NCollection_List_Handle_Standard_Transient

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _TColStd.NCollection_List_Handle_Standard_Transient_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_Handle_Standard_Transient self, NCollection_List_Handle_Standard_Transient theOther) -> NCollection_List_Handle_Standard_Transient

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _TColStd.NCollection_List_Handle_Standard_Transient_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_Handle_Standard_Transient self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_List_Handle_Standard_Transient_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_List_Handle_Standard_Transient_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_List_Handle_Standard_Transient_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_Handle_Standard_Transient self, Handle_Standard_Transient theItem) -> Handle_Standard_Transient
        Append(NCollection_List_Handle_Standard_Transient self, Handle_Standard_Transient theItem, NCollection_List< opencascade::handle< Standard_Transient > >::Iterator & theIter)
        Append(NCollection_List_Handle_Standard_Transient self, NCollection_List_Handle_Standard_Transient theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _TColStd.NCollection_List_Handle_Standard_Transient_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_Handle_Standard_Transient self, Handle_Standard_Transient theItem) -> Handle_Standard_Transient
        Prepend(NCollection_List_Handle_Standard_Transient self, NCollection_List_Handle_Standard_Transient theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _TColStd.NCollection_List_Handle_Standard_Transient_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_Handle_Standard_Transient self)

        RemoveFirst item


        """
        return _TColStd.NCollection_List_Handle_Standard_Transient_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_Handle_Standard_Transient self, NCollection_List< opencascade::handle< Standard_Transient > >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _TColStd.NCollection_List_Handle_Standard_Transient_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_Handle_Standard_Transient self, Handle_Standard_Transient theItem, NCollection_List< opencascade::handle< Standard_Transient > >::Iterator & theIter) -> Handle_Standard_Transient
        InsertBefore(NCollection_List_Handle_Standard_Transient self, NCollection_List_Handle_Standard_Transient theOther, NCollection_List< opencascade::handle< Standard_Transient > >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _TColStd.NCollection_List_Handle_Standard_Transient_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_Handle_Standard_Transient self, Handle_Standard_Transient theItem, NCollection_List< opencascade::handle< Standard_Transient > >::Iterator & theIter) -> Handle_Standard_Transient
        InsertAfter(NCollection_List_Handle_Standard_Transient self, NCollection_List_Handle_Standard_Transient theOther, NCollection_List< opencascade::handle< Standard_Transient > >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _TColStd.NCollection_List_Handle_Standard_Transient_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_Handle_Standard_Transient self)

        Reverse the list


        """
        return _TColStd.NCollection_List_Handle_Standard_Transient_Reverse(self, *args)


    def __iter__(self):
        return _TColStd.NCollection_List_Handle_Standard_Transient___iter__(self)
    __swig_destroy__ = _TColStd.delete_NCollection_List_Handle_Standard_Transient
NCollection_List_Handle_Standard_Transient_swigregister = _TColStd.NCollection_List_Handle_Standard_Transient_swigregister
NCollection_List_Handle_Standard_Transient_swigregister(NCollection_List_Handle_Standard_Transient)

class NCollection_List_Handle_Standard_Transient_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TColStd.new_NCollection_List_Handle_Standard_Transient_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TColStd.delete_NCollection_List_Handle_Standard_Transient_IteratorHelper

    def __next__(self):
        return _TColStd.NCollection_List_Handle_Standard_Transient_IteratorHelper___next__(self)
NCollection_List_Handle_Standard_Transient_IteratorHelper_swigregister = _TColStd.NCollection_List_Handle_Standard_Transient_IteratorHelper_swigregister
NCollection_List_Handle_Standard_Transient_IteratorHelper_swigregister(NCollection_List_Handle_Standard_Transient_IteratorHelper)


try:
	TColStd_ListOfTransient = NCollection_List_Handle_Standard_Transient
except NameError:
	pass # does not exist, probably ignored

class NCollection_Array2_Standard_Real(object):
    """
    Purpose:   The class Array2 represents bi-dimensional arrays 
    of fixed size known at run time. 
    The ranges of indices are user defined.

    Warning:   Programs clients of such class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.LowerRow(); i <= A.UpperRow(); i++)
    for (j = A.LowerCol(); j <= A.UpperCol(); j++)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Purpose:   The class Array2 represents bi-dimensional arrays 
        of fixed size known at run time. 
        The ranges of indices are user defined.

        Warning:   Programs clients of such class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.LowerRow(); i <= A.UpperRow(); i++)
        for (j = A.LowerCol(); j <= A.UpperCol(); j++)
        """
        this = _TColStd.new_NCollection_Array2_Standard_Real(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array2_Standard_Real self, double const & theValue)

        Initialise the values

        :type theValue: const TheItemType &

        """
        return _TColStd.NCollection_Array2_Standard_Real_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array2_Standard_Real self) -> Standard_Integer

        Size (number of items)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Standard_Real_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array2_Standard_Real self) -> Standard_Integer

        Length (number of items)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Standard_Real_Length(self, *args)


    def RowLength(self, *args):
        """
        RowLength(NCollection_Array2_Standard_Real self) -> Standard_Integer

        Returns length of the row, i.e. number of columns

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Standard_Real_RowLength(self, *args)


    def ColLength(self, *args):
        """
        ColLength(NCollection_Array2_Standard_Real self) -> Standard_Integer

        Returns length of the column, i.e. number of rows

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Standard_Real_ColLength(self, *args)


    def LowerRow(self, *args):
        """
        LowerRow(NCollection_Array2_Standard_Real self) -> Standard_Integer

        LowerRow

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Standard_Real_LowerRow(self, *args)


    def UpperRow(self, *args):
        """
        UpperRow(NCollection_Array2_Standard_Real self) -> Standard_Integer

        UpperRow

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Standard_Real_UpperRow(self, *args)


    def LowerCol(self, *args):
        """
        LowerCol(NCollection_Array2_Standard_Real self) -> Standard_Integer

        LowerCol

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Standard_Real_LowerCol(self, *args)


    def UpperCol(self, *args):
        """
        UpperCol(NCollection_Array2_Standard_Real self) -> Standard_Integer

        UpperCol

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Standard_Real_UpperCol(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array2_Standard_Real self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Array2_Standard_Real_IsDeletable(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array2_Standard_Real self, NCollection_Array2_Standard_Real theOther) -> NCollection_Array2_Standard_Real

        Assignment

        :type theOther: OCC.wrapper.NCollection.NCollection_Array2
        :rtype: OCC.wrapper.NCollection.NCollection_Array2

        """
        return _TColStd.NCollection_Array2_Standard_Real_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array2_Standard_Real self, NCollection_Array2_Standard_Real theOther) -> NCollection_Array2_Standard_Real

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Array2
        :rtype: OCC.wrapper.NCollection.NCollection_Array2

        """
        return _TColStd.NCollection_Array2_Standard_Real_assign(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theRow: int
        :type theCol: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array2_Standard_Real_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array2_Standard_Real self, Standard_Integer const theRow, Standard_Integer const theCol) -> double &

        Variable value access

        :type theRow: int
        :type theCol: int
        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Array2_Standard_Real_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to ChangeValue

        :type theRow: int
        :type theCol: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array2_Standard_Real___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array2_Standard_Real self, Standard_Integer const theRow, Standard_Integer const theCol, double const & theItem)

        SetValue

        :type theRow: int
        :type theCol: int
        :type theItem: const TheItemType &

        """
        return _TColStd.NCollection_Array2_Standard_Real_SetValue(self, *args)

    __swig_destroy__ = _TColStd.delete_NCollection_Array2_Standard_Real
NCollection_Array2_Standard_Real_swigregister = _TColStd.NCollection_Array2_Standard_Real_swigregister
NCollection_Array2_Standard_Real_swigregister(NCollection_Array2_Standard_Real)


try:
	TColStd_Array2OfReal = NCollection_Array2_Standard_Real
except NameError:
	pass # does not exist, probably ignored

class TColStd_HSequenceOfExtendedString(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TColStd_HSequenceOfExtendedString
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TColStd_HSequenceOfExtendedString(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TColStd_HSequenceOfExtendedString self) -> TColStd_HSequenceOfExtendedString
        __init__(TColStd_HSequenceOfExtendedString self, NCollection_Sequence_TCollection_ExtendedString theOther) -> TColStd_HSequenceOfExtendedString

        :type theOther: OCC.wrapper.TColStd.TColStd_SequenceOfExtendedString

        """
        this = _TColStd.new_TColStd_HSequenceOfExtendedString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfExtendedString

        """
        res = _TColStd.TColStd_HSequenceOfExtendedString_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(TColStd_HSequenceOfExtendedString self, TCollection_ExtendedString theItem)
        Append(TColStd_HSequenceOfExtendedString self, NCollection_Sequence_TCollection_ExtendedString theSequence)

        :type theSequence: OCC.wrapper.TColStd.TColStd_SequenceOfExtendedString

        """
        return _TColStd.TColStd_HSequenceOfExtendedString_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(TColStd_HSequenceOfExtendedString self) -> NCollection_Sequence_TCollection_ExtendedString

        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfExtendedString

        """
        return _TColStd.TColStd_HSequenceOfExtendedString_ChangeSequence(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TColStd.TColStd_HSequenceOfExtendedString_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TColStd.TColStd_HSequenceOfExtendedString_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.TColStd_HSequenceOfExtendedString_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TColStd.delete_TColStd_HSequenceOfExtendedString
TColStd_HSequenceOfExtendedString_swigregister = _TColStd.TColStd_HSequenceOfExtendedString_swigregister
TColStd_HSequenceOfExtendedString_swigregister(TColStd_HSequenceOfExtendedString)

def TColStd_HSequenceOfExtendedString_get_type_name(*args):
    """
    TColStd_HSequenceOfExtendedString_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TColStd.TColStd_HSequenceOfExtendedString_get_type_name(*args)

def TColStd_HSequenceOfExtendedString_get_type_descriptor(*args):
    """
    TColStd_HSequenceOfExtendedString_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TColStd.TColStd_HSequenceOfExtendedString_get_type_descriptor(*args)

class NCollection_Sequence_Standard_Boolean(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Standard_Boolean self) -> NCollection_Sequence< Standard_Boolean >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _TColStd.NCollection_Sequence_Standard_Boolean_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Standard_Boolean self) -> NCollection_Sequence< Standard_Boolean >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _TColStd.NCollection_Sequence_Standard_Boolean_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Standard_Boolean self) -> NCollection_Sequence< Standard_Boolean >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Sequence_Standard_Boolean_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Standard_Boolean self) -> NCollection_Sequence< Standard_Boolean >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Sequence_Standard_Boolean_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _TColStd.new_NCollection_Sequence_Standard_Boolean(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Standard_Boolean self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_Standard_Boolean_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Standard_Boolean self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_Standard_Boolean_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Standard_Boolean self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_Standard_Boolean_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Standard_Boolean self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_Standard_Boolean_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Standard_Boolean self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Sequence_Standard_Boolean_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Standard_Boolean self)

        Reverse sequence


        """
        return _TColStd.NCollection_Sequence_Standard_Boolean_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Standard_Boolean self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _TColStd.NCollection_Sequence_Standard_Boolean_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_Sequence_Standard_Boolean_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Standard_Boolean self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_Sequence_Standard_Boolean_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Standard_Boolean self, NCollection_Sequence_Standard_Boolean theOther) -> NCollection_Sequence_Standard_Boolean

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Standard_Boolean_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Standard_Boolean self, NCollection_Sequence_Standard_Boolean theOther) -> NCollection_Sequence_Standard_Boolean

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Standard_Boolean_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Standard_Boolean self, NCollection_Sequence< Standard_Boolean >::Iterator & thePosition)
        Remove(NCollection_Sequence_Standard_Boolean self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Standard_Boolean self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _TColStd.NCollection_Sequence_Standard_Boolean_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Standard_Boolean self, bool const & theItem)
        Append(NCollection_Sequence_Standard_Boolean self, NCollection_Sequence_Standard_Boolean theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Standard_Boolean_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Standard_Boolean self, bool const & theItem)
        Prepend(NCollection_Sequence_Standard_Boolean self, NCollection_Sequence_Standard_Boolean theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Standard_Boolean_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Standard_Boolean self, Standard_Integer const theIndex, bool const & theItem)
        InsertBefore(NCollection_Sequence_Standard_Boolean self, Standard_Integer const theIndex, NCollection_Sequence_Standard_Boolean theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Standard_Boolean_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Standard_Boolean self, NCollection_Sequence< Standard_Boolean >::Iterator & thePosition, bool const & theItem)
        InsertAfter(NCollection_Sequence_Standard_Boolean self, Standard_Integer const theIndex, NCollection_Sequence_Standard_Boolean theSeq)
        InsertAfter(NCollection_Sequence_Standard_Boolean self, Standard_Integer const theIndex, bool const & theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TColStd.NCollection_Sequence_Standard_Boolean_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Standard_Boolean self, Standard_Integer const theIndex, NCollection_Sequence_Standard_Boolean theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Standard_Boolean_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_Standard_Boolean_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Standard_Boolean self) -> bool &

        First item access

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Sequence_Standard_Boolean_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_Standard_Boolean_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Standard_Boolean self) -> bool &

        Last item access

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Sequence_Standard_Boolean_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_Standard_Boolean_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Standard_Boolean self, Standard_Integer const theIndex) -> bool &

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Sequence_Standard_Boolean_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_Standard_Boolean___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Standard_Boolean self, Standard_Integer const theIndex, bool const & theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TColStd.NCollection_Sequence_Standard_Boolean_SetValue(self, *args)


    def __iter__(self):
        return _TColStd.NCollection_Sequence_Standard_Boolean___iter__(self)
    __swig_destroy__ = _TColStd.delete_NCollection_Sequence_Standard_Boolean
NCollection_Sequence_Standard_Boolean_swigregister = _TColStd.NCollection_Sequence_Standard_Boolean_swigregister
NCollection_Sequence_Standard_Boolean_swigregister(NCollection_Sequence_Standard_Boolean)

def NCollection_Sequence_Standard_Boolean_delNode(*args):
    """
    NCollection_Sequence_Standard_Boolean_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _TColStd.NCollection_Sequence_Standard_Boolean_delNode(*args)

class NCollection_Sequence_Standard_Boolean_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TColStd.new_NCollection_Sequence_Standard_Boolean_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TColStd.delete_NCollection_Sequence_Standard_Boolean_IteratorHelper

    def __next__(self):
        return _TColStd.NCollection_Sequence_Standard_Boolean_IteratorHelper___next__(self)
NCollection_Sequence_Standard_Boolean_IteratorHelper_swigregister = _TColStd.NCollection_Sequence_Standard_Boolean_IteratorHelper_swigregister
NCollection_Sequence_Standard_Boolean_IteratorHelper_swigregister(NCollection_Sequence_Standard_Boolean_IteratorHelper)


try:
	TColStd_SequenceOfBoolean = NCollection_Sequence_Standard_Boolean
except NameError:
	pass # does not exist, probably ignored

class NCollection_Sequence_Handle_Standard_Transient(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_Standard_Transient self) -> NCollection_Sequence< opencascade::handle< Standard_Transient > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _TColStd.NCollection_Sequence_Handle_Standard_Transient_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_Standard_Transient self) -> NCollection_Sequence< opencascade::handle< Standard_Transient > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _TColStd.NCollection_Sequence_Handle_Standard_Transient_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_Standard_Transient self) -> NCollection_Sequence< opencascade::handle< Standard_Transient > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Sequence_Handle_Standard_Transient_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_Standard_Transient self) -> NCollection_Sequence< opencascade::handle< Standard_Transient > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Sequence_Handle_Standard_Transient_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _TColStd.new_NCollection_Sequence_Handle_Standard_Transient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_Standard_Transient self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_Handle_Standard_Transient_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_Standard_Transient self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_Handle_Standard_Transient_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_Standard_Transient self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_Handle_Standard_Transient_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_Standard_Transient self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_Handle_Standard_Transient_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_Standard_Transient self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Sequence_Handle_Standard_Transient_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_Standard_Transient self)

        Reverse sequence


        """
        return _TColStd.NCollection_Sequence_Handle_Standard_Transient_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_Standard_Transient self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _TColStd.NCollection_Sequence_Handle_Standard_Transient_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_Sequence_Handle_Standard_Transient_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_Standard_Transient self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_Sequence_Handle_Standard_Transient_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_Standard_Transient self, NCollection_Sequence_Handle_Standard_Transient theOther) -> NCollection_Sequence_Handle_Standard_Transient

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Handle_Standard_Transient_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_Standard_Transient self, NCollection_Sequence_Handle_Standard_Transient theOther) -> NCollection_Sequence_Handle_Standard_Transient

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Handle_Standard_Transient_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_Standard_Transient self, NCollection_Sequence< opencascade::handle< Standard_Transient > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_Standard_Transient self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_Standard_Transient self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _TColStd.NCollection_Sequence_Handle_Standard_Transient_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_Standard_Transient self, Handle_Standard_Transient theItem)
        Append(NCollection_Sequence_Handle_Standard_Transient self, NCollection_Sequence_Handle_Standard_Transient theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Handle_Standard_Transient_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_Standard_Transient self, Handle_Standard_Transient theItem)
        Prepend(NCollection_Sequence_Handle_Standard_Transient self, NCollection_Sequence_Handle_Standard_Transient theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Handle_Standard_Transient_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_Standard_Transient self, Standard_Integer const theIndex, Handle_Standard_Transient theItem)
        InsertBefore(NCollection_Sequence_Handle_Standard_Transient self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Standard_Transient theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Handle_Standard_Transient_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_Standard_Transient self, NCollection_Sequence< opencascade::handle< Standard_Transient > >::Iterator & thePosition, Handle_Standard_Transient theItem)
        InsertAfter(NCollection_Sequence_Handle_Standard_Transient self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Standard_Transient theSeq)
        InsertAfter(NCollection_Sequence_Handle_Standard_Transient self, Standard_Integer const theIndex, Handle_Standard_Transient theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TColStd.NCollection_Sequence_Handle_Standard_Transient_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_Standard_Transient self, Standard_Integer const theIndex, NCollection_Sequence_Handle_Standard_Transient theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Handle_Standard_Transient_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_Handle_Standard_Transient_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_Standard_Transient self) -> Handle_Standard_Transient

        First item access

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Sequence_Handle_Standard_Transient_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_Handle_Standard_Transient_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_Standard_Transient self) -> Handle_Standard_Transient

        Last item access

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Sequence_Handle_Standard_Transient_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_Handle_Standard_Transient_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_Standard_Transient self, Standard_Integer const theIndex) -> Handle_Standard_Transient

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Sequence_Handle_Standard_Transient_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_Handle_Standard_Transient___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_Standard_Transient self, Standard_Integer const theIndex, Handle_Standard_Transient theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TColStd.NCollection_Sequence_Handle_Standard_Transient_SetValue(self, *args)


    def __iter__(self):
        return _TColStd.NCollection_Sequence_Handle_Standard_Transient___iter__(self)
    __swig_destroy__ = _TColStd.delete_NCollection_Sequence_Handle_Standard_Transient
NCollection_Sequence_Handle_Standard_Transient_swigregister = _TColStd.NCollection_Sequence_Handle_Standard_Transient_swigregister
NCollection_Sequence_Handle_Standard_Transient_swigregister(NCollection_Sequence_Handle_Standard_Transient)

def NCollection_Sequence_Handle_Standard_Transient_delNode(*args):
    """
    NCollection_Sequence_Handle_Standard_Transient_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _TColStd.NCollection_Sequence_Handle_Standard_Transient_delNode(*args)

class NCollection_Sequence_Handle_Standard_Transient_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TColStd.new_NCollection_Sequence_Handle_Standard_Transient_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TColStd.delete_NCollection_Sequence_Handle_Standard_Transient_IteratorHelper

    def __next__(self):
        return _TColStd.NCollection_Sequence_Handle_Standard_Transient_IteratorHelper___next__(self)
NCollection_Sequence_Handle_Standard_Transient_IteratorHelper_swigregister = _TColStd.NCollection_Sequence_Handle_Standard_Transient_IteratorHelper_swigregister
NCollection_Sequence_Handle_Standard_Transient_IteratorHelper_swigregister(NCollection_Sequence_Handle_Standard_Transient_IteratorHelper)


try:
	TColStd_SequenceOfTransient = NCollection_Sequence_Handle_Standard_Transient
except NameError:
	pass # does not exist, probably ignored


try:
	Handle_TCollection_HAsciiString = TCollection.Handle_TCollection_HAsciiString
except AttributeError:
	pass # does not exist, probably ignored

class NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< Standard_Transient >,opencascade::handle< Standard_Transient >,TColStd_MapTransientHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TColStd.NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< Standard_Transient >,opencascade::handle< Standard_Transient >,TColStd_MapTransientHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TColStd.NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< Standard_Transient >,opencascade::handle< Standard_Transient >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self) -> NCollection_DataMap< opencascade::handle< Standard_Transient >,opencascade::handle< Standard_Transient >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TColStd.new_NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TColStd.NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TColStd.NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self, NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher theOther) -> NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TColStd.NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TColStd.NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey, Handle_Standard_Transient theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey, Handle_Standard_Transient theItem) -> Handle_Standard_Transient

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TColStd.NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey) -> Handle_Standard_Transient

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TColStd.NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey) -> Handle_Standard_Transient

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TColStd.NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey) -> Handle_Standard_Transient

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TColStd.NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_Size(self, *args)


    def __iter__(self):
        return _TColStd.NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher___iter__(self)
    __swig_destroy__ = _TColStd.delete_NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher
NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_swigregister = _TColStd.NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_swigregister
NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_swigregister(NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher)

class NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TColStd.new_NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TColStd.delete_NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_IteratorHelper

    def __next__(self):
        return _TColStd.NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_IteratorHelper___next__(self)
NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_IteratorHelper_swigregister = _TColStd.NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_IteratorHelper_swigregister
NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_IteratorHelper_swigregister(NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher_IteratorHelper)


try:
	TColStd_DataMapOfTransientTransient = NCollection_DataMap_Handle_Standard_Transient_Handle_Standard_Transient_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored

class TColStd_HArray1OfCharacter(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TColStd_HArray1OfCharacter
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TColStd_HArray1OfCharacter(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TColStd_HArray1OfCharacter self, Standard_Integer const theLower, Standard_Integer const theUpper) -> TColStd_HArray1OfCharacter
        __init__(TColStd_HArray1OfCharacter self, Standard_Integer const theLower, Standard_Integer const theUpper, TColStd_Array1OfCharacter::value_type const & theValue) -> TColStd_HArray1OfCharacter
        __init__(TColStd_HArray1OfCharacter self, NCollection_Array1_Standard_Character theOther) -> TColStd_HArray1OfCharacter

        :type theOther: OCC.wrapper.TColStd.TColStd_Array1OfCharacter

        """
        this = _TColStd.new_TColStd_HArray1OfCharacter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfCharacter

        """
        res = _TColStd.TColStd_HArray1OfCharacter_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(TColStd_HArray1OfCharacter self) -> NCollection_Array1_Standard_Character

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfCharacter

        """
        return _TColStd.TColStd_HArray1OfCharacter_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TColStd.TColStd_HArray1OfCharacter_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TColStd.TColStd_HArray1OfCharacter_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.TColStd_HArray1OfCharacter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TColStd.delete_TColStd_HArray1OfCharacter
TColStd_HArray1OfCharacter_swigregister = _TColStd.TColStd_HArray1OfCharacter_swigregister
TColStd_HArray1OfCharacter_swigregister(TColStd_HArray1OfCharacter)

def TColStd_HArray1OfCharacter_get_type_name(*args):
    """
    TColStd_HArray1OfCharacter_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TColStd.TColStd_HArray1OfCharacter_get_type_name(*args)

def TColStd_HArray1OfCharacter_get_type_descriptor(*args):
    """
    TColStd_HArray1OfCharacter_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TColStd.TColStd_HArray1OfCharacter_get_type_descriptor(*args)

class NCollection_DefaultHasher_Handle_Standard_Transient(object):
    """
    Purpose:     The  DefaultHasher  is a  Hasher  that is used by
    default in NCollection maps. 
    To compute the  hash code of the key  is used the
    global function HashCode.
    To compare two keys is used  the  global function 
    IsEqual.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def HashCode(*args):
        """
        HashCode(Handle_Standard_Transient theKey, Standard_Integer const Upper) -> Standard_Integer

        :type theKey: const TheKeyType &
        :type Upper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_DefaultHasher_Handle_Standard_Transient_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args):
        """
        IsEqual(Handle_Standard_Transient theKey1, Handle_Standard_Transient theKey2) -> Standard_Boolean

        :type theKey1: const TheKeyType &
        :type theKey2: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_DefaultHasher_Handle_Standard_Transient_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    def __init__(self):
        """
        Purpose:     The  DefaultHasher  is a  Hasher  that is used by
        default in NCollection maps. 
        To compute the  hash code of the key  is used the
        global function HashCode.
        To compare two keys is used  the  global function 
        IsEqual.
        """
        this = _TColStd.new_NCollection_DefaultHasher_Handle_Standard_Transient()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TColStd.delete_NCollection_DefaultHasher_Handle_Standard_Transient
NCollection_DefaultHasher_Handle_Standard_Transient_swigregister = _TColStd.NCollection_DefaultHasher_Handle_Standard_Transient_swigregister
NCollection_DefaultHasher_Handle_Standard_Transient_swigregister(NCollection_DefaultHasher_Handle_Standard_Transient)

def NCollection_DefaultHasher_Handle_Standard_Transient_HashCode(*args):
    """
    NCollection_DefaultHasher_Handle_Standard_Transient_HashCode(Handle_Standard_Transient theKey, Standard_Integer const Upper) -> Standard_Integer

    :type theKey: const TheKeyType &
    :type Upper: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _TColStd.NCollection_DefaultHasher_Handle_Standard_Transient_HashCode(*args)

def NCollection_DefaultHasher_Handle_Standard_Transient_IsEqual(*args):
    """
    NCollection_DefaultHasher_Handle_Standard_Transient_IsEqual(Handle_Standard_Transient theKey1, Handle_Standard_Transient theKey2) -> Standard_Boolean

    :type theKey1: const TheKeyType &
    :type theKey2: const TheKeyType &
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TColStd.NCollection_DefaultHasher_Handle_Standard_Transient_IsEqual(*args)


try:
	TColStd_MapTransientHasher = NCollection_DefaultHasher_Handle_Standard_Transient
except NameError:
	pass # does not exist, probably ignored

class TColStd_HArray1OfListOfInteger(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TColStd_HArray1OfListOfInteger
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TColStd_HArray1OfListOfInteger(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TColStd_HArray1OfListOfInteger self, Standard_Integer const theLower, Standard_Integer const theUpper) -> TColStd_HArray1OfListOfInteger
        __init__(TColStd_HArray1OfListOfInteger self, Standard_Integer const theLower, Standard_Integer const theUpper, NCollection_List_Standard_Integer theValue) -> TColStd_HArray1OfListOfInteger
        __init__(TColStd_HArray1OfListOfInteger self, NCollection_Array1_TColStd_ListOfInteger theOther) -> TColStd_HArray1OfListOfInteger

        :type theOther: OCC.wrapper.TColStd.TColStd_Array1OfListOfInteger

        """
        this = _TColStd.new_TColStd_HArray1OfListOfInteger(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfListOfInteger

        """
        res = _TColStd.TColStd_HArray1OfListOfInteger_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(TColStd_HArray1OfListOfInteger self) -> NCollection_Array1_TColStd_ListOfInteger

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfListOfInteger

        """
        return _TColStd.TColStd_HArray1OfListOfInteger_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TColStd.TColStd_HArray1OfListOfInteger_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TColStd.TColStd_HArray1OfListOfInteger_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.TColStd_HArray1OfListOfInteger_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TColStd.delete_TColStd_HArray1OfListOfInteger
TColStd_HArray1OfListOfInteger_swigregister = _TColStd.TColStd_HArray1OfListOfInteger_swigregister
TColStd_HArray1OfListOfInteger_swigregister(TColStd_HArray1OfListOfInteger)

def TColStd_HArray1OfListOfInteger_get_type_name(*args):
    """
    TColStd_HArray1OfListOfInteger_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TColStd.TColStd_HArray1OfListOfInteger_get_type_name(*args)

def TColStd_HArray1OfListOfInteger_get_type_descriptor(*args):
    """
    TColStd_HArray1OfListOfInteger_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TColStd.TColStd_HArray1OfListOfInteger_get_type_descriptor(*args)

class Handle_TColStd_HArray1OfAsciiString(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TColStd_HArray1OfAsciiString self)

        Nullify the handle


        """
        return _TColStd.Handle_TColStd_HArray1OfAsciiString_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TColStd_HArray1OfAsciiString self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TColStd.Handle_TColStd_HArray1OfAsciiString_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TColStd_HArray1OfAsciiString self, TColStd_HArray1OfAsciiString thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TColStd.Handle_TColStd_HArray1OfAsciiString_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TColStd_HArray1OfAsciiString self, Handle_TColStd_HArray1OfAsciiString theHandle) -> Handle_TColStd_HArray1OfAsciiString
        assign(Handle_TColStd_HArray1OfAsciiString self, TColStd_HArray1OfAsciiString thePtr) -> Handle_TColStd_HArray1OfAsciiString
        assign(Handle_TColStd_HArray1OfAsciiString self, Handle_TColStd_HArray1OfAsciiString theHandle) -> Handle_TColStd_HArray1OfAsciiString

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TColStd.Handle_TColStd_HArray1OfAsciiString_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TColStd_HArray1OfAsciiString self) -> TColStd_HArray1OfAsciiString

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HArray1OfAsciiString_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TColStd_HArray1OfAsciiString self) -> TColStd_HArray1OfAsciiString

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HArray1OfAsciiString___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TColStd_HArray1OfAsciiString self) -> TColStd_HArray1OfAsciiString

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TColStd.Handle_TColStd_HArray1OfAsciiString___ref__(self, *args)


    def __hash__(self):
        return _TColStd.Handle_TColStd_HArray1OfAsciiString___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TColStd.Handle_TColStd_HArray1OfAsciiString___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TColStd.new_Handle_TColStd_HArray1OfAsciiString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TColStd.Handle_TColStd_HArray1OfAsciiString_DownCast)
    __swig_destroy__ = _TColStd.delete_Handle_TColStd_HArray1OfAsciiString

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfAsciiString

        """
        res = _TColStd.Handle_TColStd_HArray1OfAsciiString_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_TColStd_HArray1OfAsciiString self) -> NCollection_Array1_TCollection_AsciiString

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfAsciiString

        """
        return _TColStd.Handle_TColStd_HArray1OfAsciiString_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TColStd_HArray1OfAsciiString self) -> char const *

        :rtype: const char *

        """
        return _TColStd.Handle_TColStd_HArray1OfAsciiString_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HArray1OfAsciiString_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HArray1OfAsciiString_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TColStd_HArray1OfAsciiString self)

        Memory deallocator for transient classes


        """
        return _TColStd.Handle_TColStd_HArray1OfAsciiString_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TColStd_HArray1OfAsciiString self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TColStd_HArray1OfAsciiString self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HArray1OfAsciiString_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TColStd_HArray1OfAsciiString self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TColStd_HArray1OfAsciiString self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HArray1OfAsciiString_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TColStd_HArray1OfAsciiString self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TColStd.Handle_TColStd_HArray1OfAsciiString_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TColStd_HArray1OfAsciiString self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray1OfAsciiString_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TColStd_HArray1OfAsciiString self)

        Increments the reference counter of this object


        """
        return _TColStd.Handle_TColStd_HArray1OfAsciiString_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TColStd_HArray1OfAsciiString self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray1OfAsciiString_DecrementRefCounter(self, *args)

Handle_TColStd_HArray1OfAsciiString_swigregister = _TColStd.Handle_TColStd_HArray1OfAsciiString_swigregister
Handle_TColStd_HArray1OfAsciiString_swigregister(Handle_TColStd_HArray1OfAsciiString)

def Handle_TColStd_HArray1OfAsciiString_DownCast(thing):
    return _TColStd.Handle_TColStd_HArray1OfAsciiString_DownCast(thing)
Handle_TColStd_HArray1OfAsciiString_DownCast = _TColStd.Handle_TColStd_HArray1OfAsciiString_DownCast

class NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString self) -> NCollection_DataMap< TCollection_ExtendedString,Standard_Integer,TCollection_ExtendedString >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TColStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString self) -> NCollection_DataMap< TCollection_ExtendedString,Standard_Integer,TCollection_ExtendedString >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TColStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString self) -> NCollection_DataMap< TCollection_ExtendedString,Standard_Integer,TCollection_ExtendedString >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString self) -> NCollection_DataMap< TCollection_ExtendedString,Standard_Integer,TCollection_ExtendedString >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TColStd.new_NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString self, NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TColStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString self, NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString theOther) -> NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TColStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString self, NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString theOther) -> NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TColStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TColStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString self, TCollection_ExtendedString theKey, int const & theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString self, TCollection_ExtendedString theKey, int const & theItem) -> int *

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TColStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> int const *

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TColStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> int *

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TColStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> int &

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TColStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString_Size(self, *args)


    def __iter__(self):
        return _TColStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString___iter__(self)
    __swig_destroy__ = _TColStd.delete_NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString
NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString_swigregister = _TColStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString_swigregister
NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString_swigregister(NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString)

class NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TColStd.new_NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TColStd.delete_NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString_IteratorHelper

    def __next__(self):
        return _TColStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString_IteratorHelper___next__(self)
NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString_IteratorHelper_swigregister = _TColStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString_IteratorHelper_swigregister
NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString_IteratorHelper_swigregister(NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString_IteratorHelper)


try:
	TColStd_DataMapOfStringInteger = NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString
except NameError:
	pass # does not exist, probably ignored

class NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self) -> NCollection_DataMap< TCollection_AsciiString,Standard_Integer,TCollection_AsciiString >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TColStd.NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self) -> NCollection_DataMap< TCollection_AsciiString,Standard_Integer,TCollection_AsciiString >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TColStd.NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self) -> NCollection_DataMap< TCollection_AsciiString,Standard_Integer,TCollection_AsciiString >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self) -> NCollection_DataMap< TCollection_AsciiString,Standard_Integer,TCollection_AsciiString >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TColStd.new_NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self, NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TColStd.NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self, NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString theOther) -> NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TColStd.NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self, NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString theOther) -> NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TColStd.NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TColStd.NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self, TCollection_AsciiString theKey, int const & theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self, TCollection_AsciiString theKey, int const & theItem) -> int *

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TColStd.NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self, TCollection_AsciiString theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self, TCollection_AsciiString theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self, TCollection_AsciiString theKey) -> int const *

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TColStd.NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self, TCollection_AsciiString theKey) -> int *

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TColStd.NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self, TCollection_AsciiString theKey) -> int &

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TColStd.NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_Size(self, *args)


    def __iter__(self):
        return _TColStd.NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString___iter__(self)
    __swig_destroy__ = _TColStd.delete_NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString
NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_swigregister = _TColStd.NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_swigregister
NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_swigregister(NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString)

class NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TColStd.new_NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TColStd.delete_NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_IteratorHelper

    def __next__(self):
        return _TColStd.NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_IteratorHelper___next__(self)
NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_IteratorHelper_swigregister = _TColStd.NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_IteratorHelper_swigregister
NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_IteratorHelper_swigregister(NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString_IteratorHelper)


try:
	TColStd_DataMapOfAsciiStringInteger = NCollection_DataMap_TCollection_AsciiString_Standard_Integer_TCollection_AsciiString
except NameError:
	pass # does not exist, probably ignored

class NCollection_Array1_TCollection_AsciiString(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_TCollection_AsciiString self) -> NCollection_Array1< TCollection_AsciiString >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _TColStd.NCollection_Array1_TCollection_AsciiString_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_TCollection_AsciiString self) -> NCollection_Array1< TCollection_AsciiString >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _TColStd.NCollection_Array1_TCollection_AsciiString_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_TCollection_AsciiString self) -> NCollection_Array1< TCollection_AsciiString >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Array1_TCollection_AsciiString_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_TCollection_AsciiString self) -> NCollection_Array1< TCollection_AsciiString >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Array1_TCollection_AsciiString_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _TColStd.new_NCollection_Array1_TCollection_AsciiString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_TCollection_AsciiString self, TCollection_AsciiString theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _TColStd.NCollection_Array1_TCollection_AsciiString_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_TCollection_AsciiString self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_TCollection_AsciiString_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_TCollection_AsciiString self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_TCollection_AsciiString_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_TCollection_AsciiString self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Array1_TCollection_AsciiString_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_TCollection_AsciiString self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_TCollection_AsciiString_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_TCollection_AsciiString self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_TCollection_AsciiString_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_TCollection_AsciiString self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Array1_TCollection_AsciiString_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_TCollection_AsciiString self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Array1_TCollection_AsciiString_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_TCollection_AsciiString self, NCollection_Array1_TCollection_AsciiString theOther) -> NCollection_Array1_TCollection_AsciiString

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TColStd.NCollection_Array1_TCollection_AsciiString_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_TCollection_AsciiString self, NCollection_Array1_TCollection_AsciiString theOther) -> NCollection_Array1_TCollection_AsciiString

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TColStd.NCollection_Array1_TCollection_AsciiString_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_TCollection_AsciiString self, NCollection_Array1_TCollection_AsciiString theOther) -> NCollection_Array1_TCollection_AsciiString
        assign(NCollection_Array1_TCollection_AsciiString self, NCollection_Array1_TCollection_AsciiString theOther) -> NCollection_Array1_TCollection_AsciiString

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TColStd.NCollection_Array1_TCollection_AsciiString_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_TCollection_AsciiString_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_TCollection_AsciiString self) -> TCollection_AsciiString

        @return first element

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Array1_TCollection_AsciiString_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_TCollection_AsciiString_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_TCollection_AsciiString self) -> TCollection_AsciiString

        @return last element

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Array1_TCollection_AsciiString_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_TCollection_AsciiString_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_TCollection_AsciiString self, Standard_Integer const theIndex) -> TCollection_AsciiString

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Array1_TCollection_AsciiString_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_TCollection_AsciiString___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_TCollection_AsciiString_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_TCollection_AsciiString self, Standard_Integer const theIndex, TCollection_AsciiString theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TColStd.NCollection_Array1_TCollection_AsciiString_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_TCollection_AsciiString self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _TColStd.NCollection_Array1_TCollection_AsciiString_Resize(self, *args)

    __swig_destroy__ = _TColStd.delete_NCollection_Array1_TCollection_AsciiString
NCollection_Array1_TCollection_AsciiString_swigregister = _TColStd.NCollection_Array1_TCollection_AsciiString_swigregister
NCollection_Array1_TCollection_AsciiString_swigregister(NCollection_Array1_TCollection_AsciiString)


try:
	TColStd_Array1OfAsciiString = NCollection_Array1_TCollection_AsciiString
except NameError:
	pass # does not exist, probably ignored

class NCollection_Array1_Standard_Character(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Standard_Character self) -> NCollection_Array1< Standard_Character >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _TColStd.NCollection_Array1_Standard_Character_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Standard_Character self) -> NCollection_Array1< Standard_Character >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _TColStd.NCollection_Array1_Standard_Character_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Standard_Character self) -> NCollection_Array1< Standard_Character >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Array1_Standard_Character_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Standard_Character self) -> NCollection_Array1< Standard_Character >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Array1_Standard_Character_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _TColStd.new_NCollection_Array1_Standard_Character(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Standard_Character self, char const & theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _TColStd.NCollection_Array1_Standard_Character_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Standard_Character self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_Standard_Character_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Standard_Character self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_Standard_Character_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Standard_Character self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Array1_Standard_Character_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Standard_Character self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_Standard_Character_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Standard_Character self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_Standard_Character_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Standard_Character self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Array1_Standard_Character_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Standard_Character self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Array1_Standard_Character_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Standard_Character self, NCollection_Array1_Standard_Character theOther) -> NCollection_Array1_Standard_Character

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TColStd.NCollection_Array1_Standard_Character_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Standard_Character self, NCollection_Array1_Standard_Character theOther) -> NCollection_Array1_Standard_Character

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TColStd.NCollection_Array1_Standard_Character_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Standard_Character self, NCollection_Array1_Standard_Character theOther) -> NCollection_Array1_Standard_Character
        assign(NCollection_Array1_Standard_Character self, NCollection_Array1_Standard_Character theOther) -> NCollection_Array1_Standard_Character

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TColStd.NCollection_Array1_Standard_Character_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_Standard_Character_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Standard_Character self) -> char &

        @return first element

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Array1_Standard_Character_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_Standard_Character_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Standard_Character self) -> char &

        @return last element

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Array1_Standard_Character_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_Standard_Character_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Standard_Character self, Standard_Integer const theIndex) -> char &

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Array1_Standard_Character_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_Standard_Character___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_Standard_Character_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Standard_Character self, Standard_Integer const theIndex, char const & theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TColStd.NCollection_Array1_Standard_Character_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Standard_Character self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _TColStd.NCollection_Array1_Standard_Character_Resize(self, *args)

    __swig_destroy__ = _TColStd.delete_NCollection_Array1_Standard_Character
NCollection_Array1_Standard_Character_swigregister = _TColStd.NCollection_Array1_Standard_Character_swigregister
NCollection_Array1_Standard_Character_swigregister(NCollection_Array1_Standard_Character)


try:
	TColStd_Array1OfCharacter = NCollection_Array1_Standard_Character
except NameError:
	pass # does not exist, probably ignored

class NCollection_Array2_Standard_Boolean(object):
    """
    Purpose:   The class Array2 represents bi-dimensional arrays 
    of fixed size known at run time. 
    The ranges of indices are user defined.

    Warning:   Programs clients of such class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.LowerRow(); i <= A.UpperRow(); i++)
    for (j = A.LowerCol(); j <= A.UpperCol(); j++)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Purpose:   The class Array2 represents bi-dimensional arrays 
        of fixed size known at run time. 
        The ranges of indices are user defined.

        Warning:   Programs clients of such class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.LowerRow(); i <= A.UpperRow(); i++)
        for (j = A.LowerCol(); j <= A.UpperCol(); j++)
        """
        this = _TColStd.new_NCollection_Array2_Standard_Boolean(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array2_Standard_Boolean self, bool const & theValue)

        Initialise the values

        :type theValue: const TheItemType &

        """
        return _TColStd.NCollection_Array2_Standard_Boolean_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array2_Standard_Boolean self) -> Standard_Integer

        Size (number of items)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Standard_Boolean_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array2_Standard_Boolean self) -> Standard_Integer

        Length (number of items)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Standard_Boolean_Length(self, *args)


    def RowLength(self, *args):
        """
        RowLength(NCollection_Array2_Standard_Boolean self) -> Standard_Integer

        Returns length of the row, i.e. number of columns

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Standard_Boolean_RowLength(self, *args)


    def ColLength(self, *args):
        """
        ColLength(NCollection_Array2_Standard_Boolean self) -> Standard_Integer

        Returns length of the column, i.e. number of rows

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Standard_Boolean_ColLength(self, *args)


    def LowerRow(self, *args):
        """
        LowerRow(NCollection_Array2_Standard_Boolean self) -> Standard_Integer

        LowerRow

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Standard_Boolean_LowerRow(self, *args)


    def UpperRow(self, *args):
        """
        UpperRow(NCollection_Array2_Standard_Boolean self) -> Standard_Integer

        UpperRow

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Standard_Boolean_UpperRow(self, *args)


    def LowerCol(self, *args):
        """
        LowerCol(NCollection_Array2_Standard_Boolean self) -> Standard_Integer

        LowerCol

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Standard_Boolean_LowerCol(self, *args)


    def UpperCol(self, *args):
        """
        UpperCol(NCollection_Array2_Standard_Boolean self) -> Standard_Integer

        UpperCol

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Standard_Boolean_UpperCol(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array2_Standard_Boolean self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Array2_Standard_Boolean_IsDeletable(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array2_Standard_Boolean self, NCollection_Array2_Standard_Boolean theOther) -> NCollection_Array2_Standard_Boolean

        Assignment

        :type theOther: OCC.wrapper.NCollection.NCollection_Array2
        :rtype: OCC.wrapper.NCollection.NCollection_Array2

        """
        return _TColStd.NCollection_Array2_Standard_Boolean_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array2_Standard_Boolean self, NCollection_Array2_Standard_Boolean theOther) -> NCollection_Array2_Standard_Boolean

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Array2
        :rtype: OCC.wrapper.NCollection.NCollection_Array2

        """
        return _TColStd.NCollection_Array2_Standard_Boolean_assign(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theRow: int
        :type theCol: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array2_Standard_Boolean_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array2_Standard_Boolean self, Standard_Integer const theRow, Standard_Integer const theCol) -> bool &

        Variable value access

        :type theRow: int
        :type theCol: int
        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Array2_Standard_Boolean_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to ChangeValue

        :type theRow: int
        :type theCol: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array2_Standard_Boolean___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array2_Standard_Boolean self, Standard_Integer const theRow, Standard_Integer const theCol, bool const & theItem)

        SetValue

        :type theRow: int
        :type theCol: int
        :type theItem: const TheItemType &

        """
        return _TColStd.NCollection_Array2_Standard_Boolean_SetValue(self, *args)

    __swig_destroy__ = _TColStd.delete_NCollection_Array2_Standard_Boolean
NCollection_Array2_Standard_Boolean_swigregister = _TColStd.NCollection_Array2_Standard_Boolean_swigregister
NCollection_Array2_Standard_Boolean_swigregister(NCollection_Array2_Standard_Boolean)


try:
	TColStd_Array2OfBoolean = NCollection_Array2_Standard_Boolean
except NameError:
	pass # does not exist, probably ignored

class NCollection_Map_TCollection_AsciiString_TCollection_AsciiString(NCollection.NCollection_BaseMap):
    """
    Purpose:     Single hashed Map. This  Map is used  to store and
    retrieve keys in linear time.

    The ::Iterator class can be  used to explore  the
    content of the map. It is not  wise to iterate and
    modify a map in parallel.

    To compute  the hashcode of  the key the  function
    ::HashCode must be defined in the global namespace

    To compare two keys the function ::IsEqual must be
    defined in the global namespace.

    The performance of  a Map is conditionned  by  its
    number of buckets that  should be kept greater  to
    the number   of keys.  This  map has  an automatic
    management of the number of buckets. It is resized
    when  the number of Keys  becomes greater than the
    number of buckets.

    If you have a fair  idea of the number of  objects
    you  can save on automatic   resizing by giving  a
    number of buckets  at creation or using the ReSize
    method. This should be  consider only for  crucial
    optimisation issues.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def cbegin(self, *args):
        """
        cbegin(NCollection_Map_TCollection_AsciiString_TCollection_AsciiString self) -> NCollection_Map< TCollection_AsciiString,TCollection_AsciiString >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Map_TCollection_AsciiString_TCollection_AsciiString_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Map_TCollection_AsciiString_TCollection_AsciiString self) -> NCollection_Map< TCollection_AsciiString,TCollection_AsciiString >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Map_TCollection_AsciiString_TCollection_AsciiString_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Single hashed Map. This  Map is used  to store and
        retrieve keys in linear time.

        The ::Iterator class can be  used to explore  the
        content of the map. It is not  wise to iterate and
        modify a map in parallel.

        To compute  the hashcode of  the key the  function
        ::HashCode must be defined in the global namespace

        To compare two keys the function ::IsEqual must be
        defined in the global namespace.

        The performance of  a Map is conditionned  by  its
        number of buckets that  should be kept greater  to
        the number   of keys.  This  map has  an automatic
        management of the number of buckets. It is resized
        when  the number of Keys  becomes greater than the
        number of buckets.

        If you have a fair  idea of the number of  objects
        you  can save on automatic   resizing by giving  a
        number of buckets  at creation or using the ReSize
        method. This should be  consider only for  crucial
        optimisation issues.
        """
        this = _TColStd.new_NCollection_Map_TCollection_AsciiString_TCollection_AsciiString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_Map_TCollection_AsciiString_TCollection_AsciiString self, NCollection_Map_TCollection_AsciiString_TCollection_AsciiString theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TColStd.NCollection_Map_TCollection_AsciiString_TCollection_AsciiString_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Map_TCollection_AsciiString_TCollection_AsciiString self, NCollection_Map_TCollection_AsciiString_TCollection_AsciiString theOther) -> NCollection_Map_TCollection_AsciiString_TCollection_AsciiString

        Assign.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TColStd.NCollection_Map_TCollection_AsciiString_TCollection_AsciiString_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Map_TCollection_AsciiString_TCollection_AsciiString self, NCollection_Map_TCollection_AsciiString_TCollection_AsciiString theOther) -> NCollection_Map_TCollection_AsciiString_TCollection_AsciiString

        Assign operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TColStd.NCollection_Map_TCollection_AsciiString_TCollection_AsciiString_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_Map_TCollection_AsciiString_TCollection_AsciiString self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TColStd.NCollection_Map_TCollection_AsciiString_TCollection_AsciiString_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_Map_TCollection_AsciiString_TCollection_AsciiString self, TCollection_AsciiString K) -> Standard_Boolean

        Add

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_TCollection_AsciiString_TCollection_AsciiString_Add(self, *args)


    def Added(self, *args):
        """
        Added: add a new key if not yet in the map, and return 
        reference to either newly added or previously existing object

        :type K: const TheKeyType &
        :rtype: const TheKeyType &

        """
        res = _TColStd.NCollection_Map_TCollection_AsciiString_TCollection_AsciiString_Added(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Remove(self, *args):
        """
        Remove(NCollection_Map_TCollection_AsciiString_TCollection_AsciiString self, TCollection_AsciiString K) -> Standard_Boolean

        Remove

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_TCollection_AsciiString_TCollection_AsciiString_Remove(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_Map_TCollection_AsciiString_TCollection_AsciiString self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_Map_TCollection_AsciiString_TCollection_AsciiString self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_Map_TCollection_AsciiString_TCollection_AsciiString_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Map_TCollection_AsciiString_TCollection_AsciiString self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Map_TCollection_AsciiString_TCollection_AsciiString_Size(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(NCollection_Map_TCollection_AsciiString_TCollection_AsciiString self, NCollection_Map_TCollection_AsciiString_TCollection_AsciiString theOther) -> Standard_Boolean

        @return true if two maps contains exactly the same keys

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_TCollection_AsciiString_TCollection_AsciiString_IsEqual(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_Map_TCollection_AsciiString_TCollection_AsciiString self, TCollection_AsciiString K) -> Standard_Boolean
        Contains(NCollection_Map_TCollection_AsciiString_TCollection_AsciiString self, NCollection_Map_TCollection_AsciiString_TCollection_AsciiString theOther) -> Standard_Boolean

        @return true if this map contains ALL keys of another map.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_TCollection_AsciiString_TCollection_AsciiString_Contains(self, *args)


    def Union(self, *args):
        """
        Union(NCollection_Map_TCollection_AsciiString_TCollection_AsciiString self, NCollection_Map_TCollection_AsciiString_TCollection_AsciiString theLeft, NCollection_Map_TCollection_AsciiString_TCollection_AsciiString theRight)

        Sets this Map to be the result of union (aka addition, fuse, merge, boolean OR) operation between two given Maps
        The new Map contains the values that are contained either in the first map or in the second map or in both.
        All previous content of this Map is cleared.
        This map (result of the boolean operation) can also be passed as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TColStd.NCollection_Map_TCollection_AsciiString_TCollection_AsciiString_Union(self, *args)


    def Unite(self, *args):
        """
        Unite(NCollection_Map_TCollection_AsciiString_TCollection_AsciiString self, NCollection_Map_TCollection_AsciiString_TCollection_AsciiString theOther) -> Standard_Boolean

        Apply to this Map the boolean operation union (aka addition, fuse, merge, boolean OR) with another (given) Map.
        The result contains the values that were previously contained in this map or contained in the given (operand) map.
        This algorithm is similar to method Union().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_TCollection_AsciiString_TCollection_AsciiString_Unite(self, *args)


    def HasIntersection(self, *args):
        """
        HasIntersection(NCollection_Map_TCollection_AsciiString_TCollection_AsciiString self, NCollection_Map_TCollection_AsciiString_TCollection_AsciiString theMap) -> Standard_Boolean

        Returns true if this and theMap have common elements.

        :type theMap: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_TCollection_AsciiString_TCollection_AsciiString_HasIntersection(self, *args)


    def Intersection(self, *args):
        """
        Intersection(NCollection_Map_TCollection_AsciiString_TCollection_AsciiString self, NCollection_Map_TCollection_AsciiString_TCollection_AsciiString theLeft, NCollection_Map_TCollection_AsciiString_TCollection_AsciiString theRight)

        Sets this Map to be the result of intersection (aka multiplication, common, boolean AND) operation between two given Maps.
        The new Map contains only the values that are contained in both map operands.
        All previous content of this Map is cleared.
        This same map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TColStd.NCollection_Map_TCollection_AsciiString_TCollection_AsciiString_Intersection(self, *args)


    def Intersect(self, *args):
        """
        Intersect(NCollection_Map_TCollection_AsciiString_TCollection_AsciiString self, NCollection_Map_TCollection_AsciiString_TCollection_AsciiString theOther) -> Standard_Boolean

        Apply to this Map the intersection operation (aka multiplication, common, boolean AND) with another (given) Map.
        The result contains only the values that are contained in both this and the given maps.
        This algorithm is similar to method Intersection().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_TCollection_AsciiString_TCollection_AsciiString_Intersect(self, *args)


    def Subtraction(self, *args):
        """
        Subtraction(NCollection_Map_TCollection_AsciiString_TCollection_AsciiString self, NCollection_Map_TCollection_AsciiString_TCollection_AsciiString theLeft, NCollection_Map_TCollection_AsciiString_TCollection_AsciiString theRight)

        Sets this Map to be the result of subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation between two given Maps.
        The new Map contains only the values that are contained in the first map operands and not contained in the second one.
        All previous content of this Map is cleared.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TColStd.NCollection_Map_TCollection_AsciiString_TCollection_AsciiString_Subtraction(self, *args)


    def Subtract(self, *args):
        """
        Subtract(NCollection_Map_TCollection_AsciiString_TCollection_AsciiString self, NCollection_Map_TCollection_AsciiString_TCollection_AsciiString theOther) -> Standard_Boolean

        Apply to this Map the subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation with another (given) Map.
        The result contains only the values that were previously contained in this map and not contained in this map.
        This algorithm is similar to method Subtract() with two operands.
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_TCollection_AsciiString_TCollection_AsciiString_Subtract(self, *args)


    def Difference(self, *args):
        """
        Difference(NCollection_Map_TCollection_AsciiString_TCollection_AsciiString self, NCollection_Map_TCollection_AsciiString_TCollection_AsciiString theLeft, NCollection_Map_TCollection_AsciiString_TCollection_AsciiString theRight)

        Sets this Map to be the result of symmetric difference (aka exclusive disjunction, boolean XOR) operation between two given Maps.
        The new Map contains the values that are contained only in the first or the second operand maps but not in both.
        All previous content of this Map is cleared. This map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TColStd.NCollection_Map_TCollection_AsciiString_TCollection_AsciiString_Difference(self, *args)


    def Differ(self, *args):
        """
        Differ(NCollection_Map_TCollection_AsciiString_TCollection_AsciiString self, NCollection_Map_TCollection_AsciiString_TCollection_AsciiString theOther) -> Standard_Boolean

        Apply to this Map the symmetric difference (aka exclusive disjunction, boolean XOR) operation with another (given) Map.
        The result contains the values that are contained only in this or the operand map, but not in both.
        This algorithm is similar to method Difference().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_TCollection_AsciiString_TCollection_AsciiString_Differ(self, *args)


    def __iter__(self):
        return _TColStd.NCollection_Map_TCollection_AsciiString_TCollection_AsciiString___iter__(self)
    __swig_destroy__ = _TColStd.delete_NCollection_Map_TCollection_AsciiString_TCollection_AsciiString
NCollection_Map_TCollection_AsciiString_TCollection_AsciiString_swigregister = _TColStd.NCollection_Map_TCollection_AsciiString_TCollection_AsciiString_swigregister
NCollection_Map_TCollection_AsciiString_TCollection_AsciiString_swigregister(NCollection_Map_TCollection_AsciiString_TCollection_AsciiString)

class NCollection_Map_TCollection_AsciiString_TCollection_AsciiString_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TColStd.new_NCollection_Map_TCollection_AsciiString_TCollection_AsciiString_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TColStd.delete_NCollection_Map_TCollection_AsciiString_TCollection_AsciiString_IteratorHelper

    def __next__(self):
        return _TColStd.NCollection_Map_TCollection_AsciiString_TCollection_AsciiString_IteratorHelper___next__(self)
NCollection_Map_TCollection_AsciiString_TCollection_AsciiString_IteratorHelper_swigregister = _TColStd.NCollection_Map_TCollection_AsciiString_TCollection_AsciiString_IteratorHelper_swigregister
NCollection_Map_TCollection_AsciiString_TCollection_AsciiString_IteratorHelper_swigregister(NCollection_Map_TCollection_AsciiString_TCollection_AsciiString_IteratorHelper)


try:
	TColStd_MapOfAsciiString = NCollection_Map_TCollection_AsciiString_TCollection_AsciiString
except NameError:
	pass # does not exist, probably ignored

class Handle_TColStd_HSequenceOfInteger(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TColStd_HSequenceOfInteger self)

        Nullify the handle


        """
        return _TColStd.Handle_TColStd_HSequenceOfInteger_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TColStd_HSequenceOfInteger self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TColStd.Handle_TColStd_HSequenceOfInteger_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TColStd_HSequenceOfInteger self, TColStd_HSequenceOfInteger thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TColStd.Handle_TColStd_HSequenceOfInteger_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TColStd_HSequenceOfInteger self, Handle_TColStd_HSequenceOfInteger theHandle) -> Handle_TColStd_HSequenceOfInteger
        assign(Handle_TColStd_HSequenceOfInteger self, TColStd_HSequenceOfInteger thePtr) -> Handle_TColStd_HSequenceOfInteger
        assign(Handle_TColStd_HSequenceOfInteger self, Handle_TColStd_HSequenceOfInteger theHandle) -> Handle_TColStd_HSequenceOfInteger

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TColStd.Handle_TColStd_HSequenceOfInteger_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TColStd_HSequenceOfInteger self) -> TColStd_HSequenceOfInteger

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HSequenceOfInteger_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TColStd_HSequenceOfInteger self) -> TColStd_HSequenceOfInteger

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HSequenceOfInteger___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TColStd_HSequenceOfInteger self) -> TColStd_HSequenceOfInteger

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TColStd.Handle_TColStd_HSequenceOfInteger___ref__(self, *args)


    def __hash__(self):
        return _TColStd.Handle_TColStd_HSequenceOfInteger___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TColStd.Handle_TColStd_HSequenceOfInteger___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TColStd.new_Handle_TColStd_HSequenceOfInteger(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TColStd.Handle_TColStd_HSequenceOfInteger_DownCast)
    __swig_destroy__ = _TColStd.delete_Handle_TColStd_HSequenceOfInteger

    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfInteger

        """
        res = _TColStd.Handle_TColStd_HSequenceOfInteger_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Handle_TColStd_HSequenceOfInteger self, TColStd_SequenceOfInteger::value_type const & theItem)
        Append(Handle_TColStd_HSequenceOfInteger self, NCollection_Sequence_Standard_Integer theSequence)

        :type theSequence: OCC.wrapper.TColStd.TColStd_SequenceOfInteger

        """
        return _TColStd.Handle_TColStd_HSequenceOfInteger_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Handle_TColStd_HSequenceOfInteger self) -> NCollection_Sequence_Standard_Integer

        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfInteger

        """
        return _TColStd.Handle_TColStd_HSequenceOfInteger_ChangeSequence(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TColStd_HSequenceOfInteger self) -> char const *

        :rtype: const char *

        """
        return _TColStd.Handle_TColStd_HSequenceOfInteger_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HSequenceOfInteger_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HSequenceOfInteger_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TColStd_HSequenceOfInteger self)

        Memory deallocator for transient classes


        """
        return _TColStd.Handle_TColStd_HSequenceOfInteger_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TColStd_HSequenceOfInteger self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TColStd_HSequenceOfInteger self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HSequenceOfInteger_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TColStd_HSequenceOfInteger self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TColStd_HSequenceOfInteger self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HSequenceOfInteger_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TColStd_HSequenceOfInteger self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TColStd.Handle_TColStd_HSequenceOfInteger_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TColStd_HSequenceOfInteger self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HSequenceOfInteger_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TColStd_HSequenceOfInteger self)

        Increments the reference counter of this object


        """
        return _TColStd.Handle_TColStd_HSequenceOfInteger_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TColStd_HSequenceOfInteger self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HSequenceOfInteger_DecrementRefCounter(self, *args)

Handle_TColStd_HSequenceOfInteger_swigregister = _TColStd.Handle_TColStd_HSequenceOfInteger_swigregister
Handle_TColStd_HSequenceOfInteger_swigregister(Handle_TColStd_HSequenceOfInteger)

def Handle_TColStd_HSequenceOfInteger_DownCast(thing):
    return _TColStd.Handle_TColStd_HSequenceOfInteger_DownCast(thing)
Handle_TColStd_HSequenceOfInteger_DownCast = _TColStd.Handle_TColStd_HSequenceOfInteger_DownCast

class Handle_TColStd_HSequenceOfAsciiString(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TColStd_HSequenceOfAsciiString self)

        Nullify the handle


        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TColStd_HSequenceOfAsciiString self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TColStd_HSequenceOfAsciiString self, TColStd_HSequenceOfAsciiString thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TColStd_HSequenceOfAsciiString self, Handle_TColStd_HSequenceOfAsciiString theHandle) -> Handle_TColStd_HSequenceOfAsciiString
        assign(Handle_TColStd_HSequenceOfAsciiString self, TColStd_HSequenceOfAsciiString thePtr) -> Handle_TColStd_HSequenceOfAsciiString
        assign(Handle_TColStd_HSequenceOfAsciiString self, Handle_TColStd_HSequenceOfAsciiString theHandle) -> Handle_TColStd_HSequenceOfAsciiString

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TColStd_HSequenceOfAsciiString self) -> TColStd_HSequenceOfAsciiString

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TColStd_HSequenceOfAsciiString self) -> TColStd_HSequenceOfAsciiString

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TColStd_HSequenceOfAsciiString self) -> TColStd_HSequenceOfAsciiString

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString___ref__(self, *args)


    def __hash__(self):
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TColStd.Handle_TColStd_HSequenceOfAsciiString___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TColStd.new_Handle_TColStd_HSequenceOfAsciiString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TColStd.Handle_TColStd_HSequenceOfAsciiString_DownCast)
    __swig_destroy__ = _TColStd.delete_Handle_TColStd_HSequenceOfAsciiString

    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString

        """
        res = _TColStd.Handle_TColStd_HSequenceOfAsciiString_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Handle_TColStd_HSequenceOfAsciiString self, TCollection_AsciiString theItem)
        Append(Handle_TColStd_HSequenceOfAsciiString self, NCollection_Sequence_TCollection_AsciiString theSequence)

        :type theSequence: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Handle_TColStd_HSequenceOfAsciiString self) -> NCollection_Sequence_TCollection_AsciiString

        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfAsciiString

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_ChangeSequence(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TColStd_HSequenceOfAsciiString self) -> char const *

        :rtype: const char *

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HSequenceOfAsciiString_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HSequenceOfAsciiString_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def begin(self, *args):
        """
        begin(Handle_TColStd_HSequenceOfAsciiString self) -> NCollection_Sequence< TCollection_AsciiString >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_begin(self, *args)


    def end(self, *args):
        """
        end(Handle_TColStd_HSequenceOfAsciiString self) -> NCollection_Sequence< TCollection_AsciiString >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(Handle_TColStd_HSequenceOfAsciiString self) -> NCollection_Sequence< TCollection_AsciiString >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(Handle_TColStd_HSequenceOfAsciiString self) -> NCollection_Sequence< TCollection_AsciiString >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_cend(self, *args)


    def Size(self, *args):
        """
        Size(Handle_TColStd_HSequenceOfAsciiString self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_Size(self, *args)


    def Length(self, *args):
        """
        Length(Handle_TColStd_HSequenceOfAsciiString self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(Handle_TColStd_HSequenceOfAsciiString self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(Handle_TColStd_HSequenceOfAsciiString self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_TColStd_HSequenceOfAsciiString self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(Handle_TColStd_HSequenceOfAsciiString self)

        Reverse sequence


        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(Handle_TColStd_HSequenceOfAsciiString self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_Exchange(self, *args)


    def delNode(self, *args):
        """
        delNode(Handle_TColStd_HSequenceOfAsciiString self, NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_delNode(self, *args)


    def Clear(self, *args):
        """
        Clear(Handle_TColStd_HSequenceOfAsciiString self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(Handle_TColStd_HSequenceOfAsciiString self, NCollection_Sequence_TCollection_AsciiString theOther) -> NCollection_Sequence_TCollection_AsciiString

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_Assign(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_TColStd_HSequenceOfAsciiString self, NCollection_Sequence< TCollection_AsciiString >::Iterator & thePosition)
        Remove(Handle_TColStd_HSequenceOfAsciiString self, Standard_Integer const theIndex)
        Remove(Handle_TColStd_HSequenceOfAsciiString self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_Remove(self, *args)


    def Prepend(self, *args):
        """
        Prepend(Handle_TColStd_HSequenceOfAsciiString self, TCollection_AsciiString theItem)
        Prepend(Handle_TColStd_HSequenceOfAsciiString self, NCollection_Sequence_TCollection_AsciiString theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(Handle_TColStd_HSequenceOfAsciiString self, Standard_Integer const theIndex, TCollection_AsciiString theItem)
        InsertBefore(Handle_TColStd_HSequenceOfAsciiString self, Standard_Integer const theIndex, NCollection_Sequence_TCollection_AsciiString theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(Handle_TColStd_HSequenceOfAsciiString self, NCollection_Sequence< TCollection_AsciiString >::Iterator & thePosition, TCollection_AsciiString theItem)
        InsertAfter(Handle_TColStd_HSequenceOfAsciiString self, Standard_Integer const theIndex, NCollection_Sequence_TCollection_AsciiString theSeq)
        InsertAfter(Handle_TColStd_HSequenceOfAsciiString self, Standard_Integer const theIndex, TCollection_AsciiString theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(Handle_TColStd_HSequenceOfAsciiString self, Standard_Integer const theIndex, NCollection_Sequence_TCollection_AsciiString theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _TColStd.Handle_TColStd_HSequenceOfAsciiString_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(Handle_TColStd_HSequenceOfAsciiString self) -> TCollection_AsciiString

        First item access

        :rtype: TheItemType &

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _TColStd.Handle_TColStd_HSequenceOfAsciiString_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(Handle_TColStd_HSequenceOfAsciiString self) -> TCollection_AsciiString

        Last item access

        :rtype: TheItemType &

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.Handle_TColStd_HSequenceOfAsciiString_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.Handle_TColStd_HSequenceOfAsciiString___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(Handle_TColStd_HSequenceOfAsciiString self, Standard_Integer const theIndex) -> TCollection_AsciiString

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_TColStd_HSequenceOfAsciiString self, Standard_Integer const theIndex, TCollection_AsciiString theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_SetValue(self, *args)


    def __iter__(self):
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString___iter__(self)

    def Allocator(self, *args):
        """
        Returns attached allocator

        :rtype: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        res = _TColStd.Handle_TColStd_HSequenceOfAsciiString_Allocator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TColStd_HSequenceOfAsciiString self)

        Memory deallocator for transient classes


        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TColStd_HSequenceOfAsciiString self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TColStd_HSequenceOfAsciiString self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TColStd_HSequenceOfAsciiString self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TColStd_HSequenceOfAsciiString self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TColStd_HSequenceOfAsciiString self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TColStd_HSequenceOfAsciiString self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TColStd_HSequenceOfAsciiString self)

        Increments the reference counter of this object


        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TColStd_HSequenceOfAsciiString self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HSequenceOfAsciiString_DecrementRefCounter(self, *args)

Handle_TColStd_HSequenceOfAsciiString_swigregister = _TColStd.Handle_TColStd_HSequenceOfAsciiString_swigregister
Handle_TColStd_HSequenceOfAsciiString_swigregister(Handle_TColStd_HSequenceOfAsciiString)

def Handle_TColStd_HSequenceOfAsciiString_DownCast(thing):
    return _TColStd.Handle_TColStd_HSequenceOfAsciiString_DownCast(thing)
Handle_TColStd_HSequenceOfAsciiString_DownCast = _TColStd.Handle_TColStd_HSequenceOfAsciiString_DownCast

class NCollection_Sequence_Standard_Real(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Standard_Real self) -> NCollection_Sequence< Standard_Real >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _TColStd.NCollection_Sequence_Standard_Real_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Standard_Real self) -> NCollection_Sequence< Standard_Real >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _TColStd.NCollection_Sequence_Standard_Real_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Standard_Real self) -> NCollection_Sequence< Standard_Real >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Sequence_Standard_Real_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Standard_Real self) -> NCollection_Sequence< Standard_Real >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Sequence_Standard_Real_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _TColStd.new_NCollection_Sequence_Standard_Real(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Standard_Real self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_Standard_Real_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Standard_Real self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_Standard_Real_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Standard_Real self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_Standard_Real_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Standard_Real self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_Standard_Real_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Standard_Real self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Sequence_Standard_Real_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Standard_Real self)

        Reverse sequence


        """
        return _TColStd.NCollection_Sequence_Standard_Real_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Standard_Real self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _TColStd.NCollection_Sequence_Standard_Real_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_Sequence_Standard_Real_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Standard_Real self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_Sequence_Standard_Real_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Standard_Real self, NCollection_Sequence_Standard_Real theOther) -> NCollection_Sequence_Standard_Real

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Standard_Real_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Standard_Real self, NCollection_Sequence_Standard_Real theOther) -> NCollection_Sequence_Standard_Real

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Standard_Real_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Standard_Real self, NCollection_Sequence< Standard_Real >::Iterator & thePosition)
        Remove(NCollection_Sequence_Standard_Real self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Standard_Real self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _TColStd.NCollection_Sequence_Standard_Real_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Standard_Real self, double const & theItem)
        Append(NCollection_Sequence_Standard_Real self, NCollection_Sequence_Standard_Real theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Standard_Real_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Standard_Real self, double const & theItem)
        Prepend(NCollection_Sequence_Standard_Real self, NCollection_Sequence_Standard_Real theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Standard_Real_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Standard_Real self, Standard_Integer const theIndex, double const & theItem)
        InsertBefore(NCollection_Sequence_Standard_Real self, Standard_Integer const theIndex, NCollection_Sequence_Standard_Real theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Standard_Real_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Standard_Real self, NCollection_Sequence< Standard_Real >::Iterator & thePosition, double const & theItem)
        InsertAfter(NCollection_Sequence_Standard_Real self, Standard_Integer const theIndex, NCollection_Sequence_Standard_Real theSeq)
        InsertAfter(NCollection_Sequence_Standard_Real self, Standard_Integer const theIndex, double const & theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TColStd.NCollection_Sequence_Standard_Real_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Standard_Real self, Standard_Integer const theIndex, NCollection_Sequence_Standard_Real theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Standard_Real_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_Standard_Real_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Standard_Real self) -> double &

        First item access

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Sequence_Standard_Real_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_Standard_Real_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Standard_Real self) -> double &

        Last item access

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Sequence_Standard_Real_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_Standard_Real_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Standard_Real self, Standard_Integer const theIndex) -> double &

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Sequence_Standard_Real_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_Standard_Real___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Standard_Real self, Standard_Integer const theIndex, double const & theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TColStd.NCollection_Sequence_Standard_Real_SetValue(self, *args)


    def __iter__(self):
        return _TColStd.NCollection_Sequence_Standard_Real___iter__(self)
    __swig_destroy__ = _TColStd.delete_NCollection_Sequence_Standard_Real
NCollection_Sequence_Standard_Real_swigregister = _TColStd.NCollection_Sequence_Standard_Real_swigregister
NCollection_Sequence_Standard_Real_swigregister(NCollection_Sequence_Standard_Real)

def NCollection_Sequence_Standard_Real_delNode(*args):
    """
    NCollection_Sequence_Standard_Real_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _TColStd.NCollection_Sequence_Standard_Real_delNode(*args)

class NCollection_Sequence_Standard_Real_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TColStd.new_NCollection_Sequence_Standard_Real_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TColStd.delete_NCollection_Sequence_Standard_Real_IteratorHelper

    def __next__(self):
        return _TColStd.NCollection_Sequence_Standard_Real_IteratorHelper___next__(self)
NCollection_Sequence_Standard_Real_IteratorHelper_swigregister = _TColStd.NCollection_Sequence_Standard_Real_IteratorHelper_swigregister
NCollection_Sequence_Standard_Real_IteratorHelper_swigregister(NCollection_Sequence_Standard_Real_IteratorHelper)


try:
	TColStd_SequenceOfReal = NCollection_Sequence_Standard_Real
except NameError:
	pass # does not exist, probably ignored

class NCollection_List_Standard_Integer(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_Standard_Integer self) -> NCollection_List< Standard_Integer >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _TColStd.NCollection_List_Standard_Integer_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_Standard_Integer self) -> NCollection_List< Standard_Integer >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _TColStd.NCollection_List_Standard_Integer_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_Standard_Integer self) -> NCollection_List< Standard_Integer >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_List_Standard_Integer_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_Standard_Integer self) -> NCollection_List< Standard_Integer >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_List_Standard_Integer_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _TColStd.new_NCollection_List_Standard_Integer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_Standard_Integer self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_List_Standard_Integer_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_Standard_Integer self, NCollection_List_Standard_Integer theOther) -> NCollection_List_Standard_Integer

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _TColStd.NCollection_List_Standard_Integer_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_Standard_Integer self, NCollection_List_Standard_Integer theOther) -> NCollection_List_Standard_Integer

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _TColStd.NCollection_List_Standard_Integer_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_Standard_Integer self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_List_Standard_Integer_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_List_Standard_Integer_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_List_Standard_Integer_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_Standard_Integer self, int const & theItem) -> int
        Append(NCollection_List_Standard_Integer self, int const & theItem, NCollection_List< Standard_Integer >::Iterator & theIter)
        Append(NCollection_List_Standard_Integer self, NCollection_List_Standard_Integer theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _TColStd.NCollection_List_Standard_Integer_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_Standard_Integer self, int const & theItem) -> int
        Prepend(NCollection_List_Standard_Integer self, NCollection_List_Standard_Integer theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _TColStd.NCollection_List_Standard_Integer_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_Standard_Integer self)

        RemoveFirst item


        """
        return _TColStd.NCollection_List_Standard_Integer_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_Standard_Integer self, NCollection_List< Standard_Integer >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _TColStd.NCollection_List_Standard_Integer_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_Standard_Integer self, int const & theItem, NCollection_List< Standard_Integer >::Iterator & theIter) -> int
        InsertBefore(NCollection_List_Standard_Integer self, NCollection_List_Standard_Integer theOther, NCollection_List< Standard_Integer >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _TColStd.NCollection_List_Standard_Integer_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_Standard_Integer self, int const & theItem, NCollection_List< Standard_Integer >::Iterator & theIter) -> int
        InsertAfter(NCollection_List_Standard_Integer self, NCollection_List_Standard_Integer theOther, NCollection_List< Standard_Integer >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _TColStd.NCollection_List_Standard_Integer_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_Standard_Integer self)

        Reverse the list


        """
        return _TColStd.NCollection_List_Standard_Integer_Reverse(self, *args)


    def __iter__(self):
        return _TColStd.NCollection_List_Standard_Integer___iter__(self)
    __swig_destroy__ = _TColStd.delete_NCollection_List_Standard_Integer
NCollection_List_Standard_Integer_swigregister = _TColStd.NCollection_List_Standard_Integer_swigregister
NCollection_List_Standard_Integer_swigregister(NCollection_List_Standard_Integer)

class NCollection_List_Standard_Integer_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TColStd.new_NCollection_List_Standard_Integer_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TColStd.delete_NCollection_List_Standard_Integer_IteratorHelper

    def __next__(self):
        return _TColStd.NCollection_List_Standard_Integer_IteratorHelper___next__(self)
NCollection_List_Standard_Integer_IteratorHelper_swigregister = _TColStd.NCollection_List_Standard_Integer_IteratorHelper_swigregister
NCollection_List_Standard_Integer_IteratorHelper_swigregister(NCollection_List_Standard_Integer_IteratorHelper)


try:
	TColStd_ListOfInteger = NCollection_List_Standard_Integer
except NameError:
	pass # does not exist, probably ignored

class Handle_TColStd_HArray1OfCharacter(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TColStd_HArray1OfCharacter self)

        Nullify the handle


        """
        return _TColStd.Handle_TColStd_HArray1OfCharacter_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TColStd_HArray1OfCharacter self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TColStd.Handle_TColStd_HArray1OfCharacter_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TColStd_HArray1OfCharacter self, TColStd_HArray1OfCharacter thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TColStd.Handle_TColStd_HArray1OfCharacter_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TColStd_HArray1OfCharacter self, Handle_TColStd_HArray1OfCharacter theHandle) -> Handle_TColStd_HArray1OfCharacter
        assign(Handle_TColStd_HArray1OfCharacter self, TColStd_HArray1OfCharacter thePtr) -> Handle_TColStd_HArray1OfCharacter
        assign(Handle_TColStd_HArray1OfCharacter self, Handle_TColStd_HArray1OfCharacter theHandle) -> Handle_TColStd_HArray1OfCharacter

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TColStd.Handle_TColStd_HArray1OfCharacter_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TColStd_HArray1OfCharacter self) -> TColStd_HArray1OfCharacter

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HArray1OfCharacter_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TColStd_HArray1OfCharacter self) -> TColStd_HArray1OfCharacter

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HArray1OfCharacter___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TColStd_HArray1OfCharacter self) -> TColStd_HArray1OfCharacter

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TColStd.Handle_TColStd_HArray1OfCharacter___ref__(self, *args)


    def __hash__(self):
        return _TColStd.Handle_TColStd_HArray1OfCharacter___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TColStd.Handle_TColStd_HArray1OfCharacter___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TColStd.new_Handle_TColStd_HArray1OfCharacter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TColStd.Handle_TColStd_HArray1OfCharacter_DownCast)
    __swig_destroy__ = _TColStd.delete_Handle_TColStd_HArray1OfCharacter

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfCharacter

        """
        res = _TColStd.Handle_TColStd_HArray1OfCharacter_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_TColStd_HArray1OfCharacter self) -> NCollection_Array1_Standard_Character

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfCharacter

        """
        return _TColStd.Handle_TColStd_HArray1OfCharacter_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TColStd_HArray1OfCharacter self) -> char const *

        :rtype: const char *

        """
        return _TColStd.Handle_TColStd_HArray1OfCharacter_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HArray1OfCharacter_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HArray1OfCharacter_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TColStd_HArray1OfCharacter self)

        Memory deallocator for transient classes


        """
        return _TColStd.Handle_TColStd_HArray1OfCharacter_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TColStd_HArray1OfCharacter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TColStd_HArray1OfCharacter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HArray1OfCharacter_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TColStd_HArray1OfCharacter self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TColStd_HArray1OfCharacter self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HArray1OfCharacter_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TColStd_HArray1OfCharacter self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TColStd.Handle_TColStd_HArray1OfCharacter_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TColStd_HArray1OfCharacter self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray1OfCharacter_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TColStd_HArray1OfCharacter self)

        Increments the reference counter of this object


        """
        return _TColStd.Handle_TColStd_HArray1OfCharacter_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TColStd_HArray1OfCharacter self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray1OfCharacter_DecrementRefCounter(self, *args)

Handle_TColStd_HArray1OfCharacter_swigregister = _TColStd.Handle_TColStd_HArray1OfCharacter_swigregister
Handle_TColStd_HArray1OfCharacter_swigregister(Handle_TColStd_HArray1OfCharacter)

def Handle_TColStd_HArray1OfCharacter_DownCast(thing):
    return _TColStd.Handle_TColStd_HArray1OfCharacter_DownCast(thing)
Handle_TColStd_HArray1OfCharacter_DownCast = _TColStd.Handle_TColStd_HArray1OfCharacter_DownCast

class TColStd_HArray1OfBoolean(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TColStd_HArray1OfBoolean
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TColStd_HArray1OfBoolean(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TColStd_HArray1OfBoolean self, Standard_Integer const theLower, Standard_Integer const theUpper) -> TColStd_HArray1OfBoolean
        __init__(TColStd_HArray1OfBoolean self, Standard_Integer const theLower, Standard_Integer const theUpper, TColStd_Array1OfBoolean::value_type const & theValue) -> TColStd_HArray1OfBoolean
        __init__(TColStd_HArray1OfBoolean self, NCollection_Array1_Standard_Boolean theOther) -> TColStd_HArray1OfBoolean

        :type theOther: OCC.wrapper.TColStd.TColStd_Array1OfBoolean

        """
        this = _TColStd.new_TColStd_HArray1OfBoolean(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfBoolean

        """
        res = _TColStd.TColStd_HArray1OfBoolean_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(TColStd_HArray1OfBoolean self) -> NCollection_Array1_Standard_Boolean

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfBoolean

        """
        return _TColStd.TColStd_HArray1OfBoolean_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TColStd.TColStd_HArray1OfBoolean_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TColStd.TColStd_HArray1OfBoolean_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.TColStd_HArray1OfBoolean_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TColStd.delete_TColStd_HArray1OfBoolean
TColStd_HArray1OfBoolean_swigregister = _TColStd.TColStd_HArray1OfBoolean_swigregister
TColStd_HArray1OfBoolean_swigregister(TColStd_HArray1OfBoolean)

def TColStd_HArray1OfBoolean_get_type_name(*args):
    """
    TColStd_HArray1OfBoolean_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TColStd.TColStd_HArray1OfBoolean_get_type_name(*args)

def TColStd_HArray1OfBoolean_get_type_descriptor(*args):
    """
    TColStd_HArray1OfBoolean_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TColStd.TColStd_HArray1OfBoolean_get_type_descriptor(*args)

class NCollection_Array1_TColStd_ListOfInteger(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_TColStd_ListOfInteger self) -> NCollection_Array1< TColStd_ListOfInteger >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _TColStd.NCollection_Array1_TColStd_ListOfInteger_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_TColStd_ListOfInteger self) -> NCollection_Array1< TColStd_ListOfInteger >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _TColStd.NCollection_Array1_TColStd_ListOfInteger_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_TColStd_ListOfInteger self) -> NCollection_Array1< TColStd_ListOfInteger >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Array1_TColStd_ListOfInteger_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_TColStd_ListOfInteger self) -> NCollection_Array1< TColStd_ListOfInteger >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Array1_TColStd_ListOfInteger_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _TColStd.new_NCollection_Array1_TColStd_ListOfInteger(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_TColStd_ListOfInteger self, NCollection_List_Standard_Integer theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _TColStd.NCollection_Array1_TColStd_ListOfInteger_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_TColStd_ListOfInteger self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_TColStd_ListOfInteger_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_TColStd_ListOfInteger self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_TColStd_ListOfInteger_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_TColStd_ListOfInteger self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Array1_TColStd_ListOfInteger_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_TColStd_ListOfInteger self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_TColStd_ListOfInteger_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_TColStd_ListOfInteger self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_TColStd_ListOfInteger_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_TColStd_ListOfInteger self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Array1_TColStd_ListOfInteger_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_TColStd_ListOfInteger self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Array1_TColStd_ListOfInteger_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_TColStd_ListOfInteger self, NCollection_Array1_TColStd_ListOfInteger theOther) -> NCollection_Array1_TColStd_ListOfInteger

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TColStd.NCollection_Array1_TColStd_ListOfInteger_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_TColStd_ListOfInteger self, NCollection_Array1_TColStd_ListOfInteger theOther) -> NCollection_Array1_TColStd_ListOfInteger

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TColStd.NCollection_Array1_TColStd_ListOfInteger_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_TColStd_ListOfInteger self, NCollection_Array1_TColStd_ListOfInteger theOther) -> NCollection_Array1_TColStd_ListOfInteger
        assign(NCollection_Array1_TColStd_ListOfInteger self, NCollection_Array1_TColStd_ListOfInteger theOther) -> NCollection_Array1_TColStd_ListOfInteger

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TColStd.NCollection_Array1_TColStd_ListOfInteger_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_TColStd_ListOfInteger_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_TColStd_ListOfInteger self) -> NCollection_List_Standard_Integer

        @return first element

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Array1_TColStd_ListOfInteger_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_TColStd_ListOfInteger_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_TColStd_ListOfInteger self) -> NCollection_List_Standard_Integer

        @return last element

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Array1_TColStd_ListOfInteger_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_TColStd_ListOfInteger_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_TColStd_ListOfInteger self, Standard_Integer const theIndex) -> NCollection_List_Standard_Integer

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Array1_TColStd_ListOfInteger_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_TColStd_ListOfInteger___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_TColStd_ListOfInteger_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_TColStd_ListOfInteger self, Standard_Integer const theIndex, NCollection_List_Standard_Integer theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TColStd.NCollection_Array1_TColStd_ListOfInteger_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_TColStd_ListOfInteger self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _TColStd.NCollection_Array1_TColStd_ListOfInteger_Resize(self, *args)

    __swig_destroy__ = _TColStd.delete_NCollection_Array1_TColStd_ListOfInteger
NCollection_Array1_TColStd_ListOfInteger_swigregister = _TColStd.NCollection_Array1_TColStd_ListOfInteger_swigregister
NCollection_Array1_TColStd_ListOfInteger_swigregister(NCollection_Array1_TColStd_ListOfInteger)


try:
	TColStd_Array1OfListOfInteger = NCollection_Array1_TColStd_ListOfInteger
except NameError:
	pass # does not exist, probably ignored

class Handle_TColStd_HArray2OfBoolean(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TColStd_HArray2OfBoolean self)

        Nullify the handle


        """
        return _TColStd.Handle_TColStd_HArray2OfBoolean_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TColStd_HArray2OfBoolean self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TColStd.Handle_TColStd_HArray2OfBoolean_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TColStd_HArray2OfBoolean self, TColStd_HArray2OfBoolean thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TColStd.Handle_TColStd_HArray2OfBoolean_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TColStd_HArray2OfBoolean self, Handle_TColStd_HArray2OfBoolean theHandle) -> Handle_TColStd_HArray2OfBoolean
        assign(Handle_TColStd_HArray2OfBoolean self, TColStd_HArray2OfBoolean thePtr) -> Handle_TColStd_HArray2OfBoolean
        assign(Handle_TColStd_HArray2OfBoolean self, Handle_TColStd_HArray2OfBoolean theHandle) -> Handle_TColStd_HArray2OfBoolean

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TColStd.Handle_TColStd_HArray2OfBoolean_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TColStd_HArray2OfBoolean self) -> TColStd_HArray2OfBoolean

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HArray2OfBoolean_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TColStd_HArray2OfBoolean self) -> TColStd_HArray2OfBoolean

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HArray2OfBoolean___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TColStd_HArray2OfBoolean self) -> TColStd_HArray2OfBoolean

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TColStd.Handle_TColStd_HArray2OfBoolean___ref__(self, *args)


    def __hash__(self):
        return _TColStd.Handle_TColStd_HArray2OfBoolean___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TColStd.Handle_TColStd_HArray2OfBoolean___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TColStd.new_Handle_TColStd_HArray2OfBoolean(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TColStd.Handle_TColStd_HArray2OfBoolean_DownCast)
    __swig_destroy__ = _TColStd.delete_Handle_TColStd_HArray2OfBoolean

    def Array2(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array2OfBoolean

        """
        res = _TColStd.Handle_TColStd_HArray2OfBoolean_Array2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray2(self, *args):
        """
        ChangeArray2(Handle_TColStd_HArray2OfBoolean self) -> NCollection_Array2_Standard_Boolean

        :rtype: OCC.wrapper.TColStd.TColStd_Array2OfBoolean

        """
        return _TColStd.Handle_TColStd_HArray2OfBoolean_ChangeArray2(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TColStd_HArray2OfBoolean self) -> char const *

        :rtype: const char *

        """
        return _TColStd.Handle_TColStd_HArray2OfBoolean_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HArray2OfBoolean_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HArray2OfBoolean_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TColStd_HArray2OfBoolean self)

        Memory deallocator for transient classes


        """
        return _TColStd.Handle_TColStd_HArray2OfBoolean_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TColStd_HArray2OfBoolean self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TColStd_HArray2OfBoolean self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HArray2OfBoolean_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TColStd_HArray2OfBoolean self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TColStd_HArray2OfBoolean self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HArray2OfBoolean_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TColStd_HArray2OfBoolean self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TColStd.Handle_TColStd_HArray2OfBoolean_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TColStd_HArray2OfBoolean self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray2OfBoolean_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TColStd_HArray2OfBoolean self)

        Increments the reference counter of this object


        """
        return _TColStd.Handle_TColStd_HArray2OfBoolean_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TColStd_HArray2OfBoolean self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray2OfBoolean_DecrementRefCounter(self, *args)

Handle_TColStd_HArray2OfBoolean_swigregister = _TColStd.Handle_TColStd_HArray2OfBoolean_swigregister
Handle_TColStd_HArray2OfBoolean_swigregister(Handle_TColStd_HArray2OfBoolean)

def Handle_TColStd_HArray2OfBoolean_DownCast(thing):
    return _TColStd.Handle_TColStd_HArray2OfBoolean_DownCast(thing)
Handle_TColStd_HArray2OfBoolean_DownCast = _TColStd.Handle_TColStd_HArray2OfBoolean_DownCast

class NCollection_Sequence_TCollection_ExtendedString(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_TCollection_ExtendedString self) -> NCollection_Sequence< TCollection_ExtendedString >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _TColStd.NCollection_Sequence_TCollection_ExtendedString_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_TCollection_ExtendedString self) -> NCollection_Sequence< TCollection_ExtendedString >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _TColStd.NCollection_Sequence_TCollection_ExtendedString_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_TCollection_ExtendedString self) -> NCollection_Sequence< TCollection_ExtendedString >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Sequence_TCollection_ExtendedString_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_TCollection_ExtendedString self) -> NCollection_Sequence< TCollection_ExtendedString >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Sequence_TCollection_ExtendedString_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _TColStd.new_NCollection_Sequence_TCollection_ExtendedString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_TCollection_ExtendedString self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_TCollection_ExtendedString_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_TCollection_ExtendedString self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_TCollection_ExtendedString_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_TCollection_ExtendedString self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_TCollection_ExtendedString_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_TCollection_ExtendedString self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_TCollection_ExtendedString_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_TCollection_ExtendedString self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Sequence_TCollection_ExtendedString_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_TCollection_ExtendedString self)

        Reverse sequence


        """
        return _TColStd.NCollection_Sequence_TCollection_ExtendedString_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_TCollection_ExtendedString self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _TColStd.NCollection_Sequence_TCollection_ExtendedString_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_Sequence_TCollection_ExtendedString_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_TCollection_ExtendedString self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_Sequence_TCollection_ExtendedString_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_TCollection_ExtendedString self, NCollection_Sequence_TCollection_ExtendedString theOther) -> NCollection_Sequence_TCollection_ExtendedString

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_TCollection_ExtendedString_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_TCollection_ExtendedString self, NCollection_Sequence_TCollection_ExtendedString theOther) -> NCollection_Sequence_TCollection_ExtendedString

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_TCollection_ExtendedString_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_TCollection_ExtendedString self, NCollection_Sequence< TCollection_ExtendedString >::Iterator & thePosition)
        Remove(NCollection_Sequence_TCollection_ExtendedString self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_TCollection_ExtendedString self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _TColStd.NCollection_Sequence_TCollection_ExtendedString_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_TCollection_ExtendedString self, TCollection_ExtendedString theItem)
        Append(NCollection_Sequence_TCollection_ExtendedString self, NCollection_Sequence_TCollection_ExtendedString theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_TCollection_ExtendedString_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_TCollection_ExtendedString self, TCollection_ExtendedString theItem)
        Prepend(NCollection_Sequence_TCollection_ExtendedString self, NCollection_Sequence_TCollection_ExtendedString theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_TCollection_ExtendedString_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_TCollection_ExtendedString self, Standard_Integer const theIndex, TCollection_ExtendedString theItem)
        InsertBefore(NCollection_Sequence_TCollection_ExtendedString self, Standard_Integer const theIndex, NCollection_Sequence_TCollection_ExtendedString theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_TCollection_ExtendedString_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_TCollection_ExtendedString self, NCollection_Sequence< TCollection_ExtendedString >::Iterator & thePosition, TCollection_ExtendedString theItem)
        InsertAfter(NCollection_Sequence_TCollection_ExtendedString self, Standard_Integer const theIndex, NCollection_Sequence_TCollection_ExtendedString theSeq)
        InsertAfter(NCollection_Sequence_TCollection_ExtendedString self, Standard_Integer const theIndex, TCollection_ExtendedString theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TColStd.NCollection_Sequence_TCollection_ExtendedString_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_TCollection_ExtendedString self, Standard_Integer const theIndex, NCollection_Sequence_TCollection_ExtendedString theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_TCollection_ExtendedString_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_TCollection_ExtendedString_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_TCollection_ExtendedString self) -> TCollection_ExtendedString

        First item access

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Sequence_TCollection_ExtendedString_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_TCollection_ExtendedString_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_TCollection_ExtendedString self) -> TCollection_ExtendedString

        Last item access

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Sequence_TCollection_ExtendedString_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_TCollection_ExtendedString_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_TCollection_ExtendedString self, Standard_Integer const theIndex) -> TCollection_ExtendedString

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Sequence_TCollection_ExtendedString_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_TCollection_ExtendedString___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_TCollection_ExtendedString self, Standard_Integer const theIndex, TCollection_ExtendedString theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TColStd.NCollection_Sequence_TCollection_ExtendedString_SetValue(self, *args)


    def __iter__(self):
        return _TColStd.NCollection_Sequence_TCollection_ExtendedString___iter__(self)
    __swig_destroy__ = _TColStd.delete_NCollection_Sequence_TCollection_ExtendedString
NCollection_Sequence_TCollection_ExtendedString_swigregister = _TColStd.NCollection_Sequence_TCollection_ExtendedString_swigregister
NCollection_Sequence_TCollection_ExtendedString_swigregister(NCollection_Sequence_TCollection_ExtendedString)

def NCollection_Sequence_TCollection_ExtendedString_delNode(*args):
    """
    NCollection_Sequence_TCollection_ExtendedString_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _TColStd.NCollection_Sequence_TCollection_ExtendedString_delNode(*args)

class NCollection_Sequence_TCollection_ExtendedString_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TColStd.new_NCollection_Sequence_TCollection_ExtendedString_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TColStd.delete_NCollection_Sequence_TCollection_ExtendedString_IteratorHelper

    def __next__(self):
        return _TColStd.NCollection_Sequence_TCollection_ExtendedString_IteratorHelper___next__(self)
NCollection_Sequence_TCollection_ExtendedString_IteratorHelper_swigregister = _TColStd.NCollection_Sequence_TCollection_ExtendedString_IteratorHelper_swigregister
NCollection_Sequence_TCollection_ExtendedString_IteratorHelper_swigregister(NCollection_Sequence_TCollection_ExtendedString_IteratorHelper)


try:
	TColStd_SequenceOfExtendedString = NCollection_Sequence_TCollection_ExtendedString
except NameError:
	pass # does not exist, probably ignored

class NCollection_Sequence_Standard_Integer(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Standard_Integer self) -> NCollection_Sequence< Standard_Integer >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _TColStd.NCollection_Sequence_Standard_Integer_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Standard_Integer self) -> NCollection_Sequence< Standard_Integer >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _TColStd.NCollection_Sequence_Standard_Integer_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Standard_Integer self) -> NCollection_Sequence< Standard_Integer >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Sequence_Standard_Integer_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Standard_Integer self) -> NCollection_Sequence< Standard_Integer >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Sequence_Standard_Integer_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _TColStd.new_NCollection_Sequence_Standard_Integer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Standard_Integer self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_Standard_Integer_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Standard_Integer self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_Standard_Integer_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Standard_Integer self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_Standard_Integer_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Standard_Integer self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_Standard_Integer_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Standard_Integer self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Sequence_Standard_Integer_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Standard_Integer self)

        Reverse sequence


        """
        return _TColStd.NCollection_Sequence_Standard_Integer_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Standard_Integer self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _TColStd.NCollection_Sequence_Standard_Integer_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_Sequence_Standard_Integer_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Standard_Integer self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_Sequence_Standard_Integer_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Standard_Integer self, NCollection_Sequence_Standard_Integer theOther) -> NCollection_Sequence_Standard_Integer

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Standard_Integer_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Standard_Integer self, NCollection_Sequence_Standard_Integer theOther) -> NCollection_Sequence_Standard_Integer

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Standard_Integer_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Standard_Integer self, NCollection_Sequence< Standard_Integer >::Iterator & thePosition)
        Remove(NCollection_Sequence_Standard_Integer self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Standard_Integer self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _TColStd.NCollection_Sequence_Standard_Integer_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Standard_Integer self, int const & theItem)
        Append(NCollection_Sequence_Standard_Integer self, NCollection_Sequence_Standard_Integer theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Standard_Integer_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Standard_Integer self, int const & theItem)
        Prepend(NCollection_Sequence_Standard_Integer self, NCollection_Sequence_Standard_Integer theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Standard_Integer_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Standard_Integer self, Standard_Integer const theIndex, int const & theItem)
        InsertBefore(NCollection_Sequence_Standard_Integer self, Standard_Integer const theIndex, NCollection_Sequence_Standard_Integer theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Standard_Integer_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Standard_Integer self, NCollection_Sequence< Standard_Integer >::Iterator & thePosition, int const & theItem)
        InsertAfter(NCollection_Sequence_Standard_Integer self, Standard_Integer const theIndex, NCollection_Sequence_Standard_Integer theSeq)
        InsertAfter(NCollection_Sequence_Standard_Integer self, Standard_Integer const theIndex, int const & theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TColStd.NCollection_Sequence_Standard_Integer_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Standard_Integer self, Standard_Integer const theIndex, NCollection_Sequence_Standard_Integer theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Standard_Integer_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_Standard_Integer_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Standard_Integer self) -> int &

        First item access

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Sequence_Standard_Integer_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_Standard_Integer_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Standard_Integer self) -> int &

        Last item access

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Sequence_Standard_Integer_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_Standard_Integer_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Standard_Integer self, Standard_Integer const theIndex) -> int &

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Sequence_Standard_Integer_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_Standard_Integer___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Standard_Integer self, Standard_Integer const theIndex, int const & theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TColStd.NCollection_Sequence_Standard_Integer_SetValue(self, *args)


    def __iter__(self):
        return _TColStd.NCollection_Sequence_Standard_Integer___iter__(self)
    __swig_destroy__ = _TColStd.delete_NCollection_Sequence_Standard_Integer
NCollection_Sequence_Standard_Integer_swigregister = _TColStd.NCollection_Sequence_Standard_Integer_swigregister
NCollection_Sequence_Standard_Integer_swigregister(NCollection_Sequence_Standard_Integer)

def NCollection_Sequence_Standard_Integer_delNode(*args):
    """
    NCollection_Sequence_Standard_Integer_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _TColStd.NCollection_Sequence_Standard_Integer_delNode(*args)

class NCollection_Sequence_Standard_Integer_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TColStd.new_NCollection_Sequence_Standard_Integer_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TColStd.delete_NCollection_Sequence_Standard_Integer_IteratorHelper

    def __next__(self):
        return _TColStd.NCollection_Sequence_Standard_Integer_IteratorHelper___next__(self)
NCollection_Sequence_Standard_Integer_IteratorHelper_swigregister = _TColStd.NCollection_Sequence_Standard_Integer_IteratorHelper_swigregister
NCollection_Sequence_Standard_Integer_IteratorHelper_swigregister(NCollection_Sequence_Standard_Integer_IteratorHelper)


try:
	TColStd_SequenceOfInteger = NCollection_Sequence_Standard_Integer
except NameError:
	pass # does not exist, probably ignored

class NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used to  store  keys and to bind
    an index to them.  Each new key stored in  the map
    gets an index.  Index are incremented  as keys are
    stored in the map. A key can be found by the index
    and an index by the  key. No key  but the last can
    be removed so the indices are in the range 1..Extent.
    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher self) -> NCollection_IndexedMap< Standard_Real,TColStd_MapRealHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher self) -> NCollection_IndexedMap< Standard_Real,TColStd_MapRealHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used to  store  keys and to bind
        an index to them.  Each new key stored in  the map
        gets an index.  Index are incremented  as keys are
        stored in the map. A key can be found by the index
        and an index by the  key. No key  but the last can
        be removed so the indices are in the range 1..Extent.
        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _TColStd.new_NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher self, NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedMap

        """
        return _TColStd.NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher self, NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher theOther) -> NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher

        Assign.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedMap

        """
        return _TColStd.NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher self, NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher theOther) -> NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedMap

        """
        return _TColStd.NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher self, Standard_Integer const theExtent)

        ReSize

        :type theExtent: int

        """
        return _TColStd.NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher self, double const & theKey1) -> Standard_Integer

        Add

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher self, double const & theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher self, Standard_Integer const theIndex, double const & theKey1)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &

        """
        return _TColStd.NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _TColStd.NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher self)

        RemoveLast


        """
        return _TColStd.NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _TColStd.NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher self, double const & theKey1) -> Standard_Boolean

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _TColStd.NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _TColStd.NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher self, double const & theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher_FindIndex(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher_Size(self, *args)


    def __iter__(self):
        return _TColStd.NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher___iter__(self)
    __swig_destroy__ = _TColStd.delete_NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher
NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher_swigregister = _TColStd.NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher_swigregister
NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher_swigregister(NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher)

class NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TColStd.new_NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TColStd.delete_NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher_IteratorHelper

    def __next__(self):
        return _TColStd.NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher_IteratorHelper___next__(self)
NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher_IteratorHelper_swigregister = _TColStd.NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher_IteratorHelper_swigregister
NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher_IteratorHelper_swigregister(NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher_IteratorHelper)


try:
	TColStd_IndexedMapOfReal = NCollection_IndexedMap_Standard_Real_TColStd_MapRealHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used to  store  keys and to bind
    an index to them.  Each new key stored in  the map
    gets an index.  Index are incremented  as keys are
    stored in the map. A key can be found by the index
    and an index by the  key. No key  but the last can
    be removed so the indices are in the range 1..Extent.
    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher self) -> NCollection_IndexedMap< Standard_Integer,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher self) -> NCollection_IndexedMap< Standard_Integer,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used to  store  keys and to bind
        an index to them.  Each new key stored in  the map
        gets an index.  Index are incremented  as keys are
        stored in the map. A key can be found by the index
        and an index by the  key. No key  but the last can
        be removed so the indices are in the range 1..Extent.
        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _TColStd.new_NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher self, NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedMap

        """
        return _TColStd.NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher self, NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher theOther) -> NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher

        Assign.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedMap

        """
        return _TColStd.NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher self, NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher theOther) -> NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedMap

        """
        return _TColStd.NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher self, Standard_Integer const theExtent)

        ReSize

        :type theExtent: int

        """
        return _TColStd.NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher self, int const & theKey1) -> Standard_Integer

        Add

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher self, int const & theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher self, Standard_Integer const theIndex, int const & theKey1)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &

        """
        return _TColStd.NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _TColStd.NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher self)

        RemoveLast


        """
        return _TColStd.NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _TColStd.NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher self, int const & theKey1) -> Standard_Boolean

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _TColStd.NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _TColStd.NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher self, int const & theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher_FindIndex(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher_Size(self, *args)


    def __iter__(self):
        return _TColStd.NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher___iter__(self)
    __swig_destroy__ = _TColStd.delete_NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher
NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher_swigregister = _TColStd.NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher_swigregister
NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher_swigregister(NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher)

class NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TColStd.new_NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TColStd.delete_NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher_IteratorHelper

    def __next__(self):
        return _TColStd.NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher_IteratorHelper___next__(self)
NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher_IteratorHelper_swigregister = _TColStd.NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher_IteratorHelper_swigregister
NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher_IteratorHelper_swigregister(NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher_IteratorHelper)


try:
	TColStd_IndexedMapOfInteger = NCollection_IndexedMap_Standard_Integer_TColStd_MapIntegerHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_TColStd_HSequenceOfHAsciiString(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TColStd_HSequenceOfHAsciiString self)

        Nullify the handle


        """
        return _TColStd.Handle_TColStd_HSequenceOfHAsciiString_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TColStd_HSequenceOfHAsciiString self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TColStd.Handle_TColStd_HSequenceOfHAsciiString_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TColStd_HSequenceOfHAsciiString self, TColStd_HSequenceOfHAsciiString thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TColStd.Handle_TColStd_HSequenceOfHAsciiString_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TColStd_HSequenceOfHAsciiString self, Handle_TColStd_HSequenceOfHAsciiString theHandle) -> Handle_TColStd_HSequenceOfHAsciiString
        assign(Handle_TColStd_HSequenceOfHAsciiString self, TColStd_HSequenceOfHAsciiString thePtr) -> Handle_TColStd_HSequenceOfHAsciiString
        assign(Handle_TColStd_HSequenceOfHAsciiString self, Handle_TColStd_HSequenceOfHAsciiString theHandle) -> Handle_TColStd_HSequenceOfHAsciiString

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TColStd.Handle_TColStd_HSequenceOfHAsciiString_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TColStd_HSequenceOfHAsciiString self) -> TColStd_HSequenceOfHAsciiString

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HSequenceOfHAsciiString_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TColStd_HSequenceOfHAsciiString self) -> TColStd_HSequenceOfHAsciiString

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HSequenceOfHAsciiString___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TColStd_HSequenceOfHAsciiString self) -> TColStd_HSequenceOfHAsciiString

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TColStd.Handle_TColStd_HSequenceOfHAsciiString___ref__(self, *args)


    def __hash__(self):
        return _TColStd.Handle_TColStd_HSequenceOfHAsciiString___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TColStd.Handle_TColStd_HSequenceOfHAsciiString___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TColStd.new_Handle_TColStd_HSequenceOfHAsciiString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TColStd.Handle_TColStd_HSequenceOfHAsciiString_DownCast)
    __swig_destroy__ = _TColStd.delete_Handle_TColStd_HSequenceOfHAsciiString

    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfHAsciiString

        """
        res = _TColStd.Handle_TColStd_HSequenceOfHAsciiString_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Handle_TColStd_HSequenceOfHAsciiString self, Handle_TCollection_HAsciiString theItem)
        Append(Handle_TColStd_HSequenceOfHAsciiString self, NCollection_Sequence_Handle_TCollection_HAsciiString theSequence)

        :type theSequence: OCC.wrapper.TColStd.TColStd_SequenceOfHAsciiString

        """
        return _TColStd.Handle_TColStd_HSequenceOfHAsciiString_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Handle_TColStd_HSequenceOfHAsciiString self) -> NCollection_Sequence_Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfHAsciiString

        """
        return _TColStd.Handle_TColStd_HSequenceOfHAsciiString_ChangeSequence(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TColStd_HSequenceOfHAsciiString self) -> char const *

        :rtype: const char *

        """
        return _TColStd.Handle_TColStd_HSequenceOfHAsciiString_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HSequenceOfHAsciiString_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HSequenceOfHAsciiString_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TColStd_HSequenceOfHAsciiString self)

        Memory deallocator for transient classes


        """
        return _TColStd.Handle_TColStd_HSequenceOfHAsciiString_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TColStd_HSequenceOfHAsciiString self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TColStd_HSequenceOfHAsciiString self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HSequenceOfHAsciiString_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TColStd_HSequenceOfHAsciiString self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TColStd_HSequenceOfHAsciiString self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HSequenceOfHAsciiString_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TColStd_HSequenceOfHAsciiString self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TColStd.Handle_TColStd_HSequenceOfHAsciiString_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TColStd_HSequenceOfHAsciiString self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HSequenceOfHAsciiString_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TColStd_HSequenceOfHAsciiString self)

        Increments the reference counter of this object


        """
        return _TColStd.Handle_TColStd_HSequenceOfHAsciiString_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TColStd_HSequenceOfHAsciiString self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HSequenceOfHAsciiString_DecrementRefCounter(self, *args)

Handle_TColStd_HSequenceOfHAsciiString_swigregister = _TColStd.Handle_TColStd_HSequenceOfHAsciiString_swigregister
Handle_TColStd_HSequenceOfHAsciiString_swigregister(Handle_TColStd_HSequenceOfHAsciiString)

def Handle_TColStd_HSequenceOfHAsciiString_DownCast(thing):
    return _TColStd.Handle_TColStd_HSequenceOfHAsciiString_DownCast(thing)
Handle_TColStd_HSequenceOfHAsciiString_DownCast = _TColStd.Handle_TColStd_HSequenceOfHAsciiString_DownCast

class NCollection_Array1_Standard_Boolean(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Standard_Boolean self) -> NCollection_Array1< Standard_Boolean >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _TColStd.NCollection_Array1_Standard_Boolean_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Standard_Boolean self) -> NCollection_Array1< Standard_Boolean >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _TColStd.NCollection_Array1_Standard_Boolean_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Standard_Boolean self) -> NCollection_Array1< Standard_Boolean >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Array1_Standard_Boolean_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Standard_Boolean self) -> NCollection_Array1< Standard_Boolean >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Array1_Standard_Boolean_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _TColStd.new_NCollection_Array1_Standard_Boolean(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Standard_Boolean self, bool const & theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _TColStd.NCollection_Array1_Standard_Boolean_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Standard_Boolean self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_Standard_Boolean_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Standard_Boolean self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_Standard_Boolean_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Standard_Boolean self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Array1_Standard_Boolean_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Standard_Boolean self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_Standard_Boolean_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Standard_Boolean self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_Standard_Boolean_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Standard_Boolean self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Array1_Standard_Boolean_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Standard_Boolean self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Array1_Standard_Boolean_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Standard_Boolean self, NCollection_Array1_Standard_Boolean theOther) -> NCollection_Array1_Standard_Boolean

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TColStd.NCollection_Array1_Standard_Boolean_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Standard_Boolean self, NCollection_Array1_Standard_Boolean theOther) -> NCollection_Array1_Standard_Boolean

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TColStd.NCollection_Array1_Standard_Boolean_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Standard_Boolean self, NCollection_Array1_Standard_Boolean theOther) -> NCollection_Array1_Standard_Boolean
        assign(NCollection_Array1_Standard_Boolean self, NCollection_Array1_Standard_Boolean theOther) -> NCollection_Array1_Standard_Boolean

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TColStd.NCollection_Array1_Standard_Boolean_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_Standard_Boolean_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Standard_Boolean self) -> bool &

        @return first element

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Array1_Standard_Boolean_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_Standard_Boolean_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Standard_Boolean self) -> bool &

        @return last element

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Array1_Standard_Boolean_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_Standard_Boolean_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Standard_Boolean self, Standard_Integer const theIndex) -> bool &

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Array1_Standard_Boolean_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_Standard_Boolean___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_Standard_Boolean_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Standard_Boolean self, Standard_Integer const theIndex, bool const & theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TColStd.NCollection_Array1_Standard_Boolean_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Standard_Boolean self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _TColStd.NCollection_Array1_Standard_Boolean_Resize(self, *args)

    __swig_destroy__ = _TColStd.delete_NCollection_Array1_Standard_Boolean
NCollection_Array1_Standard_Boolean_swigregister = _TColStd.NCollection_Array1_Standard_Boolean_swigregister
NCollection_Array1_Standard_Boolean_swigregister(NCollection_Array1_Standard_Boolean)


try:
	TColStd_Array1OfBoolean = NCollection_Array1_Standard_Boolean
except NameError:
	pass # does not exist, probably ignored

class Handle_TColStd_HSequenceOfExtendedString(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TColStd_HSequenceOfExtendedString self)

        Nullify the handle


        """
        return _TColStd.Handle_TColStd_HSequenceOfExtendedString_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TColStd_HSequenceOfExtendedString self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TColStd.Handle_TColStd_HSequenceOfExtendedString_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TColStd_HSequenceOfExtendedString self, TColStd_HSequenceOfExtendedString thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TColStd.Handle_TColStd_HSequenceOfExtendedString_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TColStd_HSequenceOfExtendedString self, Handle_TColStd_HSequenceOfExtendedString theHandle) -> Handle_TColStd_HSequenceOfExtendedString
        assign(Handle_TColStd_HSequenceOfExtendedString self, TColStd_HSequenceOfExtendedString thePtr) -> Handle_TColStd_HSequenceOfExtendedString
        assign(Handle_TColStd_HSequenceOfExtendedString self, Handle_TColStd_HSequenceOfExtendedString theHandle) -> Handle_TColStd_HSequenceOfExtendedString

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TColStd.Handle_TColStd_HSequenceOfExtendedString_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TColStd_HSequenceOfExtendedString self) -> TColStd_HSequenceOfExtendedString

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HSequenceOfExtendedString_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TColStd_HSequenceOfExtendedString self) -> TColStd_HSequenceOfExtendedString

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HSequenceOfExtendedString___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TColStd_HSequenceOfExtendedString self) -> TColStd_HSequenceOfExtendedString

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TColStd.Handle_TColStd_HSequenceOfExtendedString___ref__(self, *args)


    def __hash__(self):
        return _TColStd.Handle_TColStd_HSequenceOfExtendedString___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TColStd.Handle_TColStd_HSequenceOfExtendedString___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TColStd.new_Handle_TColStd_HSequenceOfExtendedString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TColStd.Handle_TColStd_HSequenceOfExtendedString_DownCast)
    __swig_destroy__ = _TColStd.delete_Handle_TColStd_HSequenceOfExtendedString

    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfExtendedString

        """
        res = _TColStd.Handle_TColStd_HSequenceOfExtendedString_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Handle_TColStd_HSequenceOfExtendedString self, TCollection_ExtendedString theItem)
        Append(Handle_TColStd_HSequenceOfExtendedString self, NCollection_Sequence_TCollection_ExtendedString theSequence)

        :type theSequence: OCC.wrapper.TColStd.TColStd_SequenceOfExtendedString

        """
        return _TColStd.Handle_TColStd_HSequenceOfExtendedString_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Handle_TColStd_HSequenceOfExtendedString self) -> NCollection_Sequence_TCollection_ExtendedString

        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfExtendedString

        """
        return _TColStd.Handle_TColStd_HSequenceOfExtendedString_ChangeSequence(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TColStd_HSequenceOfExtendedString self) -> char const *

        :rtype: const char *

        """
        return _TColStd.Handle_TColStd_HSequenceOfExtendedString_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HSequenceOfExtendedString_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HSequenceOfExtendedString_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TColStd_HSequenceOfExtendedString self)

        Memory deallocator for transient classes


        """
        return _TColStd.Handle_TColStd_HSequenceOfExtendedString_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TColStd_HSequenceOfExtendedString self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TColStd_HSequenceOfExtendedString self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HSequenceOfExtendedString_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TColStd_HSequenceOfExtendedString self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TColStd_HSequenceOfExtendedString self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HSequenceOfExtendedString_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TColStd_HSequenceOfExtendedString self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TColStd.Handle_TColStd_HSequenceOfExtendedString_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TColStd_HSequenceOfExtendedString self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HSequenceOfExtendedString_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TColStd_HSequenceOfExtendedString self)

        Increments the reference counter of this object


        """
        return _TColStd.Handle_TColStd_HSequenceOfExtendedString_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TColStd_HSequenceOfExtendedString self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HSequenceOfExtendedString_DecrementRefCounter(self, *args)

Handle_TColStd_HSequenceOfExtendedString_swigregister = _TColStd.Handle_TColStd_HSequenceOfExtendedString_swigregister
Handle_TColStd_HSequenceOfExtendedString_swigregister(Handle_TColStd_HSequenceOfExtendedString)

def Handle_TColStd_HSequenceOfExtendedString_DownCast(thing):
    return _TColStd.Handle_TColStd_HSequenceOfExtendedString_DownCast(thing)
Handle_TColStd_HSequenceOfExtendedString_DownCast = _TColStd.Handle_TColStd_HSequenceOfExtendedString_DownCast

class Handle_TColStd_HSequenceOfTransient(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TColStd_HSequenceOfTransient self)

        Nullify the handle


        """
        return _TColStd.Handle_TColStd_HSequenceOfTransient_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TColStd_HSequenceOfTransient self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TColStd.Handle_TColStd_HSequenceOfTransient_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TColStd_HSequenceOfTransient self, TColStd_HSequenceOfTransient thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TColStd.Handle_TColStd_HSequenceOfTransient_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TColStd_HSequenceOfTransient self, Handle_TColStd_HSequenceOfTransient theHandle) -> Handle_TColStd_HSequenceOfTransient
        assign(Handle_TColStd_HSequenceOfTransient self, TColStd_HSequenceOfTransient thePtr) -> Handle_TColStd_HSequenceOfTransient
        assign(Handle_TColStd_HSequenceOfTransient self, Handle_TColStd_HSequenceOfTransient theHandle) -> Handle_TColStd_HSequenceOfTransient

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TColStd.Handle_TColStd_HSequenceOfTransient_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TColStd_HSequenceOfTransient self) -> TColStd_HSequenceOfTransient

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HSequenceOfTransient_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TColStd_HSequenceOfTransient self) -> TColStd_HSequenceOfTransient

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HSequenceOfTransient___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TColStd_HSequenceOfTransient self) -> TColStd_HSequenceOfTransient

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TColStd.Handle_TColStd_HSequenceOfTransient___ref__(self, *args)


    def __hash__(self):
        return _TColStd.Handle_TColStd_HSequenceOfTransient___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TColStd.Handle_TColStd_HSequenceOfTransient___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TColStd.new_Handle_TColStd_HSequenceOfTransient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TColStd.Handle_TColStd_HSequenceOfTransient_DownCast)
    __swig_destroy__ = _TColStd.delete_Handle_TColStd_HSequenceOfTransient

    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfTransient

        """
        res = _TColStd.Handle_TColStd_HSequenceOfTransient_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Handle_TColStd_HSequenceOfTransient self, Handle_Standard_Transient theItem)
        Append(Handle_TColStd_HSequenceOfTransient self, NCollection_Sequence_Handle_Standard_Transient theSequence)

        :type theSequence: OCC.wrapper.TColStd.TColStd_SequenceOfTransient

        """
        return _TColStd.Handle_TColStd_HSequenceOfTransient_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Handle_TColStd_HSequenceOfTransient self) -> NCollection_Sequence_Handle_Standard_Transient

        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfTransient

        """
        return _TColStd.Handle_TColStd_HSequenceOfTransient_ChangeSequence(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TColStd_HSequenceOfTransient self) -> char const *

        :rtype: const char *

        """
        return _TColStd.Handle_TColStd_HSequenceOfTransient_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HSequenceOfTransient_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HSequenceOfTransient_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TColStd_HSequenceOfTransient self)

        Memory deallocator for transient classes


        """
        return _TColStd.Handle_TColStd_HSequenceOfTransient_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TColStd_HSequenceOfTransient self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TColStd_HSequenceOfTransient self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HSequenceOfTransient_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TColStd_HSequenceOfTransient self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TColStd_HSequenceOfTransient self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HSequenceOfTransient_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TColStd_HSequenceOfTransient self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TColStd.Handle_TColStd_HSequenceOfTransient_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TColStd_HSequenceOfTransient self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HSequenceOfTransient_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TColStd_HSequenceOfTransient self)

        Increments the reference counter of this object


        """
        return _TColStd.Handle_TColStd_HSequenceOfTransient_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TColStd_HSequenceOfTransient self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HSequenceOfTransient_DecrementRefCounter(self, *args)

Handle_TColStd_HSequenceOfTransient_swigregister = _TColStd.Handle_TColStd_HSequenceOfTransient_swigregister
Handle_TColStd_HSequenceOfTransient_swigregister(Handle_TColStd_HSequenceOfTransient)

def Handle_TColStd_HSequenceOfTransient_DownCast(thing):
    return _TColStd.Handle_TColStd_HSequenceOfTransient_DownCast(thing)
Handle_TColStd_HSequenceOfTransient_DownCast = _TColStd.Handle_TColStd_HSequenceOfTransient_DownCast

class Handle_TColStd_HSequenceOfHExtendedString(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TColStd_HSequenceOfHExtendedString self)

        Nullify the handle


        """
        return _TColStd.Handle_TColStd_HSequenceOfHExtendedString_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TColStd_HSequenceOfHExtendedString self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TColStd.Handle_TColStd_HSequenceOfHExtendedString_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TColStd_HSequenceOfHExtendedString self, TColStd_HSequenceOfHExtendedString thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TColStd.Handle_TColStd_HSequenceOfHExtendedString_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TColStd_HSequenceOfHExtendedString self, Handle_TColStd_HSequenceOfHExtendedString theHandle) -> Handle_TColStd_HSequenceOfHExtendedString
        assign(Handle_TColStd_HSequenceOfHExtendedString self, TColStd_HSequenceOfHExtendedString thePtr) -> Handle_TColStd_HSequenceOfHExtendedString
        assign(Handle_TColStd_HSequenceOfHExtendedString self, Handle_TColStd_HSequenceOfHExtendedString theHandle) -> Handle_TColStd_HSequenceOfHExtendedString

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TColStd.Handle_TColStd_HSequenceOfHExtendedString_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TColStd_HSequenceOfHExtendedString self) -> TColStd_HSequenceOfHExtendedString

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HSequenceOfHExtendedString_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TColStd_HSequenceOfHExtendedString self) -> TColStd_HSequenceOfHExtendedString

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HSequenceOfHExtendedString___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TColStd_HSequenceOfHExtendedString self) -> TColStd_HSequenceOfHExtendedString

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TColStd.Handle_TColStd_HSequenceOfHExtendedString___ref__(self, *args)


    def __hash__(self):
        return _TColStd.Handle_TColStd_HSequenceOfHExtendedString___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TColStd.Handle_TColStd_HSequenceOfHExtendedString___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TColStd.new_Handle_TColStd_HSequenceOfHExtendedString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TColStd.Handle_TColStd_HSequenceOfHExtendedString_DownCast)
    __swig_destroy__ = _TColStd.delete_Handle_TColStd_HSequenceOfHExtendedString

    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfHExtendedString

        """
        res = _TColStd.Handle_TColStd_HSequenceOfHExtendedString_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Handle_TColStd_HSequenceOfHExtendedString self, Handle_TCollection_HExtendedString theItem)
        Append(Handle_TColStd_HSequenceOfHExtendedString self, NCollection_Sequence_Handle_TCollection_HExtendedString theSequence)

        :type theSequence: OCC.wrapper.TColStd.TColStd_SequenceOfHExtendedString

        """
        return _TColStd.Handle_TColStd_HSequenceOfHExtendedString_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Handle_TColStd_HSequenceOfHExtendedString self) -> NCollection_Sequence_Handle_TCollection_HExtendedString

        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfHExtendedString

        """
        return _TColStd.Handle_TColStd_HSequenceOfHExtendedString_ChangeSequence(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TColStd_HSequenceOfHExtendedString self) -> char const *

        :rtype: const char *

        """
        return _TColStd.Handle_TColStd_HSequenceOfHExtendedString_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HSequenceOfHExtendedString_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HSequenceOfHExtendedString_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TColStd_HSequenceOfHExtendedString self)

        Memory deallocator for transient classes


        """
        return _TColStd.Handle_TColStd_HSequenceOfHExtendedString_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TColStd_HSequenceOfHExtendedString self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TColStd_HSequenceOfHExtendedString self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HSequenceOfHExtendedString_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TColStd_HSequenceOfHExtendedString self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TColStd_HSequenceOfHExtendedString self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HSequenceOfHExtendedString_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TColStd_HSequenceOfHExtendedString self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TColStd.Handle_TColStd_HSequenceOfHExtendedString_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TColStd_HSequenceOfHExtendedString self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HSequenceOfHExtendedString_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TColStd_HSequenceOfHExtendedString self)

        Increments the reference counter of this object


        """
        return _TColStd.Handle_TColStd_HSequenceOfHExtendedString_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TColStd_HSequenceOfHExtendedString self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HSequenceOfHExtendedString_DecrementRefCounter(self, *args)

Handle_TColStd_HSequenceOfHExtendedString_swigregister = _TColStd.Handle_TColStd_HSequenceOfHExtendedString_swigregister
Handle_TColStd_HSequenceOfHExtendedString_swigregister(Handle_TColStd_HSequenceOfHExtendedString)

def Handle_TColStd_HSequenceOfHExtendedString_DownCast(thing):
    return _TColStd.Handle_TColStd_HSequenceOfHExtendedString_DownCast(thing)
Handle_TColStd_HSequenceOfHExtendedString_DownCast = _TColStd.Handle_TColStd_HSequenceOfHExtendedString_DownCast

class TColStd_HArray1OfInteger(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TColStd_HArray1OfInteger
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TColStd_HArray1OfInteger(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TColStd_HArray1OfInteger self, Standard_Integer const theLower, Standard_Integer const theUpper) -> TColStd_HArray1OfInteger
        __init__(TColStd_HArray1OfInteger self, Standard_Integer const theLower, Standard_Integer const theUpper, TColStd_Array1OfInteger::value_type const & theValue) -> TColStd_HArray1OfInteger
        __init__(TColStd_HArray1OfInteger self, NCollection_Array1_Standard_Integer theOther) -> TColStd_HArray1OfInteger

        :type theOther: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        this = _TColStd.new_TColStd_HArray1OfInteger(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        res = _TColStd.TColStd_HArray1OfInteger_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(TColStd_HArray1OfInteger self) -> NCollection_Array1_Standard_Integer

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _TColStd.TColStd_HArray1OfInteger_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TColStd.TColStd_HArray1OfInteger_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TColStd.TColStd_HArray1OfInteger_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.TColStd_HArray1OfInteger_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TColStd.delete_TColStd_HArray1OfInteger
TColStd_HArray1OfInteger_swigregister = _TColStd.TColStd_HArray1OfInteger_swigregister
TColStd_HArray1OfInteger_swigregister(TColStd_HArray1OfInteger)

def TColStd_HArray1OfInteger_get_type_name(*args):
    """
    TColStd_HArray1OfInteger_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TColStd.TColStd_HArray1OfInteger_get_type_name(*args)

def TColStd_HArray1OfInteger_get_type_descriptor(*args):
    """
    TColStd_HArray1OfInteger_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TColStd.TColStd_HArray1OfInteger_get_type_descriptor(*args)

class NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used  to store keys and to  bind
    an index to them.  Each  new key stored in the map
    gets an index.  Index are  incremented as keys are
    stored in the map. A key can be found by the index
    and an index by the key.  No  key but the last can
    be  removed so the  indices   are in the range 1..
    Extent.  An Item is stored with each key.

    This   class is   similar  to  IndexedMap     from
    NCollection  with the Item as  a new feature. Note
    the important difference on  the operator  ().  In
    the IndexedMap this operator returns  the Key.  In
    the IndexedDataMap this operator returns the Item.

    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString self) -> NCollection_IndexedDataMap< TCollection_AsciiString,TCollection_AsciiString,TCollection_AsciiString >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TColStd.NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString self) -> NCollection_IndexedDataMap< TCollection_AsciiString,TCollection_AsciiString,TCollection_AsciiString >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TColStd.NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString self) -> NCollection_IndexedDataMap< TCollection_AsciiString,TCollection_AsciiString,TCollection_AsciiString >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString self) -> NCollection_IndexedDataMap< TCollection_AsciiString,TCollection_AsciiString,TCollection_AsciiString >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used  to store keys and to  bind
        an index to them.  Each  new key stored in the map
        gets an index.  Index are  incremented as keys are
        stored in the map. A key can be found by the index
        and an index by the key.  No  key but the last can
        be  removed so the  indices   are in the range 1..
        Extent.  An Item is stored with each key.

        This   class is   similar  to  IndexedMap     from
        NCollection  with the Item as  a new feature. Note
        the important difference on  the operator  ().  In
        the IndexedMap this operator returns  the Key.  In
        the IndexedDataMap this operator returns the Item.

        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _TColStd.new_NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString self, NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TColStd.NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString self, NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString theOther) -> NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TColStd.NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString self, NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString theOther) -> NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedDataMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedDataMap

        """
        return _TColStd.NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TColStd.NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString self, TCollection_AsciiString theKey1, TCollection_AsciiString theItem) -> Standard_Integer

        Returns the Index of already bound Key or appends new Key with specified Item value.
        @param theKey1 Key to search (and to bind, if it was not bound already)
        @param theItem Item value to set for newly bound Key; ignored if Key was already bound
        @return index of Key

        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString self, TCollection_AsciiString theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString self, Standard_Integer const theIndex, TCollection_AsciiString theKey1, TCollection_AsciiString theItem)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &
        :type theItem: const TheItemType &

        """
        return _TColStd.NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _TColStd.NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString self)

        RemoveLast


        """
        return _TColStd.NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _TColStd.NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString self, TCollection_AsciiString theKey1)

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &

        """
        return _TColStd.NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _TColStd.NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindFromIndex(self, *args):
        """
        FindFromIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_FindFromIndex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFromIndex(self, *args):
        """
        ChangeFromIndex(NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString self, Standard_Integer const theIndex) -> TCollection_AsciiString

        ChangeFromIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TColStd.NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_ChangeFromIndex(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString self, TCollection_AsciiString theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_FindIndex(self, *args)


    def ChangeFromKey(self, *args):
        """
        ChangeFromKey(NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString self, TCollection_AsciiString theKey1) -> TCollection_AsciiString

        ChangeFromKey

        :type theKey1: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TColStd.NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_ChangeFromKey(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString self, TCollection_AsciiString theKey1) -> TCollection_AsciiString

        Seek returns pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TColStd.NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_Seek(self, *args)


    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString self, TCollection_AsciiString theKey1) -> TCollection_AsciiString

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL if Key was not found.

        :type theKey1: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TColStd.NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_ChangeSeek(self, *args)


    def FindFromKey(self, *args):
        """
        FindFromKey

        :type theKey1: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_FindFromKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_Size(self, *args)


    def __iter__(self):
        return _TColStd.NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString___iter__(self)
    __swig_destroy__ = _TColStd.delete_NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString
NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_swigregister = _TColStd.NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_swigregister
NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_swigregister(NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString)

class NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TColStd.new_NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TColStd.delete_NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_IteratorHelper

    def __next__(self):
        return _TColStd.NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_IteratorHelper___next__(self)
NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_IteratorHelper_swigregister = _TColStd.NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_IteratorHelper_swigregister
NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_IteratorHelper_swigregister(NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString_IteratorHelper)


try:
	TColStd_IndexedDataMapOfStringString = NCollection_IndexedDataMap_TCollection_AsciiString_TCollection_AsciiString_TCollection_AsciiString
except NameError:
	pass # does not exist, probably ignored

class NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     Single hashed Map. This  Map is used  to store and
    retrieve keys in linear time.

    The ::Iterator class can be  used to explore  the
    content of the map. It is not  wise to iterate and
    modify a map in parallel.

    To compute  the hashcode of  the key the  function
    ::HashCode must be defined in the global namespace

    To compare two keys the function ::IsEqual must be
    defined in the global namespace.

    The performance of  a Map is conditionned  by  its
    number of buckets that  should be kept greater  to
    the number   of keys.  This  map has  an automatic
    management of the number of buckets. It is resized
    when  the number of Keys  becomes greater than the
    number of buckets.

    If you have a fair  idea of the number of  objects
    you  can save on automatic   resizing by giving  a
    number of buckets  at creation or using the ReSize
    method. This should be  consider only for  crucial
    optimisation issues.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def cbegin(self, *args):
        """
        cbegin(NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher self) -> NCollection_Map< opencascade::handle< Standard_Transient >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher self) -> NCollection_Map< opencascade::handle< Standard_Transient >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Single hashed Map. This  Map is used  to store and
        retrieve keys in linear time.

        The ::Iterator class can be  used to explore  the
        content of the map. It is not  wise to iterate and
        modify a map in parallel.

        To compute  the hashcode of  the key the  function
        ::HashCode must be defined in the global namespace

        To compare two keys the function ::IsEqual must be
        defined in the global namespace.

        The performance of  a Map is conditionned  by  its
        number of buckets that  should be kept greater  to
        the number   of keys.  This  map has  an automatic
        management of the number of buckets. It is resized
        when  the number of Keys  becomes greater than the
        number of buckets.

        If you have a fair  idea of the number of  objects
        you  can save on automatic   resizing by giving  a
        number of buckets  at creation or using the ReSize
        method. This should be  consider only for  crucial
        optimisation issues.
        """
        this = _TColStd.new_NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher self, NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TColStd.NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher self, NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher theOther) -> NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher

        Assign.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TColStd.NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher self, NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher theOther) -> NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher

        Assign operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TColStd.NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TColStd.NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher self, Handle_Standard_Transient K) -> Standard_Boolean

        Add

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher_Add(self, *args)


    def Added(self, *args):
        """
        Added: add a new key if not yet in the map, and return 
        reference to either newly added or previously existing object

        :type K: const TheKeyType &
        :rtype: const TheKeyType &

        """
        res = _TColStd.NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher_Added(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Remove(self, *args):
        """
        Remove(NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher self, Handle_Standard_Transient K) -> Standard_Boolean

        Remove

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher_Remove(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher_Size(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher self, NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher theOther) -> Standard_Boolean

        @return true if two maps contains exactly the same keys

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher_IsEqual(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher self, Handle_Standard_Transient K) -> Standard_Boolean
        Contains(NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher self, NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher theOther) -> Standard_Boolean

        @return true if this map contains ALL keys of another map.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher_Contains(self, *args)


    def Union(self, *args):
        """
        Union(NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher self, NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher theLeft, NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher theRight)

        Sets this Map to be the result of union (aka addition, fuse, merge, boolean OR) operation between two given Maps
        The new Map contains the values that are contained either in the first map or in the second map or in both.
        All previous content of this Map is cleared.
        This map (result of the boolean operation) can also be passed as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TColStd.NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher_Union(self, *args)


    def Unite(self, *args):
        """
        Unite(NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher self, NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher theOther) -> Standard_Boolean

        Apply to this Map the boolean operation union (aka addition, fuse, merge, boolean OR) with another (given) Map.
        The result contains the values that were previously contained in this map or contained in the given (operand) map.
        This algorithm is similar to method Union().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher_Unite(self, *args)


    def HasIntersection(self, *args):
        """
        HasIntersection(NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher self, NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher theMap) -> Standard_Boolean

        Returns true if this and theMap have common elements.

        :type theMap: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher_HasIntersection(self, *args)


    def Intersection(self, *args):
        """
        Intersection(NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher self, NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher theLeft, NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher theRight)

        Sets this Map to be the result of intersection (aka multiplication, common, boolean AND) operation between two given Maps.
        The new Map contains only the values that are contained in both map operands.
        All previous content of this Map is cleared.
        This same map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TColStd.NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher_Intersection(self, *args)


    def Intersect(self, *args):
        """
        Intersect(NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher self, NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher theOther) -> Standard_Boolean

        Apply to this Map the intersection operation (aka multiplication, common, boolean AND) with another (given) Map.
        The result contains only the values that are contained in both this and the given maps.
        This algorithm is similar to method Intersection().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher_Intersect(self, *args)


    def Subtraction(self, *args):
        """
        Subtraction(NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher self, NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher theLeft, NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher theRight)

        Sets this Map to be the result of subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation between two given Maps.
        The new Map contains only the values that are contained in the first map operands and not contained in the second one.
        All previous content of this Map is cleared.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TColStd.NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher_Subtraction(self, *args)


    def Subtract(self, *args):
        """
        Subtract(NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher self, NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher theOther) -> Standard_Boolean

        Apply to this Map the subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation with another (given) Map.
        The result contains only the values that were previously contained in this map and not contained in this map.
        This algorithm is similar to method Subtract() with two operands.
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher_Subtract(self, *args)


    def Difference(self, *args):
        """
        Difference(NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher self, NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher theLeft, NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher theRight)

        Sets this Map to be the result of symmetric difference (aka exclusive disjunction, boolean XOR) operation between two given Maps.
        The new Map contains the values that are contained only in the first or the second operand maps but not in both.
        All previous content of this Map is cleared. This map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TColStd.NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher_Difference(self, *args)


    def Differ(self, *args):
        """
        Differ(NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher self, NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher theOther) -> Standard_Boolean

        Apply to this Map the symmetric difference (aka exclusive disjunction, boolean XOR) operation with another (given) Map.
        The result contains the values that are contained only in this or the operand map, but not in both.
        This algorithm is similar to method Difference().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher_Differ(self, *args)


    def __iter__(self):
        return _TColStd.NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher___iter__(self)
    __swig_destroy__ = _TColStd.delete_NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher
NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher_swigregister = _TColStd.NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher_swigregister
NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher_swigregister(NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher)

class NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TColStd.new_NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TColStd.delete_NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher_IteratorHelper

    def __next__(self):
        return _TColStd.NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher_IteratorHelper___next__(self)
NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher_IteratorHelper_swigregister = _TColStd.NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher_IteratorHelper_swigregister
NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher_IteratorHelper_swigregister(NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher_IteratorHelper)


try:
	TColStd_MapOfTransient = NCollection_Map_Handle_Standard_Transient_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored


try:
	Handle_Standard_Transient = Standard.Handle_Standard_Transient
except AttributeError:
	pass # does not exist, probably ignored

class NCollection_Sequence_Standard_Address(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Standard_Address self) -> NCollection_Sequence< void * >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _TColStd.NCollection_Sequence_Standard_Address_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Standard_Address self) -> NCollection_Sequence< void * >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _TColStd.NCollection_Sequence_Standard_Address_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Standard_Address self) -> NCollection_Sequence< void * >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Sequence_Standard_Address_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Standard_Address self) -> NCollection_Sequence< void * >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Sequence_Standard_Address_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _TColStd.new_NCollection_Sequence_Standard_Address(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Standard_Address self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_Standard_Address_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Standard_Address self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_Standard_Address_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Standard_Address self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_Standard_Address_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Standard_Address self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_Standard_Address_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Standard_Address self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Sequence_Standard_Address_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Standard_Address self)

        Reverse sequence


        """
        return _TColStd.NCollection_Sequence_Standard_Address_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Standard_Address self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _TColStd.NCollection_Sequence_Standard_Address_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_Sequence_Standard_Address_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Standard_Address self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_Sequence_Standard_Address_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Standard_Address self, NCollection_Sequence_Standard_Address theOther) -> NCollection_Sequence_Standard_Address

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Standard_Address_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Standard_Address self, NCollection_Sequence_Standard_Address theOther) -> NCollection_Sequence_Standard_Address

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Standard_Address_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Standard_Address self, NCollection_Sequence< void * >::Iterator & thePosition)
        Remove(NCollection_Sequence_Standard_Address self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Standard_Address self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _TColStd.NCollection_Sequence_Standard_Address_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Standard_Address self, void *const & theItem)
        Append(NCollection_Sequence_Standard_Address self, NCollection_Sequence_Standard_Address theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Standard_Address_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Standard_Address self, void *const & theItem)
        Prepend(NCollection_Sequence_Standard_Address self, NCollection_Sequence_Standard_Address theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Standard_Address_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Standard_Address self, Standard_Integer const theIndex, void *const & theItem)
        InsertBefore(NCollection_Sequence_Standard_Address self, Standard_Integer const theIndex, NCollection_Sequence_Standard_Address theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Standard_Address_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Standard_Address self, NCollection_Sequence< void * >::Iterator & thePosition, void *const & theItem)
        InsertAfter(NCollection_Sequence_Standard_Address self, Standard_Integer const theIndex, NCollection_Sequence_Standard_Address theSeq)
        InsertAfter(NCollection_Sequence_Standard_Address self, Standard_Integer const theIndex, void *const & theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TColStd.NCollection_Sequence_Standard_Address_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Standard_Address self, Standard_Integer const theIndex, NCollection_Sequence_Standard_Address theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Standard_Address_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_Standard_Address_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Standard_Address self) -> void *&

        First item access

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Sequence_Standard_Address_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_Standard_Address_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Standard_Address self) -> void *&

        Last item access

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Sequence_Standard_Address_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_Standard_Address_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Standard_Address self, Standard_Integer const theIndex) -> void *&

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Sequence_Standard_Address_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_Standard_Address___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Standard_Address self, Standard_Integer const theIndex, void *const & theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TColStd.NCollection_Sequence_Standard_Address_SetValue(self, *args)


    def __iter__(self):
        return _TColStd.NCollection_Sequence_Standard_Address___iter__(self)
    __swig_destroy__ = _TColStd.delete_NCollection_Sequence_Standard_Address
NCollection_Sequence_Standard_Address_swigregister = _TColStd.NCollection_Sequence_Standard_Address_swigregister
NCollection_Sequence_Standard_Address_swigregister(NCollection_Sequence_Standard_Address)

def NCollection_Sequence_Standard_Address_delNode(*args):
    """
    NCollection_Sequence_Standard_Address_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _TColStd.NCollection_Sequence_Standard_Address_delNode(*args)

class NCollection_Sequence_Standard_Address_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TColStd.new_NCollection_Sequence_Standard_Address_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TColStd.delete_NCollection_Sequence_Standard_Address_IteratorHelper

    def __next__(self):
        return _TColStd.NCollection_Sequence_Standard_Address_IteratorHelper___next__(self)
NCollection_Sequence_Standard_Address_IteratorHelper_swigregister = _TColStd.NCollection_Sequence_Standard_Address_IteratorHelper_swigregister
NCollection_Sequence_Standard_Address_IteratorHelper_swigregister(NCollection_Sequence_Standard_Address_IteratorHelper)


try:
	TColStd_SequenceOfAddress = NCollection_Sequence_Standard_Address
except NameError:
	pass # does not exist, probably ignored

class NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,Standard_Real,TColStd_MapIntegerHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,Standard_Real,TColStd_MapIntegerHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,Standard_Real,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,Standard_Real,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TColStd.new_NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher self, int const & theKey, double const & theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher self, int const & theKey, double const & theItem) -> double *

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher self, int const & theKey) -> double const *

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher self, int const & theKey) -> double *

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher self, int const & theKey) -> double &

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher_Size(self, *args)


    def __iter__(self):
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher___iter__(self)
    __swig_destroy__ = _TColStd.delete_NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher
NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher_swigregister = _TColStd.NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher_swigregister
NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher_swigregister(NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher)

class NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TColStd.new_NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TColStd.delete_NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher_IteratorHelper

    def __next__(self):
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher_IteratorHelper___next__(self)
NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher_IteratorHelper_swigregister = _TColStd.NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher_IteratorHelper_swigregister
NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher_IteratorHelper_swigregister(NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher_IteratorHelper)


try:
	TColStd_DataMapOfIntegerReal = NCollection_DataMap_Standard_Integer_Standard_Real_TColStd_MapIntegerHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_TColStd_HArray2OfTransient(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TColStd_HArray2OfTransient self)

        Nullify the handle


        """
        return _TColStd.Handle_TColStd_HArray2OfTransient_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TColStd_HArray2OfTransient self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TColStd.Handle_TColStd_HArray2OfTransient_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TColStd_HArray2OfTransient self, TColStd_HArray2OfTransient thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TColStd.Handle_TColStd_HArray2OfTransient_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TColStd_HArray2OfTransient self, Handle_TColStd_HArray2OfTransient theHandle) -> Handle_TColStd_HArray2OfTransient
        assign(Handle_TColStd_HArray2OfTransient self, TColStd_HArray2OfTransient thePtr) -> Handle_TColStd_HArray2OfTransient
        assign(Handle_TColStd_HArray2OfTransient self, Handle_TColStd_HArray2OfTransient theHandle) -> Handle_TColStd_HArray2OfTransient

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TColStd.Handle_TColStd_HArray2OfTransient_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TColStd_HArray2OfTransient self) -> TColStd_HArray2OfTransient

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HArray2OfTransient_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TColStd_HArray2OfTransient self) -> TColStd_HArray2OfTransient

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HArray2OfTransient___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TColStd_HArray2OfTransient self) -> TColStd_HArray2OfTransient

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TColStd.Handle_TColStd_HArray2OfTransient___ref__(self, *args)


    def __hash__(self):
        return _TColStd.Handle_TColStd_HArray2OfTransient___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TColStd.Handle_TColStd_HArray2OfTransient___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TColStd.new_Handle_TColStd_HArray2OfTransient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TColStd.Handle_TColStd_HArray2OfTransient_DownCast)
    __swig_destroy__ = _TColStd.delete_Handle_TColStd_HArray2OfTransient

    def Array2(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array2OfTransient

        """
        res = _TColStd.Handle_TColStd_HArray2OfTransient_Array2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray2(self, *args):
        """
        ChangeArray2(Handle_TColStd_HArray2OfTransient self) -> NCollection_Array2_Handle_Standard_Transient

        :rtype: OCC.wrapper.TColStd.TColStd_Array2OfTransient

        """
        return _TColStd.Handle_TColStd_HArray2OfTransient_ChangeArray2(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TColStd_HArray2OfTransient self) -> char const *

        :rtype: const char *

        """
        return _TColStd.Handle_TColStd_HArray2OfTransient_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HArray2OfTransient_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HArray2OfTransient_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Init(self, *args):
        """
        Init(Handle_TColStd_HArray2OfTransient self, Handle_Standard_Transient theValue)

        Initialise the values

        :type theValue: const TheItemType &

        """
        return _TColStd.Handle_TColStd_HArray2OfTransient_Init(self, *args)


    def Size(self, *args):
        """
        Size(Handle_TColStd_HArray2OfTransient self) -> Standard_Integer

        Size (number of items)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray2OfTransient_Size(self, *args)


    def Length(self, *args):
        """
        Length(Handle_TColStd_HArray2OfTransient self) -> Standard_Integer

        Length (number of items)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray2OfTransient_Length(self, *args)


    def RowLength(self, *args):
        """
        RowLength(Handle_TColStd_HArray2OfTransient self) -> Standard_Integer

        Returns length of the row, i.e. number of columns

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray2OfTransient_RowLength(self, *args)


    def ColLength(self, *args):
        """
        ColLength(Handle_TColStd_HArray2OfTransient self) -> Standard_Integer

        Returns length of the column, i.e. number of rows

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray2OfTransient_ColLength(self, *args)


    def LowerRow(self, *args):
        """
        LowerRow(Handle_TColStd_HArray2OfTransient self) -> Standard_Integer

        LowerRow

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray2OfTransient_LowerRow(self, *args)


    def UpperRow(self, *args):
        """
        UpperRow(Handle_TColStd_HArray2OfTransient self) -> Standard_Integer

        UpperRow

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray2OfTransient_UpperRow(self, *args)


    def LowerCol(self, *args):
        """
        LowerCol(Handle_TColStd_HArray2OfTransient self) -> Standard_Integer

        LowerCol

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray2OfTransient_LowerCol(self, *args)


    def UpperCol(self, *args):
        """
        UpperCol(Handle_TColStd_HArray2OfTransient self) -> Standard_Integer

        UpperCol

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray2OfTransient_UpperCol(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(Handle_TColStd_HArray2OfTransient self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HArray2OfTransient_IsDeletable(self, *args)


    def Assign(self, *args):
        """
        Assign(Handle_TColStd_HArray2OfTransient self, NCollection_Array2_Handle_Standard_Transient theOther) -> NCollection_Array2_Handle_Standard_Transient

        Assignment

        :type theOther: OCC.wrapper.NCollection.NCollection_Array2
        :rtype: OCC.wrapper.NCollection.NCollection_Array2

        """
        return _TColStd.Handle_TColStd_HArray2OfTransient_Assign(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theRow: int
        :type theCol: int
        :rtype: const TheItemType &

        """
        res = _TColStd.Handle_TColStd_HArray2OfTransient_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __call__(self, *args):
        """
        operator() - alias to ChangeValue

        :type theRow: int
        :type theCol: int
        :rtype: const TheItemType &

        """
        res = _TColStd.Handle_TColStd_HArray2OfTransient___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(Handle_TColStd_HArray2OfTransient self, Standard_Integer const theRow, Standard_Integer const theCol) -> Handle_Standard_Transient

        Variable value access

        :type theRow: int
        :type theCol: int
        :rtype: TheItemType &

        """
        return _TColStd.Handle_TColStd_HArray2OfTransient_ChangeValue(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_TColStd_HArray2OfTransient self, Standard_Integer const theRow, Standard_Integer const theCol, Handle_Standard_Transient theItem)

        SetValue

        :type theRow: int
        :type theCol: int
        :type theItem: const TheItemType &

        """
        return _TColStd.Handle_TColStd_HArray2OfTransient_SetValue(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TColStd_HArray2OfTransient self)

        Memory deallocator for transient classes


        """
        return _TColStd.Handle_TColStd_HArray2OfTransient_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TColStd_HArray2OfTransient self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TColStd_HArray2OfTransient self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HArray2OfTransient_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TColStd_HArray2OfTransient self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TColStd_HArray2OfTransient self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HArray2OfTransient_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TColStd_HArray2OfTransient self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TColStd.Handle_TColStd_HArray2OfTransient_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TColStd_HArray2OfTransient self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray2OfTransient_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TColStd_HArray2OfTransient self)

        Increments the reference counter of this object


        """
        return _TColStd.Handle_TColStd_HArray2OfTransient_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TColStd_HArray2OfTransient self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray2OfTransient_DecrementRefCounter(self, *args)

Handle_TColStd_HArray2OfTransient_swigregister = _TColStd.Handle_TColStd_HArray2OfTransient_swigregister
Handle_TColStd_HArray2OfTransient_swigregister(Handle_TColStd_HArray2OfTransient)

def Handle_TColStd_HArray2OfTransient_DownCast(thing):
    return _TColStd.Handle_TColStd_HArray2OfTransient_DownCast(thing)
Handle_TColStd_HArray2OfTransient_DownCast = _TColStd.Handle_TColStd_HArray2OfTransient_DownCast

class NCollection_Array2_Standard_Character(object):
    """
    Purpose:   The class Array2 represents bi-dimensional arrays 
    of fixed size known at run time. 
    The ranges of indices are user defined.

    Warning:   Programs clients of such class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.LowerRow(); i <= A.UpperRow(); i++)
    for (j = A.LowerCol(); j <= A.UpperCol(); j++)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Purpose:   The class Array2 represents bi-dimensional arrays 
        of fixed size known at run time. 
        The ranges of indices are user defined.

        Warning:   Programs clients of such class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.LowerRow(); i <= A.UpperRow(); i++)
        for (j = A.LowerCol(); j <= A.UpperCol(); j++)
        """
        this = _TColStd.new_NCollection_Array2_Standard_Character(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array2_Standard_Character self, char const & theValue)

        Initialise the values

        :type theValue: const TheItemType &

        """
        return _TColStd.NCollection_Array2_Standard_Character_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array2_Standard_Character self) -> Standard_Integer

        Size (number of items)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Standard_Character_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array2_Standard_Character self) -> Standard_Integer

        Length (number of items)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Standard_Character_Length(self, *args)


    def RowLength(self, *args):
        """
        RowLength(NCollection_Array2_Standard_Character self) -> Standard_Integer

        Returns length of the row, i.e. number of columns

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Standard_Character_RowLength(self, *args)


    def ColLength(self, *args):
        """
        ColLength(NCollection_Array2_Standard_Character self) -> Standard_Integer

        Returns length of the column, i.e. number of rows

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Standard_Character_ColLength(self, *args)


    def LowerRow(self, *args):
        """
        LowerRow(NCollection_Array2_Standard_Character self) -> Standard_Integer

        LowerRow

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Standard_Character_LowerRow(self, *args)


    def UpperRow(self, *args):
        """
        UpperRow(NCollection_Array2_Standard_Character self) -> Standard_Integer

        UpperRow

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Standard_Character_UpperRow(self, *args)


    def LowerCol(self, *args):
        """
        LowerCol(NCollection_Array2_Standard_Character self) -> Standard_Integer

        LowerCol

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Standard_Character_LowerCol(self, *args)


    def UpperCol(self, *args):
        """
        UpperCol(NCollection_Array2_Standard_Character self) -> Standard_Integer

        UpperCol

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Standard_Character_UpperCol(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array2_Standard_Character self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Array2_Standard_Character_IsDeletable(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array2_Standard_Character self, NCollection_Array2_Standard_Character theOther) -> NCollection_Array2_Standard_Character

        Assignment

        :type theOther: OCC.wrapper.NCollection.NCollection_Array2
        :rtype: OCC.wrapper.NCollection.NCollection_Array2

        """
        return _TColStd.NCollection_Array2_Standard_Character_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array2_Standard_Character self, NCollection_Array2_Standard_Character theOther) -> NCollection_Array2_Standard_Character

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Array2
        :rtype: OCC.wrapper.NCollection.NCollection_Array2

        """
        return _TColStd.NCollection_Array2_Standard_Character_assign(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theRow: int
        :type theCol: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array2_Standard_Character_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array2_Standard_Character self, Standard_Integer const theRow, Standard_Integer const theCol) -> char &

        Variable value access

        :type theRow: int
        :type theCol: int
        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Array2_Standard_Character_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to ChangeValue

        :type theRow: int
        :type theCol: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array2_Standard_Character___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array2_Standard_Character self, Standard_Integer const theRow, Standard_Integer const theCol, char const & theItem)

        SetValue

        :type theRow: int
        :type theCol: int
        :type theItem: const TheItemType &

        """
        return _TColStd.NCollection_Array2_Standard_Character_SetValue(self, *args)

    __swig_destroy__ = _TColStd.delete_NCollection_Array2_Standard_Character
NCollection_Array2_Standard_Character_swigregister = _TColStd.NCollection_Array2_Standard_Character_swigregister
NCollection_Array2_Standard_Character_swigregister(NCollection_Array2_Standard_Character)


try:
	TColStd_Array2OfCharacter = NCollection_Array2_Standard_Character
except NameError:
	pass # does not exist, probably ignored

class Handle_TColStd_HSequenceOfReal(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TColStd_HSequenceOfReal self)

        Nullify the handle


        """
        return _TColStd.Handle_TColStd_HSequenceOfReal_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TColStd_HSequenceOfReal self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TColStd.Handle_TColStd_HSequenceOfReal_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TColStd_HSequenceOfReal self, TColStd_HSequenceOfReal thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TColStd.Handle_TColStd_HSequenceOfReal_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TColStd_HSequenceOfReal self, Handle_TColStd_HSequenceOfReal theHandle) -> Handle_TColStd_HSequenceOfReal
        assign(Handle_TColStd_HSequenceOfReal self, TColStd_HSequenceOfReal thePtr) -> Handle_TColStd_HSequenceOfReal
        assign(Handle_TColStd_HSequenceOfReal self, Handle_TColStd_HSequenceOfReal theHandle) -> Handle_TColStd_HSequenceOfReal

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TColStd.Handle_TColStd_HSequenceOfReal_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TColStd_HSequenceOfReal self) -> TColStd_HSequenceOfReal

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HSequenceOfReal_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TColStd_HSequenceOfReal self) -> TColStd_HSequenceOfReal

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HSequenceOfReal___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TColStd_HSequenceOfReal self) -> TColStd_HSequenceOfReal

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TColStd.Handle_TColStd_HSequenceOfReal___ref__(self, *args)


    def __hash__(self):
        return _TColStd.Handle_TColStd_HSequenceOfReal___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TColStd.Handle_TColStd_HSequenceOfReal___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TColStd.new_Handle_TColStd_HSequenceOfReal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TColStd.Handle_TColStd_HSequenceOfReal_DownCast)
    __swig_destroy__ = _TColStd.delete_Handle_TColStd_HSequenceOfReal

    def Sequence(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfReal

        """
        res = _TColStd.Handle_TColStd_HSequenceOfReal_Sequence(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Handle_TColStd_HSequenceOfReal self, TColStd_SequenceOfReal::value_type const & theItem)
        Append(Handle_TColStd_HSequenceOfReal self, NCollection_Sequence_Standard_Real theSequence)

        :type theSequence: OCC.wrapper.TColStd.TColStd_SequenceOfReal

        """
        return _TColStd.Handle_TColStd_HSequenceOfReal_Append(self, *args)


    def ChangeSequence(self, *args):
        """
        ChangeSequence(Handle_TColStd_HSequenceOfReal self) -> NCollection_Sequence_Standard_Real

        :rtype: OCC.wrapper.TColStd.TColStd_SequenceOfReal

        """
        return _TColStd.Handle_TColStd_HSequenceOfReal_ChangeSequence(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TColStd_HSequenceOfReal self) -> char const *

        :rtype: const char *

        """
        return _TColStd.Handle_TColStd_HSequenceOfReal_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HSequenceOfReal_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HSequenceOfReal_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TColStd_HSequenceOfReal self)

        Memory deallocator for transient classes


        """
        return _TColStd.Handle_TColStd_HSequenceOfReal_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TColStd_HSequenceOfReal self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TColStd_HSequenceOfReal self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HSequenceOfReal_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TColStd_HSequenceOfReal self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TColStd_HSequenceOfReal self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HSequenceOfReal_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TColStd_HSequenceOfReal self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TColStd.Handle_TColStd_HSequenceOfReal_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TColStd_HSequenceOfReal self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HSequenceOfReal_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TColStd_HSequenceOfReal self)

        Increments the reference counter of this object


        """
        return _TColStd.Handle_TColStd_HSequenceOfReal_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TColStd_HSequenceOfReal self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HSequenceOfReal_DecrementRefCounter(self, *args)

Handle_TColStd_HSequenceOfReal_swigregister = _TColStd.Handle_TColStd_HSequenceOfReal_swigregister
Handle_TColStd_HSequenceOfReal_swigregister(Handle_TColStd_HSequenceOfReal)

def Handle_TColStd_HSequenceOfReal_DownCast(thing):
    return _TColStd.Handle_TColStd_HSequenceOfReal_DownCast(thing)
Handle_TColStd_HSequenceOfReal_DownCast = _TColStd.Handle_TColStd_HSequenceOfReal_DownCast

class Handle_TColStd_HArray1OfListOfInteger(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TColStd_HArray1OfListOfInteger self)

        Nullify the handle


        """
        return _TColStd.Handle_TColStd_HArray1OfListOfInteger_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TColStd_HArray1OfListOfInteger self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TColStd.Handle_TColStd_HArray1OfListOfInteger_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TColStd_HArray1OfListOfInteger self, TColStd_HArray1OfListOfInteger thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TColStd.Handle_TColStd_HArray1OfListOfInteger_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TColStd_HArray1OfListOfInteger self, Handle_TColStd_HArray1OfListOfInteger theHandle) -> Handle_TColStd_HArray1OfListOfInteger
        assign(Handle_TColStd_HArray1OfListOfInteger self, TColStd_HArray1OfListOfInteger thePtr) -> Handle_TColStd_HArray1OfListOfInteger
        assign(Handle_TColStd_HArray1OfListOfInteger self, Handle_TColStd_HArray1OfListOfInteger theHandle) -> Handle_TColStd_HArray1OfListOfInteger

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TColStd.Handle_TColStd_HArray1OfListOfInteger_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TColStd_HArray1OfListOfInteger self) -> TColStd_HArray1OfListOfInteger

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HArray1OfListOfInteger_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TColStd_HArray1OfListOfInteger self) -> TColStd_HArray1OfListOfInteger

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HArray1OfListOfInteger___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TColStd_HArray1OfListOfInteger self) -> TColStd_HArray1OfListOfInteger

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TColStd.Handle_TColStd_HArray1OfListOfInteger___ref__(self, *args)


    def __hash__(self):
        return _TColStd.Handle_TColStd_HArray1OfListOfInteger___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TColStd.Handle_TColStd_HArray1OfListOfInteger___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TColStd.new_Handle_TColStd_HArray1OfListOfInteger(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TColStd.Handle_TColStd_HArray1OfListOfInteger_DownCast)
    __swig_destroy__ = _TColStd.delete_Handle_TColStd_HArray1OfListOfInteger

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfListOfInteger

        """
        res = _TColStd.Handle_TColStd_HArray1OfListOfInteger_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_TColStd_HArray1OfListOfInteger self) -> NCollection_Array1_TColStd_ListOfInteger

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfListOfInteger

        """
        return _TColStd.Handle_TColStd_HArray1OfListOfInteger_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TColStd_HArray1OfListOfInteger self) -> char const *

        :rtype: const char *

        """
        return _TColStd.Handle_TColStd_HArray1OfListOfInteger_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HArray1OfListOfInteger_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HArray1OfListOfInteger_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TColStd_HArray1OfListOfInteger self)

        Memory deallocator for transient classes


        """
        return _TColStd.Handle_TColStd_HArray1OfListOfInteger_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TColStd_HArray1OfListOfInteger self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TColStd_HArray1OfListOfInteger self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HArray1OfListOfInteger_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TColStd_HArray1OfListOfInteger self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TColStd_HArray1OfListOfInteger self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HArray1OfListOfInteger_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TColStd_HArray1OfListOfInteger self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TColStd.Handle_TColStd_HArray1OfListOfInteger_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TColStd_HArray1OfListOfInteger self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray1OfListOfInteger_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TColStd_HArray1OfListOfInteger self)

        Increments the reference counter of this object


        """
        return _TColStd.Handle_TColStd_HArray1OfListOfInteger_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TColStd_HArray1OfListOfInteger self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray1OfListOfInteger_DecrementRefCounter(self, *args)

Handle_TColStd_HArray1OfListOfInteger_swigregister = _TColStd.Handle_TColStd_HArray1OfListOfInteger_swigregister
Handle_TColStd_HArray1OfListOfInteger_swigregister(Handle_TColStd_HArray1OfListOfInteger)

def Handle_TColStd_HArray1OfListOfInteger_DownCast(thing):
    return _TColStd.Handle_TColStd_HArray1OfListOfInteger_DownCast(thing)
Handle_TColStd_HArray1OfListOfInteger_DownCast = _TColStd.Handle_TColStd_HArray1OfListOfInteger_DownCast

class NCollection_List_TCollection_AsciiString(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_TCollection_AsciiString self) -> NCollection_List< TCollection_AsciiString >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _TColStd.NCollection_List_TCollection_AsciiString_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_TCollection_AsciiString self) -> NCollection_List< TCollection_AsciiString >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _TColStd.NCollection_List_TCollection_AsciiString_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_TCollection_AsciiString self) -> NCollection_List< TCollection_AsciiString >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_List_TCollection_AsciiString_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_TCollection_AsciiString self) -> NCollection_List< TCollection_AsciiString >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_List_TCollection_AsciiString_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _TColStd.new_NCollection_List_TCollection_AsciiString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_TCollection_AsciiString self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_List_TCollection_AsciiString_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_TCollection_AsciiString self, NCollection_List_TCollection_AsciiString theOther) -> NCollection_List_TCollection_AsciiString

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _TColStd.NCollection_List_TCollection_AsciiString_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_TCollection_AsciiString self, NCollection_List_TCollection_AsciiString theOther) -> NCollection_List_TCollection_AsciiString

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _TColStd.NCollection_List_TCollection_AsciiString_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_TCollection_AsciiString self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_List_TCollection_AsciiString_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_List_TCollection_AsciiString_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_List_TCollection_AsciiString_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_TCollection_AsciiString self, TCollection_AsciiString theItem) -> TCollection_AsciiString
        Append(NCollection_List_TCollection_AsciiString self, TCollection_AsciiString theItem, NCollection_List< TCollection_AsciiString >::Iterator & theIter)
        Append(NCollection_List_TCollection_AsciiString self, NCollection_List_TCollection_AsciiString theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _TColStd.NCollection_List_TCollection_AsciiString_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_TCollection_AsciiString self, TCollection_AsciiString theItem) -> TCollection_AsciiString
        Prepend(NCollection_List_TCollection_AsciiString self, NCollection_List_TCollection_AsciiString theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _TColStd.NCollection_List_TCollection_AsciiString_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_TCollection_AsciiString self)

        RemoveFirst item


        """
        return _TColStd.NCollection_List_TCollection_AsciiString_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_TCollection_AsciiString self, NCollection_List< TCollection_AsciiString >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _TColStd.NCollection_List_TCollection_AsciiString_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_TCollection_AsciiString self, TCollection_AsciiString theItem, NCollection_List< TCollection_AsciiString >::Iterator & theIter) -> TCollection_AsciiString
        InsertBefore(NCollection_List_TCollection_AsciiString self, NCollection_List_TCollection_AsciiString theOther, NCollection_List< TCollection_AsciiString >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _TColStd.NCollection_List_TCollection_AsciiString_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_TCollection_AsciiString self, TCollection_AsciiString theItem, NCollection_List< TCollection_AsciiString >::Iterator & theIter) -> TCollection_AsciiString
        InsertAfter(NCollection_List_TCollection_AsciiString self, NCollection_List_TCollection_AsciiString theOther, NCollection_List< TCollection_AsciiString >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _TColStd.NCollection_List_TCollection_AsciiString_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_TCollection_AsciiString self)

        Reverse the list


        """
        return _TColStd.NCollection_List_TCollection_AsciiString_Reverse(self, *args)


    def __iter__(self):
        return _TColStd.NCollection_List_TCollection_AsciiString___iter__(self)
    __swig_destroy__ = _TColStd.delete_NCollection_List_TCollection_AsciiString
NCollection_List_TCollection_AsciiString_swigregister = _TColStd.NCollection_List_TCollection_AsciiString_swigregister
NCollection_List_TCollection_AsciiString_swigregister(NCollection_List_TCollection_AsciiString)

class NCollection_List_TCollection_AsciiString_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TColStd.new_NCollection_List_TCollection_AsciiString_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TColStd.delete_NCollection_List_TCollection_AsciiString_IteratorHelper

    def __next__(self):
        return _TColStd.NCollection_List_TCollection_AsciiString_IteratorHelper___next__(self)
NCollection_List_TCollection_AsciiString_IteratorHelper_swigregister = _TColStd.NCollection_List_TCollection_AsciiString_IteratorHelper_swigregister
NCollection_List_TCollection_AsciiString_IteratorHelper_swigregister(NCollection_List_TCollection_AsciiString_IteratorHelper)


try:
	TColStd_ListOfAsciiString = NCollection_List_TCollection_AsciiString
except NameError:
	pass # does not exist, probably ignored

class NCollection_DefaultHasher_Standard_Real(object):
    """
    Purpose:     The  DefaultHasher  is a  Hasher  that is used by
    default in NCollection maps. 
    To compute the  hash code of the key  is used the
    global function HashCode.
    To compare two keys is used  the  global function 
    IsEqual.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def HashCode(*args):
        """
        HashCode(double const & theKey, Standard_Integer const Upper) -> Standard_Integer

        :type theKey: const TheKeyType &
        :type Upper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_DefaultHasher_Standard_Real_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args):
        """
        IsEqual(double const & theKey1, double const & theKey2) -> Standard_Boolean

        :type theKey1: const TheKeyType &
        :type theKey2: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_DefaultHasher_Standard_Real_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    def __init__(self):
        """
        Purpose:     The  DefaultHasher  is a  Hasher  that is used by
        default in NCollection maps. 
        To compute the  hash code of the key  is used the
        global function HashCode.
        To compare two keys is used  the  global function 
        IsEqual.
        """
        this = _TColStd.new_NCollection_DefaultHasher_Standard_Real()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TColStd.delete_NCollection_DefaultHasher_Standard_Real
NCollection_DefaultHasher_Standard_Real_swigregister = _TColStd.NCollection_DefaultHasher_Standard_Real_swigregister
NCollection_DefaultHasher_Standard_Real_swigregister(NCollection_DefaultHasher_Standard_Real)

def NCollection_DefaultHasher_Standard_Real_HashCode(*args):
    """
    NCollection_DefaultHasher_Standard_Real_HashCode(double const & theKey, Standard_Integer const Upper) -> Standard_Integer

    :type theKey: const TheKeyType &
    :type Upper: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _TColStd.NCollection_DefaultHasher_Standard_Real_HashCode(*args)

def NCollection_DefaultHasher_Standard_Real_IsEqual(*args):
    """
    NCollection_DefaultHasher_Standard_Real_IsEqual(double const & theKey1, double const & theKey2) -> Standard_Boolean

    :type theKey1: const TheKeyType &
    :type theKey2: const TheKeyType &
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TColStd.NCollection_DefaultHasher_Standard_Real_IsEqual(*args)


try:
	TColStd_MapRealHasher = NCollection_DefaultHasher_Standard_Real
except NameError:
	pass # does not exist, probably ignored

class NCollection_Sequence_Handle_TCollection_HAsciiString(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_TCollection_HAsciiString self) -> NCollection_Sequence< opencascade::handle< TCollection_HAsciiString > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HAsciiString_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_TCollection_HAsciiString self) -> NCollection_Sequence< opencascade::handle< TCollection_HAsciiString > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HAsciiString_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_TCollection_HAsciiString self) -> NCollection_Sequence< opencascade::handle< TCollection_HAsciiString > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HAsciiString_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_TCollection_HAsciiString self) -> NCollection_Sequence< opencascade::handle< TCollection_HAsciiString > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HAsciiString_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _TColStd.new_NCollection_Sequence_Handle_TCollection_HAsciiString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_TCollection_HAsciiString self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HAsciiString_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_TCollection_HAsciiString self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HAsciiString_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_TCollection_HAsciiString self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HAsciiString_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_TCollection_HAsciiString self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HAsciiString_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_TCollection_HAsciiString self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HAsciiString_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_TCollection_HAsciiString self)

        Reverse sequence


        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HAsciiString_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_TCollection_HAsciiString self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HAsciiString_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HAsciiString_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_TCollection_HAsciiString self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HAsciiString_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_TCollection_HAsciiString self, NCollection_Sequence_Handle_TCollection_HAsciiString theOther) -> NCollection_Sequence_Handle_TCollection_HAsciiString

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HAsciiString_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_TCollection_HAsciiString self, NCollection_Sequence_Handle_TCollection_HAsciiString theOther) -> NCollection_Sequence_Handle_TCollection_HAsciiString

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HAsciiString_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_TCollection_HAsciiString self, NCollection_Sequence< opencascade::handle< TCollection_HAsciiString > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_TCollection_HAsciiString self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_TCollection_HAsciiString self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HAsciiString_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_TCollection_HAsciiString self, Handle_TCollection_HAsciiString theItem)
        Append(NCollection_Sequence_Handle_TCollection_HAsciiString self, NCollection_Sequence_Handle_TCollection_HAsciiString theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HAsciiString_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_TCollection_HAsciiString self, Handle_TCollection_HAsciiString theItem)
        Prepend(NCollection_Sequence_Handle_TCollection_HAsciiString self, NCollection_Sequence_Handle_TCollection_HAsciiString theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HAsciiString_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_TCollection_HAsciiString self, Standard_Integer const theIndex, Handle_TCollection_HAsciiString theItem)
        InsertBefore(NCollection_Sequence_Handle_TCollection_HAsciiString self, Standard_Integer const theIndex, NCollection_Sequence_Handle_TCollection_HAsciiString theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HAsciiString_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_TCollection_HAsciiString self, NCollection_Sequence< opencascade::handle< TCollection_HAsciiString > >::Iterator & thePosition, Handle_TCollection_HAsciiString theItem)
        InsertAfter(NCollection_Sequence_Handle_TCollection_HAsciiString self, Standard_Integer const theIndex, NCollection_Sequence_Handle_TCollection_HAsciiString theSeq)
        InsertAfter(NCollection_Sequence_Handle_TCollection_HAsciiString self, Standard_Integer const theIndex, Handle_TCollection_HAsciiString theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HAsciiString_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_TCollection_HAsciiString self, Standard_Integer const theIndex, NCollection_Sequence_Handle_TCollection_HAsciiString theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HAsciiString_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_Handle_TCollection_HAsciiString_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_TCollection_HAsciiString self) -> Handle_TCollection_HAsciiString

        First item access

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HAsciiString_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_Handle_TCollection_HAsciiString_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_TCollection_HAsciiString self) -> Handle_TCollection_HAsciiString

        Last item access

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HAsciiString_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_Handle_TCollection_HAsciiString_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_TCollection_HAsciiString self, Standard_Integer const theIndex) -> Handle_TCollection_HAsciiString

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HAsciiString_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_Handle_TCollection_HAsciiString___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_TCollection_HAsciiString self, Standard_Integer const theIndex, Handle_TCollection_HAsciiString theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HAsciiString_SetValue(self, *args)


    def __iter__(self):
        return _TColStd.NCollection_Sequence_Handle_TCollection_HAsciiString___iter__(self)
    __swig_destroy__ = _TColStd.delete_NCollection_Sequence_Handle_TCollection_HAsciiString
NCollection_Sequence_Handle_TCollection_HAsciiString_swigregister = _TColStd.NCollection_Sequence_Handle_TCollection_HAsciiString_swigregister
NCollection_Sequence_Handle_TCollection_HAsciiString_swigregister(NCollection_Sequence_Handle_TCollection_HAsciiString)

def NCollection_Sequence_Handle_TCollection_HAsciiString_delNode(*args):
    """
    NCollection_Sequence_Handle_TCollection_HAsciiString_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _TColStd.NCollection_Sequence_Handle_TCollection_HAsciiString_delNode(*args)

class NCollection_Sequence_Handle_TCollection_HAsciiString_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TColStd.new_NCollection_Sequence_Handle_TCollection_HAsciiString_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TColStd.delete_NCollection_Sequence_Handle_TCollection_HAsciiString_IteratorHelper

    def __next__(self):
        return _TColStd.NCollection_Sequence_Handle_TCollection_HAsciiString_IteratorHelper___next__(self)
NCollection_Sequence_Handle_TCollection_HAsciiString_IteratorHelper_swigregister = _TColStd.NCollection_Sequence_Handle_TCollection_HAsciiString_IteratorHelper_swigregister
NCollection_Sequence_Handle_TCollection_HAsciiString_IteratorHelper_swigregister(NCollection_Sequence_Handle_TCollection_HAsciiString_IteratorHelper)


try:
	TColStd_SequenceOfHAsciiString = NCollection_Sequence_Handle_TCollection_HAsciiString
except NameError:
	pass # does not exist, probably ignored

class NCollection_Sequence_Handle_TCollection_HExtendedString(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_Handle_TCollection_HExtendedString self) -> NCollection_Sequence< opencascade::handle< TCollection_HExtendedString > >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HExtendedString_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_Handle_TCollection_HExtendedString self) -> NCollection_Sequence< opencascade::handle< TCollection_HExtendedString > >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HExtendedString_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_Handle_TCollection_HExtendedString self) -> NCollection_Sequence< opencascade::handle< TCollection_HExtendedString > >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HExtendedString_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_Handle_TCollection_HExtendedString self) -> NCollection_Sequence< opencascade::handle< TCollection_HExtendedString > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HExtendedString_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _TColStd.new_NCollection_Sequence_Handle_TCollection_HExtendedString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_Handle_TCollection_HExtendedString self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HExtendedString_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_Handle_TCollection_HExtendedString self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HExtendedString_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_Handle_TCollection_HExtendedString self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HExtendedString_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_Handle_TCollection_HExtendedString self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HExtendedString_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_Handle_TCollection_HExtendedString self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HExtendedString_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_Handle_TCollection_HExtendedString self)

        Reverse sequence


        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HExtendedString_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_Handle_TCollection_HExtendedString self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HExtendedString_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HExtendedString_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_Handle_TCollection_HExtendedString self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HExtendedString_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_Handle_TCollection_HExtendedString self, NCollection_Sequence_Handle_TCollection_HExtendedString theOther) -> NCollection_Sequence_Handle_TCollection_HExtendedString

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HExtendedString_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_Handle_TCollection_HExtendedString self, NCollection_Sequence_Handle_TCollection_HExtendedString theOther) -> NCollection_Sequence_Handle_TCollection_HExtendedString

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HExtendedString_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_Handle_TCollection_HExtendedString self, NCollection_Sequence< opencascade::handle< TCollection_HExtendedString > >::Iterator & thePosition)
        Remove(NCollection_Sequence_Handle_TCollection_HExtendedString self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_Handle_TCollection_HExtendedString self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HExtendedString_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_Handle_TCollection_HExtendedString self, Handle_TCollection_HExtendedString theItem)
        Append(NCollection_Sequence_Handle_TCollection_HExtendedString self, NCollection_Sequence_Handle_TCollection_HExtendedString theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HExtendedString_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_Handle_TCollection_HExtendedString self, Handle_TCollection_HExtendedString theItem)
        Prepend(NCollection_Sequence_Handle_TCollection_HExtendedString self, NCollection_Sequence_Handle_TCollection_HExtendedString theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HExtendedString_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_Handle_TCollection_HExtendedString self, Standard_Integer const theIndex, Handle_TCollection_HExtendedString theItem)
        InsertBefore(NCollection_Sequence_Handle_TCollection_HExtendedString self, Standard_Integer const theIndex, NCollection_Sequence_Handle_TCollection_HExtendedString theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HExtendedString_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_Handle_TCollection_HExtendedString self, NCollection_Sequence< opencascade::handle< TCollection_HExtendedString > >::Iterator & thePosition, Handle_TCollection_HExtendedString theItem)
        InsertAfter(NCollection_Sequence_Handle_TCollection_HExtendedString self, Standard_Integer const theIndex, NCollection_Sequence_Handle_TCollection_HExtendedString theSeq)
        InsertAfter(NCollection_Sequence_Handle_TCollection_HExtendedString self, Standard_Integer const theIndex, Handle_TCollection_HExtendedString theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HExtendedString_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_Handle_TCollection_HExtendedString self, Standard_Integer const theIndex, NCollection_Sequence_Handle_TCollection_HExtendedString theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HExtendedString_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_Handle_TCollection_HExtendedString_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_Handle_TCollection_HExtendedString self) -> Handle_TCollection_HExtendedString

        First item access

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HExtendedString_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_Handle_TCollection_HExtendedString_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_Handle_TCollection_HExtendedString self) -> Handle_TCollection_HExtendedString

        Last item access

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HExtendedString_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_Handle_TCollection_HExtendedString_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_Handle_TCollection_HExtendedString self, Standard_Integer const theIndex) -> Handle_TCollection_HExtendedString

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HExtendedString_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Sequence_Handle_TCollection_HExtendedString___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_Handle_TCollection_HExtendedString self, Standard_Integer const theIndex, Handle_TCollection_HExtendedString theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TColStd.NCollection_Sequence_Handle_TCollection_HExtendedString_SetValue(self, *args)


    def __iter__(self):
        return _TColStd.NCollection_Sequence_Handle_TCollection_HExtendedString___iter__(self)
    __swig_destroy__ = _TColStd.delete_NCollection_Sequence_Handle_TCollection_HExtendedString
NCollection_Sequence_Handle_TCollection_HExtendedString_swigregister = _TColStd.NCollection_Sequence_Handle_TCollection_HExtendedString_swigregister
NCollection_Sequence_Handle_TCollection_HExtendedString_swigregister(NCollection_Sequence_Handle_TCollection_HExtendedString)

def NCollection_Sequence_Handle_TCollection_HExtendedString_delNode(*args):
    """
    NCollection_Sequence_Handle_TCollection_HExtendedString_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _TColStd.NCollection_Sequence_Handle_TCollection_HExtendedString_delNode(*args)

class NCollection_Sequence_Handle_TCollection_HExtendedString_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TColStd.new_NCollection_Sequence_Handle_TCollection_HExtendedString_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TColStd.delete_NCollection_Sequence_Handle_TCollection_HExtendedString_IteratorHelper

    def __next__(self):
        return _TColStd.NCollection_Sequence_Handle_TCollection_HExtendedString_IteratorHelper___next__(self)
NCollection_Sequence_Handle_TCollection_HExtendedString_IteratorHelper_swigregister = _TColStd.NCollection_Sequence_Handle_TCollection_HExtendedString_IteratorHelper_swigregister
NCollection_Sequence_Handle_TCollection_HExtendedString_IteratorHelper_swigregister(NCollection_Sequence_Handle_TCollection_HExtendedString_IteratorHelper)


try:
	TColStd_SequenceOfHExtendedString = NCollection_Sequence_Handle_TCollection_HExtendedString
except NameError:
	pass # does not exist, probably ignored

class NCollection_Array1_Handle_Standard_Transient(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Handle_Standard_Transient self) -> NCollection_Array1< opencascade::handle< Standard_Transient > >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _TColStd.NCollection_Array1_Handle_Standard_Transient_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Handle_Standard_Transient self) -> NCollection_Array1< opencascade::handle< Standard_Transient > >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _TColStd.NCollection_Array1_Handle_Standard_Transient_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Handle_Standard_Transient self) -> NCollection_Array1< opencascade::handle< Standard_Transient > >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Array1_Handle_Standard_Transient_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Handle_Standard_Transient self) -> NCollection_Array1< opencascade::handle< Standard_Transient > >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Array1_Handle_Standard_Transient_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _TColStd.new_NCollection_Array1_Handle_Standard_Transient(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Handle_Standard_Transient self, Handle_Standard_Transient theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _TColStd.NCollection_Array1_Handle_Standard_Transient_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Handle_Standard_Transient self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_Handle_Standard_Transient_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Handle_Standard_Transient self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_Handle_Standard_Transient_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Handle_Standard_Transient self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Array1_Handle_Standard_Transient_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Handle_Standard_Transient self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_Handle_Standard_Transient_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Handle_Standard_Transient self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_Handle_Standard_Transient_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Handle_Standard_Transient self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Array1_Handle_Standard_Transient_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Handle_Standard_Transient self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Array1_Handle_Standard_Transient_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Handle_Standard_Transient self, NCollection_Array1_Handle_Standard_Transient theOther) -> NCollection_Array1_Handle_Standard_Transient

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TColStd.NCollection_Array1_Handle_Standard_Transient_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Handle_Standard_Transient self, NCollection_Array1_Handle_Standard_Transient theOther) -> NCollection_Array1_Handle_Standard_Transient

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TColStd.NCollection_Array1_Handle_Standard_Transient_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Handle_Standard_Transient self, NCollection_Array1_Handle_Standard_Transient theOther) -> NCollection_Array1_Handle_Standard_Transient
        assign(NCollection_Array1_Handle_Standard_Transient self, NCollection_Array1_Handle_Standard_Transient theOther) -> NCollection_Array1_Handle_Standard_Transient

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TColStd.NCollection_Array1_Handle_Standard_Transient_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_Handle_Standard_Transient_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Handle_Standard_Transient self) -> Handle_Standard_Transient

        @return first element

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Array1_Handle_Standard_Transient_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_Handle_Standard_Transient_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Handle_Standard_Transient self) -> Handle_Standard_Transient

        @return last element

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Array1_Handle_Standard_Transient_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_Handle_Standard_Transient_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Handle_Standard_Transient self, Standard_Integer const theIndex) -> Handle_Standard_Transient

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Array1_Handle_Standard_Transient_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_Handle_Standard_Transient___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_Handle_Standard_Transient_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Handle_Standard_Transient self, Standard_Integer const theIndex, Handle_Standard_Transient theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TColStd.NCollection_Array1_Handle_Standard_Transient_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Handle_Standard_Transient self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _TColStd.NCollection_Array1_Handle_Standard_Transient_Resize(self, *args)

    __swig_destroy__ = _TColStd.delete_NCollection_Array1_Handle_Standard_Transient
NCollection_Array1_Handle_Standard_Transient_swigregister = _TColStd.NCollection_Array1_Handle_Standard_Transient_swigregister
NCollection_Array1_Handle_Standard_Transient_swigregister(NCollection_Array1_Handle_Standard_Transient)


try:
	TColStd_Array1OfTransient = NCollection_Array1_Handle_Standard_Transient
except NameError:
	pass # does not exist, probably ignored

class NCollection_Array2_Standard_Integer(object):
    """
    Purpose:   The class Array2 represents bi-dimensional arrays 
    of fixed size known at run time. 
    The ranges of indices are user defined.

    Warning:   Programs clients of such class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.LowerRow(); i <= A.UpperRow(); i++)
    for (j = A.LowerCol(); j <= A.UpperCol(); j++)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Purpose:   The class Array2 represents bi-dimensional arrays 
        of fixed size known at run time. 
        The ranges of indices are user defined.

        Warning:   Programs clients of such class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.LowerRow(); i <= A.UpperRow(); i++)
        for (j = A.LowerCol(); j <= A.UpperCol(); j++)
        """
        this = _TColStd.new_NCollection_Array2_Standard_Integer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array2_Standard_Integer self, int const & theValue)

        Initialise the values

        :type theValue: const TheItemType &

        """
        return _TColStd.NCollection_Array2_Standard_Integer_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array2_Standard_Integer self) -> Standard_Integer

        Size (number of items)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Standard_Integer_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array2_Standard_Integer self) -> Standard_Integer

        Length (number of items)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Standard_Integer_Length(self, *args)


    def RowLength(self, *args):
        """
        RowLength(NCollection_Array2_Standard_Integer self) -> Standard_Integer

        Returns length of the row, i.e. number of columns

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Standard_Integer_RowLength(self, *args)


    def ColLength(self, *args):
        """
        ColLength(NCollection_Array2_Standard_Integer self) -> Standard_Integer

        Returns length of the column, i.e. number of rows

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Standard_Integer_ColLength(self, *args)


    def LowerRow(self, *args):
        """
        LowerRow(NCollection_Array2_Standard_Integer self) -> Standard_Integer

        LowerRow

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Standard_Integer_LowerRow(self, *args)


    def UpperRow(self, *args):
        """
        UpperRow(NCollection_Array2_Standard_Integer self) -> Standard_Integer

        UpperRow

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Standard_Integer_UpperRow(self, *args)


    def LowerCol(self, *args):
        """
        LowerCol(NCollection_Array2_Standard_Integer self) -> Standard_Integer

        LowerCol

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Standard_Integer_LowerCol(self, *args)


    def UpperCol(self, *args):
        """
        UpperCol(NCollection_Array2_Standard_Integer self) -> Standard_Integer

        UpperCol

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array2_Standard_Integer_UpperCol(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array2_Standard_Integer self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Array2_Standard_Integer_IsDeletable(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array2_Standard_Integer self, NCollection_Array2_Standard_Integer theOther) -> NCollection_Array2_Standard_Integer

        Assignment

        :type theOther: OCC.wrapper.NCollection.NCollection_Array2
        :rtype: OCC.wrapper.NCollection.NCollection_Array2

        """
        return _TColStd.NCollection_Array2_Standard_Integer_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array2_Standard_Integer self, NCollection_Array2_Standard_Integer theOther) -> NCollection_Array2_Standard_Integer

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Array2
        :rtype: OCC.wrapper.NCollection.NCollection_Array2

        """
        return _TColStd.NCollection_Array2_Standard_Integer_assign(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theRow: int
        :type theCol: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array2_Standard_Integer_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array2_Standard_Integer self, Standard_Integer const theRow, Standard_Integer const theCol) -> int &

        Variable value access

        :type theRow: int
        :type theCol: int
        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Array2_Standard_Integer_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to ChangeValue

        :type theRow: int
        :type theCol: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array2_Standard_Integer___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array2_Standard_Integer self, Standard_Integer const theRow, Standard_Integer const theCol, int const & theItem)

        SetValue

        :type theRow: int
        :type theCol: int
        :type theItem: const TheItemType &

        """
        return _TColStd.NCollection_Array2_Standard_Integer_SetValue(self, *args)

    __swig_destroy__ = _TColStd.delete_NCollection_Array2_Standard_Integer
NCollection_Array2_Standard_Integer_swigregister = _TColStd.NCollection_Array2_Standard_Integer_swigregister
NCollection_Array2_Standard_Integer_swigregister(NCollection_Array2_Standard_Integer)


try:
	TColStd_Array2OfInteger = NCollection_Array2_Standard_Integer
except NameError:
	pass # does not exist, probably ignored


try:
	Handle_TCollection_HExtendedString = TCollection.Handle_TCollection_HExtendedString
except AttributeError:
	pass # does not exist, probably ignored

class Handle_TColStd_HArray2OfReal(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TColStd_HArray2OfReal self)

        Nullify the handle


        """
        return _TColStd.Handle_TColStd_HArray2OfReal_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TColStd_HArray2OfReal self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TColStd.Handle_TColStd_HArray2OfReal_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TColStd_HArray2OfReal self, TColStd_HArray2OfReal thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TColStd.Handle_TColStd_HArray2OfReal_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TColStd_HArray2OfReal self, Handle_TColStd_HArray2OfReal theHandle) -> Handle_TColStd_HArray2OfReal
        assign(Handle_TColStd_HArray2OfReal self, TColStd_HArray2OfReal thePtr) -> Handle_TColStd_HArray2OfReal
        assign(Handle_TColStd_HArray2OfReal self, Handle_TColStd_HArray2OfReal theHandle) -> Handle_TColStd_HArray2OfReal

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TColStd.Handle_TColStd_HArray2OfReal_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TColStd_HArray2OfReal self) -> TColStd_HArray2OfReal

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HArray2OfReal_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TColStd_HArray2OfReal self) -> TColStd_HArray2OfReal

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HArray2OfReal___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TColStd_HArray2OfReal self) -> TColStd_HArray2OfReal

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TColStd.Handle_TColStd_HArray2OfReal___ref__(self, *args)


    def __hash__(self):
        return _TColStd.Handle_TColStd_HArray2OfReal___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TColStd.Handle_TColStd_HArray2OfReal___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TColStd.new_Handle_TColStd_HArray2OfReal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TColStd.Handle_TColStd_HArray2OfReal_DownCast)
    __swig_destroy__ = _TColStd.delete_Handle_TColStd_HArray2OfReal

    def Array2(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array2OfReal

        """
        res = _TColStd.Handle_TColStd_HArray2OfReal_Array2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray2(self, *args):
        """
        ChangeArray2(Handle_TColStd_HArray2OfReal self) -> NCollection_Array2_Standard_Real

        :rtype: OCC.wrapper.TColStd.TColStd_Array2OfReal

        """
        return _TColStd.Handle_TColStd_HArray2OfReal_ChangeArray2(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TColStd_HArray2OfReal self) -> char const *

        :rtype: const char *

        """
        return _TColStd.Handle_TColStd_HArray2OfReal_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HArray2OfReal_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HArray2OfReal_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TColStd_HArray2OfReal self)

        Memory deallocator for transient classes


        """
        return _TColStd.Handle_TColStd_HArray2OfReal_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TColStd_HArray2OfReal self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TColStd_HArray2OfReal self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HArray2OfReal_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TColStd_HArray2OfReal self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TColStd_HArray2OfReal self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HArray2OfReal_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TColStd_HArray2OfReal self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TColStd.Handle_TColStd_HArray2OfReal_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TColStd_HArray2OfReal self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray2OfReal_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TColStd_HArray2OfReal self)

        Increments the reference counter of this object


        """
        return _TColStd.Handle_TColStd_HArray2OfReal_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TColStd_HArray2OfReal self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray2OfReal_DecrementRefCounter(self, *args)

Handle_TColStd_HArray2OfReal_swigregister = _TColStd.Handle_TColStd_HArray2OfReal_swigregister
Handle_TColStd_HArray2OfReal_swigregister(Handle_TColStd_HArray2OfReal)

def Handle_TColStd_HArray2OfReal_DownCast(thing):
    return _TColStd.Handle_TColStd_HArray2OfReal_DownCast(thing)
Handle_TColStd_HArray2OfReal_DownCast = _TColStd.Handle_TColStd_HArray2OfReal_DownCast

class NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used to  store  keys and to bind
    an index to them.  Each new key stored in  the map
    gets an index.  Index are incremented  as keys are
    stored in the map. A key can be found by the index
    and an index by the  key. No key  but the last can
    be removed so the indices are in the range 1..Extent.
    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher self) -> NCollection_IndexedMap< opencascade::handle< Standard_Transient >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher self) -> NCollection_IndexedMap< opencascade::handle< Standard_Transient >,TColStd_MapTransientHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used to  store  keys and to bind
        an index to them.  Each new key stored in  the map
        gets an index.  Index are incremented  as keys are
        stored in the map. A key can be found by the index
        and an index by the  key. No key  but the last can
        be removed so the indices are in the range 1..Extent.
        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _TColStd.new_NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher self, NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedMap

        """
        return _TColStd.NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher self, NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher theOther) -> NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher

        Assign.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedMap

        """
        return _TColStd.NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher self, NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher theOther) -> NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedMap

        """
        return _TColStd.NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher self, Standard_Integer const theExtent)

        ReSize

        :type theExtent: int

        """
        return _TColStd.NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey1) -> Standard_Integer

        Add

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher self, Standard_Integer const theIndex, Handle_Standard_Transient theKey1)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &

        """
        return _TColStd.NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _TColStd.NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher self)

        RemoveLast


        """
        return _TColStd.NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _TColStd.NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey1) -> Standard_Boolean

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _TColStd.NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _TColStd.NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher self, Handle_Standard_Transient theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher_FindIndex(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher_Size(self, *args)


    def __iter__(self):
        return _TColStd.NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher___iter__(self)
    __swig_destroy__ = _TColStd.delete_NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher
NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher_swigregister = _TColStd.NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher_swigregister
NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher_swigregister(NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher)

class NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TColStd.new_NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TColStd.delete_NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher_IteratorHelper

    def __next__(self):
        return _TColStd.NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher_IteratorHelper___next__(self)
NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher_IteratorHelper_swigregister = _TColStd.NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher_IteratorHelper_swigregister
NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher_IteratorHelper_swigregister(NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher_IteratorHelper)


try:
	TColStd_IndexedMapOfTransient = NCollection_IndexedMap_Handle_Standard_Transient_TColStd_MapTransientHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_Array1_Standard_Real(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Standard_Real self) -> NCollection_Array1< Standard_Real >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _TColStd.NCollection_Array1_Standard_Real_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Standard_Real self) -> NCollection_Array1< Standard_Real >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _TColStd.NCollection_Array1_Standard_Real_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Standard_Real self) -> NCollection_Array1< Standard_Real >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Array1_Standard_Real_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Standard_Real self) -> NCollection_Array1< Standard_Real >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Array1_Standard_Real_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _TColStd.new_NCollection_Array1_Standard_Real(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Standard_Real self, double const & theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _TColStd.NCollection_Array1_Standard_Real_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Standard_Real self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_Standard_Real_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Standard_Real self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_Standard_Real_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Standard_Real self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Array1_Standard_Real_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Standard_Real self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_Standard_Real_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Standard_Real self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_Standard_Real_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Standard_Real self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Array1_Standard_Real_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Standard_Real self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Array1_Standard_Real_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Standard_Real self, NCollection_Array1_Standard_Real theOther) -> NCollection_Array1_Standard_Real

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TColStd.NCollection_Array1_Standard_Real_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Standard_Real self, NCollection_Array1_Standard_Real theOther) -> NCollection_Array1_Standard_Real

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TColStd.NCollection_Array1_Standard_Real_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Standard_Real self, NCollection_Array1_Standard_Real theOther) -> NCollection_Array1_Standard_Real
        assign(NCollection_Array1_Standard_Real self, NCollection_Array1_Standard_Real theOther) -> NCollection_Array1_Standard_Real

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TColStd.NCollection_Array1_Standard_Real_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_Standard_Real_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Standard_Real self) -> double &

        @return first element

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Array1_Standard_Real_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_Standard_Real_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Standard_Real self) -> double &

        @return last element

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Array1_Standard_Real_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_Standard_Real_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Standard_Real self, Standard_Integer const theIndex) -> double &

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Array1_Standard_Real_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_Standard_Real___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_Standard_Real_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Standard_Real self, Standard_Integer const theIndex, double const & theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TColStd.NCollection_Array1_Standard_Real_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Standard_Real self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _TColStd.NCollection_Array1_Standard_Real_Resize(self, *args)

    __swig_destroy__ = _TColStd.delete_NCollection_Array1_Standard_Real
NCollection_Array1_Standard_Real_swigregister = _TColStd.NCollection_Array1_Standard_Real_swigregister
NCollection_Array1_Standard_Real_swigregister(NCollection_Array1_Standard_Real)


try:
	TColStd_Array1OfReal = NCollection_Array1_Standard_Real
except NameError:
	pass # does not exist, probably ignored

class NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,Standard_Integer,TColStd_MapIntegerHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,Standard_Integer,TColStd_MapIntegerHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,Standard_Integer,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher self) -> NCollection_DataMap< Standard_Integer,Standard_Integer,TColStd_MapIntegerHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TColStd.new_NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher self, NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher theOther) -> NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher self, int const & theKey, int const & theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher self, int const & theKey, int const & theItem) -> int *

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher self, int const & theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher self, int const & theKey) -> int const *

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher self, int const & theKey) -> int *

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher self, int const & theKey) -> int &

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher_Size(self, *args)


    def __iter__(self):
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher___iter__(self)
    __swig_destroy__ = _TColStd.delete_NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher
NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher_swigregister = _TColStd.NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher_swigregister
NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher_swigregister(NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher)

class NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TColStd.new_NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TColStd.delete_NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher_IteratorHelper

    def __next__(self):
        return _TColStd.NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher_IteratorHelper___next__(self)
NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher_IteratorHelper_swigregister = _TColStd.NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher_IteratorHelper_swigregister
NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher_IteratorHelper_swigregister(NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher_IteratorHelper)


try:
	TColStd_DataMapOfIntegerInteger = NCollection_DataMap_Standard_Integer_Standard_Integer_TColStd_MapIntegerHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_TColStd_HArray1OfInteger(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TColStd_HArray1OfInteger self)

        Nullify the handle


        """
        return _TColStd.Handle_TColStd_HArray1OfInteger_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TColStd_HArray1OfInteger self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TColStd.Handle_TColStd_HArray1OfInteger_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TColStd_HArray1OfInteger self, TColStd_HArray1OfInteger thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TColStd.Handle_TColStd_HArray1OfInteger_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TColStd_HArray1OfInteger self, Handle_TColStd_HArray1OfInteger theHandle) -> Handle_TColStd_HArray1OfInteger
        assign(Handle_TColStd_HArray1OfInteger self, TColStd_HArray1OfInteger thePtr) -> Handle_TColStd_HArray1OfInteger
        assign(Handle_TColStd_HArray1OfInteger self, Handle_TColStd_HArray1OfInteger theHandle) -> Handle_TColStd_HArray1OfInteger

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TColStd.Handle_TColStd_HArray1OfInteger_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TColStd_HArray1OfInteger self) -> TColStd_HArray1OfInteger

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HArray1OfInteger_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TColStd_HArray1OfInteger self) -> TColStd_HArray1OfInteger

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HArray1OfInteger___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TColStd_HArray1OfInteger self) -> TColStd_HArray1OfInteger

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TColStd.Handle_TColStd_HArray1OfInteger___ref__(self, *args)


    def __hash__(self):
        return _TColStd.Handle_TColStd_HArray1OfInteger___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TColStd.Handle_TColStd_HArray1OfInteger___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TColStd.new_Handle_TColStd_HArray1OfInteger(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TColStd.Handle_TColStd_HArray1OfInteger_DownCast)
    __swig_destroy__ = _TColStd.delete_Handle_TColStd_HArray1OfInteger

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        res = _TColStd.Handle_TColStd_HArray1OfInteger_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_TColStd_HArray1OfInteger self) -> NCollection_Array1_Standard_Integer

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _TColStd.Handle_TColStd_HArray1OfInteger_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TColStd_HArray1OfInteger self) -> char const *

        :rtype: const char *

        """
        return _TColStd.Handle_TColStd_HArray1OfInteger_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HArray1OfInteger_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HArray1OfInteger_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TColStd_HArray1OfInteger self)

        Memory deallocator for transient classes


        """
        return _TColStd.Handle_TColStd_HArray1OfInteger_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TColStd_HArray1OfInteger self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TColStd_HArray1OfInteger self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HArray1OfInteger_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TColStd_HArray1OfInteger self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TColStd_HArray1OfInteger self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HArray1OfInteger_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TColStd_HArray1OfInteger self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TColStd.Handle_TColStd_HArray1OfInteger_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TColStd_HArray1OfInteger self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray1OfInteger_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TColStd_HArray1OfInteger self)

        Increments the reference counter of this object


        """
        return _TColStd.Handle_TColStd_HArray1OfInteger_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TColStd_HArray1OfInteger self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray1OfInteger_DecrementRefCounter(self, *args)

Handle_TColStd_HArray1OfInteger_swigregister = _TColStd.Handle_TColStd_HArray1OfInteger_swigregister
Handle_TColStd_HArray1OfInteger_swigregister(Handle_TColStd_HArray1OfInteger)

def Handle_TColStd_HArray1OfInteger_DownCast(thing):
    return _TColStd.Handle_TColStd_HArray1OfInteger_DownCast(thing)
Handle_TColStd_HArray1OfInteger_DownCast = _TColStd.Handle_TColStd_HArray1OfInteger_DownCast

class Handle_TColStd_HArray1OfBoolean(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TColStd_HArray1OfBoolean self)

        Nullify the handle


        """
        return _TColStd.Handle_TColStd_HArray1OfBoolean_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TColStd_HArray1OfBoolean self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TColStd.Handle_TColStd_HArray1OfBoolean_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TColStd_HArray1OfBoolean self, TColStd_HArray1OfBoolean thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TColStd.Handle_TColStd_HArray1OfBoolean_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TColStd_HArray1OfBoolean self, Handle_TColStd_HArray1OfBoolean theHandle) -> Handle_TColStd_HArray1OfBoolean
        assign(Handle_TColStd_HArray1OfBoolean self, TColStd_HArray1OfBoolean thePtr) -> Handle_TColStd_HArray1OfBoolean
        assign(Handle_TColStd_HArray1OfBoolean self, Handle_TColStd_HArray1OfBoolean theHandle) -> Handle_TColStd_HArray1OfBoolean

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TColStd.Handle_TColStd_HArray1OfBoolean_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TColStd_HArray1OfBoolean self) -> TColStd_HArray1OfBoolean

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HArray1OfBoolean_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TColStd_HArray1OfBoolean self) -> TColStd_HArray1OfBoolean

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TColStd.Handle_TColStd_HArray1OfBoolean___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TColStd_HArray1OfBoolean self) -> TColStd_HArray1OfBoolean

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TColStd.Handle_TColStd_HArray1OfBoolean___ref__(self, *args)


    def __hash__(self):
        return _TColStd.Handle_TColStd_HArray1OfBoolean___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TColStd.Handle_TColStd_HArray1OfBoolean___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TColStd.new_Handle_TColStd_HArray1OfBoolean(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TColStd.Handle_TColStd_HArray1OfBoolean_DownCast)
    __swig_destroy__ = _TColStd.delete_Handle_TColStd_HArray1OfBoolean

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfBoolean

        """
        res = _TColStd.Handle_TColStd_HArray1OfBoolean_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_TColStd_HArray1OfBoolean self) -> NCollection_Array1_Standard_Boolean

        :rtype: OCC.wrapper.TColStd.TColStd_Array1OfBoolean

        """
        return _TColStd.Handle_TColStd_HArray1OfBoolean_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TColStd_HArray1OfBoolean self) -> char const *

        :rtype: const char *

        """
        return _TColStd.Handle_TColStd_HArray1OfBoolean_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HArray1OfBoolean_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TColStd.Handle_TColStd_HArray1OfBoolean_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TColStd_HArray1OfBoolean self)

        Memory deallocator for transient classes


        """
        return _TColStd.Handle_TColStd_HArray1OfBoolean_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TColStd_HArray1OfBoolean self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TColStd_HArray1OfBoolean self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HArray1OfBoolean_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TColStd_HArray1OfBoolean self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TColStd_HArray1OfBoolean self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.Handle_TColStd_HArray1OfBoolean_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TColStd_HArray1OfBoolean self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TColStd.Handle_TColStd_HArray1OfBoolean_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TColStd_HArray1OfBoolean self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray1OfBoolean_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TColStd_HArray1OfBoolean self)

        Increments the reference counter of this object


        """
        return _TColStd.Handle_TColStd_HArray1OfBoolean_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TColStd_HArray1OfBoolean self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.Handle_TColStd_HArray1OfBoolean_DecrementRefCounter(self, *args)

Handle_TColStd_HArray1OfBoolean_swigregister = _TColStd.Handle_TColStd_HArray1OfBoolean_swigregister
Handle_TColStd_HArray1OfBoolean_swigregister(Handle_TColStd_HArray1OfBoolean)

def Handle_TColStd_HArray1OfBoolean_DownCast(thing):
    return _TColStd.Handle_TColStd_HArray1OfBoolean_DownCast(thing)
Handle_TColStd_HArray1OfBoolean_DownCast = _TColStd.Handle_TColStd_HArray1OfBoolean_DownCast

class NCollection_Array1_Standard_Integer(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_Standard_Integer self) -> NCollection_Array1< Standard_Integer >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _TColStd.NCollection_Array1_Standard_Integer_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_Standard_Integer self) -> NCollection_Array1< Standard_Integer >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _TColStd.NCollection_Array1_Standard_Integer_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_Standard_Integer self) -> NCollection_Array1< Standard_Integer >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Array1_Standard_Integer_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_Standard_Integer self) -> NCollection_Array1< Standard_Integer >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _TColStd.NCollection_Array1_Standard_Integer_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _TColStd.new_NCollection_Array1_Standard_Integer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_Standard_Integer self, int const & theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _TColStd.NCollection_Array1_Standard_Integer_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_Standard_Integer self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_Standard_Integer_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_Standard_Integer self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_Standard_Integer_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_Standard_Integer self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Array1_Standard_Integer_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_Standard_Integer self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_Standard_Integer_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_Standard_Integer self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TColStd.NCollection_Array1_Standard_Integer_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_Standard_Integer self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Array1_Standard_Integer_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_Standard_Integer self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TColStd.NCollection_Array1_Standard_Integer_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_Standard_Integer self, NCollection_Array1_Standard_Integer theOther) -> NCollection_Array1_Standard_Integer

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TColStd.NCollection_Array1_Standard_Integer_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_Standard_Integer self, NCollection_Array1_Standard_Integer theOther) -> NCollection_Array1_Standard_Integer

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TColStd.NCollection_Array1_Standard_Integer_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_Standard_Integer self, NCollection_Array1_Standard_Integer theOther) -> NCollection_Array1_Standard_Integer
        assign(NCollection_Array1_Standard_Integer self, NCollection_Array1_Standard_Integer theOther) -> NCollection_Array1_Standard_Integer

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TColStd.NCollection_Array1_Standard_Integer_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_Standard_Integer_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_Standard_Integer self) -> int &

        @return first element

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Array1_Standard_Integer_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_Standard_Integer_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_Standard_Integer self) -> int &

        @return last element

        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Array1_Standard_Integer_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_Standard_Integer_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_Standard_Integer self, Standard_Integer const theIndex) -> int &

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TColStd.NCollection_Array1_Standard_Integer_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_Standard_Integer___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TColStd.NCollection_Array1_Standard_Integer_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_Standard_Integer self, Standard_Integer const theIndex, int const & theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TColStd.NCollection_Array1_Standard_Integer_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_Standard_Integer self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _TColStd.NCollection_Array1_Standard_Integer_Resize(self, *args)

    __swig_destroy__ = _TColStd.delete_NCollection_Array1_Standard_Integer
NCollection_Array1_Standard_Integer_swigregister = _TColStd.NCollection_Array1_Standard_Integer_swigregister
NCollection_Array1_Standard_Integer_swigregister(NCollection_Array1_Standard_Integer)


try:
	TColStd_Array1OfInteger = NCollection_Array1_Standard_Integer
except NameError:
	pass # does not exist, probably ignored




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_ShapeFix')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_ShapeFix')
    _ShapeFix = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ShapeFix', [dirname(__file__)])
        except ImportError:
            import _ShapeFix
            return _ShapeFix
        try:
            _mod = imp.load_module('_ShapeFix', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _ShapeFix = swig_import_helper()
    del swig_import_helper
else:
    import _ShapeFix
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ShapeFix.delete_SwigPyIterator

    def value(self):
        return _ShapeFix.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _ShapeFix.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _ShapeFix.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _ShapeFix.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _ShapeFix.SwigPyIterator_equal(self, x)

    def copy(self):
        return _ShapeFix.SwigPyIterator_copy(self)

    def next(self):
        return _ShapeFix.SwigPyIterator_next(self)

    def __next__(self):
        return _ShapeFix.SwigPyIterator___next__(self)

    def previous(self):
        return _ShapeFix.SwigPyIterator_previous(self)

    def advance(self, n):
        return _ShapeFix.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _ShapeFix.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _ShapeFix.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _ShapeFix.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _ShapeFix.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _ShapeFix.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _ShapeFix.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _ShapeFix.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _ShapeFix.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_ShapeFix.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _ShapeFix.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _ShapeFix.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ShapeFix.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _ShapeFix.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _ShapeFix.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _ShapeFix.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _ShapeFix.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_ShapeFix.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _ShapeFix.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _ShapeFix.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ShapeFix.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _ShapeFix.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _ShapeFix.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _ShapeFix.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _ShapeFix.ptr_to_number(item)
ptr_to_number = _ShapeFix.ptr_to_number

def HashCode(*args):
    return _ShapeFix.HashCode(*args)
HashCode = _ShapeFix.HashCode

def ptr_equal(a, b):
    return _ShapeFix.ptr_equal(a, b)
ptr_equal = _ShapeFix.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import ShapeExtend
else:
    import ShapeExtend
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColGeom
else:
    import TColGeom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import ShapeBuild
else:
    import ShapeBuild
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepTools
else:
    import BRepTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Poly
else:
    import Poly
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TShort
else:
    import TShort
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRep
else:
    import BRep
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import ShapeAnalysis
else:
    import ShapeAnalysis
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntRes2d
else:
    import IntRes2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import ShapeConstruct
else:
    import ShapeConstruct
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepBuilderAPI
else:
    import BRepBuilderAPI
del _swig_python_version_info
class ShapeFix_EdgeProjAux(Standard.Standard_Transient):
    """
    Project 3D point (vertex) on pcurves to find Vertex Parameter
    on parametric representation of an edge
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeFix_EdgeProjAux
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeFix_EdgeProjAux(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeFix_EdgeProjAux self) -> ShapeFix_EdgeProjAux
        __init__(ShapeFix_EdgeProjAux self, TopoDS_Face F, TopoDS_Edge E) -> ShapeFix_EdgeProjAux

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        this = _ShapeFix.new_ShapeFix_EdgeProjAux(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(ShapeFix_EdgeProjAux self, TopoDS_Face F, TopoDS_Edge E)

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _ShapeFix.ShapeFix_EdgeProjAux_Init(self, *args)


    def Compute(self, *args):
        """
        Compute(ShapeFix_EdgeProjAux self, Standard_Real const preci)

        :type preci: float

        """
        return _ShapeFix.ShapeFix_EdgeProjAux_Compute(self, *args)


    def IsFirstDone(self, *args):
        """
        IsFirstDone(ShapeFix_EdgeProjAux self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_EdgeProjAux_IsFirstDone(self, *args)


    def IsLastDone(self, *args):
        """
        IsLastDone(ShapeFix_EdgeProjAux self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_EdgeProjAux_IsLastDone(self, *args)


    def FirstParam(self, *args):
        """
        FirstParam(ShapeFix_EdgeProjAux self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.ShapeFix_EdgeProjAux_FirstParam(self, *args)


    def LastParam(self, *args):
        """
        LastParam(ShapeFix_EdgeProjAux self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.ShapeFix_EdgeProjAux_LastParam(self, *args)


    def IsIso(self, *args):
        """
        IsIso(ShapeFix_EdgeProjAux self, Handle_Geom2d_Curve C) -> Standard_Boolean

        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_EdgeProjAux_IsIso(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeFix.ShapeFix_EdgeProjAux_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeFix.ShapeFix_EdgeProjAux_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.ShapeFix_EdgeProjAux_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeFix.delete_ShapeFix_EdgeProjAux
ShapeFix_EdgeProjAux_swigregister = _ShapeFix.ShapeFix_EdgeProjAux_swigregister
ShapeFix_EdgeProjAux_swigregister(ShapeFix_EdgeProjAux)

def ShapeFix_EdgeProjAux_get_type_name(*args):
    """
    ShapeFix_EdgeProjAux_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeFix.ShapeFix_EdgeProjAux_get_type_name(*args)

def ShapeFix_EdgeProjAux_get_type_descriptor(*args):
    """
    ShapeFix_EdgeProjAux_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeFix.ShapeFix_EdgeProjAux_get_type_descriptor(*args)

class ShapeFix_Root(Standard.Standard_Transient):
    """
    Root class for fixing operations
    Provides context for recording changes (optional),
    basic precision value and limit (minimal and
    maximal) values for tolerances,
    and message registrator
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeFix_Root
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeFix_Root(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeFix_Root self) -> ShapeFix_Root

        Empty Constructor (no context is created)


        """
        this = _ShapeFix.new_ShapeFix_Root(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Set(self, *args):
        """
        Set(ShapeFix_Root self, Handle_ShapeFix_Root Root)

        Copy all fields from another Root object

        :type Root: OCC.wrapper.ShapeFix.Handle_ShapeFix_Root

        """
        return _ShapeFix.ShapeFix_Root_Set(self, *args)


    def SetContext(self, *args):
        """
        SetContext(ShapeFix_Root self, Handle_ShapeBuild_ReShape context)

        Sets context

        :type context: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeFix.ShapeFix_Root_SetContext(self, *args)


    def Context(self, *args):
        """
        Context(ShapeFix_Root self) -> Handle_ShapeBuild_ReShape

        Returns context

        :rtype: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeFix.ShapeFix_Root_Context(self, *args)


    def SetMsgRegistrator(self, *args):
        """
        SetMsgRegistrator(ShapeFix_Root self, Handle_ShapeExtend_BasicMsgRegistrator msgreg)

        Sets message registrator

        :type msgreg: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeFix.ShapeFix_Root_SetMsgRegistrator(self, *args)


    def MsgRegistrator(self, *args):
        """
        MsgRegistrator(ShapeFix_Root self) -> Handle_ShapeExtend_BasicMsgRegistrator

        Returns message registrator

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeFix.ShapeFix_Root_MsgRegistrator(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(ShapeFix_Root self, Standard_Real const preci)

        Sets basic precision value

        :type preci: float

        """
        return _ShapeFix.ShapeFix_Root_SetPrecision(self, *args)


    def Precision(self, *args):
        """
        Precision(ShapeFix_Root self) -> Standard_Real

        Returns basic precision value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.ShapeFix_Root_Precision(self, *args)


    def SetMinTolerance(self, *args):
        """
        SetMinTolerance(ShapeFix_Root self, Standard_Real const mintol)

        Sets minimal allowed tolerance

        :type mintol: float

        """
        return _ShapeFix.ShapeFix_Root_SetMinTolerance(self, *args)


    def MinTolerance(self, *args):
        """
        MinTolerance(ShapeFix_Root self) -> Standard_Real

        Returns minimal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.ShapeFix_Root_MinTolerance(self, *args)


    def SetMaxTolerance(self, *args):
        """
        SetMaxTolerance(ShapeFix_Root self, Standard_Real const maxtol)

        Sets maximal allowed tolerance

        :type maxtol: float

        """
        return _ShapeFix.ShapeFix_Root_SetMaxTolerance(self, *args)


    def MaxTolerance(self, *args):
        """
        MaxTolerance(ShapeFix_Root self) -> Standard_Real

        Returns maximal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.ShapeFix_Root_MaxTolerance(self, *args)


    def LimitTolerance(self, *args):
        """
        LimitTolerance(ShapeFix_Root self, Standard_Real const toler) -> Standard_Real

        Returns tolerance limited by [myMinTol,myMaxTol]

        :type toler: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.ShapeFix_Root_LimitTolerance(self, *args)


    def SendMsg(self, *args):
        """
        SendMsg(ShapeFix_Root self, TopoDS_Shape shape, Message_Msg message, Message_Gravity const gravity=Message_Info)
        SendMsg(ShapeFix_Root self, Message_Msg message, Message_Gravity const gravity=Message_Info)

        Sends a message to be attached to myShape.
        Calls previous method.

        :type message: OCC.wrapper.Message.Message_Msg
        :type gravity: OCC.wrapper.Message.Message_Gravity

        """
        return _ShapeFix.ShapeFix_Root_SendMsg(self, *args)


    def SendWarning(self, *args):
        """
        SendWarning(ShapeFix_Root self, TopoDS_Shape shape, Message_Msg message)
        SendWarning(ShapeFix_Root self, Message_Msg message)

        Calls previous method for myShape.

        :type message: OCC.wrapper.Message.Message_Msg

        """
        return _ShapeFix.ShapeFix_Root_SendWarning(self, *args)


    def SendFail(self, *args):
        """
        SendFail(ShapeFix_Root self, TopoDS_Shape shape, Message_Msg message)
        SendFail(ShapeFix_Root self, Message_Msg message)

        Calls previous method for myShape.

        :type message: OCC.wrapper.Message.Message_Msg

        """
        return _ShapeFix.ShapeFix_Root_SendFail(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeFix.ShapeFix_Root_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeFix.ShapeFix_Root_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.ShapeFix_Root_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeFix.delete_ShapeFix_Root
ShapeFix_Root_swigregister = _ShapeFix.ShapeFix_Root_swigregister
ShapeFix_Root_swigregister(ShapeFix_Root)

def ShapeFix_Root_get_type_name(*args):
    """
    ShapeFix_Root_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeFix.ShapeFix_Root_get_type_name(*args)

def ShapeFix_Root_get_type_descriptor(*args):
    """
    ShapeFix_Root_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeFix.ShapeFix_Root_get_type_descriptor(*args)

class ShapeFix_ComposeShell(ShapeFix_Root):
    """
    This class is intended to create a shell from the composite
    surface (grid of surfaces) and set of wires.
    It may be either division of the supporting surface of the
    face, or creating a shape corresponding to face on composite
    surface which is missing in CAS.CADE but exists in some other
    systems.

    It splits (if necessary) original face to several ones by
    splitting lines which are joint lines on a supplied grid of
    surfaces (U- and V- isolines of the  composite surface).
    There are two modes of work, which differ in the way of
    handling faces on periodic surfaces:

    - if ClosedMode is False (default), when splitting itself is
    done as if surface were not periodic. The periodicity of the
    underlying surface is taken into account by duplicating splitting
    lines in the periodic direction, as necessary to split all
    the wires (whole parametrical range of a face)
    In this mode, some regularization procedures are performed
    (indexation of splitted segments by patch numbers), and it is
    expected to be more reliable and robust in case of bad shapes

    - if ClosedMode is True, when everything on a periodic surfaces
    is considered as modulo period. This allows to deal with wires
    which are closed in 3d but not in 2d, with wires which may be
    shifted on several periods in 2d etc. However, this mode is
    less reliable since some regularizations do not work for it.

    The work is made basing on pcurves of the edges. These pcurves
    should already exist (for example, in the case of division of
    existing face), then they are taken as is. The existing pcurves
    should be assigned to one surface (face) for all edges,
    this surface (face) will be used only for accessing pcurves,
    and it may have any geometry.

    All the modifications are recorded in the context tool
    (ShapeBuild_ReShape).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeFix_ComposeShell
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeFix_ComposeShell(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeFix_ComposeShell self) -> ShapeFix_ComposeShell

        Creates empty tool.


        """
        this = _ShapeFix.new_ShapeFix_ComposeShell(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(ShapeFix_ComposeShell self, Handle_ShapeExtend_CompositeSurface Grid, TopLoc_Location L, TopoDS_Face Face, Standard_Real const Prec)

        Initializes with composite surface, face and precision.
        Here face defines both set of wires and way of getting
        pcurves. Precision is used (together with tolerance of edges)
        for handling subtle cases, such as tangential intersections.

        :type Grid: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_CompositeSurface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Face: OCC.wrapper.TopoDS.TopoDS_Face
        :type Prec: float

        """
        return _ShapeFix.ShapeFix_ComposeShell_Init(self, *args)


    def ClosedMode(self, *args):
        """
        ClosedMode(ShapeFix_ComposeShell self) -> Standard_Boolean &

        Returns (modifiable) flag for special 'closed'
        mode which forces ComposeShell to consider
        all pcurves on closed surface as modulo period.
        This can reduce reliability, but allows to deal
        with wires closed in 3d but open in 2d (missing seam)
        Default is False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_ComposeShell_ClosedMode(self, *args)


    def Perform(self, *args):
        """
        Perform(ShapeFix_ComposeShell self) -> Standard_Boolean

        Performs the work on already loaded data.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_ComposeShell_Perform(self, *args)


    def SplitEdges(self, *args):
        """
        SplitEdges(ShapeFix_ComposeShell self)

        Splits edges in the original shape by grid.
        This is a part of Perform() which does not produce any
        resulting shape; the only result is filled context
        where splittings are recorded.

        NOTE: If edge is splitted, it is replaced by wire, and
        order of edges in the wire corresponds to FORWARD orientation
        of the edge.


        """
        return _ShapeFix.ShapeFix_ComposeShell_SplitEdges(self, *args)


    def Result(self, *args):
        """
        Returns resulting shell or face (or Null shape if not done)

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _ShapeFix.ShapeFix_ComposeShell_Result(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Status(self, *args):
        """
        Status(ShapeFix_ComposeShell self, ShapeExtend_Status const status) -> Standard_Boolean

        Queries status of last call to Perform()
        OK   : nothing done (some kind of error)
        DONE1: splitting is done, at least one new face created
        DONE2: splitting is done, several new faces obtained
        FAIL1: misoriented wire encountered (handled)
        FAIL2: recoverable parity error
        FAIL3: edge with no pcurve on supporting face
        FAIL4: unrecoverable algorithm error (parity check)

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_ComposeShell_Status(self, *args)


    def DispatchWires(self, *args):
        """
        DispatchWires(ShapeFix_ComposeShell self, NCollection_Sequence_TopoDS_Shape faces, NCollection_Sequence_ShapeFix_WireSegment wires)

        Creates new faces from the set of (closed) wires. Each wire
        is put on corresponding patch in the composite surface,
        and all pcurves on the initial (pseudo)face are reassigned to
        that surface. If several wires are one inside another, single
        face is created.

        :type faces: OCC.wrapper.TopTools.TopTools_SequenceOfShape
        :type wires: OCC.wrapper.ShapeFix.ShapeFix_SequenceOfWireSegment

        """
        return _ShapeFix.ShapeFix_ComposeShell_DispatchWires(self, *args)


    def SetTransferParamTool(self, *args):
        """
        SetTransferParamTool(ShapeFix_ComposeShell self, Handle_ShapeAnalysis_TransferParameters TransferParam)

        Sets tool for transfer parameters from 3d to 2d and vice versa.

        :type TransferParam: OCC.wrapper.ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters

        """
        return _ShapeFix.ShapeFix_ComposeShell_SetTransferParamTool(self, *args)


    def GetTransferParamTool(self, *args):
        """
        GetTransferParamTool(ShapeFix_ComposeShell self) -> Handle_ShapeAnalysis_TransferParameters

        Gets tool for transfer parameters from 3d to 2d and vice versa.

        :rtype: OCC.wrapper.ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters

        """
        return _ShapeFix.ShapeFix_ComposeShell_GetTransferParamTool(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeFix.ShapeFix_ComposeShell_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeFix.ShapeFix_ComposeShell_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.ShapeFix_ComposeShell_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeFix.delete_ShapeFix_ComposeShell
ShapeFix_ComposeShell_swigregister = _ShapeFix.ShapeFix_ComposeShell_swigregister
ShapeFix_ComposeShell_swigregister(ShapeFix_ComposeShell)

def ShapeFix_ComposeShell_get_type_name(*args):
    """
    ShapeFix_ComposeShell_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeFix.ShapeFix_ComposeShell_get_type_name(*args)

def ShapeFix_ComposeShell_get_type_descriptor(*args):
    """
    ShapeFix_ComposeShell_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeFix.ShapeFix_ComposeShell_get_type_descriptor(*args)

class ShapeFix_Wireframe(ShapeFix_Root):
    """Provides methods for fixing wireframe of shape"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeFix_Wireframe
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeFix_Wireframe(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeFix_Wireframe self) -> ShapeFix_Wireframe
        __init__(ShapeFix_Wireframe self, TopoDS_Shape shape) -> ShapeFix_Wireframe

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _ShapeFix.new_ShapeFix_Wireframe(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ClearStatuses(self, *args):
        """
        ClearStatuses(ShapeFix_Wireframe self)

        Clears all statuses


        """
        return _ShapeFix.ShapeFix_Wireframe_ClearStatuses(self, *args)


    def Load(self, *args):
        """
        Load(ShapeFix_Wireframe self, TopoDS_Shape shape)

        Loads a shape, resets statuses

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.ShapeFix_Wireframe_Load(self, *args)


    def FixWireGaps(self, *args):
        """
        FixWireGaps(ShapeFix_Wireframe self) -> Standard_Boolean

        Fixes gaps between ends of curves of adjacent edges
        (both 3d and pcurves) in wires
        If precision is 0.0, uses Precision::Confusion().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wireframe_FixWireGaps(self, *args)


    def FixSmallEdges(self, *args):
        """
        FixSmallEdges(ShapeFix_Wireframe self) -> Standard_Boolean

        Fixes small edges in shape by merging adjacent edges
        If precision is 0.0, uses Precision::Confusion().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wireframe_FixSmallEdges(self, *args)


    def CheckSmallEdges(self, *args):
        """
        CheckSmallEdges(ShapeFix_Wireframe self, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theSmallEdges, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher theEdgeToFaces, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher theFaceWithSmall, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theMultyEdges) -> Standard_Boolean

        Auxiliary tool for FixSmallEdges which checks for small edges and fills the maps.
        Returns True if at least one small edge has been found.

        :type theSmallEdges: OCC.wrapper.TopTools.TopTools_MapOfShape
        :type theEdgeToFaces: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape
        :type theFaceWithSmall: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape
        :type theMultyEdges: OCC.wrapper.TopTools.TopTools_MapOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wireframe_CheckSmallEdges(self, *args)


    def MergeSmallEdges(self, *args):
        """
        MergeSmallEdges(ShapeFix_Wireframe self, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theSmallEdges, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher theEdgeToFaces, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher theFaceWithSmall, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theMultyEdges, Standard_Boolean const theModeDrop, Standard_Real const theLimitAngle=-1) -> Standard_Boolean

        Auxiliary tool for FixSmallEdges which merges small edges.
        If theModeDrop is equal to Standard_True then small edges,
        which cannot be connected with adjacent edges are dropped.
        Otherwise they are kept.
        theLimitAngle specifies maximum allowed tangency
        discontinuity between adjacent edges.
        If theLimitAngle is equal to -1, this angle is not taken into account.

        :type theSmallEdges: OCC.wrapper.TopTools.TopTools_MapOfShape
        :type theEdgeToFaces: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape
        :type theFaceWithSmall: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape
        :type theMultyEdges: OCC.wrapper.TopTools.TopTools_MapOfShape
        :type theModeDrop: bool
        :type theLimitAngle: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wireframe_MergeSmallEdges(self, *args)


    def StatusWireGaps(self, *args):
        """
        StatusWireGaps(ShapeFix_Wireframe self, ShapeExtend_Status const status) -> Standard_Boolean

        Decodes the status of the last FixWireGaps.
        OK - No gaps were found
        DONE1 - Some gaps in 3D were fixed
        DONE2 - Some gaps in 2D were fixed
        FAIL1 - Failed to fix some gaps in 3D
        FAIL2 - Failed to fix some gaps in 2D

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wireframe_StatusWireGaps(self, *args)


    def StatusSmallEdges(self, *args):
        """
        StatusSmallEdges(ShapeFix_Wireframe self, ShapeExtend_Status const status) -> Standard_Boolean

        Decodes the status of the last FixSmallEdges.
        OK - No small edges were found
        DONE1 - Some small edges were fixed
        FAIL1 - Failed to fix some small edges

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wireframe_StatusSmallEdges(self, *args)


    def Shape(self, *args):
        """
        Shape(ShapeFix_Wireframe self) -> TopoDS_Shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.ShapeFix_Wireframe_Shape(self, *args)


    def ModeDropSmallEdges(self, *args):
        """
        ModeDropSmallEdges(ShapeFix_Wireframe self) -> Standard_Boolean &

        Returns mode managing removing small edges.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wireframe_ModeDropSmallEdges(self, *args)


    def SetLimitAngle(self, *args):
        """
        SetLimitAngle(ShapeFix_Wireframe self, Standard_Real const theLimitAngle)

        Set limit angle for merging edges.

        :type theLimitAngle: float

        """
        return _ShapeFix.ShapeFix_Wireframe_SetLimitAngle(self, *args)


    def LimitAngle(self, *args):
        """
        LimitAngle(ShapeFix_Wireframe self) -> Standard_Real

        Get limit angle for merging edges.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.ShapeFix_Wireframe_LimitAngle(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeFix.ShapeFix_Wireframe_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeFix.ShapeFix_Wireframe_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.ShapeFix_Wireframe_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeFix.delete_ShapeFix_Wireframe
ShapeFix_Wireframe_swigregister = _ShapeFix.ShapeFix_Wireframe_swigregister
ShapeFix_Wireframe_swigregister(ShapeFix_Wireframe)

def ShapeFix_Wireframe_get_type_name(*args):
    """
    ShapeFix_Wireframe_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeFix.ShapeFix_Wireframe_get_type_name(*args)

def ShapeFix_Wireframe_get_type_descriptor(*args):
    """
    ShapeFix_Wireframe_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeFix.ShapeFix_Wireframe_get_type_descriptor(*args)

class ShapeFix_Wire(ShapeFix_Root):
    """
    This class provides a set of tools for repairing a wire.

    These are methods Fix...(), organised in two levels:

    Level 1: Advanced - each method in this level fixes one separate problem,
    usually dealing with either single edge or connection of the
    two adjacent edges. These methods should be used carefully and
    called in right sequence, because some of them depend on others.

    Level 2: Public (API) - methods which group several methods of level 1
    and call them in a proper sequence in order to make some
    consistent set of fixes for a whole wire. It is possible to
    control calls to methods of the advanced level from methods of
    the public level by use of flags Fix..Mode() (see below).

    Fixes can be made in three ways:
    1. Increasing tolerance of an edge or a vertex
    2. Changing topology (adding/removing/replacing edge in the wire
    and/or replacing the vertex in the edge)
    3. Changing geometry (shifting vertex or adjusting ends of edge
    curve to vertices, or recomputing curves of the edge)

    When fix can be made in more than one way (e.g., either
    by increasing tolerance or shifting a vertex), it is choosen
    according to the flags:
    ModifyTopologyMode - allows modification of the topology.
    This flag can be set when fixing a wire on
    the separate (free) face, and should be
    unset for face which is part of shell.
    ModifyGeometryMode - allows modification of the geometry.

    The order of descriptions of Fix() methods in this CDL
    approximately corresponds to the optimal order of calls.

    NOTE: most of fixing methods expect edges in the
    ShapeExtend_WireData to be ordered, so it is necessary to make
    call to FixReorder() before any other fixes

    ShapeFix_Wire should be initialized prior to any fix by the
    following data:
    a) Wire (ether TopoDS_Wire or ShapeExtend_Wire)
    b) Face or surface
    c) Precision
    d) Maximal tail angle and width
    This can be done either by calling corresponding methods
    (LoadWire, SetFace or SetSurface, SetPrecision, SetMaxTailAngle
    and SetMaxTailWidth), or
    by loading already filled ShapeAnalisis_Wire with method Load
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeFix_Wire
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeFix_Wire(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeFix_Wire self) -> ShapeFix_Wire
        __init__(ShapeFix_Wire self, TopoDS_Wire wire, TopoDS_Face face, Standard_Real const prec) -> ShapeFix_Wire

        Create new object with default flags and prepare it for use
        (Loads analyzer with all the data for the wire and face)

        :type wire: OCC.wrapper.TopoDS.TopoDS_Wire
        :type face: OCC.wrapper.TopoDS.TopoDS_Face
        :type prec: float

        """
        this = _ShapeFix.new_ShapeFix_Wire(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ClearModes(self, *args):
        """
        ClearModes(ShapeFix_Wire self)

        Sets all modes to default


        """
        return _ShapeFix.ShapeFix_Wire_ClearModes(self, *args)


    def ClearStatuses(self, *args):
        """
        ClearStatuses(ShapeFix_Wire self)

        Clears all statuses


        """
        return _ShapeFix.ShapeFix_Wire_ClearStatuses(self, *args)


    def Init(self, *args):
        """
        Init(ShapeFix_Wire self, TopoDS_Wire wire, TopoDS_Face face, Standard_Real const prec)
        Init(ShapeFix_Wire self, Handle_ShapeAnalysis_Wire saw)

        Load analyzer with all the data already prepared
        and drops all fixing statuses
        If analyzer contains face, there is no need to set it
        by SetFace or SetSurface

        :type saw: OCC.wrapper.ShapeAnalysis.Handle_ShapeAnalysis_Wire

        """
        return _ShapeFix.ShapeFix_Wire_Init(self, *args)


    def Load(self, *args):
        """
        Load(ShapeFix_Wire self, TopoDS_Wire wire)
        Load(ShapeFix_Wire self, Handle_ShapeExtend_WireData sbwd)

        Load data for the wire, and drops all fixing statuses

        :type sbwd: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_WireData

        """
        return _ShapeFix.ShapeFix_Wire_Load(self, *args)


    def SetFace(self, *args):
        """
        SetFace(ShapeFix_Wire self, TopoDS_Face face)

        Set working face for the wire

        :type face: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _ShapeFix.ShapeFix_Wire_SetFace(self, *args)


    def SetSurface(self, *args):
        """
        SetSurface(ShapeFix_Wire self, Handle_Geom_Surface surf)
        SetSurface(ShapeFix_Wire self, Handle_Geom_Surface surf, TopLoc_Location loc)

        Set surface for the wire

        :type surf: OCC.wrapper.Geom.Handle_Geom_Surface
        :type loc: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _ShapeFix.ShapeFix_Wire_SetSurface(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(ShapeFix_Wire self, Standard_Real const prec)

        Set working precision (to root and to analyzer)

        :type prec: float

        """
        return _ShapeFix.ShapeFix_Wire_SetPrecision(self, *args)


    def SetMaxTailAngle(self, *args):
        """
        SetMaxTailAngle(ShapeFix_Wire self, Standard_Real const theMaxTailAngle)

        Sets the maximal allowed angle of the tails in radians.

        :type theMaxTailAngle: float

        """
        return _ShapeFix.ShapeFix_Wire_SetMaxTailAngle(self, *args)


    def SetMaxTailWidth(self, *args):
        """
        SetMaxTailWidth(ShapeFix_Wire self, Standard_Real const theMaxTailWidth)

        Sets the maximal allowed width of the tails.

        :type theMaxTailWidth: float

        """
        return _ShapeFix.ShapeFix_Wire_SetMaxTailWidth(self, *args)


    def IsLoaded(self, *args):
        """
        IsLoaded(ShapeFix_Wire self) -> Standard_Boolean

        Tells if the wire is loaded

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_IsLoaded(self, *args)


    def IsReady(self, *args):
        """
        IsReady(ShapeFix_Wire self) -> Standard_Boolean

        Tells if the wire and face are loaded

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_IsReady(self, *args)


    def NbEdges(self, *args):
        """
        NbEdges(ShapeFix_Wire self) -> Standard_Integer

        returns number of edges in the working wire

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Wire_NbEdges(self, *args)


    def Wire(self, *args):
        """
        Wire(ShapeFix_Wire self) -> TopoDS_Wire

        Makes the resulting Wire (by basic Brep_Builder)

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _ShapeFix.ShapeFix_Wire_Wire(self, *args)


    def WireAPIMake(self, *args):
        """
        WireAPIMake(ShapeFix_Wire self) -> TopoDS_Wire

        Makes the resulting Wire (by BRepAPI_MakeWire)

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _ShapeFix.ShapeFix_Wire_WireAPIMake(self, *args)


    def Analyzer(self, *args):
        """
        Analyzer(ShapeFix_Wire self) -> Handle_ShapeAnalysis_Wire

        returns field Analyzer (working tool)

        :rtype: OCC.wrapper.ShapeAnalysis.Handle_ShapeAnalysis_Wire

        """
        return _ShapeFix.ShapeFix_Wire_Analyzer(self, *args)


    def WireData(self, *args):
        """
        returns working wire

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_WireData

        """
        res = _ShapeFix.ShapeFix_Wire_WireData(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Face(self, *args):
        """
        returns working face (Analyzer.Face())

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _ShapeFix.ShapeFix_Wire_Face(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ModifyTopologyMode(self, *args):
        """
        ModifyTopologyMode(ShapeFix_Wire self) -> Standard_Boolean &

        Returns (modifiable) the flag which defines whether it is
        allowed to modify topology of the wire during fixing
        (adding/removing edges etc.)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_ModifyTopologyMode(self, *args)


    def ModifyGeometryMode(self, *args):
        """
        ModifyGeometryMode(ShapeFix_Wire self) -> Standard_Boolean &

        Returns (modifiable) the flag which defines whether the Fix..()
        methods are allowed to modify geometry of the edges and vertices

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_ModifyGeometryMode(self, *args)


    def ModifyRemoveLoopMode(self, *args):
        """
        ModifyRemoveLoopMode(ShapeFix_Wire self) -> Standard_Integer &

        Returns (modifiable) the flag which defines whether the Fix..()
        methods are allowed to modify RemoveLoop of the edges

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Wire_ModifyRemoveLoopMode(self, *args)


    def ClosedWireMode(self, *args):
        """
        ClosedWireMode(ShapeFix_Wire self) -> Standard_Boolean &

        Returns (modifiable) the flag which defines whether the wire
        is to be closed (by calling methods like FixDegenerated()
        and FixConnected() for last and first edges).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_ClosedWireMode(self, *args)


    def PreferencePCurveMode(self, *args):
        """
        PreferencePCurveMode(ShapeFix_Wire self) -> Standard_Boolean &

        Returns (modifiable) the flag which defines whether the 2d (True)
        representation of the wire is preferable over 3d one (in the
        case of ambiguity in FixEdgeCurves).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_PreferencePCurveMode(self, *args)


    def FixGapsByRangesMode(self, *args):
        """
        FixGapsByRangesMode(ShapeFix_Wire self) -> Standard_Boolean &

        Returns (modifiable) the flag which defines whether tool
        tries to fix gaps first by changing curves ranges (i.e.
        using intersection, extrema, projections) or not.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_FixGapsByRangesMode(self, *args)


    def FixReorderMode(self, *args):
        """
        FixReorderMode(ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Wire_FixReorderMode(self, *args)


    def FixSmallMode(self, *args):
        """
        FixSmallMode(ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Wire_FixSmallMode(self, *args)


    def FixConnectedMode(self, *args):
        """
        FixConnectedMode(ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Wire_FixConnectedMode(self, *args)


    def FixEdgeCurvesMode(self, *args):
        """
        FixEdgeCurvesMode(ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Wire_FixEdgeCurvesMode(self, *args)


    def FixDegeneratedMode(self, *args):
        """
        FixDegeneratedMode(ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Wire_FixDegeneratedMode(self, *args)


    def FixSelfIntersectionMode(self, *args):
        """
        FixSelfIntersectionMode(ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Wire_FixSelfIntersectionMode(self, *args)


    def FixLackingMode(self, *args):
        """
        FixLackingMode(ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Wire_FixLackingMode(self, *args)


    def FixGaps3dMode(self, *args):
        """
        FixGaps3dMode(ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Wire_FixGaps3dMode(self, *args)


    def FixGaps2dMode(self, *args):
        """
        FixGaps2dMode(ShapeFix_Wire self) -> Standard_Integer &

        Returns (modifiable) the flag for corresponding Fix..() method
        which defines whether this method will be called from the
        method APIFix():
        -1 default
        1 method will be called
        0 method will not be called

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Wire_FixGaps2dMode(self, *args)


    def FixReversed2dMode(self, *args):
        """
        FixReversed2dMode(ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Wire_FixReversed2dMode(self, *args)


    def FixRemovePCurveMode(self, *args):
        """
        FixRemovePCurveMode(ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Wire_FixRemovePCurveMode(self, *args)


    def FixAddPCurveMode(self, *args):
        """
        FixAddPCurveMode(ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Wire_FixAddPCurveMode(self, *args)


    def FixRemoveCurve3dMode(self, *args):
        """
        FixRemoveCurve3dMode(ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Wire_FixRemoveCurve3dMode(self, *args)


    def FixAddCurve3dMode(self, *args):
        """
        FixAddCurve3dMode(ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Wire_FixAddCurve3dMode(self, *args)


    def FixSeamMode(self, *args):
        """
        FixSeamMode(ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Wire_FixSeamMode(self, *args)


    def FixShiftedMode(self, *args):
        """
        FixShiftedMode(ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Wire_FixShiftedMode(self, *args)


    def FixSameParameterMode(self, *args):
        """
        FixSameParameterMode(ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Wire_FixSameParameterMode(self, *args)


    def FixVertexToleranceMode(self, *args):
        """
        FixVertexToleranceMode(ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Wire_FixVertexToleranceMode(self, *args)


    def FixNotchedEdgesMode(self, *args):
        """
        FixNotchedEdgesMode(ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Wire_FixNotchedEdgesMode(self, *args)


    def FixSelfIntersectingEdgeMode(self, *args):
        """
        FixSelfIntersectingEdgeMode(ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Wire_FixSelfIntersectingEdgeMode(self, *args)


    def FixIntersectingEdgesMode(self, *args):
        """
        FixIntersectingEdgesMode(ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Wire_FixIntersectingEdgesMode(self, *args)


    def FixNonAdjacentIntersectingEdgesMode(self, *args):
        """
        FixNonAdjacentIntersectingEdgesMode(ShapeFix_Wire self) -> Standard_Integer &

        Returns (modifiable) the flag for corresponding Fix..() method
        which defines whether this method will be called from the
        corresponding Fix..() method of the public level:
        -1 default
        1 method will be called
        0 method will not be called

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Wire_FixNonAdjacentIntersectingEdgesMode(self, *args)


    def FixTailMode(self, *args):
        """
        FixTailMode(ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Wire_FixTailMode(self, *args)


    def Perform(self, *args):
        """
        Perform(ShapeFix_Wire self) -> Standard_Boolean

        This method performs all the available fixes.
        If some fix is turned on or off explicitly by the Fix..Mode() flag,
        this fix is either called or not depending on that flag.
        Else (i.e. if flag is default) fix is called depending on the
        situation: some fixes are not called or are limited if order of
        edges in the wire is not OK, or depending on modes

        The order of the fixes and default behaviour of Perform() are:
        FixReorder
        FixSmall (with lockvtx true if ! TopoMode or if wire is not ordered)
        FixConnected (if wire is ordered)
        FixEdgeCurves (without FixShifted if wire is not ordered)
        FixDegenerated (if wire is ordered)
        FixSelfIntersection (if wire is ordered and ClosedMode is True)
        FixLacking (if wire is ordered)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_Perform(self, *args)


    def FixEdgeCurves(self, *args):
        """
        FixEdgeCurves(ShapeFix_Wire self) -> Standard_Boolean

        Groups the fixes dealing with 3d and pcurves of the edges.
        The order of the fixes and the default behaviour are:
        ShapeFix_Edge::FixReversed2d
        ShapeFix_Edge::FixRemovePCurve (only if forced)
        ShapeFix_Edge::FixAddPCurve
        ShapeFix_Edge::FixRemoveCurve3d (only if forced)
        ShapeFix_Edge::FixAddCurve3d
        FixSeam,
        FixShifted,
        ShapeFix_Edge::FixSameParameter

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_FixEdgeCurves(self, *args)


    def FixSelfIntersection(self, *args):
        """
        FixSelfIntersection(ShapeFix_Wire self) -> Standard_Boolean

        Applies FixSelfIntersectingEdge(num) and
        FixIntersectingEdges(num) to all edges in the wire and
        FixIntersectingEdges(num1, num2) for all pairs num1 and num2
        such that num2 >= num1 + 2
        and removes wrong edges if any

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_FixSelfIntersection(self, *args)


    def FixClosed(self, *args):
        """
        FixClosed(ShapeFix_Wire self, Standard_Real const prec=-1.0) -> Standard_Boolean

        Fixes a wire to be well closed
        It performs FixConnected, FixDegenerated and FixLacking between
        last and first edges (independingly on flag ClosedMode and modes
        for these fixings)
        If <prec> is -1 then MaxTolerance() is taken.

        :type prec: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_FixClosed(self, *args)


    def FixGaps3d(self, *args):
        """
        FixGaps3d(ShapeFix_Wire self) -> Standard_Boolean

        Fixes gaps between ends of 3d curves on adjacent edges
        myPrecision is used to detect the gaps.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_FixGaps3d(self, *args)


    def FixGaps2d(self, *args):
        """
        FixGaps2d(ShapeFix_Wire self) -> Standard_Boolean

        Fixes gaps between ends of pcurves on adjacent edges
        myPrecision is used to detect the gaps.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_FixGaps2d(self, *args)


    def FixReorder(self, *args):
        """
        FixReorder(ShapeFix_Wire self) -> Standard_Boolean
        FixReorder(ShapeFix_Wire self, ShapeAnalysis_WireOrder wi) -> Standard_Boolean

        Reorder edges in the wire as determined by WireOrder
        that should be filled and computed before

        :type wi: OCC.wrapper.ShapeAnalysis.ShapeAnalysis_WireOrder
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_FixReorder(self, *args)


    def FixSmall(self, *args):
        """
        FixSmall(ShapeFix_Wire self, Standard_Boolean const lockvtx, Standard_Real const precsmall=0.0) -> Standard_Integer
        FixSmall(ShapeFix_Wire self, Standard_Integer const num, Standard_Boolean const lockvtx, Standard_Real const precsmall) -> Standard_Boolean

        Fixes Null Length Edge to be removed
        If an Edge has Null Length (regarding preci, or <precsmall>
        - what is smaller), it should be removed
        It can be with no problem if its two vertices are the same
        Else, if lockvtx is False, it is removed and its end vertex
        is put on the preceeding edge
        But if lockvtx is True, this edge must be kept ...

        :type num: int
        :type lockvtx: bool
        :type precsmall: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_FixSmall(self, *args)


    def FixConnected(self, *args):
        """
        FixConnected(ShapeFix_Wire self, Standard_Real const prec=-1.0) -> Standard_Boolean
        FixConnected(ShapeFix_Wire self, Standard_Integer const num, Standard_Real const prec) -> Standard_Boolean

        Fixes connected edges (preceeding and current)
        Forces Vertices (end of preceeding-begin of current) to be
        the same one
        Tests with starting preci or, if given greater, <prec>
        If <prec> is -1 then MaxTolerance() is taken.

        :type num: int
        :type prec: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_FixConnected(self, *args)


    def FixSeam(self, *args):
        """
        FixSeam(ShapeFix_Wire self, Standard_Integer const num) -> Standard_Boolean

        Fixes a seam edge
        A Seam edge has two pcurves, one for forward. one for reversed
        The forward pcurve must be set as first

        NOTE that correct order of pcurves in the seam edge depends on
        its orientation (i.e., on orientation of the wire, method of
        exploration of edges etc.).
        Since wire represented by the ShapeExtend_WireData is always forward
        (orientation is accounted by edges), it will work correct if:
        1. Wire created from ShapeExtend_WireData with methods
        ShapeExtend_WireData::Wire..() is added into the FORWARD face
        (orientation can be applied later)
        2. Wire is extracted from the face with orientation not composed
        with orientation of the face

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_FixSeam(self, *args)


    def FixShifted(self, *args):
        """
        FixShifted(ShapeFix_Wire self) -> Standard_Boolean

        Fixes edges which have pcurves shifted by whole parameter
        range on the closed surface (the case may occur if pcurve
        of edge was computed by projecting 3d curve, which goes
        along the seam).
        It compares each two consequent edges and tries to connect them
        if distance between ends is near to range of the surface.
        It also can detect and fix the case if all pcurves are connected,
        but lie out of parametric bounds of the surface.
        In addition to FixShifted from ShapeFix_Wire, more
        sophisticated check of degenerate points is performed,
        and special cases like sphere given by two meridians
        are treated.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_FixShifted(self, *args)


    def FixDegenerated(self, *args):
        """
        FixDegenerated(ShapeFix_Wire self) -> Standard_Boolean
        FixDegenerated(ShapeFix_Wire self, Standard_Integer const num) -> Standard_Boolean

        Fixes Degenerated Edge
        Checks an <num-th> edge or a point between <num>th-1 and <num>th
        edges for a singularity on a supporting surface.
        If singularity is detected, either adds new degenerated edge
        (before <num>th), or makes <num>th edge to be degenerated.

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_FixDegenerated(self, *args)


    def FixLacking(self, *args):
        """
        FixLacking(ShapeFix_Wire self, Standard_Boolean const force) -> Standard_Boolean
        FixLacking(ShapeFix_Wire self, Standard_Integer const num, Standard_Boolean const force) -> Standard_Boolean

        Fixes Lacking Edge
        Test if two adjucent edges are disconnected in 2d (while
        connected in 3d), and in that case either increase tolerance
        of the vertex or add a new edge (straight in 2d space), in
        order to close wire in 2d.
        Returns True if edge was added or tolerance was increased.

        :type num: int
        :type force: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_FixLacking(self, *args)


    def FixNotchedEdges(self, *args):
        """
        FixNotchedEdges(ShapeFix_Wire self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_FixNotchedEdges(self, *args)


    def FixGap3d(self, *args):
        """
        FixGap3d(ShapeFix_Wire self, Standard_Integer const num, Standard_Boolean const convert) -> Standard_Boolean

        Fixes gap between ends of 3d curves on num-1 and num-th edges.
        myPrecision is used to detect the gap.
        If convert is True, converts curves to bsplines to bend.

        :type num: int
        :type convert: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_FixGap3d(self, *args)


    def FixGap2d(self, *args):
        """
        FixGap2d(ShapeFix_Wire self, Standard_Integer const num, Standard_Boolean const convert) -> Standard_Boolean

        Fixes gap between ends of pcurves on num-1 and num-th edges.
        myPrecision is used to detect the gap.
        If convert is True, converts pcurves to bsplines to bend.

        :type num: int
        :type convert: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_FixGap2d(self, *args)


    def FixTails(self, *args):
        """
        FixTails(ShapeFix_Wire self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_FixTails(self, *args)


    def StatusReorder(self, *args):
        """
        StatusReorder(ShapeFix_Wire self, ShapeExtend_Status const status) -> Standard_Boolean

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_StatusReorder(self, *args)


    def StatusSmall(self, *args):
        """
        StatusSmall(ShapeFix_Wire self, ShapeExtend_Status const status) -> Standard_Boolean

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_StatusSmall(self, *args)


    def StatusConnected(self, *args):
        """
        StatusConnected(ShapeFix_Wire self, ShapeExtend_Status const status) -> Standard_Boolean

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_StatusConnected(self, *args)


    def StatusEdgeCurves(self, *args):
        """
        StatusEdgeCurves(ShapeFix_Wire self, ShapeExtend_Status const status) -> Standard_Boolean

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_StatusEdgeCurves(self, *args)


    def StatusDegenerated(self, *args):
        """
        StatusDegenerated(ShapeFix_Wire self, ShapeExtend_Status const status) -> Standard_Boolean

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_StatusDegenerated(self, *args)


    def StatusSelfIntersection(self, *args):
        """
        StatusSelfIntersection(ShapeFix_Wire self, ShapeExtend_Status const status) -> Standard_Boolean

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_StatusSelfIntersection(self, *args)


    def StatusLacking(self, *args):
        """
        StatusLacking(ShapeFix_Wire self, ShapeExtend_Status const status) -> Standard_Boolean

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_StatusLacking(self, *args)


    def StatusClosed(self, *args):
        """
        StatusClosed(ShapeFix_Wire self, ShapeExtend_Status const status) -> Standard_Boolean

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_StatusClosed(self, *args)


    def StatusGaps3d(self, *args):
        """
        StatusGaps3d(ShapeFix_Wire self, ShapeExtend_Status const status) -> Standard_Boolean

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_StatusGaps3d(self, *args)


    def StatusGaps2d(self, *args):
        """
        StatusGaps2d(ShapeFix_Wire self, ShapeExtend_Status const status) -> Standard_Boolean

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_StatusGaps2d(self, *args)


    def StatusNotches(self, *args):
        """
        StatusNotches(ShapeFix_Wire self, ShapeExtend_Status const status) -> Standard_Boolean

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_StatusNotches(self, *args)


    def StatusRemovedSegment(self, *args):
        """
        StatusRemovedSegment(ShapeFix_Wire self) -> Standard_Boolean

        Querying the status of perfomed API fixing procedures
        Each Status..() methods gives information about the last call to
        the corresponding Fix..() method of API level:
        OK  : no problems detected; nothing done
        DONE: some problem(s) was(were) detected and successfully fixed
        FAIL: some problem(s) cannot be fixed

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_StatusRemovedSegment(self, *args)


    def StatusFixTails(self, *args):
        """
        StatusFixTails(ShapeFix_Wire self, ShapeExtend_Status const status) -> Standard_Boolean

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_StatusFixTails(self, *args)


    def LastFixStatus(self, *args):
        """
        LastFixStatus(ShapeFix_Wire self, ShapeExtend_Status const status) -> Standard_Boolean

        Queries the status of last call to methods Fix... of
        advanced level
        For details see corresponding methods; universal statuses are:
        OK  : problem not detected; nothing done
        DONE: problem was detected and successfully fixed
        FAIL: problem cannot be fixed

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Wire_LastFixStatus(self, *args)


    def FixEdgeTool(self, *args):
        """
        FixEdgeTool(ShapeFix_Wire self) -> Handle_ShapeFix_Edge

        Returns tool for fixing wires.

        :rtype: OCC.wrapper.ShapeFix.Handle_ShapeFix_Edge

        """
        return _ShapeFix.ShapeFix_Wire_FixEdgeTool(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeFix.ShapeFix_Wire_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeFix.ShapeFix_Wire_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.ShapeFix_Wire_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeFix.delete_ShapeFix_Wire
ShapeFix_Wire_swigregister = _ShapeFix.ShapeFix_Wire_swigregister
ShapeFix_Wire_swigregister(ShapeFix_Wire)

def ShapeFix_Wire_get_type_name(*args):
    """
    ShapeFix_Wire_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeFix.ShapeFix_Wire_get_type_name(*args)

def ShapeFix_Wire_get_type_descriptor(*args):
    """
    ShapeFix_Wire_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeFix.ShapeFix_Wire_get_type_descriptor(*args)

class ShapeFix_Shell(ShapeFix_Root):
    """Fixing orientation of faces in shell"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeFix_Shell
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeFix_Shell(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeFix_Shell self) -> ShapeFix_Shell
        __init__(ShapeFix_Shell self, TopoDS_Shell shape) -> ShapeFix_Shell

        Initializes by shell.

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shell

        """
        this = _ShapeFix.new_ShapeFix_Shell(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(ShapeFix_Shell self, TopoDS_Shell shell)

        Initializes by shell.

        :type shell: OCC.wrapper.TopoDS.TopoDS_Shell

        """
        return _ShapeFix.ShapeFix_Shell_Init(self, *args)


    def Perform(self, *args):
        """
        Perform(ShapeFix_Shell self, Handle_Message_ProgressIndicator theProgress=0) -> Standard_Boolean

        Iterates on subshapes and performs fixes
        (for each face calls ShapeFix_Face::Perform and
        then calls FixFaceOrientation). The passed progress
        indicator allows user to consult the current progress
        stage and abort algorithm if needed.

        :type theProgress: OCC.wrapper.Message.Handle_Message_ProgressIndicator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Shell_Perform(self, *args)


    def FixFaceOrientation(self, *args):
        """
        FixFaceOrientation(ShapeFix_Shell self, TopoDS_Shell shell, Standard_Boolean const isAccountMultiConex, Standard_Boolean const NonManifold) -> Standard_Boolean

        Fixes orientation of faces in shell.
        Changes orientation of face in the shell, if it is oriented opposite
        to neigbouring faces. If it is not possible to orient all faces in the
        shell (like in case of mebious band), this method orients only subset
        of faces. Other faces are stored in Error compound.
        Modes :
        isAccountMultiConex - mode for account cases of multiconnexity.
        If this mode is equal to Standard_True, separate shells will be created
        in the cases of multiconnexity. If this mode is equal to Standard_False,
        one shell will be created without account of multiconnexity.By defautt - Standard_True;
        NonManifold - mode for creation of non-manifold shells.
        If this mode is equal to Standard_True one non-manifold will be created from shell
        contains multishared edges. Else if this mode is equal to Standard_False only
        manifold shells will be created. By default - Standard_False.

        :type shell: OCC.wrapper.TopoDS.TopoDS_Shell
        :type isAccountMultiConex: bool
        :type NonManifold: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Shell_FixFaceOrientation(self, *args)


    def Shell(self, *args):
        """
        Shell(ShapeFix_Shell self) -> TopoDS_Shell

        Returns fixed shell (or subset of oriented faces).

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shell

        """
        return _ShapeFix.ShapeFix_Shell_Shell(self, *args)


    def Shape(self, *args):
        """
        Shape(ShapeFix_Shell self) -> TopoDS_Shape

        In case of multiconnexity returns compound of fixed shells
        else returns one shell..

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.ShapeFix_Shell_Shape(self, *args)


    def NbShells(self, *args):
        """
        NbShells(ShapeFix_Shell self) -> Standard_Integer

        Returns Number of obtainrd shells;

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Shell_NbShells(self, *args)


    def ErrorFaces(self, *args):
        """
        ErrorFaces(ShapeFix_Shell self) -> TopoDS_Compound

        Returns not oriented subset of faces.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Compound

        """
        return _ShapeFix.ShapeFix_Shell_ErrorFaces(self, *args)


    def Status(self, *args):
        """
        Status(ShapeFix_Shell self, ShapeExtend_Status const status) -> Standard_Boolean

        Returns the status of the last Fix.

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Shell_Status(self, *args)


    def FixFaceTool(self, *args):
        """
        FixFaceTool(ShapeFix_Shell self) -> Handle_ShapeFix_Face

        Returns tool for fixing faces.

        :rtype: OCC.wrapper.ShapeFix.Handle_ShapeFix_Face

        """
        return _ShapeFix.ShapeFix_Shell_FixFaceTool(self, *args)


    def SetMsgRegistrator(self, *args):
        """
        SetMsgRegistrator(ShapeFix_Shell self, Handle_ShapeExtend_BasicMsgRegistrator msgreg)

        Sets message registrator

        :type msgreg: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeFix.ShapeFix_Shell_SetMsgRegistrator(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(ShapeFix_Shell self, Standard_Real const preci)

        Sets basic precision value (also to FixWireTool)

        :type preci: float

        """
        return _ShapeFix.ShapeFix_Shell_SetPrecision(self, *args)


    def SetMinTolerance(self, *args):
        """
        SetMinTolerance(ShapeFix_Shell self, Standard_Real const mintol)

        Sets minimal allowed tolerance (also to FixWireTool)

        :type mintol: float

        """
        return _ShapeFix.ShapeFix_Shell_SetMinTolerance(self, *args)


    def SetMaxTolerance(self, *args):
        """
        SetMaxTolerance(ShapeFix_Shell self, Standard_Real const maxtol)

        Sets maximal allowed tolerance (also to FixWireTool)

        :type maxtol: float

        """
        return _ShapeFix.ShapeFix_Shell_SetMaxTolerance(self, *args)


    def FixFaceMode(self, *args):
        """
        FixFaceMode(ShapeFix_Shell self) -> Standard_Integer &

        Returns (modifiable) the mode for applying fixes of
        ShapeFix_Face, by default True.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Shell_FixFaceMode(self, *args)


    def FixOrientationMode(self, *args):
        """
        FixOrientationMode(ShapeFix_Shell self) -> Standard_Integer &

        Returns (modifiable) the mode for applying
        FixFaceOrientation, by default True.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Shell_FixOrientationMode(self, *args)


    def SetNonManifoldFlag(self, *args):
        """
        SetNonManifoldFlag(ShapeFix_Shell self, Standard_Boolean const isNonManifold)

        Sets NonManifold flag

        :type isNonManifold: bool

        """
        return _ShapeFix.ShapeFix_Shell_SetNonManifoldFlag(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeFix.ShapeFix_Shell_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeFix.ShapeFix_Shell_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.ShapeFix_Shell_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeFix.delete_ShapeFix_Shell
ShapeFix_Shell_swigregister = _ShapeFix.ShapeFix_Shell_swigregister
ShapeFix_Shell_swigregister(ShapeFix_Shell)

def ShapeFix_Shell_get_type_name(*args):
    """
    ShapeFix_Shell_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeFix.ShapeFix_Shell_get_type_name(*args)

def ShapeFix_Shell_get_type_descriptor(*args):
    """
    ShapeFix_Shell_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeFix.ShapeFix_Shell_get_type_descriptor(*args)

class ShapeFix_Face(ShapeFix_Root):
    """
    This operator allows to perform various fixes on face
    and its wires: fixes provided by ShapeFix_Wire,
    fixing orientation of wires, addition of natural bounds,
    fixing of missing seam edge,
    and detection and removal of null-area wires
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeFix_Face
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeFix_Face(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeFix_Face self) -> ShapeFix_Face
        __init__(ShapeFix_Face self, TopoDS_Face face) -> ShapeFix_Face

        Creates a tool and loads a face

        :type face: OCC.wrapper.TopoDS.TopoDS_Face

        """
        this = _ShapeFix.new_ShapeFix_Face(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ClearModes(self, *args):
        """
        ClearModes(ShapeFix_Face self)

        Sets all modes to default


        """
        return _ShapeFix.ShapeFix_Face_ClearModes(self, *args)


    def Init(self, *args):
        """
        Init(ShapeFix_Face self, TopoDS_Face face)
        Init(ShapeFix_Face self, Handle_Geom_Surface surf, Standard_Real const preci, Standard_Boolean const fwd)
        Init(ShapeFix_Face self, Handle_ShapeAnalysis_Surface surf, Standard_Real const preci, Standard_Boolean const fwd)

        Starts the creation of the face
        By default it will be FORWARD, or REVERSED if <fwd> is False

        :type surf: OCC.wrapper.ShapeAnalysis.Handle_ShapeAnalysis_Surface
        :type preci: float
        :type fwd: bool

        """
        return _ShapeFix.ShapeFix_Face_Init(self, *args)


    def SetMsgRegistrator(self, *args):
        """
        SetMsgRegistrator(ShapeFix_Face self, Handle_ShapeExtend_BasicMsgRegistrator msgreg)

        Sets message registrator

        :type msgreg: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeFix.ShapeFix_Face_SetMsgRegistrator(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(ShapeFix_Face self, Standard_Real const preci)

        Sets basic precision value (also to FixWireTool)

        :type preci: float

        """
        return _ShapeFix.ShapeFix_Face_SetPrecision(self, *args)


    def SetMinTolerance(self, *args):
        """
        SetMinTolerance(ShapeFix_Face self, Standard_Real const mintol)

        Sets minimal allowed tolerance (also to FixWireTool)

        :type mintol: float

        """
        return _ShapeFix.ShapeFix_Face_SetMinTolerance(self, *args)


    def SetMaxTolerance(self, *args):
        """
        SetMaxTolerance(ShapeFix_Face self, Standard_Real const maxtol)

        Sets maximal allowed tolerance (also to FixWireTool)

        :type maxtol: float

        """
        return _ShapeFix.ShapeFix_Face_SetMaxTolerance(self, *args)


    def FixWireMode(self, *args):
        """
        FixWireMode(ShapeFix_Face self) -> Standard_Integer &

        Returns (modifiable) the mode for applying fixes of
        ShapeFix_Wire, by default True.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Face_FixWireMode(self, *args)


    def FixOrientationMode(self, *args):
        """
        FixOrientationMode(ShapeFix_Face self) -> Standard_Integer &

        Returns (modifiable) the fix orientation mode, by default
        True. If True, wires oriented to border limited square.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Face_FixOrientationMode(self, *args)


    def FixAddNaturalBoundMode(self, *args):
        """
        FixAddNaturalBoundMode(ShapeFix_Face self) -> Standard_Integer &

        Returns (modifiable) the add natural bound mode.
        If true, natural boundary is added on faces that miss them.
        Default is False for faces with single wire (they are
        handled by FixOrientation in that case) and True for others.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Face_FixAddNaturalBoundMode(self, *args)


    def FixMissingSeamMode(self, *args):
        """
        FixMissingSeamMode(ShapeFix_Face self) -> Standard_Integer &

        Returns (modifiable) the fix missing seam mode, by default
        True. If True, tries to insert seam is missed.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Face_FixMissingSeamMode(self, *args)


    def FixSmallAreaWireMode(self, *args):
        """
        FixSmallAreaWireMode(ShapeFix_Face self) -> Standard_Integer &

        Returns (modifiable) the fix small area wire mode, by default
        False. If True, drops small wires.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Face_FixSmallAreaWireMode(self, *args)


    def RemoveSmallAreaFaceMode(self, *args):
        """
        RemoveSmallAreaFaceMode(ShapeFix_Face self) -> Standard_Integer &

        Returns (modifiable) the remove face with small area, by default
        False. If True, drops faces with small outer wires.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Face_RemoveSmallAreaFaceMode(self, *args)


    def FixIntersectingWiresMode(self, *args):
        """
        FixIntersectingWiresMode(ShapeFix_Face self) -> Standard_Integer &

        Returns (modifiable) the fix intersecting wires mode
        by default True.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Face_FixIntersectingWiresMode(self, *args)


    def FixLoopWiresMode(self, *args):
        """
        FixLoopWiresMode(ShapeFix_Face self) -> Standard_Integer &

        Returns (modifiable) the fix loop wires mode
        by default True.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Face_FixLoopWiresMode(self, *args)


    def FixSplitFaceMode(self, *args):
        """
        FixSplitFaceMode(ShapeFix_Face self) -> Standard_Integer &

        Returns (modifiable) the fix split face mode
        by default True.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Face_FixSplitFaceMode(self, *args)


    def AutoCorrectPrecisionMode(self, *args):
        """
        AutoCorrectPrecisionMode(ShapeFix_Face self) -> Standard_Integer &

        Returns (modifiable) the auto-correct precision mode
        by default False.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Face_AutoCorrectPrecisionMode(self, *args)


    def FixPeriodicDegeneratedMode(self, *args):
        """
        FixPeriodicDegeneratedMode(ShapeFix_Face self) -> Standard_Integer &

        Returns (modifiable) the activation flag for periodic
        degenerated fix. False by default.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Face_FixPeriodicDegeneratedMode(self, *args)


    def Face(self, *args):
        """
        Face(ShapeFix_Face self) -> TopoDS_Face

        Returns a face which corresponds to the current state
        Warning: The finally produced face may be another one ... but with the
        same support

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _ShapeFix.ShapeFix_Face_Face(self, *args)


    def Result(self, *args):
        """
        Result(ShapeFix_Face self) -> TopoDS_Shape

        Returns resulting shape (Face or Shell if splitted)
        To be used instead of Face() if FixMissingSeam involved

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.ShapeFix_Face_Result(self, *args)


    def Add(self, *args):
        """
        Add(ShapeFix_Face self, TopoDS_Wire wire)

        Add a wire to current face using BRep_Builder.
        Wire is added without taking into account orientation of face
        (as if face were FORWARD).

        :type wire: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _ShapeFix.ShapeFix_Face_Add(self, *args)


    def Perform(self, *args):
        """
        Perform(ShapeFix_Face self) -> Standard_Boolean

        Performs all the fixes, depending on modes
        Function Status returns the status of last call to Perform()
        ShapeExtend_OK   : face was OK, nothing done
        ShapeExtend_DONE1: some wires are fixed
        ShapeExtend_DONE2: orientation of wires fixed
        ShapeExtend_DONE3: missing seam added
        ShapeExtend_DONE4: small area wire removed
        ShapeExtend_DONE5: natural bounds added
        ShapeExtend_FAIL1: some fails during fixing wires
        ShapeExtend_FAIL2: cannot fix orientation of wires
        ShapeExtend_FAIL3: cannot add missing seam
        ShapeExtend_FAIL4: cannot remove small area wire

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Face_Perform(self, *args)


    def FixOrientation(self, *args):
        """
        FixOrientation(ShapeFix_Face self) -> Standard_Boolean
        FixOrientation(ShapeFix_Face self, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher MapWires) -> Standard_Boolean

        Fixes orientation of wires on the face
        It tries to make all wires lie outside all others (according
        to orientation) by reversing orientation of some of them.
        If face lying on sphere or torus has single wire and
        AddNaturalBoundMode is True, that wire is not reversed in
        any case (supposing that natural bound will be added).
        Returns True if wires were reversed
        OutWires return information about out wires + list of
        internal wires for each (for performing split face).

        :type MapWires: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Face_FixOrientation(self, *args)


    def FixAddNaturalBound(self, *args):
        """
        FixAddNaturalBound(ShapeFix_Face self) -> Standard_Boolean

        Adds natural boundary on face if it is missing.
        Two cases are supported:
        - face has no wires
        - face lies on geometrically double-closed surface
        (sphere or torus) and none of wires is left-oriented
        Returns True if natural boundary was added

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Face_FixAddNaturalBound(self, *args)


    def FixMissingSeam(self, *args):
        """
        FixMissingSeam(ShapeFix_Face self) -> Standard_Boolean

        Detects and fixes the special case when face on a closed
        surface is given by two wires closed in 3d but with gap in 2d.
        In that case it creates a new wire from the two, and adds a
        missing seam edge
        Returns True if missing seam was added

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Face_FixMissingSeam(self, *args)


    def FixSmallAreaWire(self, *args):
        """
        FixSmallAreaWire(ShapeFix_Face self, Standard_Boolean const theIsRemoveSmallFace) -> Standard_Boolean

        Detects wires with small area (that is less than
        100*Precision::PConfusion(). Removes these wires if they are internal.
        Returns : True if at least one small wire removed,
        False if does nothing.

        :type theIsRemoveSmallFace: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Face_FixSmallAreaWire(self, *args)


    def FixLoopWire(self, *args):
        """
        FixLoopWire(ShapeFix_Face self, NCollection_Sequence_TopoDS_Shape aResWires) -> Standard_Boolean

        Detects if wire has a loop and fixes this situation by splitting on the few parts.
        if wire has a loops and it was splitted Status was set to value ShapeExtend_DONE6.

        :type aResWires: OCC.wrapper.TopTools.TopTools_SequenceOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Face_FixLoopWire(self, *args)


    def FixIntersectingWires(self, *args):
        """
        FixIntersectingWires(ShapeFix_Face self) -> Standard_Boolean

        Detects and fixes the special case when face has more than one wire
        and this wires have intersection point

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Face_FixIntersectingWires(self, *args)


    def FixWiresTwoCoincEdges(self, *args):
        """
        FixWiresTwoCoincEdges(ShapeFix_Face self) -> Standard_Boolean

        If wire contains two coincidence edges it must be removed
        Queries on status after Perform()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Face_FixWiresTwoCoincEdges(self, *args)


    def FixSplitFace(self, *args):
        """
        FixSplitFace(ShapeFix_Face self, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher MapWires) -> Standard_Boolean

        Split face if there are more than one out wire
        using inrormation after FixOrientation()

        :type MapWires: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Face_FixSplitFace(self, *args)


    def FixPeriodicDegenerated(self, *args):
        """
        FixPeriodicDegenerated(ShapeFix_Face self) -> Standard_Boolean

        Fixes topology for a specific case when face is composed
        by a single wire belting a periodic surface. In that case
        a degenerated edge is reconstructed in the degenerated pole
        of the surface. Initial wire gets consistent orientation.
        Must be used in couple and before FixMissingSeam routine

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Face_FixPeriodicDegenerated(self, *args)


    def Status(self, *args):
        """
        Status(ShapeFix_Face self, ShapeExtend_Status const status) -> Standard_Boolean

        Returns the status of last call to Perform()
        ShapeExtend_OK   : face was OK, nothing done
        ShapeExtend_DONE1: some wires are fixed
        ShapeExtend_DONE2: orientation of wires fixed
        ShapeExtend_DONE3: missing seam added
        ShapeExtend_DONE4: small area wire removed
        ShapeExtend_DONE5: natural bounds added
        ShapeExtend_DONE8: face may be splited
        ShapeExtend_FAIL1: some fails during fixing wires
        ShapeExtend_FAIL2: cannot fix orientation of wires
        ShapeExtend_FAIL3: cannot add missing seam
        ShapeExtend_FAIL4: cannot remove small area wire

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Face_Status(self, *args)


    def FixWireTool(self, *args):
        """
        FixWireTool(ShapeFix_Face self) -> Handle_ShapeFix_Wire

        Returns tool for fixing wires.

        :rtype: OCC.wrapper.ShapeFix.Handle_ShapeFix_Wire

        """
        return _ShapeFix.ShapeFix_Face_FixWireTool(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeFix.ShapeFix_Face_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeFix.ShapeFix_Face_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.ShapeFix_Face_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeFix.delete_ShapeFix_Face
ShapeFix_Face_swigregister = _ShapeFix.ShapeFix_Face_swigregister
ShapeFix_Face_swigregister(ShapeFix_Face)

def ShapeFix_Face_get_type_name(*args):
    """
    ShapeFix_Face_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeFix.ShapeFix_Face_get_type_name(*args)

def ShapeFix_Face_get_type_descriptor(*args):
    """
    ShapeFix_Face_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeFix.ShapeFix_Face_get_type_descriptor(*args)

class ShapeFix_FixSmallFace(ShapeFix_Root):
    """Fixing face with small size"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeFix_FixSmallFace
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeFix_FixSmallFace(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeFix_FixSmallFace self) -> ShapeFix_FixSmallFace

        Fixing face with small size
        """
        this = _ShapeFix.new_ShapeFix_FixSmallFace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(ShapeFix_FixSmallFace self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.ShapeFix_FixSmallFace_Init(self, *args)


    def Perform(self, *args):
        """
        Perform(ShapeFix_FixSmallFace self)

        Fixing case of spot face


        """
        return _ShapeFix.ShapeFix_FixSmallFace_Perform(self, *args)


    def FixSpotFace(self, *args):
        """
        FixSpotFace(ShapeFix_FixSmallFace self) -> TopoDS_Shape

        Fixing case of spot face, if tol = -1 used local tolerance.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.ShapeFix_FixSmallFace_FixSpotFace(self, *args)


    def ReplaceVerticesInCaseOfSpot(self, *args):
        """
        ReplaceVerticesInCaseOfSpot(ShapeFix_FixSmallFace self, TopoDS_Face F, Standard_Real const tol) -> Standard_Boolean

        Compute average vertex and replacing vertices by new one.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_FixSmallFace_ReplaceVerticesInCaseOfSpot(self, *args)


    def RemoveFacesInCaseOfSpot(self, *args):
        """
        RemoveFacesInCaseOfSpot(ShapeFix_FixSmallFace self, TopoDS_Face F) -> Standard_Boolean

        Remove spot face from compound

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_FixSmallFace_RemoveFacesInCaseOfSpot(self, *args)


    def FixStripFace(self, *args):
        """
        FixStripFace(ShapeFix_FixSmallFace self, Standard_Boolean const wasdone) -> TopoDS_Shape

        Fixing case of strip face, if tol = -1 used local tolerance

        :type wasdone: bool
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.ShapeFix_FixSmallFace_FixStripFace(self, *args)


    def ReplaceInCaseOfStrip(self, *args):
        """
        ReplaceInCaseOfStrip(ShapeFix_FixSmallFace self, TopoDS_Face F, TopoDS_Edge E1, TopoDS_Edge E2, Standard_Real const tol) -> Standard_Boolean

        Replace veretces and edges.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type E1: OCC.wrapper.TopoDS.TopoDS_Edge
        :type E2: OCC.wrapper.TopoDS.TopoDS_Edge
        :type tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_FixSmallFace_ReplaceInCaseOfStrip(self, *args)


    def RemoveFacesInCaseOfStrip(self, *args):
        """
        RemoveFacesInCaseOfStrip(ShapeFix_FixSmallFace self, TopoDS_Face F) -> Standard_Boolean

        Remove strip face from compound.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_FixSmallFace_RemoveFacesInCaseOfStrip(self, *args)


    def ComputeSharedEdgeForStripFace(self, *args):
        """
        ComputeSharedEdgeForStripFace(ShapeFix_FixSmallFace self, TopoDS_Face F, TopoDS_Edge E1, TopoDS_Edge E2, TopoDS_Face F1, Standard_Real const tol) -> TopoDS_Edge

        Compute average edge for strip face

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type E1: OCC.wrapper.TopoDS.TopoDS_Edge
        :type E2: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type tol: float
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _ShapeFix.ShapeFix_FixSmallFace_ComputeSharedEdgeForStripFace(self, *args)


    def FixSplitFace(self, *args):
        """
        FixSplitFace(ShapeFix_FixSmallFace self, TopoDS_Shape S) -> TopoDS_Shape

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.ShapeFix_FixSmallFace_FixSplitFace(self, *args)


    def SplitOneFace(self, *args):
        """
        SplitOneFace(ShapeFix_FixSmallFace self, TopoDS_Face F, TopoDS_Compound theSplittedFaces) -> Standard_Boolean

        Compute data for face splitting.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type theSplittedFaces: OCC.wrapper.TopoDS.TopoDS_Compound
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_FixSmallFace_SplitOneFace(self, *args)


    def FixFace(self, *args):
        """
        FixFace(ShapeFix_FixSmallFace self, TopoDS_Face F) -> TopoDS_Face

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _ShapeFix.ShapeFix_FixSmallFace_FixFace(self, *args)


    def FixShape(self, *args):
        """
        FixShape(ShapeFix_FixSmallFace self) -> TopoDS_Shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.ShapeFix_FixSmallFace_FixShape(self, *args)


    def Shape(self, *args):
        """
        Shape(ShapeFix_FixSmallFace self) -> TopoDS_Shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.ShapeFix_FixSmallFace_Shape(self, *args)


    def FixPinFace(self, *args):
        """
        FixPinFace(ShapeFix_FixSmallFace self, TopoDS_Face F) -> Standard_Boolean

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_FixSmallFace_FixPinFace(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeFix.ShapeFix_FixSmallFace_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeFix.ShapeFix_FixSmallFace_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.ShapeFix_FixSmallFace_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeFix.delete_ShapeFix_FixSmallFace
ShapeFix_FixSmallFace_swigregister = _ShapeFix.ShapeFix_FixSmallFace_swigregister
ShapeFix_FixSmallFace_swigregister(ShapeFix_FixSmallFace)

def ShapeFix_FixSmallFace_get_type_name(*args):
    """
    ShapeFix_FixSmallFace_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeFix.ShapeFix_FixSmallFace_get_type_name(*args)

def ShapeFix_FixSmallFace_get_type_descriptor(*args):
    """
    ShapeFix_FixSmallFace_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeFix.ShapeFix_FixSmallFace_get_type_descriptor(*args)

class ShapeFix_WireSegment(object):
    """
    This class is auxiliary class (data storage) used in ComposeShell.
    It is intended for representing segment of the wire
    (or whole wire). The segment itself is represented by
    ShapeExtend_WireData. In addition, some associated data
    necessary for computations are stored:

    * Orientation flag - determines current use of the segment
    and used for parity checking:

    TopAbs_FORWARD and TopAbs_REVERSED - says that segment was
    traversed once in the corresponding direction, and hence
    it should be traversed once more in opposite direction;

    TopAbs_EXTERNAL - the segment was not yet traversed in any
    direction (i.e. not yet used as boundary)

    TopAbs_INTERNAL - the segment was traversed in both
    directions and hence is out of further work.

    Segments of initial bounding wires are created with
    orientation REVERSED (for outer wire) or FORWARD (for inner
    wires), and segments of splitting seams - with orientation
    EXTERNAL.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ShapeFix_WireSegment self) -> ShapeFix_WireSegment
        __init__(ShapeFix_WireSegment self, Handle_ShapeExtend_WireData wire, TopAbs_Orientation const ori=TopAbs_EXTERNAL) -> ShapeFix_WireSegment

        Creates segment and initializes it with wire and orientation.

        :type wire: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_WireData
        :type ori: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        this = _ShapeFix.new_ShapeFix_WireSegment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Clear(self, *args):
        """
        Clear(ShapeFix_WireSegment self)

        Clears all fields.


        """
        return _ShapeFix.ShapeFix_WireSegment_Clear(self, *args)


    def Load(self, *args):
        """
        Load(ShapeFix_WireSegment self, Handle_ShapeExtend_WireData wire)

        Loads wire.

        :type wire: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_WireData

        """
        return _ShapeFix.ShapeFix_WireSegment_Load(self, *args)


    def WireData(self, *args):
        """
        Returns wire.

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_WireData

        """
        res = _ShapeFix.ShapeFix_WireSegment_WireData(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Orientation(self, *args):
        """
        Orientation(ShapeFix_WireSegment self, TopAbs_Orientation const ori)
        Orientation(ShapeFix_WireSegment self) -> TopAbs_Orientation

        Returns orientation flag.

        :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _ShapeFix.ShapeFix_WireSegment_Orientation(self, *args)


    def FirstVertex(self, *args):
        """
        FirstVertex(ShapeFix_WireSegment self) -> TopoDS_Vertex

        Returns first vertex of the first edge in the wire
        (no dependance on Orientation()).

        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _ShapeFix.ShapeFix_WireSegment_FirstVertex(self, *args)


    def LastVertex(self, *args):
        """
        LastVertex(ShapeFix_WireSegment self) -> TopoDS_Vertex

        Returns last vertex of the last edge in the wire
        (no dependance on Orientation()).

        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _ShapeFix.ShapeFix_WireSegment_LastVertex(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(ShapeFix_WireSegment self) -> Standard_Boolean

        Returns True if FirstVertex() == LastVertex()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_WireSegment_IsClosed(self, *args)


    def NbEdges(self, *args):
        """
        NbEdges(ShapeFix_WireSegment self) -> Standard_Integer

        Returns Number of edges in the wire

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_WireSegment_NbEdges(self, *args)


    def Edge(self, *args):
        """
        Edge(ShapeFix_WireSegment self, Standard_Integer const i) -> TopoDS_Edge

        Returns edge by given index in the wire

        :type i: int
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _ShapeFix.ShapeFix_WireSegment_Edge(self, *args)


    def SetEdge(self, *args):
        """
        SetEdge(ShapeFix_WireSegment self, Standard_Integer const i, TopoDS_Edge edge)

        Replaces edge at index i by new one.

        :type i: int
        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _ShapeFix.ShapeFix_WireSegment_SetEdge(self, *args)


    def AddEdge(self, *args):
        """
        AddEdge(ShapeFix_WireSegment self, Standard_Integer const i, TopoDS_Edge edge)
        AddEdge(ShapeFix_WireSegment self, Standard_Integer const i, TopoDS_Edge edge, Standard_Integer const iumin, Standard_Integer const iumax, Standard_Integer const ivmin, Standard_Integer const ivmax)

        Insert a new edge with index i and explicitly defined
        patch indices. If i==0, edge is inserted at end of wire.

        :type i: int
        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type iumin: int
        :type iumax: int
        :type ivmin: int
        :type ivmax: int

        """
        return _ShapeFix.ShapeFix_WireSegment_AddEdge(self, *args)


    def SetPatchIndex(self, *args):
        """
        SetPatchIndex(ShapeFix_WireSegment self, Standard_Integer const i, Standard_Integer const iumin, Standard_Integer const iumax, Standard_Integer const ivmin, Standard_Integer const ivmax)

        Set patch indices for edge i.

        :type i: int
        :type iumin: int
        :type iumax: int
        :type ivmin: int
        :type ivmax: int

        """
        return _ShapeFix.ShapeFix_WireSegment_SetPatchIndex(self, *args)


    def DefineIUMin(self, *args):
        """
        DefineIUMin(ShapeFix_WireSegment self, Standard_Integer const i, Standard_Integer const iumin)

        :type i: int
        :type iumin: int

        """
        return _ShapeFix.ShapeFix_WireSegment_DefineIUMin(self, *args)


    def DefineIUMax(self, *args):
        """
        DefineIUMax(ShapeFix_WireSegment self, Standard_Integer const i, Standard_Integer const iumax)

        :type i: int
        :type iumax: int

        """
        return _ShapeFix.ShapeFix_WireSegment_DefineIUMax(self, *args)


    def DefineIVMin(self, *args):
        """
        DefineIVMin(ShapeFix_WireSegment self, Standard_Integer const i, Standard_Integer const ivmin)

        :type i: int
        :type ivmin: int

        """
        return _ShapeFix.ShapeFix_WireSegment_DefineIVMin(self, *args)


    def DefineIVMax(self, *args):
        """
        DefineIVMax(ShapeFix_WireSegment self, Standard_Integer const i, Standard_Integer const ivmax)

        Modify minimal or maximal patch index for edge i.
        The corresponding patch index for that edge is modified so
        as to satisfy eq. iumin <= myIUMin(i) <= myIUMax(i) <= iumax

        :type i: int
        :type ivmax: int

        """
        return _ShapeFix.ShapeFix_WireSegment_DefineIVMax(self, *args)


    def GetPatchIndex(self, *args):
        """
        GetPatchIndex(ShapeFix_WireSegment self, Standard_Integer const i)

        Returns patch indices for edge i.

        :type i: int
        :type iumin: int
        :type iumax: int
        :type ivmin: int
        :type ivmax: int

        """
        return _ShapeFix.ShapeFix_WireSegment_GetPatchIndex(self, *args)


    def CheckPatchIndex(self, *args):
        """
        CheckPatchIndex(ShapeFix_WireSegment self, Standard_Integer const i) -> Standard_Boolean

        Checks patch indices for edge i to satisfy equations
        IUMin(i) <= IUMax(i) <= IUMin(i)+1

        :type i: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_WireSegment_CheckPatchIndex(self, *args)


    def SetVertex(self, *args):
        """
        SetVertex(ShapeFix_WireSegment self, TopoDS_Vertex theVertex)

        :type theVertex: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _ShapeFix.ShapeFix_WireSegment_SetVertex(self, *args)


    def GetVertex(self, *args):
        """
        GetVertex(ShapeFix_WireSegment self) -> TopoDS_Vertex

        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _ShapeFix.ShapeFix_WireSegment_GetVertex(self, *args)


    def IsVertex(self, *args):
        """
        IsVertex(ShapeFix_WireSegment self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_WireSegment_IsVertex(self, *args)

    __swig_destroy__ = _ShapeFix.delete_ShapeFix_WireSegment
ShapeFix_WireSegment_swigregister = _ShapeFix.ShapeFix_WireSegment_swigregister
ShapeFix_WireSegment_swigregister(ShapeFix_WireSegment)

class ShapeFix_SplitCommonVertex(ShapeFix_Root):
    """
    Two wires have common vertex - this case is valid in BRep model
    and isn't valid in STEP => before writing into STEP it is necessary
    to split this vertex (each wire must has one vertex)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeFix_SplitCommonVertex
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeFix_SplitCommonVertex(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeFix_SplitCommonVertex self) -> ShapeFix_SplitCommonVertex

        Two wires have common vertex - this case is valid in BRep model
        and isn't valid in STEP => before writing into STEP it is necessary
        to split this vertex (each wire must has one vertex)
        """
        this = _ShapeFix.new_ShapeFix_SplitCommonVertex(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(ShapeFix_SplitCommonVertex self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.ShapeFix_SplitCommonVertex_Init(self, *args)


    def Perform(self, *args):
        """Perform(ShapeFix_SplitCommonVertex self)"""
        return _ShapeFix.ShapeFix_SplitCommonVertex_Perform(self, *args)


    def Shape(self, *args):
        """
        Shape(ShapeFix_SplitCommonVertex self) -> TopoDS_Shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.ShapeFix_SplitCommonVertex_Shape(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeFix.ShapeFix_SplitCommonVertex_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeFix.ShapeFix_SplitCommonVertex_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.ShapeFix_SplitCommonVertex_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeFix.delete_ShapeFix_SplitCommonVertex
ShapeFix_SplitCommonVertex_swigregister = _ShapeFix.ShapeFix_SplitCommonVertex_swigregister
ShapeFix_SplitCommonVertex_swigregister(ShapeFix_SplitCommonVertex)

def ShapeFix_SplitCommonVertex_get_type_name(*args):
    """
    ShapeFix_SplitCommonVertex_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeFix.ShapeFix_SplitCommonVertex_get_type_name(*args)

def ShapeFix_SplitCommonVertex_get_type_descriptor(*args):
    """
    ShapeFix_SplitCommonVertex_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeFix.ShapeFix_SplitCommonVertex_get_type_descriptor(*args)

class Handle_ShapeFix_EdgeProjAux(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeFix_EdgeProjAux self)

        Nullify the handle


        """
        return _ShapeFix.Handle_ShapeFix_EdgeProjAux_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeFix_EdgeProjAux self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeFix.Handle_ShapeFix_EdgeProjAux_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeFix_EdgeProjAux self, ShapeFix_EdgeProjAux thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeFix.Handle_ShapeFix_EdgeProjAux_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeFix_EdgeProjAux self, Handle_ShapeFix_EdgeProjAux theHandle) -> Handle_ShapeFix_EdgeProjAux
        assign(Handle_ShapeFix_EdgeProjAux self, ShapeFix_EdgeProjAux thePtr) -> Handle_ShapeFix_EdgeProjAux
        assign(Handle_ShapeFix_EdgeProjAux self, Handle_ShapeFix_EdgeProjAux theHandle) -> Handle_ShapeFix_EdgeProjAux

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeFix.Handle_ShapeFix_EdgeProjAux_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeFix_EdgeProjAux self) -> ShapeFix_EdgeProjAux

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeFix.Handle_ShapeFix_EdgeProjAux_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeFix_EdgeProjAux self) -> ShapeFix_EdgeProjAux

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeFix.Handle_ShapeFix_EdgeProjAux___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeFix_EdgeProjAux self) -> ShapeFix_EdgeProjAux

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeFix.Handle_ShapeFix_EdgeProjAux___ref__(self, *args)


    def __hash__(self):
        return _ShapeFix.Handle_ShapeFix_EdgeProjAux___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeFix.Handle_ShapeFix_EdgeProjAux___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeFix.new_Handle_ShapeFix_EdgeProjAux(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeFix.Handle_ShapeFix_EdgeProjAux_DownCast)
    __swig_destroy__ = _ShapeFix.delete_Handle_ShapeFix_EdgeProjAux

    def Init(self, *args):
        """
        Init(Handle_ShapeFix_EdgeProjAux self, TopoDS_Face F, TopoDS_Edge E)

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _ShapeFix.Handle_ShapeFix_EdgeProjAux_Init(self, *args)


    def Compute(self, *args):
        """
        Compute(Handle_ShapeFix_EdgeProjAux self, Standard_Real const preci)

        :type preci: float

        """
        return _ShapeFix.Handle_ShapeFix_EdgeProjAux_Compute(self, *args)


    def IsFirstDone(self, *args):
        """
        IsFirstDone(Handle_ShapeFix_EdgeProjAux self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_EdgeProjAux_IsFirstDone(self, *args)


    def IsLastDone(self, *args):
        """
        IsLastDone(Handle_ShapeFix_EdgeProjAux self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_EdgeProjAux_IsLastDone(self, *args)


    def FirstParam(self, *args):
        """
        FirstParam(Handle_ShapeFix_EdgeProjAux self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_EdgeProjAux_FirstParam(self, *args)


    def LastParam(self, *args):
        """
        LastParam(Handle_ShapeFix_EdgeProjAux self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_EdgeProjAux_LastParam(self, *args)


    def IsIso(self, *args):
        """
        IsIso(Handle_ShapeFix_EdgeProjAux self, Handle_Geom2d_Curve C) -> Standard_Boolean

        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_EdgeProjAux_IsIso(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeFix_EdgeProjAux self) -> char const *

        :rtype: const char *

        """
        return _ShapeFix.Handle_ShapeFix_EdgeProjAux_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.Handle_ShapeFix_EdgeProjAux_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.Handle_ShapeFix_EdgeProjAux_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_ShapeFix_EdgeProjAux self)

        Memory deallocator for transient classes


        """
        return _ShapeFix.Handle_ShapeFix_EdgeProjAux_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeFix_EdgeProjAux self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeFix_EdgeProjAux self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_EdgeProjAux_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeFix_EdgeProjAux self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeFix_EdgeProjAux self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_EdgeProjAux_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeFix_EdgeProjAux self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeFix.Handle_ShapeFix_EdgeProjAux_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeFix_EdgeProjAux self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_EdgeProjAux_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeFix_EdgeProjAux self)

        Increments the reference counter of this object


        """
        return _ShapeFix.Handle_ShapeFix_EdgeProjAux_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeFix_EdgeProjAux self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_EdgeProjAux_DecrementRefCounter(self, *args)

Handle_ShapeFix_EdgeProjAux_swigregister = _ShapeFix.Handle_ShapeFix_EdgeProjAux_swigregister
Handle_ShapeFix_EdgeProjAux_swigregister(Handle_ShapeFix_EdgeProjAux)

def Handle_ShapeFix_EdgeProjAux_DownCast(thing):
    return _ShapeFix.Handle_ShapeFix_EdgeProjAux_DownCast(thing)
Handle_ShapeFix_EdgeProjAux_DownCast = _ShapeFix.Handle_ShapeFix_EdgeProjAux_DownCast

class ShapeFix_Edge(Standard.Standard_Transient):
    """
    Fixing invalid edge.
    Geometrical and/or topological inconsistency:
    - no 3d curve or pcurve,
    - mismatching orientation of 3d curve and pcurve,
    - incorrect SameParameter flag (curve deviation is greater than
    edge tolerance),
    - not adjacent curves (3d or pcurve) to the vertices.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeFix_Edge
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeFix_Edge(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeFix_Edge self) -> ShapeFix_Edge

        Empty constructor


        """
        this = _ShapeFix.new_ShapeFix_Edge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Projector(self, *args):
        """
        Projector(ShapeFix_Edge self) -> Handle_ShapeConstruct_ProjectCurveOnSurface

        Returns the projector used for recomputing missing pcurves
        Can be used for adjusting parameters of projector

        :rtype: OCC.wrapper.ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface

        """
        return _ShapeFix.ShapeFix_Edge_Projector(self, *args)


    def FixRemovePCurve(self, *args):
        """
        FixRemovePCurve(ShapeFix_Edge self, TopoDS_Edge edge, TopoDS_Face face) -> Standard_Boolean
        FixRemovePCurve(ShapeFix_Edge self, TopoDS_Edge edge, Handle_Geom_Surface surface, TopLoc_Location location) -> Standard_Boolean

        Removes the pcurve(s) of the edge if it does not match the
        vertices
        Check is done
        Use    : It is to be called when pcurve of an edge can be wrong
        (e.g., after import from IGES)
        Returns: True, if does not match, removed (status DONE)
        False, (status OK) if matches or (status FAIL) if no pcurve,
        nothing done

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type surface: OCC.wrapper.Geom.Handle_Geom_Surface
        :type location: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Edge_FixRemovePCurve(self, *args)


    def FixRemoveCurve3d(self, *args):
        """
        FixRemoveCurve3d(ShapeFix_Edge self, TopoDS_Edge edge) -> Standard_Boolean

        Removes 3d curve of the edge if it does not match the vertices
        Returns: True,  if does not match, removed (status DONE)
        False, (status OK) if matches or (status FAIL) if no 3d curve,
        nothing done

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Edge_FixRemoveCurve3d(self, *args)


    def FixAddPCurve(self, *args):
        """
        FixAddPCurve(ShapeFix_Edge self, TopoDS_Edge edge, TopoDS_Face face, Standard_Boolean const isSeam, Standard_Real const prec=0.0) -> Standard_Boolean
        FixAddPCurve(ShapeFix_Edge self, TopoDS_Edge edge, Handle_Geom_Surface surface, TopLoc_Location location, Standard_Boolean const isSeam, Standard_Real const prec=0.0) -> Standard_Boolean
        FixAddPCurve(ShapeFix_Edge self, TopoDS_Edge edge, TopoDS_Face face, Standard_Boolean const isSeam, Handle_ShapeAnalysis_Surface surfana, Standard_Real const prec=0.0) -> Standard_Boolean
        FixAddPCurve(ShapeFix_Edge self, TopoDS_Edge edge, Handle_Geom_Surface surface, TopLoc_Location location, Standard_Boolean const isSeam, Handle_ShapeAnalysis_Surface surfana, Standard_Real const prec=0.0) -> Standard_Boolean

        Adds pcurve(s) of the edge if missing (by projecting 3d curve)
        Parameter isSeam indicates if the edge is a seam.
        The parameter <prec> defines the precision for calculations.
        If it is 0 (default), the tolerance of the edge is taken.
        Remark : This method is rather for internal use since it accepts parameter
        <surfana> for optimization of computations
        Use    : It is to be called after FixRemovePCurve (if removed) or in any
        case when edge can have no pcurve
        Returns: True if pcurve was added, else False
        Status :
        OK   : Pcurve exists
        FAIL1: No 3d curve
        FAIL2: fail during projecting
        DONE1: Pcurve was added
        DONE2: specific case of pcurve going through degenerated point on
        sphere encountered during projection (see class
        ShapeConstruct_ProjectCurveOnSurface for more info)

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type surface: OCC.wrapper.Geom.Handle_Geom_Surface
        :type location: OCC.wrapper.TopLoc.TopLoc_Location
        :type isSeam: bool
        :type surfana: OCC.wrapper.ShapeAnalysis.Handle_ShapeAnalysis_Surface
        :type prec: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Edge_FixAddPCurve(self, *args)


    def FixAddCurve3d(self, *args):
        """
        FixAddCurve3d(ShapeFix_Edge self, TopoDS_Edge edge) -> Standard_Boolean

        Tries to build 3d curve of the edge if missing
        Use    : It is to be called after FixRemoveCurve3d (if removed) or in any
        case when edge can have no 3d curve
        Returns: True if 3d curve was added, else False
        Status :
        OK   : 3d curve exists
        FAIL1: BRepLib::BuildCurve3d() has failed
        DONE1: 3d curve was added

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Edge_FixAddCurve3d(self, *args)


    def FixVertexTolerance(self, *args):
        """
        FixVertexTolerance(ShapeFix_Edge self, TopoDS_Edge edge, TopoDS_Face face) -> Standard_Boolean
        FixVertexTolerance(ShapeFix_Edge self, TopoDS_Edge edge) -> Standard_Boolean

        Increases the tolerances of the edge vertices to comprise
        the ends of 3d curve and pcurve on the given face
        (first method) or all pcurves stored in an edge (second one)
        Returns: True, if tolerances have been increased, otherwise False
        Status:
        OK   : the original tolerances have not been changed
        DONE1: the tolerance of first vertex has been increased
        DONE2: the tolerance of last  vertex has been increased

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Edge_FixVertexTolerance(self, *args)


    def FixReversed2d(self, *args):
        """
        FixReversed2d(ShapeFix_Edge self, TopoDS_Edge edge, TopoDS_Face face) -> Standard_Boolean
        FixReversed2d(ShapeFix_Edge self, TopoDS_Edge edge, Handle_Geom_Surface surface, TopLoc_Location location) -> Standard_Boolean

        Fixes edge if pcurve is directed opposite to 3d curve
        Check is done by call to the function
        ShapeAnalysis_Edge::CheckCurve3dWithPCurve()
        Warning: For seam edge this method will check and fix the pcurve in only
        one direction. Hence, it should be called twice for seam edge:
        once with edge orientation FORWARD and once with REVERSED.
        Returns: False if nothing done, True if reversed (status DONE)
        Status:  OK    - pcurve OK, nothing done
        FAIL1 - no pcurve
        FAIL2 - no 3d curve
        DONE1 - pcurve was reversed

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type surface: OCC.wrapper.Geom.Handle_Geom_Surface
        :type location: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Edge_FixReversed2d(self, *args)


    def FixSameParameter(self, *args):
        """
        FixSameParameter(ShapeFix_Edge self, TopoDS_Edge edge, Standard_Real const tolerance=0.0) -> Standard_Boolean
        FixSameParameter(ShapeFix_Edge self, TopoDS_Edge edge, TopoDS_Face face, Standard_Real const tolerance=0.0) -> Standard_Boolean

        Tries to make edge SameParameter and sets corresponding
        tolerance and SameParameter flag.
        First, it makes edge same range if SameRange flag is not set.

        If flag SameParameter is set, this method calls the
        function ShapeAnalysis_Edge::CheckSameParameter() that
        calculates the maximal deviation of pcurves of the edge from
        its 3d curve. If deviation > tolerance, the tolerance of edge
        is increased to a value of deviation. If deviation < tolerance
        nothing happens.

        If flag SameParameter is not set, this method chooses the best
        variant (one that has minimal tolerance), either
        a. only after computing deviation (as above) or
        b. after calling standard procedure BRepLib::SameParameter
        and computing deviation (as above). If <tolerance> > 0, it is
        used as parameter for BRepLib::SameParameter, otherwise,
        tolerance of the edge is used.

        Use    : Is to be called after all pcurves and 3d curve of the edge are
        correctly computed
        Remark : SameParameter flag is always set to True after this method
        Returns: True, if something done, else False
        Status : OK    - edge was initially SameParameter, nothing is done
        FAIL1 - computation of deviation of pcurves from 3d curve has failed
        FAIL2 - BRepLib::SameParameter() has failed
        DONE1 - tolerance of the edge was increased
        DONE2 - flag SameParameter was set to True (only if
        BRepLib::SameParameter() did not set it)
        DONE3 - edge was modified by BRepLib::SameParameter() to SameParameter
        DONE4 - not used anymore
        DONE5 - if the edge resulting from BRepLib has been chosen, i.e. variant b. above
        (only for edges with not set SameParameter)

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type face: OCC.wrapper.TopoDS.TopoDS_Face
        :type tolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Edge_FixSameParameter(self, *args)


    def Status(self, *args):
        """
        Status(ShapeFix_Edge self, ShapeExtend_Status const status) -> Standard_Boolean

        Returns the status (in the form of True/False) of last Fix

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Edge_Status(self, *args)


    def SetContext(self, *args):
        """
        SetContext(ShapeFix_Edge self, Handle_ShapeBuild_ReShape context)

        Sets context

        :type context: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeFix.ShapeFix_Edge_SetContext(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeFix.ShapeFix_Edge_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeFix.ShapeFix_Edge_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.ShapeFix_Edge_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeFix.delete_ShapeFix_Edge
ShapeFix_Edge_swigregister = _ShapeFix.ShapeFix_Edge_swigregister
ShapeFix_Edge_swigregister(ShapeFix_Edge)

def ShapeFix_Edge_get_type_name(*args):
    """
    ShapeFix_Edge_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeFix.ShapeFix_Edge_get_type_name(*args)

def ShapeFix_Edge_get_type_descriptor(*args):
    """
    ShapeFix_Edge_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeFix.ShapeFix_Edge_get_type_descriptor(*args)

class Handle_ShapeFix_Edge(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeFix_Edge self)

        Nullify the handle


        """
        return _ShapeFix.Handle_ShapeFix_Edge_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeFix_Edge self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeFix.Handle_ShapeFix_Edge_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeFix_Edge self, ShapeFix_Edge thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeFix.Handle_ShapeFix_Edge_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeFix_Edge self, Handle_ShapeFix_Edge theHandle) -> Handle_ShapeFix_Edge
        assign(Handle_ShapeFix_Edge self, ShapeFix_Edge thePtr) -> Handle_ShapeFix_Edge
        assign(Handle_ShapeFix_Edge self, Handle_ShapeFix_Edge theHandle) -> Handle_ShapeFix_Edge

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeFix.Handle_ShapeFix_Edge_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeFix_Edge self) -> ShapeFix_Edge

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeFix.Handle_ShapeFix_Edge_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeFix_Edge self) -> ShapeFix_Edge

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeFix.Handle_ShapeFix_Edge___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeFix_Edge self) -> ShapeFix_Edge

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeFix.Handle_ShapeFix_Edge___ref__(self, *args)


    def __hash__(self):
        return _ShapeFix.Handle_ShapeFix_Edge___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeFix.Handle_ShapeFix_Edge___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeFix.new_Handle_ShapeFix_Edge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeFix.Handle_ShapeFix_Edge_DownCast)
    __swig_destroy__ = _ShapeFix.delete_Handle_ShapeFix_Edge

    def Projector(self, *args):
        """
        Projector(Handle_ShapeFix_Edge self) -> Handle_ShapeConstruct_ProjectCurveOnSurface

        Returns the projector used for recomputing missing pcurves
        Can be used for adjusting parameters of projector

        :rtype: OCC.wrapper.ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface

        """
        return _ShapeFix.Handle_ShapeFix_Edge_Projector(self, *args)


    def FixRemovePCurve(self, *args):
        """
        FixRemovePCurve(Handle_ShapeFix_Edge self, TopoDS_Edge edge, TopoDS_Face face) -> Standard_Boolean
        FixRemovePCurve(Handle_ShapeFix_Edge self, TopoDS_Edge edge, Handle_Geom_Surface surface, TopLoc_Location location) -> Standard_Boolean

        Removes the pcurve(s) of the edge if it does not match the
        vertices
        Check is done
        Use    : It is to be called when pcurve of an edge can be wrong
        (e.g., after import from IGES)
        Returns: True, if does not match, removed (status DONE)
        False, (status OK) if matches or (status FAIL) if no pcurve,
        nothing done

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type surface: OCC.wrapper.Geom.Handle_Geom_Surface
        :type location: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Edge_FixRemovePCurve(self, *args)


    def FixRemoveCurve3d(self, *args):
        """
        FixRemoveCurve3d(Handle_ShapeFix_Edge self, TopoDS_Edge edge) -> Standard_Boolean

        Removes 3d curve of the edge if it does not match the vertices
        Returns: True,  if does not match, removed (status DONE)
        False, (status OK) if matches or (status FAIL) if no 3d curve,
        nothing done

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Edge_FixRemoveCurve3d(self, *args)


    def FixAddPCurve(self, *args):
        """
        FixAddPCurve(Handle_ShapeFix_Edge self, TopoDS_Edge edge, TopoDS_Face face, Standard_Boolean const isSeam, Standard_Real const prec=0.0) -> Standard_Boolean
        FixAddPCurve(Handle_ShapeFix_Edge self, TopoDS_Edge edge, Handle_Geom_Surface surface, TopLoc_Location location, Standard_Boolean const isSeam, Standard_Real const prec=0.0) -> Standard_Boolean
        FixAddPCurve(Handle_ShapeFix_Edge self, TopoDS_Edge edge, TopoDS_Face face, Standard_Boolean const isSeam, Handle_ShapeAnalysis_Surface surfana, Standard_Real const prec=0.0) -> Standard_Boolean
        FixAddPCurve(Handle_ShapeFix_Edge self, TopoDS_Edge edge, Handle_Geom_Surface surface, TopLoc_Location location, Standard_Boolean const isSeam, Handle_ShapeAnalysis_Surface surfana, Standard_Real const prec=0.0) -> Standard_Boolean

        Adds pcurve(s) of the edge if missing (by projecting 3d curve)
        Parameter isSeam indicates if the edge is a seam.
        The parameter <prec> defines the precision for calculations.
        If it is 0 (default), the tolerance of the edge is taken.
        Remark : This method is rather for internal use since it accepts parameter
        <surfana> for optimization of computations
        Use    : It is to be called after FixRemovePCurve (if removed) or in any
        case when edge can have no pcurve
        Returns: True if pcurve was added, else False
        Status :
        OK   : Pcurve exists
        FAIL1: No 3d curve
        FAIL2: fail during projecting
        DONE1: Pcurve was added
        DONE2: specific case of pcurve going through degenerated point on
        sphere encountered during projection (see class
        ShapeConstruct_ProjectCurveOnSurface for more info)

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type surface: OCC.wrapper.Geom.Handle_Geom_Surface
        :type location: OCC.wrapper.TopLoc.TopLoc_Location
        :type isSeam: bool
        :type surfana: OCC.wrapper.ShapeAnalysis.Handle_ShapeAnalysis_Surface
        :type prec: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Edge_FixAddPCurve(self, *args)


    def FixAddCurve3d(self, *args):
        """
        FixAddCurve3d(Handle_ShapeFix_Edge self, TopoDS_Edge edge) -> Standard_Boolean

        Tries to build 3d curve of the edge if missing
        Use    : It is to be called after FixRemoveCurve3d (if removed) or in any
        case when edge can have no 3d curve
        Returns: True if 3d curve was added, else False
        Status :
        OK   : 3d curve exists
        FAIL1: BRepLib::BuildCurve3d() has failed
        DONE1: 3d curve was added

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Edge_FixAddCurve3d(self, *args)


    def FixVertexTolerance(self, *args):
        """
        FixVertexTolerance(Handle_ShapeFix_Edge self, TopoDS_Edge edge, TopoDS_Face face) -> Standard_Boolean
        FixVertexTolerance(Handle_ShapeFix_Edge self, TopoDS_Edge edge) -> Standard_Boolean

        Increases the tolerances of the edge vertices to comprise
        the ends of 3d curve and pcurve on the given face
        (first method) or all pcurves stored in an edge (second one)
        Returns: True, if tolerances have been increased, otherwise False
        Status:
        OK   : the original tolerances have not been changed
        DONE1: the tolerance of first vertex has been increased
        DONE2: the tolerance of last  vertex has been increased

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Edge_FixVertexTolerance(self, *args)


    def FixReversed2d(self, *args):
        """
        FixReversed2d(Handle_ShapeFix_Edge self, TopoDS_Edge edge, TopoDS_Face face) -> Standard_Boolean
        FixReversed2d(Handle_ShapeFix_Edge self, TopoDS_Edge edge, Handle_Geom_Surface surface, TopLoc_Location location) -> Standard_Boolean

        Fixes edge if pcurve is directed opposite to 3d curve
        Check is done by call to the function
        ShapeAnalysis_Edge::CheckCurve3dWithPCurve()
        Warning: For seam edge this method will check and fix the pcurve in only
        one direction. Hence, it should be called twice for seam edge:
        once with edge orientation FORWARD and once with REVERSED.
        Returns: False if nothing done, True if reversed (status DONE)
        Status:  OK    - pcurve OK, nothing done
        FAIL1 - no pcurve
        FAIL2 - no 3d curve
        DONE1 - pcurve was reversed

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type surface: OCC.wrapper.Geom.Handle_Geom_Surface
        :type location: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Edge_FixReversed2d(self, *args)


    def FixSameParameter(self, *args):
        """
        FixSameParameter(Handle_ShapeFix_Edge self, TopoDS_Edge edge, Standard_Real const tolerance=0.0) -> Standard_Boolean
        FixSameParameter(Handle_ShapeFix_Edge self, TopoDS_Edge edge, TopoDS_Face face, Standard_Real const tolerance=0.0) -> Standard_Boolean

        Tries to make edge SameParameter and sets corresponding
        tolerance and SameParameter flag.
        First, it makes edge same range if SameRange flag is not set.

        If flag SameParameter is set, this method calls the
        function ShapeAnalysis_Edge::CheckSameParameter() that
        calculates the maximal deviation of pcurves of the edge from
        its 3d curve. If deviation > tolerance, the tolerance of edge
        is increased to a value of deviation. If deviation < tolerance
        nothing happens.

        If flag SameParameter is not set, this method chooses the best
        variant (one that has minimal tolerance), either
        a. only after computing deviation (as above) or
        b. after calling standard procedure BRepLib::SameParameter
        and computing deviation (as above). If <tolerance> > 0, it is
        used as parameter for BRepLib::SameParameter, otherwise,
        tolerance of the edge is used.

        Use    : Is to be called after all pcurves and 3d curve of the edge are
        correctly computed
        Remark : SameParameter flag is always set to True after this method
        Returns: True, if something done, else False
        Status : OK    - edge was initially SameParameter, nothing is done
        FAIL1 - computation of deviation of pcurves from 3d curve has failed
        FAIL2 - BRepLib::SameParameter() has failed
        DONE1 - tolerance of the edge was increased
        DONE2 - flag SameParameter was set to True (only if
        BRepLib::SameParameter() did not set it)
        DONE3 - edge was modified by BRepLib::SameParameter() to SameParameter
        DONE4 - not used anymore
        DONE5 - if the edge resulting from BRepLib has been chosen, i.e. variant b. above
        (only for edges with not set SameParameter)

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type face: OCC.wrapper.TopoDS.TopoDS_Face
        :type tolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Edge_FixSameParameter(self, *args)


    def Status(self, *args):
        """
        Status(Handle_ShapeFix_Edge self, ShapeExtend_Status const status) -> Standard_Boolean

        Returns the status (in the form of True/False) of last Fix

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Edge_Status(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_ShapeFix_Edge self, Handle_ShapeBuild_ReShape context)

        Sets context

        :type context: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeFix.Handle_ShapeFix_Edge_SetContext(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeFix_Edge self) -> char const *

        :rtype: const char *

        """
        return _ShapeFix.Handle_ShapeFix_Edge_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.Handle_ShapeFix_Edge_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.Handle_ShapeFix_Edge_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_ShapeFix_Edge self)

        Memory deallocator for transient classes


        """
        return _ShapeFix.Handle_ShapeFix_Edge_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeFix_Edge self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeFix_Edge self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Edge_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeFix_Edge self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeFix_Edge self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Edge_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeFix_Edge self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeFix.Handle_ShapeFix_Edge_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeFix_Edge self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Edge_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeFix_Edge self)

        Increments the reference counter of this object


        """
        return _ShapeFix.Handle_ShapeFix_Edge_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeFix_Edge self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Edge_DecrementRefCounter(self, *args)

Handle_ShapeFix_Edge_swigregister = _ShapeFix.Handle_ShapeFix_Edge_swigregister
Handle_ShapeFix_Edge_swigregister(Handle_ShapeFix_Edge)

def Handle_ShapeFix_Edge_DownCast(thing):
    return _ShapeFix.Handle_ShapeFix_Edge_DownCast(thing)
Handle_ShapeFix_Edge_DownCast = _ShapeFix.Handle_ShapeFix_Edge_DownCast

class Handle_ShapeFix_Wireframe(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeFix_Wireframe self)

        Nullify the handle


        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeFix_Wireframe self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeFix_Wireframe self, ShapeFix_Wireframe thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeFix_Wireframe self, Handle_ShapeFix_Wireframe theHandle) -> Handle_ShapeFix_Wireframe
        assign(Handle_ShapeFix_Wireframe self, ShapeFix_Wireframe thePtr) -> Handle_ShapeFix_Wireframe
        assign(Handle_ShapeFix_Wireframe self, Handle_ShapeFix_Wireframe theHandle) -> Handle_ShapeFix_Wireframe

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeFix_Wireframe self) -> ShapeFix_Wireframe

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeFix_Wireframe self) -> ShapeFix_Wireframe

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeFix_Wireframe self) -> ShapeFix_Wireframe

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe___ref__(self, *args)


    def __hash__(self):
        return _ShapeFix.Handle_ShapeFix_Wireframe___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeFix.Handle_ShapeFix_Wireframe___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeFix.new_Handle_ShapeFix_Wireframe(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeFix.Handle_ShapeFix_Wireframe_DownCast)
    __swig_destroy__ = _ShapeFix.delete_Handle_ShapeFix_Wireframe

    def ClearStatuses(self, *args):
        """
        ClearStatuses(Handle_ShapeFix_Wireframe self)

        Clears all statuses


        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_ClearStatuses(self, *args)


    def Load(self, *args):
        """
        Load(Handle_ShapeFix_Wireframe self, TopoDS_Shape shape)

        Loads a shape, resets statuses

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_Load(self, *args)


    def FixWireGaps(self, *args):
        """
        FixWireGaps(Handle_ShapeFix_Wireframe self) -> Standard_Boolean

        Fixes gaps between ends of curves of adjacent edges
        (both 3d and pcurves) in wires
        If precision is 0.0, uses Precision::Confusion().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_FixWireGaps(self, *args)


    def FixSmallEdges(self, *args):
        """
        FixSmallEdges(Handle_ShapeFix_Wireframe self) -> Standard_Boolean

        Fixes small edges in shape by merging adjacent edges
        If precision is 0.0, uses Precision::Confusion().

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_FixSmallEdges(self, *args)


    def CheckSmallEdges(self, *args):
        """
        CheckSmallEdges(Handle_ShapeFix_Wireframe self, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theSmallEdges, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher theEdgeToFaces, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher theFaceWithSmall, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theMultyEdges) -> Standard_Boolean

        Auxiliary tool for FixSmallEdges which checks for small edges and fills the maps.
        Returns True if at least one small edge has been found.

        :type theSmallEdges: OCC.wrapper.TopTools.TopTools_MapOfShape
        :type theEdgeToFaces: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape
        :type theFaceWithSmall: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape
        :type theMultyEdges: OCC.wrapper.TopTools.TopTools_MapOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_CheckSmallEdges(self, *args)


    def MergeSmallEdges(self, *args):
        """
        MergeSmallEdges(Handle_ShapeFix_Wireframe self, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theSmallEdges, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher theEdgeToFaces, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher theFaceWithSmall, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theMultyEdges, Standard_Boolean const theModeDrop, Standard_Real const theLimitAngle=-1) -> Standard_Boolean

        Auxiliary tool for FixSmallEdges which merges small edges.
        If theModeDrop is equal to Standard_True then small edges,
        which cannot be connected with adjacent edges are dropped.
        Otherwise they are kept.
        theLimitAngle specifies maximum allowed tangency
        discontinuity between adjacent edges.
        If theLimitAngle is equal to -1, this angle is not taken into account.

        :type theSmallEdges: OCC.wrapper.TopTools.TopTools_MapOfShape
        :type theEdgeToFaces: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape
        :type theFaceWithSmall: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape
        :type theMultyEdges: OCC.wrapper.TopTools.TopTools_MapOfShape
        :type theModeDrop: bool
        :type theLimitAngle: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_MergeSmallEdges(self, *args)


    def StatusWireGaps(self, *args):
        """
        StatusWireGaps(Handle_ShapeFix_Wireframe self, ShapeExtend_Status const status) -> Standard_Boolean

        Decodes the status of the last FixWireGaps.
        OK - No gaps were found
        DONE1 - Some gaps in 3D were fixed
        DONE2 - Some gaps in 2D were fixed
        FAIL1 - Failed to fix some gaps in 3D
        FAIL2 - Failed to fix some gaps in 2D

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_StatusWireGaps(self, *args)


    def StatusSmallEdges(self, *args):
        """
        StatusSmallEdges(Handle_ShapeFix_Wireframe self, ShapeExtend_Status const status) -> Standard_Boolean

        Decodes the status of the last FixSmallEdges.
        OK - No small edges were found
        DONE1 - Some small edges were fixed
        FAIL1 - Failed to fix some small edges

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_StatusSmallEdges(self, *args)


    def Shape(self, *args):
        """
        Shape(Handle_ShapeFix_Wireframe self) -> TopoDS_Shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_Shape(self, *args)


    def ModeDropSmallEdges(self, *args):
        """
        ModeDropSmallEdges(Handle_ShapeFix_Wireframe self) -> Standard_Boolean &

        Returns mode managing removing small edges.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_ModeDropSmallEdges(self, *args)


    def SetLimitAngle(self, *args):
        """
        SetLimitAngle(Handle_ShapeFix_Wireframe self, Standard_Real const theLimitAngle)

        Set limit angle for merging edges.

        :type theLimitAngle: float

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_SetLimitAngle(self, *args)


    def LimitAngle(self, *args):
        """
        LimitAngle(Handle_ShapeFix_Wireframe self) -> Standard_Real

        Get limit angle for merging edges.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_LimitAngle(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeFix_Wireframe self) -> char const *

        :rtype: const char *

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.Handle_ShapeFix_Wireframe_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.Handle_ShapeFix_Wireframe_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_ShapeFix_Wireframe self, Handle_ShapeFix_Root Root)

        Copy all fields from another Root object

        :type Root: OCC.wrapper.ShapeFix.Handle_ShapeFix_Root

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_Set(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_ShapeFix_Wireframe self, Handle_ShapeBuild_ReShape context)

        Sets context

        :type context: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_SetContext(self, *args)


    def Context(self, *args):
        """
        Context(Handle_ShapeFix_Wireframe self) -> Handle_ShapeBuild_ReShape

        Returns context

        :rtype: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_Context(self, *args)


    def SetMsgRegistrator(self, *args):
        """
        SetMsgRegistrator(Handle_ShapeFix_Wireframe self, Handle_ShapeExtend_BasicMsgRegistrator msgreg)

        Sets message registrator

        :type msgreg: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_SetMsgRegistrator(self, *args)


    def MsgRegistrator(self, *args):
        """
        MsgRegistrator(Handle_ShapeFix_Wireframe self) -> Handle_ShapeExtend_BasicMsgRegistrator

        Returns message registrator

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_MsgRegistrator(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(Handle_ShapeFix_Wireframe self, Standard_Real const preci)

        Sets basic precision value

        :type preci: float

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_SetPrecision(self, *args)


    def Precision(self, *args):
        """
        Precision(Handle_ShapeFix_Wireframe self) -> Standard_Real

        Returns basic precision value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_Precision(self, *args)


    def SetMinTolerance(self, *args):
        """
        SetMinTolerance(Handle_ShapeFix_Wireframe self, Standard_Real const mintol)

        Sets minimal allowed tolerance

        :type mintol: float

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_SetMinTolerance(self, *args)


    def MinTolerance(self, *args):
        """
        MinTolerance(Handle_ShapeFix_Wireframe self) -> Standard_Real

        Returns minimal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_MinTolerance(self, *args)


    def SetMaxTolerance(self, *args):
        """
        SetMaxTolerance(Handle_ShapeFix_Wireframe self, Standard_Real const maxtol)

        Sets maximal allowed tolerance

        :type maxtol: float

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_SetMaxTolerance(self, *args)


    def MaxTolerance(self, *args):
        """
        MaxTolerance(Handle_ShapeFix_Wireframe self) -> Standard_Real

        Returns maximal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_MaxTolerance(self, *args)


    def LimitTolerance(self, *args):
        """
        LimitTolerance(Handle_ShapeFix_Wireframe self, Standard_Real const toler) -> Standard_Real

        Returns tolerance limited by [myMinTol,myMaxTol]

        :type toler: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_LimitTolerance(self, *args)


    def SendMsg(self, *args):
        """
        SendMsg(Handle_ShapeFix_Wireframe self, TopoDS_Shape shape, Message_Msg message, Message_Gravity const gravity=Message_Info)
        SendMsg(Handle_ShapeFix_Wireframe self, Message_Msg message, Message_Gravity const gravity=Message_Info)

        Sends a message to be attached to myShape.
        Calls previous method.

        :type message: OCC.wrapper.Message.Message_Msg
        :type gravity: OCC.wrapper.Message.Message_Gravity

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_SendMsg(self, *args)


    def SendWarning(self, *args):
        """
        SendWarning(Handle_ShapeFix_Wireframe self, TopoDS_Shape shape, Message_Msg message)
        SendWarning(Handle_ShapeFix_Wireframe self, Message_Msg message)

        Calls previous method for myShape.

        :type message: OCC.wrapper.Message.Message_Msg

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_SendWarning(self, *args)


    def SendFail(self, *args):
        """
        SendFail(Handle_ShapeFix_Wireframe self, TopoDS_Shape shape, Message_Msg message)
        SendFail(Handle_ShapeFix_Wireframe self, Message_Msg message)

        Calls previous method for myShape.

        :type message: OCC.wrapper.Message.Message_Msg

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_SendFail(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeFix_Wireframe self)

        Memory deallocator for transient classes


        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeFix_Wireframe self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeFix_Wireframe self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeFix_Wireframe self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeFix_Wireframe self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeFix_Wireframe self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeFix_Wireframe self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeFix_Wireframe self)

        Increments the reference counter of this object


        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeFix_Wireframe self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Wireframe_DecrementRefCounter(self, *args)

Handle_ShapeFix_Wireframe_swigregister = _ShapeFix.Handle_ShapeFix_Wireframe_swigregister
Handle_ShapeFix_Wireframe_swigregister(Handle_ShapeFix_Wireframe)

def Handle_ShapeFix_Wireframe_DownCast(thing):
    return _ShapeFix.Handle_ShapeFix_Wireframe_DownCast(thing)
Handle_ShapeFix_Wireframe_DownCast = _ShapeFix.Handle_ShapeFix_Wireframe_DownCast

class ShapeFix_ShapeTolerance(object):
    """Modifies tolerances of sub-shapes (vertices, edges, faces)"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ShapeFix_ShapeTolerance self) -> ShapeFix_ShapeTolerance

        Modifies tolerances of sub-shapes (vertices, edges, faces)
        """
        this = _ShapeFix.new_ShapeFix_ShapeTolerance(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def LimitTolerance(self, *args):
        """
        LimitTolerance(ShapeFix_ShapeTolerance self, TopoDS_Shape shape, Standard_Real const tmin, Standard_Real const tmax=0.0, TopAbs_ShapeEnum const styp=TopAbs_SHAPE) -> Standard_Boolean

        Limits tolerances in a shape as follows :
        tmin = tmax -> as SetTolerance (forces)
        tmin = 0   -> maximum tolerance will be <tmax>
        tmax = 0 or not given (more generally, tmax < tmin) ->
        <tmax> ignored, minimum will be <tmin>
        else, maximum will be <max> and minimum will be <min>
        styp = VERTEX : only vertices are set
        styp = EDGE   : only edges are set
        styp = FACE   : only faces are set
        styp = WIRE   : to have edges and their vertices set
        styp = other value : all (vertices,edges,faces) are set
        Returns True if at least one tolerance of the sub-shape has
        been modified

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type tmin: float
        :type tmax: float
        :type styp: OCC.wrapper.TopAbs.TopAbs_ShapeEnum
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_ShapeTolerance_LimitTolerance(self, *args)


    def SetTolerance(self, *args):
        """
        SetTolerance(ShapeFix_ShapeTolerance self, TopoDS_Shape shape, Standard_Real const preci, TopAbs_ShapeEnum const styp=TopAbs_SHAPE)

        Sets (enforces) tolerances in a shape to the given value
        styp = VERTEX : only vertices are set
        styp = EDGE   : only edges are set
        styp = FACE   : only faces are set
        styp = WIRE   : to have edges and their vertices set
        styp = other value : all (vertices,edges,faces) are set

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type preci: float
        :type styp: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _ShapeFix.ShapeFix_ShapeTolerance_SetTolerance(self, *args)

    __swig_destroy__ = _ShapeFix.delete_ShapeFix_ShapeTolerance
ShapeFix_ShapeTolerance_swigregister = _ShapeFix.ShapeFix_ShapeTolerance_swigregister
ShapeFix_ShapeTolerance_swigregister(ShapeFix_ShapeTolerance)

class ShapeFix_WireVertex(object):
    """
    Fixing disconnected edges in the wire
    Fixes vertices in the wire on the basis of pre-analysis
    made by ShapeAnalysis_WireVertex (given as argument).
    The Wire has formerly been loaded in a ShapeExtend_WireData.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ShapeFix_WireVertex self) -> ShapeFix_WireVertex

        Fixing disconnected edges in the wire
        Fixes vertices in the wire on the basis of pre-analysis
        made by ShapeAnalysis_WireVertex (given as argument).
        The Wire has formerly been loaded in a ShapeExtend_WireData.
        """
        this = _ShapeFix.new_ShapeFix_WireVertex(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(ShapeFix_WireVertex self, TopoDS_Wire wire, Standard_Real const preci)
        Init(ShapeFix_WireVertex self, Handle_ShapeExtend_WireData sbwd, Standard_Real const preci)
        Init(ShapeFix_WireVertex self, ShapeAnalysis_WireVertex sawv)

        Loads all the data on wire, already analysed by
        ShapeAnalysis_WireVertex

        :type sawv: OCC.wrapper.ShapeAnalysis.ShapeAnalysis_WireVertex

        """
        return _ShapeFix.ShapeFix_WireVertex_Init(self, *args)


    def Analyzer(self, *args):
        """
        returns internal analyzer

        :rtype: OCC.wrapper.ShapeAnalysis.ShapeAnalysis_WireVertex

        """
        res = _ShapeFix.ShapeFix_WireVertex_Analyzer(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def WireData(self, *args):
        """
        returns data on wire (fixed)

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_WireData

        """
        res = _ShapeFix.ShapeFix_WireVertex_WireData(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Wire(self, *args):
        """
        Wire(ShapeFix_WireVertex self) -> TopoDS_Wire

        returns resulting wire (fixed)

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _ShapeFix.ShapeFix_WireVertex_Wire(self, *args)


    def FixSame(self, *args):
        """
        FixSame(ShapeFix_WireVertex self) -> Standard_Integer

        Fixes "Same" or "Close" status (same vertex may be set,
        without changing parameters)
        Returns the count of fixed vertices, 0 if none

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_WireVertex_FixSame(self, *args)


    def Fix(self, *args):
        """
        Fix(ShapeFix_WireVertex self) -> Standard_Integer

        Fixes all statuses except "Disjoined", i.e. the cases in which a
        common value has been set, with or without changing parameters
        Returns the count of fixed vertices, 0 if none

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_WireVertex_Fix(self, *args)

    __swig_destroy__ = _ShapeFix.delete_ShapeFix_WireVertex
ShapeFix_WireVertex_swigregister = _ShapeFix.ShapeFix_WireVertex_swigregister
ShapeFix_WireVertex_swigregister(ShapeFix_WireVertex)

class NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,Bnd_Box2d,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _ShapeFix.NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,Bnd_Box2d,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _ShapeFix.NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,Bnd_Box2d,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _ShapeFix.NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,Bnd_Box2d,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _ShapeFix.NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _ShapeFix.new_NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _ShapeFix.NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _ShapeFix.NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _ShapeFix.NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _ShapeFix.NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, Bnd_Box2d theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, Bnd_Box2d theItem) -> Bnd_Box2d

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _ShapeFix.NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Bnd_Box2d

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _ShapeFix.NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _ShapeFix.NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Bnd_Box2d

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _ShapeFix.NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Bnd_Box2d

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _ShapeFix.NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _ShapeFix.NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _ShapeFix.NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _ShapeFix.NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _ShapeFix.delete_NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher_swigregister = _ShapeFix.NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _ShapeFix.new_NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ShapeFix.delete_NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _ShapeFix.NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _ShapeFix.NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher_IteratorHelper)


try:
	ShapeFix_DataMapOfShapeBox2d = NCollection_DataMap_TopoDS_Shape_Bnd_Box2d_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_ShapeFix_Shell(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeFix_Shell self)

        Nullify the handle


        """
        return _ShapeFix.Handle_ShapeFix_Shell_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeFix_Shell self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeFix.Handle_ShapeFix_Shell_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeFix_Shell self, ShapeFix_Shell thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeFix.Handle_ShapeFix_Shell_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeFix_Shell self, Handle_ShapeFix_Shell theHandle) -> Handle_ShapeFix_Shell
        assign(Handle_ShapeFix_Shell self, ShapeFix_Shell thePtr) -> Handle_ShapeFix_Shell
        assign(Handle_ShapeFix_Shell self, Handle_ShapeFix_Shell theHandle) -> Handle_ShapeFix_Shell

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeFix.Handle_ShapeFix_Shell_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeFix_Shell self) -> ShapeFix_Shell

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeFix.Handle_ShapeFix_Shell_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeFix_Shell self) -> ShapeFix_Shell

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeFix.Handle_ShapeFix_Shell___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeFix_Shell self) -> ShapeFix_Shell

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeFix.Handle_ShapeFix_Shell___ref__(self, *args)


    def __hash__(self):
        return _ShapeFix.Handle_ShapeFix_Shell___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeFix.Handle_ShapeFix_Shell___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeFix.new_Handle_ShapeFix_Shell(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeFix.Handle_ShapeFix_Shell_DownCast)
    __swig_destroy__ = _ShapeFix.delete_Handle_ShapeFix_Shell

    def Init(self, *args):
        """
        Init(Handle_ShapeFix_Shell self, TopoDS_Shell shell)

        Initializes by shell.

        :type shell: OCC.wrapper.TopoDS.TopoDS_Shell

        """
        return _ShapeFix.Handle_ShapeFix_Shell_Init(self, *args)


    def Perform(self, *args):
        """
        Perform(Handle_ShapeFix_Shell self, Handle_Message_ProgressIndicator theProgress=0) -> Standard_Boolean

        Iterates on subshapes and performs fixes
        (for each face calls ShapeFix_Face::Perform and
        then calls FixFaceOrientation). The passed progress
        indicator allows user to consult the current progress
        stage and abort algorithm if needed.

        :type theProgress: OCC.wrapper.Message.Handle_Message_ProgressIndicator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Shell_Perform(self, *args)


    def FixFaceOrientation(self, *args):
        """
        FixFaceOrientation(Handle_ShapeFix_Shell self, TopoDS_Shell shell, Standard_Boolean const isAccountMultiConex, Standard_Boolean const NonManifold) -> Standard_Boolean

        Fixes orientation of faces in shell.
        Changes orientation of face in the shell, if it is oriented opposite
        to neigbouring faces. If it is not possible to orient all faces in the
        shell (like in case of mebious band), this method orients only subset
        of faces. Other faces are stored in Error compound.
        Modes :
        isAccountMultiConex - mode for account cases of multiconnexity.
        If this mode is equal to Standard_True, separate shells will be created
        in the cases of multiconnexity. If this mode is equal to Standard_False,
        one shell will be created without account of multiconnexity.By defautt - Standard_True;
        NonManifold - mode for creation of non-manifold shells.
        If this mode is equal to Standard_True one non-manifold will be created from shell
        contains multishared edges. Else if this mode is equal to Standard_False only
        manifold shells will be created. By default - Standard_False.

        :type shell: OCC.wrapper.TopoDS.TopoDS_Shell
        :type isAccountMultiConex: bool
        :type NonManifold: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Shell_FixFaceOrientation(self, *args)


    def Shell(self, *args):
        """
        Shell(Handle_ShapeFix_Shell self) -> TopoDS_Shell

        Returns fixed shell (or subset of oriented faces).

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shell

        """
        return _ShapeFix.Handle_ShapeFix_Shell_Shell(self, *args)


    def Shape(self, *args):
        """
        Shape(Handle_ShapeFix_Shell self) -> TopoDS_Shape

        In case of multiconnexity returns compound of fixed shells
        else returns one shell..

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.Handle_ShapeFix_Shell_Shape(self, *args)


    def NbShells(self, *args):
        """
        NbShells(Handle_ShapeFix_Shell self) -> Standard_Integer

        Returns Number of obtainrd shells;

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Shell_NbShells(self, *args)


    def ErrorFaces(self, *args):
        """
        ErrorFaces(Handle_ShapeFix_Shell self) -> TopoDS_Compound

        Returns not oriented subset of faces.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Compound

        """
        return _ShapeFix.Handle_ShapeFix_Shell_ErrorFaces(self, *args)


    def Status(self, *args):
        """
        Status(Handle_ShapeFix_Shell self, ShapeExtend_Status const status) -> Standard_Boolean

        Returns the status of the last Fix.

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Shell_Status(self, *args)


    def FixFaceTool(self, *args):
        """
        FixFaceTool(Handle_ShapeFix_Shell self) -> Handle_ShapeFix_Face

        Returns tool for fixing faces.

        :rtype: OCC.wrapper.ShapeFix.Handle_ShapeFix_Face

        """
        return _ShapeFix.Handle_ShapeFix_Shell_FixFaceTool(self, *args)


    def SetMsgRegistrator(self, *args):
        """
        SetMsgRegistrator(Handle_ShapeFix_Shell self, Handle_ShapeExtend_BasicMsgRegistrator msgreg)

        Sets message registrator

        :type msgreg: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeFix.Handle_ShapeFix_Shell_SetMsgRegistrator(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(Handle_ShapeFix_Shell self, Standard_Real const preci)

        Sets basic precision value (also to FixWireTool)

        :type preci: float

        """
        return _ShapeFix.Handle_ShapeFix_Shell_SetPrecision(self, *args)


    def SetMinTolerance(self, *args):
        """
        SetMinTolerance(Handle_ShapeFix_Shell self, Standard_Real const mintol)

        Sets minimal allowed tolerance (also to FixWireTool)

        :type mintol: float

        """
        return _ShapeFix.Handle_ShapeFix_Shell_SetMinTolerance(self, *args)


    def SetMaxTolerance(self, *args):
        """
        SetMaxTolerance(Handle_ShapeFix_Shell self, Standard_Real const maxtol)

        Sets maximal allowed tolerance (also to FixWireTool)

        :type maxtol: float

        """
        return _ShapeFix.Handle_ShapeFix_Shell_SetMaxTolerance(self, *args)


    def FixFaceMode(self, *args):
        """
        FixFaceMode(Handle_ShapeFix_Shell self) -> Standard_Integer &

        Returns (modifiable) the mode for applying fixes of
        ShapeFix_Face, by default True.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Shell_FixFaceMode(self, *args)


    def FixOrientationMode(self, *args):
        """
        FixOrientationMode(Handle_ShapeFix_Shell self) -> Standard_Integer &

        Returns (modifiable) the mode for applying
        FixFaceOrientation, by default True.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Shell_FixOrientationMode(self, *args)


    def SetNonManifoldFlag(self, *args):
        """
        SetNonManifoldFlag(Handle_ShapeFix_Shell self, Standard_Boolean const isNonManifold)

        Sets NonManifold flag

        :type isNonManifold: bool

        """
        return _ShapeFix.Handle_ShapeFix_Shell_SetNonManifoldFlag(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeFix_Shell self) -> char const *

        :rtype: const char *

        """
        return _ShapeFix.Handle_ShapeFix_Shell_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.Handle_ShapeFix_Shell_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.Handle_ShapeFix_Shell_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_ShapeFix_Shell self, Handle_ShapeFix_Root Root)

        Copy all fields from another Root object

        :type Root: OCC.wrapper.ShapeFix.Handle_ShapeFix_Root

        """
        return _ShapeFix.Handle_ShapeFix_Shell_Set(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_ShapeFix_Shell self, Handle_ShapeBuild_ReShape context)

        Sets context

        :type context: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeFix.Handle_ShapeFix_Shell_SetContext(self, *args)


    def Context(self, *args):
        """
        Context(Handle_ShapeFix_Shell self) -> Handle_ShapeBuild_ReShape

        Returns context

        :rtype: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeFix.Handle_ShapeFix_Shell_Context(self, *args)


    def MsgRegistrator(self, *args):
        """
        MsgRegistrator(Handle_ShapeFix_Shell self) -> Handle_ShapeExtend_BasicMsgRegistrator

        Returns message registrator

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeFix.Handle_ShapeFix_Shell_MsgRegistrator(self, *args)


    def Precision(self, *args):
        """
        Precision(Handle_ShapeFix_Shell self) -> Standard_Real

        Returns basic precision value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_Shell_Precision(self, *args)


    def MinTolerance(self, *args):
        """
        MinTolerance(Handle_ShapeFix_Shell self) -> Standard_Real

        Returns minimal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_Shell_MinTolerance(self, *args)


    def MaxTolerance(self, *args):
        """
        MaxTolerance(Handle_ShapeFix_Shell self) -> Standard_Real

        Returns maximal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_Shell_MaxTolerance(self, *args)


    def LimitTolerance(self, *args):
        """
        LimitTolerance(Handle_ShapeFix_Shell self, Standard_Real const toler) -> Standard_Real

        Returns tolerance limited by [myMinTol,myMaxTol]

        :type toler: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_Shell_LimitTolerance(self, *args)


    def SendMsg(self, *args):
        """
        SendMsg(Handle_ShapeFix_Shell self, TopoDS_Shape shape, Message_Msg message, Message_Gravity const gravity=Message_Info)
        SendMsg(Handle_ShapeFix_Shell self, Message_Msg message, Message_Gravity const gravity=Message_Info)

        Sends a message to be attached to myShape.
        Calls previous method.

        :type message: OCC.wrapper.Message.Message_Msg
        :type gravity: OCC.wrapper.Message.Message_Gravity

        """
        return _ShapeFix.Handle_ShapeFix_Shell_SendMsg(self, *args)


    def SendWarning(self, *args):
        """
        SendWarning(Handle_ShapeFix_Shell self, TopoDS_Shape shape, Message_Msg message)
        SendWarning(Handle_ShapeFix_Shell self, Message_Msg message)

        Calls previous method for myShape.

        :type message: OCC.wrapper.Message.Message_Msg

        """
        return _ShapeFix.Handle_ShapeFix_Shell_SendWarning(self, *args)


    def SendFail(self, *args):
        """
        SendFail(Handle_ShapeFix_Shell self, TopoDS_Shape shape, Message_Msg message)
        SendFail(Handle_ShapeFix_Shell self, Message_Msg message)

        Calls previous method for myShape.

        :type message: OCC.wrapper.Message.Message_Msg

        """
        return _ShapeFix.Handle_ShapeFix_Shell_SendFail(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeFix_Shell self)

        Memory deallocator for transient classes


        """
        return _ShapeFix.Handle_ShapeFix_Shell_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeFix_Shell self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeFix_Shell self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Shell_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeFix_Shell self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeFix_Shell self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Shell_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeFix_Shell self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeFix.Handle_ShapeFix_Shell_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeFix_Shell self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Shell_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeFix_Shell self)

        Increments the reference counter of this object


        """
        return _ShapeFix.Handle_ShapeFix_Shell_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeFix_Shell self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Shell_DecrementRefCounter(self, *args)

Handle_ShapeFix_Shell_swigregister = _ShapeFix.Handle_ShapeFix_Shell_swigregister
Handle_ShapeFix_Shell_swigregister(Handle_ShapeFix_Shell)

def Handle_ShapeFix_Shell_DownCast(thing):
    return _ShapeFix.Handle_ShapeFix_Shell_DownCast(thing)
Handle_ShapeFix_Shell_DownCast = _ShapeFix.Handle_ShapeFix_Shell_DownCast

class Handle_ShapeFix_ComposeShell(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeFix_ComposeShell self)

        Nullify the handle


        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeFix_ComposeShell self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeFix_ComposeShell self, ShapeFix_ComposeShell thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeFix_ComposeShell self, Handle_ShapeFix_ComposeShell theHandle) -> Handle_ShapeFix_ComposeShell
        assign(Handle_ShapeFix_ComposeShell self, ShapeFix_ComposeShell thePtr) -> Handle_ShapeFix_ComposeShell
        assign(Handle_ShapeFix_ComposeShell self, Handle_ShapeFix_ComposeShell theHandle) -> Handle_ShapeFix_ComposeShell

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeFix_ComposeShell self) -> ShapeFix_ComposeShell

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeFix_ComposeShell self) -> ShapeFix_ComposeShell

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeFix_ComposeShell self) -> ShapeFix_ComposeShell

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell___ref__(self, *args)


    def __hash__(self):
        return _ShapeFix.Handle_ShapeFix_ComposeShell___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeFix.Handle_ShapeFix_ComposeShell___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeFix.new_Handle_ShapeFix_ComposeShell(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeFix.Handle_ShapeFix_ComposeShell_DownCast)
    __swig_destroy__ = _ShapeFix.delete_Handle_ShapeFix_ComposeShell

    def Init(self, *args):
        """
        Init(Handle_ShapeFix_ComposeShell self, Handle_ShapeExtend_CompositeSurface Grid, TopLoc_Location L, TopoDS_Face Face, Standard_Real const Prec)

        Initializes with composite surface, face and precision.
        Here face defines both set of wires and way of getting
        pcurves. Precision is used (together with tolerance of edges)
        for handling subtle cases, such as tangential intersections.

        :type Grid: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_CompositeSurface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Face: OCC.wrapper.TopoDS.TopoDS_Face
        :type Prec: float

        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_Init(self, *args)


    def ClosedMode(self, *args):
        """
        ClosedMode(Handle_ShapeFix_ComposeShell self) -> Standard_Boolean &

        Returns (modifiable) flag for special 'closed'
        mode which forces ComposeShell to consider
        all pcurves on closed surface as modulo period.
        This can reduce reliability, but allows to deal
        with wires closed in 3d but open in 2d (missing seam)
        Default is False

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_ClosedMode(self, *args)


    def Perform(self, *args):
        """
        Perform(Handle_ShapeFix_ComposeShell self) -> Standard_Boolean

        Performs the work on already loaded data.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_Perform(self, *args)


    def SplitEdges(self, *args):
        """
        SplitEdges(Handle_ShapeFix_ComposeShell self)

        Splits edges in the original shape by grid.
        This is a part of Perform() which does not produce any
        resulting shape; the only result is filled context
        where splittings are recorded.

        NOTE: If edge is splitted, it is replaced by wire, and
        order of edges in the wire corresponds to FORWARD orientation
        of the edge.


        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_SplitEdges(self, *args)


    def Result(self, *args):
        """
        Returns resulting shell or face (or Null shape if not done)

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _ShapeFix.Handle_ShapeFix_ComposeShell_Result(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Status(self, *args):
        """
        Status(Handle_ShapeFix_ComposeShell self, ShapeExtend_Status const status) -> Standard_Boolean

        Queries status of last call to Perform()
        OK   : nothing done (some kind of error)
        DONE1: splitting is done, at least one new face created
        DONE2: splitting is done, several new faces obtained
        FAIL1: misoriented wire encountered (handled)
        FAIL2: recoverable parity error
        FAIL3: edge with no pcurve on supporting face
        FAIL4: unrecoverable algorithm error (parity check)

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_Status(self, *args)


    def DispatchWires(self, *args):
        """
        DispatchWires(Handle_ShapeFix_ComposeShell self, NCollection_Sequence_TopoDS_Shape faces, NCollection_Sequence_ShapeFix_WireSegment wires)

        Creates new faces from the set of (closed) wires. Each wire
        is put on corresponding patch in the composite surface,
        and all pcurves on the initial (pseudo)face are reassigned to
        that surface. If several wires are one inside another, single
        face is created.

        :type faces: OCC.wrapper.TopTools.TopTools_SequenceOfShape
        :type wires: OCC.wrapper.ShapeFix.ShapeFix_SequenceOfWireSegment

        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_DispatchWires(self, *args)


    def SetTransferParamTool(self, *args):
        """
        SetTransferParamTool(Handle_ShapeFix_ComposeShell self, Handle_ShapeAnalysis_TransferParameters TransferParam)

        Sets tool for transfer parameters from 3d to 2d and vice versa.

        :type TransferParam: OCC.wrapper.ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters

        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_SetTransferParamTool(self, *args)


    def GetTransferParamTool(self, *args):
        """
        GetTransferParamTool(Handle_ShapeFix_ComposeShell self) -> Handle_ShapeAnalysis_TransferParameters

        Gets tool for transfer parameters from 3d to 2d and vice versa.

        :rtype: OCC.wrapper.ShapeAnalysis.Handle_ShapeAnalysis_TransferParameters

        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_GetTransferParamTool(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeFix_ComposeShell self) -> char const *

        :rtype: const char *

        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.Handle_ShapeFix_ComposeShell_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.Handle_ShapeFix_ComposeShell_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_ShapeFix_ComposeShell self, Handle_ShapeFix_Root Root)

        Copy all fields from another Root object

        :type Root: OCC.wrapper.ShapeFix.Handle_ShapeFix_Root

        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_Set(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_ShapeFix_ComposeShell self, Handle_ShapeBuild_ReShape context)

        Sets context

        :type context: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_SetContext(self, *args)


    def Context(self, *args):
        """
        Context(Handle_ShapeFix_ComposeShell self) -> Handle_ShapeBuild_ReShape

        Returns context

        :rtype: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_Context(self, *args)


    def SetMsgRegistrator(self, *args):
        """
        SetMsgRegistrator(Handle_ShapeFix_ComposeShell self, Handle_ShapeExtend_BasicMsgRegistrator msgreg)

        Sets message registrator

        :type msgreg: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_SetMsgRegistrator(self, *args)


    def MsgRegistrator(self, *args):
        """
        MsgRegistrator(Handle_ShapeFix_ComposeShell self) -> Handle_ShapeExtend_BasicMsgRegistrator

        Returns message registrator

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_MsgRegistrator(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(Handle_ShapeFix_ComposeShell self, Standard_Real const preci)

        Sets basic precision value

        :type preci: float

        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_SetPrecision(self, *args)


    def Precision(self, *args):
        """
        Precision(Handle_ShapeFix_ComposeShell self) -> Standard_Real

        Returns basic precision value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_Precision(self, *args)


    def SetMinTolerance(self, *args):
        """
        SetMinTolerance(Handle_ShapeFix_ComposeShell self, Standard_Real const mintol)

        Sets minimal allowed tolerance

        :type mintol: float

        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_SetMinTolerance(self, *args)


    def MinTolerance(self, *args):
        """
        MinTolerance(Handle_ShapeFix_ComposeShell self) -> Standard_Real

        Returns minimal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_MinTolerance(self, *args)


    def SetMaxTolerance(self, *args):
        """
        SetMaxTolerance(Handle_ShapeFix_ComposeShell self, Standard_Real const maxtol)

        Sets maximal allowed tolerance

        :type maxtol: float

        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_SetMaxTolerance(self, *args)


    def MaxTolerance(self, *args):
        """
        MaxTolerance(Handle_ShapeFix_ComposeShell self) -> Standard_Real

        Returns maximal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_MaxTolerance(self, *args)


    def LimitTolerance(self, *args):
        """
        LimitTolerance(Handle_ShapeFix_ComposeShell self, Standard_Real const toler) -> Standard_Real

        Returns tolerance limited by [myMinTol,myMaxTol]

        :type toler: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_LimitTolerance(self, *args)


    def SendMsg(self, *args):
        """
        SendMsg(Handle_ShapeFix_ComposeShell self, TopoDS_Shape shape, Message_Msg message, Message_Gravity const gravity=Message_Info)
        SendMsg(Handle_ShapeFix_ComposeShell self, Message_Msg message, Message_Gravity const gravity=Message_Info)

        Sends a message to be attached to myShape.
        Calls previous method.

        :type message: OCC.wrapper.Message.Message_Msg
        :type gravity: OCC.wrapper.Message.Message_Gravity

        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_SendMsg(self, *args)


    def SendWarning(self, *args):
        """
        SendWarning(Handle_ShapeFix_ComposeShell self, TopoDS_Shape shape, Message_Msg message)
        SendWarning(Handle_ShapeFix_ComposeShell self, Message_Msg message)

        Calls previous method for myShape.

        :type message: OCC.wrapper.Message.Message_Msg

        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_SendWarning(self, *args)


    def SendFail(self, *args):
        """
        SendFail(Handle_ShapeFix_ComposeShell self, TopoDS_Shape shape, Message_Msg message)
        SendFail(Handle_ShapeFix_ComposeShell self, Message_Msg message)

        Calls previous method for myShape.

        :type message: OCC.wrapper.Message.Message_Msg

        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_SendFail(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeFix_ComposeShell self)

        Memory deallocator for transient classes


        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeFix_ComposeShell self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeFix_ComposeShell self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeFix_ComposeShell self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeFix_ComposeShell self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeFix_ComposeShell self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeFix_ComposeShell self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeFix_ComposeShell self)

        Increments the reference counter of this object


        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeFix_ComposeShell self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_ComposeShell_DecrementRefCounter(self, *args)

Handle_ShapeFix_ComposeShell_swigregister = _ShapeFix.Handle_ShapeFix_ComposeShell_swigregister
Handle_ShapeFix_ComposeShell_swigregister(Handle_ShapeFix_ComposeShell)

def Handle_ShapeFix_ComposeShell_DownCast(thing):
    return _ShapeFix.Handle_ShapeFix_ComposeShell_DownCast(thing)
Handle_ShapeFix_ComposeShell_DownCast = _ShapeFix.Handle_ShapeFix_ComposeShell_DownCast

class Handle_ShapeFix_Wire(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeFix_Wire self)

        Nullify the handle


        """
        return _ShapeFix.Handle_ShapeFix_Wire_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeFix_Wire self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeFix.Handle_ShapeFix_Wire_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeFix_Wire self, ShapeFix_Wire thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeFix.Handle_ShapeFix_Wire_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeFix_Wire self, Handle_ShapeFix_Wire theHandle) -> Handle_ShapeFix_Wire
        assign(Handle_ShapeFix_Wire self, ShapeFix_Wire thePtr) -> Handle_ShapeFix_Wire
        assign(Handle_ShapeFix_Wire self, Handle_ShapeFix_Wire theHandle) -> Handle_ShapeFix_Wire

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeFix.Handle_ShapeFix_Wire_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeFix_Wire self) -> ShapeFix_Wire

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeFix.Handle_ShapeFix_Wire_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeFix_Wire self) -> ShapeFix_Wire

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeFix.Handle_ShapeFix_Wire___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeFix_Wire self) -> ShapeFix_Wire

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeFix.Handle_ShapeFix_Wire___ref__(self, *args)


    def __hash__(self):
        return _ShapeFix.Handle_ShapeFix_Wire___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeFix.Handle_ShapeFix_Wire___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeFix.new_Handle_ShapeFix_Wire(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeFix.Handle_ShapeFix_Wire_DownCast)
    __swig_destroy__ = _ShapeFix.delete_Handle_ShapeFix_Wire

    def ClearModes(self, *args):
        """
        ClearModes(Handle_ShapeFix_Wire self)

        Sets all modes to default


        """
        return _ShapeFix.Handle_ShapeFix_Wire_ClearModes(self, *args)


    def ClearStatuses(self, *args):
        """
        ClearStatuses(Handle_ShapeFix_Wire self)

        Clears all statuses


        """
        return _ShapeFix.Handle_ShapeFix_Wire_ClearStatuses(self, *args)


    def Init(self, *args):
        """
        Init(Handle_ShapeFix_Wire self, TopoDS_Wire wire, TopoDS_Face face, Standard_Real const prec)
        Init(Handle_ShapeFix_Wire self, Handle_ShapeAnalysis_Wire saw)

        Load analyzer with all the data already prepared
        and drops all fixing statuses
        If analyzer contains face, there is no need to set it
        by SetFace or SetSurface

        :type saw: OCC.wrapper.ShapeAnalysis.Handle_ShapeAnalysis_Wire

        """
        return _ShapeFix.Handle_ShapeFix_Wire_Init(self, *args)


    def Load(self, *args):
        """
        Load(Handle_ShapeFix_Wire self, TopoDS_Wire wire)
        Load(Handle_ShapeFix_Wire self, Handle_ShapeExtend_WireData sbwd)

        Load data for the wire, and drops all fixing statuses

        :type sbwd: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_WireData

        """
        return _ShapeFix.Handle_ShapeFix_Wire_Load(self, *args)


    def SetFace(self, *args):
        """
        SetFace(Handle_ShapeFix_Wire self, TopoDS_Face face)

        Set working face for the wire

        :type face: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _ShapeFix.Handle_ShapeFix_Wire_SetFace(self, *args)


    def SetSurface(self, *args):
        """
        SetSurface(Handle_ShapeFix_Wire self, Handle_Geom_Surface surf)
        SetSurface(Handle_ShapeFix_Wire self, Handle_Geom_Surface surf, TopLoc_Location loc)

        Set surface for the wire

        :type surf: OCC.wrapper.Geom.Handle_Geom_Surface
        :type loc: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _ShapeFix.Handle_ShapeFix_Wire_SetSurface(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(Handle_ShapeFix_Wire self, Standard_Real const prec)

        Set working precision (to root and to analyzer)

        :type prec: float

        """
        return _ShapeFix.Handle_ShapeFix_Wire_SetPrecision(self, *args)


    def SetMaxTailAngle(self, *args):
        """
        SetMaxTailAngle(Handle_ShapeFix_Wire self, Standard_Real const theMaxTailAngle)

        Sets the maximal allowed angle of the tails in radians.

        :type theMaxTailAngle: float

        """
        return _ShapeFix.Handle_ShapeFix_Wire_SetMaxTailAngle(self, *args)


    def SetMaxTailWidth(self, *args):
        """
        SetMaxTailWidth(Handle_ShapeFix_Wire self, Standard_Real const theMaxTailWidth)

        Sets the maximal allowed width of the tails.

        :type theMaxTailWidth: float

        """
        return _ShapeFix.Handle_ShapeFix_Wire_SetMaxTailWidth(self, *args)


    def IsLoaded(self, *args):
        """
        IsLoaded(Handle_ShapeFix_Wire self) -> Standard_Boolean

        Tells if the wire is loaded

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_IsLoaded(self, *args)


    def IsReady(self, *args):
        """
        IsReady(Handle_ShapeFix_Wire self) -> Standard_Boolean

        Tells if the wire and face are loaded

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_IsReady(self, *args)


    def NbEdges(self, *args):
        """
        NbEdges(Handle_ShapeFix_Wire self) -> Standard_Integer

        returns number of edges in the working wire

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Wire_NbEdges(self, *args)


    def Wire(self, *args):
        """
        Wire(Handle_ShapeFix_Wire self) -> TopoDS_Wire

        Makes the resulting Wire (by basic Brep_Builder)

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _ShapeFix.Handle_ShapeFix_Wire_Wire(self, *args)


    def WireAPIMake(self, *args):
        """
        WireAPIMake(Handle_ShapeFix_Wire self) -> TopoDS_Wire

        Makes the resulting Wire (by BRepAPI_MakeWire)

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _ShapeFix.Handle_ShapeFix_Wire_WireAPIMake(self, *args)


    def Analyzer(self, *args):
        """
        Analyzer(Handle_ShapeFix_Wire self) -> Handle_ShapeAnalysis_Wire

        returns field Analyzer (working tool)

        :rtype: OCC.wrapper.ShapeAnalysis.Handle_ShapeAnalysis_Wire

        """
        return _ShapeFix.Handle_ShapeFix_Wire_Analyzer(self, *args)


    def WireData(self, *args):
        """
        returns working wire

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_WireData

        """
        res = _ShapeFix.Handle_ShapeFix_Wire_WireData(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Face(self, *args):
        """
        returns working face (Analyzer.Face())

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        res = _ShapeFix.Handle_ShapeFix_Wire_Face(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ModifyTopologyMode(self, *args):
        """
        ModifyTopologyMode(Handle_ShapeFix_Wire self) -> Standard_Boolean &

        Returns (modifiable) the flag which defines whether it is
        allowed to modify topology of the wire during fixing
        (adding/removing edges etc.)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_ModifyTopologyMode(self, *args)


    def ModifyGeometryMode(self, *args):
        """
        ModifyGeometryMode(Handle_ShapeFix_Wire self) -> Standard_Boolean &

        Returns (modifiable) the flag which defines whether the Fix..()
        methods are allowed to modify geometry of the edges and vertices

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_ModifyGeometryMode(self, *args)


    def ModifyRemoveLoopMode(self, *args):
        """
        ModifyRemoveLoopMode(Handle_ShapeFix_Wire self) -> Standard_Integer &

        Returns (modifiable) the flag which defines whether the Fix..()
        methods are allowed to modify RemoveLoop of the edges

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Wire_ModifyRemoveLoopMode(self, *args)


    def ClosedWireMode(self, *args):
        """
        ClosedWireMode(Handle_ShapeFix_Wire self) -> Standard_Boolean &

        Returns (modifiable) the flag which defines whether the wire
        is to be closed (by calling methods like FixDegenerated()
        and FixConnected() for last and first edges).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_ClosedWireMode(self, *args)


    def PreferencePCurveMode(self, *args):
        """
        PreferencePCurveMode(Handle_ShapeFix_Wire self) -> Standard_Boolean &

        Returns (modifiable) the flag which defines whether the 2d (True)
        representation of the wire is preferable over 3d one (in the
        case of ambiguity in FixEdgeCurves).

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_PreferencePCurveMode(self, *args)


    def FixGapsByRangesMode(self, *args):
        """
        FixGapsByRangesMode(Handle_ShapeFix_Wire self) -> Standard_Boolean &

        Returns (modifiable) the flag which defines whether tool
        tries to fix gaps first by changing curves ranges (i.e.
        using intersection, extrema, projections) or not.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixGapsByRangesMode(self, *args)


    def FixReorderMode(self, *args):
        """
        FixReorderMode(Handle_ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixReorderMode(self, *args)


    def FixSmallMode(self, *args):
        """
        FixSmallMode(Handle_ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixSmallMode(self, *args)


    def FixConnectedMode(self, *args):
        """
        FixConnectedMode(Handle_ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixConnectedMode(self, *args)


    def FixEdgeCurvesMode(self, *args):
        """
        FixEdgeCurvesMode(Handle_ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixEdgeCurvesMode(self, *args)


    def FixDegeneratedMode(self, *args):
        """
        FixDegeneratedMode(Handle_ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixDegeneratedMode(self, *args)


    def FixSelfIntersectionMode(self, *args):
        """
        FixSelfIntersectionMode(Handle_ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixSelfIntersectionMode(self, *args)


    def FixLackingMode(self, *args):
        """
        FixLackingMode(Handle_ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixLackingMode(self, *args)


    def FixGaps3dMode(self, *args):
        """
        FixGaps3dMode(Handle_ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixGaps3dMode(self, *args)


    def FixGaps2dMode(self, *args):
        """
        FixGaps2dMode(Handle_ShapeFix_Wire self) -> Standard_Integer &

        Returns (modifiable) the flag for corresponding Fix..() method
        which defines whether this method will be called from the
        method APIFix():
        -1 default
        1 method will be called
        0 method will not be called

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixGaps2dMode(self, *args)


    def FixReversed2dMode(self, *args):
        """
        FixReversed2dMode(Handle_ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixReversed2dMode(self, *args)


    def FixRemovePCurveMode(self, *args):
        """
        FixRemovePCurveMode(Handle_ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixRemovePCurveMode(self, *args)


    def FixAddPCurveMode(self, *args):
        """
        FixAddPCurveMode(Handle_ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixAddPCurveMode(self, *args)


    def FixRemoveCurve3dMode(self, *args):
        """
        FixRemoveCurve3dMode(Handle_ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixRemoveCurve3dMode(self, *args)


    def FixAddCurve3dMode(self, *args):
        """
        FixAddCurve3dMode(Handle_ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixAddCurve3dMode(self, *args)


    def FixSeamMode(self, *args):
        """
        FixSeamMode(Handle_ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixSeamMode(self, *args)


    def FixShiftedMode(self, *args):
        """
        FixShiftedMode(Handle_ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixShiftedMode(self, *args)


    def FixSameParameterMode(self, *args):
        """
        FixSameParameterMode(Handle_ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixSameParameterMode(self, *args)


    def FixVertexToleranceMode(self, *args):
        """
        FixVertexToleranceMode(Handle_ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixVertexToleranceMode(self, *args)


    def FixNotchedEdgesMode(self, *args):
        """
        FixNotchedEdgesMode(Handle_ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixNotchedEdgesMode(self, *args)


    def FixSelfIntersectingEdgeMode(self, *args):
        """
        FixSelfIntersectingEdgeMode(Handle_ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixSelfIntersectingEdgeMode(self, *args)


    def FixIntersectingEdgesMode(self, *args):
        """
        FixIntersectingEdgesMode(Handle_ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixIntersectingEdgesMode(self, *args)


    def FixNonAdjacentIntersectingEdgesMode(self, *args):
        """
        FixNonAdjacentIntersectingEdgesMode(Handle_ShapeFix_Wire self) -> Standard_Integer &

        Returns (modifiable) the flag for corresponding Fix..() method
        which defines whether this method will be called from the
        corresponding Fix..() method of the public level:
        -1 default
        1 method will be called
        0 method will not be called

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixNonAdjacentIntersectingEdgesMode(self, *args)


    def FixTailMode(self, *args):
        """
        FixTailMode(Handle_ShapeFix_Wire self) -> Standard_Integer &

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixTailMode(self, *args)


    def Perform(self, *args):
        """
        Perform(Handle_ShapeFix_Wire self) -> Standard_Boolean

        This method performs all the available fixes.
        If some fix is turned on or off explicitly by the Fix..Mode() flag,
        this fix is either called or not depending on that flag.
        Else (i.e. if flag is default) fix is called depending on the
        situation: some fixes are not called or are limited if order of
        edges in the wire is not OK, or depending on modes

        The order of the fixes and default behaviour of Perform() are:
        FixReorder
        FixSmall (with lockvtx true if ! TopoMode or if wire is not ordered)
        FixConnected (if wire is ordered)
        FixEdgeCurves (without FixShifted if wire is not ordered)
        FixDegenerated (if wire is ordered)
        FixSelfIntersection (if wire is ordered and ClosedMode is True)
        FixLacking (if wire is ordered)

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_Perform(self, *args)


    def FixReorder(self, *args):
        """
        FixReorder(Handle_ShapeFix_Wire self) -> Standard_Boolean
        FixReorder(Handle_ShapeFix_Wire self, ShapeAnalysis_WireOrder wi) -> Standard_Boolean

        Reorder edges in the wire as determined by WireOrder
        that should be filled and computed before

        :type wi: OCC.wrapper.ShapeAnalysis.ShapeAnalysis_WireOrder
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixReorder(self, *args)


    def FixSmall(self, *args):
        """
        FixSmall(Handle_ShapeFix_Wire self, Standard_Boolean const lockvtx, Standard_Real const precsmall=0.0) -> Standard_Integer
        FixSmall(Handle_ShapeFix_Wire self, Standard_Integer const num, Standard_Boolean const lockvtx, Standard_Real const precsmall) -> Standard_Boolean

        Fixes Null Length Edge to be removed
        If an Edge has Null Length (regarding preci, or <precsmall>
        - what is smaller), it should be removed
        It can be with no problem if its two vertices are the same
        Else, if lockvtx is False, it is removed and its end vertex
        is put on the preceeding edge
        But if lockvtx is True, this edge must be kept ...

        :type num: int
        :type lockvtx: bool
        :type precsmall: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixSmall(self, *args)


    def FixConnected(self, *args):
        """
        FixConnected(Handle_ShapeFix_Wire self, Standard_Real const prec=-1.0) -> Standard_Boolean
        FixConnected(Handle_ShapeFix_Wire self, Standard_Integer const num, Standard_Real const prec) -> Standard_Boolean

        Fixes connected edges (preceeding and current)
        Forces Vertices (end of preceeding-begin of current) to be
        the same one
        Tests with starting preci or, if given greater, <prec>
        If <prec> is -1 then MaxTolerance() is taken.

        :type num: int
        :type prec: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixConnected(self, *args)


    def FixEdgeCurves(self, *args):
        """
        FixEdgeCurves(Handle_ShapeFix_Wire self) -> Standard_Boolean

        Groups the fixes dealing with 3d and pcurves of the edges.
        The order of the fixes and the default behaviour are:
        ShapeFix_Edge::FixReversed2d
        ShapeFix_Edge::FixRemovePCurve (only if forced)
        ShapeFix_Edge::FixAddPCurve
        ShapeFix_Edge::FixRemoveCurve3d (only if forced)
        ShapeFix_Edge::FixAddCurve3d
        FixSeam,
        FixShifted,
        ShapeFix_Edge::FixSameParameter

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixEdgeCurves(self, *args)


    def FixDegenerated(self, *args):
        """
        FixDegenerated(Handle_ShapeFix_Wire self) -> Standard_Boolean
        FixDegenerated(Handle_ShapeFix_Wire self, Standard_Integer const num) -> Standard_Boolean

        Fixes Degenerated Edge
        Checks an <num-th> edge or a point between <num>th-1 and <num>th
        edges for a singularity on a supporting surface.
        If singularity is detected, either adds new degenerated edge
        (before <num>th), or makes <num>th edge to be degenerated.

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixDegenerated(self, *args)


    def FixSelfIntersection(self, *args):
        """
        FixSelfIntersection(Handle_ShapeFix_Wire self) -> Standard_Boolean

        Applies FixSelfIntersectingEdge(num) and
        FixIntersectingEdges(num) to all edges in the wire and
        FixIntersectingEdges(num1, num2) for all pairs num1 and num2
        such that num2 >= num1 + 2
        and removes wrong edges if any

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixSelfIntersection(self, *args)


    def FixLacking(self, *args):
        """
        FixLacking(Handle_ShapeFix_Wire self, Standard_Boolean const force) -> Standard_Boolean
        FixLacking(Handle_ShapeFix_Wire self, Standard_Integer const num, Standard_Boolean const force) -> Standard_Boolean

        Fixes Lacking Edge
        Test if two adjucent edges are disconnected in 2d (while
        connected in 3d), and in that case either increase tolerance
        of the vertex or add a new edge (straight in 2d space), in
        order to close wire in 2d.
        Returns True if edge was added or tolerance was increased.

        :type num: int
        :type force: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixLacking(self, *args)


    def FixClosed(self, *args):
        """
        FixClosed(Handle_ShapeFix_Wire self, Standard_Real const prec=-1.0) -> Standard_Boolean

        Fixes a wire to be well closed
        It performs FixConnected, FixDegenerated and FixLacking between
        last and first edges (independingly on flag ClosedMode and modes
        for these fixings)
        If <prec> is -1 then MaxTolerance() is taken.

        :type prec: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixClosed(self, *args)


    def FixGaps3d(self, *args):
        """
        FixGaps3d(Handle_ShapeFix_Wire self) -> Standard_Boolean

        Fixes gaps between ends of 3d curves on adjacent edges
        myPrecision is used to detect the gaps.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixGaps3d(self, *args)


    def FixGaps2d(self, *args):
        """
        FixGaps2d(Handle_ShapeFix_Wire self) -> Standard_Boolean

        Fixes gaps between ends of pcurves on adjacent edges
        myPrecision is used to detect the gaps.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixGaps2d(self, *args)


    def FixSeam(self, *args):
        """
        FixSeam(Handle_ShapeFix_Wire self, Standard_Integer const num) -> Standard_Boolean

        Fixes a seam edge
        A Seam edge has two pcurves, one for forward. one for reversed
        The forward pcurve must be set as first

        NOTE that correct order of pcurves in the seam edge depends on
        its orientation (i.e., on orientation of the wire, method of
        exploration of edges etc.).
        Since wire represented by the ShapeExtend_WireData is always forward
        (orientation is accounted by edges), it will work correct if:
        1. Wire created from ShapeExtend_WireData with methods
        ShapeExtend_WireData::Wire..() is added into the FORWARD face
        (orientation can be applied later)
        2. Wire is extracted from the face with orientation not composed
        with orientation of the face

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixSeam(self, *args)


    def FixShifted(self, *args):
        """
        FixShifted(Handle_ShapeFix_Wire self) -> Standard_Boolean

        Fixes edges which have pcurves shifted by whole parameter
        range on the closed surface (the case may occur if pcurve
        of edge was computed by projecting 3d curve, which goes
        along the seam).
        It compares each two consequent edges and tries to connect them
        if distance between ends is near to range of the surface.
        It also can detect and fix the case if all pcurves are connected,
        but lie out of parametric bounds of the surface.
        In addition to FixShifted from ShapeFix_Wire, more
        sophisticated check of degenerate points is performed,
        and special cases like sphere given by two meridians
        are treated.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixShifted(self, *args)


    def FixNotchedEdges(self, *args):
        """
        FixNotchedEdges(Handle_ShapeFix_Wire self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixNotchedEdges(self, *args)


    def FixGap3d(self, *args):
        """
        FixGap3d(Handle_ShapeFix_Wire self, Standard_Integer const num, Standard_Boolean const convert) -> Standard_Boolean

        Fixes gap between ends of 3d curves on num-1 and num-th edges.
        myPrecision is used to detect the gap.
        If convert is True, converts curves to bsplines to bend.

        :type num: int
        :type convert: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixGap3d(self, *args)


    def FixGap2d(self, *args):
        """
        FixGap2d(Handle_ShapeFix_Wire self, Standard_Integer const num, Standard_Boolean const convert) -> Standard_Boolean

        Fixes gap between ends of pcurves on num-1 and num-th edges.
        myPrecision is used to detect the gap.
        If convert is True, converts pcurves to bsplines to bend.

        :type num: int
        :type convert: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixGap2d(self, *args)


    def FixTails(self, *args):
        """
        FixTails(Handle_ShapeFix_Wire self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixTails(self, *args)


    def StatusReorder(self, *args):
        """
        StatusReorder(Handle_ShapeFix_Wire self, ShapeExtend_Status const status) -> Standard_Boolean

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_StatusReorder(self, *args)


    def StatusSmall(self, *args):
        """
        StatusSmall(Handle_ShapeFix_Wire self, ShapeExtend_Status const status) -> Standard_Boolean

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_StatusSmall(self, *args)


    def StatusConnected(self, *args):
        """
        StatusConnected(Handle_ShapeFix_Wire self, ShapeExtend_Status const status) -> Standard_Boolean

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_StatusConnected(self, *args)


    def StatusEdgeCurves(self, *args):
        """
        StatusEdgeCurves(Handle_ShapeFix_Wire self, ShapeExtend_Status const status) -> Standard_Boolean

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_StatusEdgeCurves(self, *args)


    def StatusDegenerated(self, *args):
        """
        StatusDegenerated(Handle_ShapeFix_Wire self, ShapeExtend_Status const status) -> Standard_Boolean

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_StatusDegenerated(self, *args)


    def StatusSelfIntersection(self, *args):
        """
        StatusSelfIntersection(Handle_ShapeFix_Wire self, ShapeExtend_Status const status) -> Standard_Boolean

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_StatusSelfIntersection(self, *args)


    def StatusLacking(self, *args):
        """
        StatusLacking(Handle_ShapeFix_Wire self, ShapeExtend_Status const status) -> Standard_Boolean

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_StatusLacking(self, *args)


    def StatusClosed(self, *args):
        """
        StatusClosed(Handle_ShapeFix_Wire self, ShapeExtend_Status const status) -> Standard_Boolean

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_StatusClosed(self, *args)


    def StatusGaps3d(self, *args):
        """
        StatusGaps3d(Handle_ShapeFix_Wire self, ShapeExtend_Status const status) -> Standard_Boolean

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_StatusGaps3d(self, *args)


    def StatusGaps2d(self, *args):
        """
        StatusGaps2d(Handle_ShapeFix_Wire self, ShapeExtend_Status const status) -> Standard_Boolean

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_StatusGaps2d(self, *args)


    def StatusNotches(self, *args):
        """
        StatusNotches(Handle_ShapeFix_Wire self, ShapeExtend_Status const status) -> Standard_Boolean

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_StatusNotches(self, *args)


    def StatusRemovedSegment(self, *args):
        """
        StatusRemovedSegment(Handle_ShapeFix_Wire self) -> Standard_Boolean

        Querying the status of perfomed API fixing procedures
        Each Status..() methods gives information about the last call to
        the corresponding Fix..() method of API level:
        OK  : no problems detected; nothing done
        DONE: some problem(s) was(were) detected and successfully fixed
        FAIL: some problem(s) cannot be fixed

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_StatusRemovedSegment(self, *args)


    def StatusFixTails(self, *args):
        """
        StatusFixTails(Handle_ShapeFix_Wire self, ShapeExtend_Status const status) -> Standard_Boolean

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_StatusFixTails(self, *args)


    def LastFixStatus(self, *args):
        """
        LastFixStatus(Handle_ShapeFix_Wire self, ShapeExtend_Status const status) -> Standard_Boolean

        Queries the status of last call to methods Fix... of
        advanced level
        For details see corresponding methods; universal statuses are:
        OK  : problem not detected; nothing done
        DONE: problem was detected and successfully fixed
        FAIL: problem cannot be fixed

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_LastFixStatus(self, *args)


    def FixEdgeTool(self, *args):
        """
        FixEdgeTool(Handle_ShapeFix_Wire self) -> Handle_ShapeFix_Edge

        Returns tool for fixing wires.

        :rtype: OCC.wrapper.ShapeFix.Handle_ShapeFix_Edge

        """
        return _ShapeFix.Handle_ShapeFix_Wire_FixEdgeTool(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeFix_Wire self) -> char const *

        :rtype: const char *

        """
        return _ShapeFix.Handle_ShapeFix_Wire_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.Handle_ShapeFix_Wire_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.Handle_ShapeFix_Wire_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_ShapeFix_Wire self, Handle_ShapeFix_Root Root)

        Copy all fields from another Root object

        :type Root: OCC.wrapper.ShapeFix.Handle_ShapeFix_Root

        """
        return _ShapeFix.Handle_ShapeFix_Wire_Set(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_ShapeFix_Wire self, Handle_ShapeBuild_ReShape context)

        Sets context

        :type context: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeFix.Handle_ShapeFix_Wire_SetContext(self, *args)


    def Context(self, *args):
        """
        Context(Handle_ShapeFix_Wire self) -> Handle_ShapeBuild_ReShape

        Returns context

        :rtype: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeFix.Handle_ShapeFix_Wire_Context(self, *args)


    def SetMsgRegistrator(self, *args):
        """
        SetMsgRegistrator(Handle_ShapeFix_Wire self, Handle_ShapeExtend_BasicMsgRegistrator msgreg)

        Sets message registrator

        :type msgreg: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeFix.Handle_ShapeFix_Wire_SetMsgRegistrator(self, *args)


    def MsgRegistrator(self, *args):
        """
        MsgRegistrator(Handle_ShapeFix_Wire self) -> Handle_ShapeExtend_BasicMsgRegistrator

        Returns message registrator

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeFix.Handle_ShapeFix_Wire_MsgRegistrator(self, *args)


    def Precision(self, *args):
        """
        Precision(Handle_ShapeFix_Wire self) -> Standard_Real

        Returns basic precision value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_Wire_Precision(self, *args)


    def SetMinTolerance(self, *args):
        """
        SetMinTolerance(Handle_ShapeFix_Wire self, Standard_Real const mintol)

        Sets minimal allowed tolerance

        :type mintol: float

        """
        return _ShapeFix.Handle_ShapeFix_Wire_SetMinTolerance(self, *args)


    def MinTolerance(self, *args):
        """
        MinTolerance(Handle_ShapeFix_Wire self) -> Standard_Real

        Returns minimal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_Wire_MinTolerance(self, *args)


    def SetMaxTolerance(self, *args):
        """
        SetMaxTolerance(Handle_ShapeFix_Wire self, Standard_Real const maxtol)

        Sets maximal allowed tolerance

        :type maxtol: float

        """
        return _ShapeFix.Handle_ShapeFix_Wire_SetMaxTolerance(self, *args)


    def MaxTolerance(self, *args):
        """
        MaxTolerance(Handle_ShapeFix_Wire self) -> Standard_Real

        Returns maximal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_Wire_MaxTolerance(self, *args)


    def LimitTolerance(self, *args):
        """
        LimitTolerance(Handle_ShapeFix_Wire self, Standard_Real const toler) -> Standard_Real

        Returns tolerance limited by [myMinTol,myMaxTol]

        :type toler: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_Wire_LimitTolerance(self, *args)


    def SendMsg(self, *args):
        """
        SendMsg(Handle_ShapeFix_Wire self, TopoDS_Shape shape, Message_Msg message, Message_Gravity const gravity=Message_Info)
        SendMsg(Handle_ShapeFix_Wire self, Message_Msg message, Message_Gravity const gravity=Message_Info)

        Sends a message to be attached to myShape.
        Calls previous method.

        :type message: OCC.wrapper.Message.Message_Msg
        :type gravity: OCC.wrapper.Message.Message_Gravity

        """
        return _ShapeFix.Handle_ShapeFix_Wire_SendMsg(self, *args)


    def SendWarning(self, *args):
        """
        SendWarning(Handle_ShapeFix_Wire self, TopoDS_Shape shape, Message_Msg message)
        SendWarning(Handle_ShapeFix_Wire self, Message_Msg message)

        Calls previous method for myShape.

        :type message: OCC.wrapper.Message.Message_Msg

        """
        return _ShapeFix.Handle_ShapeFix_Wire_SendWarning(self, *args)


    def SendFail(self, *args):
        """
        SendFail(Handle_ShapeFix_Wire self, TopoDS_Shape shape, Message_Msg message)
        SendFail(Handle_ShapeFix_Wire self, Message_Msg message)

        Calls previous method for myShape.

        :type message: OCC.wrapper.Message.Message_Msg

        """
        return _ShapeFix.Handle_ShapeFix_Wire_SendFail(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeFix_Wire self)

        Memory deallocator for transient classes


        """
        return _ShapeFix.Handle_ShapeFix_Wire_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeFix_Wire self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeFix_Wire self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeFix_Wire self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeFix_Wire self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Wire_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeFix_Wire self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeFix.Handle_ShapeFix_Wire_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeFix_Wire self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Wire_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeFix_Wire self)

        Increments the reference counter of this object


        """
        return _ShapeFix.Handle_ShapeFix_Wire_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeFix_Wire self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Wire_DecrementRefCounter(self, *args)

Handle_ShapeFix_Wire_swigregister = _ShapeFix.Handle_ShapeFix_Wire_swigregister
Handle_ShapeFix_Wire_swigregister(Handle_ShapeFix_Wire)

def Handle_ShapeFix_Wire_DownCast(thing):
    return _ShapeFix.Handle_ShapeFix_Wire_DownCast(thing)
Handle_ShapeFix_Wire_DownCast = _ShapeFix.Handle_ShapeFix_Wire_DownCast

class ShapeFix_Shape(ShapeFix_Root):
    """Fixing shape in general"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeFix_Shape
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeFix_Shape(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeFix_Shape self) -> ShapeFix_Shape
        __init__(ShapeFix_Shape self, TopoDS_Shape shape) -> ShapeFix_Shape

        Initislises by shape.

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _ShapeFix.new_ShapeFix_Shape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(ShapeFix_Shape self, TopoDS_Shape shape)

        Initislises by shape.

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.ShapeFix_Shape_Init(self, *args)


    def Perform(self, *args):
        """
        Perform(ShapeFix_Shape self, Handle_Message_ProgressIndicator theProgress=0) -> Standard_Boolean

        Iterates on sub- shape and performs fixes

        :type theProgress: OCC.wrapper.Message.Handle_Message_ProgressIndicator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Shape_Perform(self, *args)


    def Shape(self, *args):
        """
        Shape(ShapeFix_Shape self) -> TopoDS_Shape

        Returns resulting shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.ShapeFix_Shape_Shape(self, *args)


    def FixSolidTool(self, *args):
        """
        FixSolidTool(ShapeFix_Shape self) -> Handle_ShapeFix_Solid

        Returns tool for fixing solids.

        :rtype: OCC.wrapper.ShapeFix.Handle_ShapeFix_Solid

        """
        return _ShapeFix.ShapeFix_Shape_FixSolidTool(self, *args)


    def FixShellTool(self, *args):
        """
        FixShellTool(ShapeFix_Shape self) -> Handle_ShapeFix_Shell

        Returns tool for fixing shells.

        :rtype: OCC.wrapper.ShapeFix.Handle_ShapeFix_Shell

        """
        return _ShapeFix.ShapeFix_Shape_FixShellTool(self, *args)


    def FixFaceTool(self, *args):
        """
        FixFaceTool(ShapeFix_Shape self) -> Handle_ShapeFix_Face

        Returns tool for fixing faces.

        :rtype: OCC.wrapper.ShapeFix.Handle_ShapeFix_Face

        """
        return _ShapeFix.ShapeFix_Shape_FixFaceTool(self, *args)


    def FixWireTool(self, *args):
        """
        FixWireTool(ShapeFix_Shape self) -> Handle_ShapeFix_Wire

        Returns tool for fixing wires.

        :rtype: OCC.wrapper.ShapeFix.Handle_ShapeFix_Wire

        """
        return _ShapeFix.ShapeFix_Shape_FixWireTool(self, *args)


    def FixEdgeTool(self, *args):
        """
        FixEdgeTool(ShapeFix_Shape self) -> Handle_ShapeFix_Edge

        Returns tool for fixing edges.

        :rtype: OCC.wrapper.ShapeFix.Handle_ShapeFix_Edge

        """
        return _ShapeFix.ShapeFix_Shape_FixEdgeTool(self, *args)


    def Status(self, *args):
        """
        Status(ShapeFix_Shape self, ShapeExtend_Status const status) -> Standard_Boolean

        Returns the status of the last Fix.
        This can be a combination of the following flags:
        ShapeExtend_DONE1: some free edges were fixed
        ShapeExtend_DONE2: some free wires were fixed
        ShapeExtend_DONE3: some free faces were fixed
        ShapeExtend_DONE4: some free shells were fixed
        ShapeExtend_DONE5: some free solids were fixed
        ShapeExtend_DONE6: shapes in compound(s) were fixed

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Shape_Status(self, *args)


    def SetMsgRegistrator(self, *args):
        """
        SetMsgRegistrator(ShapeFix_Shape self, Handle_ShapeExtend_BasicMsgRegistrator msgreg)

        Sets message registrator

        :type msgreg: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeFix.ShapeFix_Shape_SetMsgRegistrator(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(ShapeFix_Shape self, Standard_Real const preci)

        Sets basic precision value (also to FixSolidTool)

        :type preci: float

        """
        return _ShapeFix.ShapeFix_Shape_SetPrecision(self, *args)


    def SetMinTolerance(self, *args):
        """
        SetMinTolerance(ShapeFix_Shape self, Standard_Real const mintol)

        Sets minimal allowed tolerance (also to FixSolidTool)

        :type mintol: float

        """
        return _ShapeFix.ShapeFix_Shape_SetMinTolerance(self, *args)


    def SetMaxTolerance(self, *args):
        """
        SetMaxTolerance(ShapeFix_Shape self, Standard_Real const maxtol)

        Sets maximal allowed tolerance (also to FixSolidTool)

        :type maxtol: float

        """
        return _ShapeFix.ShapeFix_Shape_SetMaxTolerance(self, *args)


    def FixSolidMode(self, *args):
        """
        FixSolidMode(ShapeFix_Shape self) -> Standard_Integer &

        Returns (modifiable) the mode for applying fixes of
        ShapeFix_Solid, by default True.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Shape_FixSolidMode(self, *args)


    def FixFreeShellMode(self, *args):
        """
        FixFreeShellMode(ShapeFix_Shape self) -> Standard_Integer &

        Returns (modifiable) the mode for applying fixes of
        ShapeFix_Shell, by default True.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Shape_FixFreeShellMode(self, *args)


    def FixFreeFaceMode(self, *args):
        """
        FixFreeFaceMode(ShapeFix_Shape self) -> Standard_Integer &

        Returns (modifiable) the mode for applying fixes of
        ShapeFix_Face, by default True.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Shape_FixFreeFaceMode(self, *args)


    def FixFreeWireMode(self, *args):
        """
        FixFreeWireMode(ShapeFix_Shape self) -> Standard_Integer &

        Returns (modifiable) the mode for applying fixes of
        ShapeFix_Wire, by default True.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Shape_FixFreeWireMode(self, *args)


    def FixSameParameterMode(self, *args):
        """
        FixSameParameterMode(ShapeFix_Shape self) -> Standard_Integer &

        Returns (modifiable) the mode for applying
        ShapeFix::SameParameter after all fixes, by default True.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Shape_FixSameParameterMode(self, *args)


    def FixVertexPositionMode(self, *args):
        """
        FixVertexPositionMode(ShapeFix_Shape self) -> Standard_Integer &

        Returns (modifiable) the mode for applying
        ShapeFix::FixVertexPosition before all fixes, by default False.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Shape_FixVertexPositionMode(self, *args)


    def FixVertexTolMode(self, *args):
        """
        FixVertexTolMode(ShapeFix_Shape self) -> Standard_Integer &

        Returns (modifiable) the mode for fixing tolerances of vertices on whole shape
        after performing all fixes

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Shape_FixVertexTolMode(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeFix.ShapeFix_Shape_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeFix.ShapeFix_Shape_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.ShapeFix_Shape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeFix.delete_ShapeFix_Shape
ShapeFix_Shape_swigregister = _ShapeFix.ShapeFix_Shape_swigregister
ShapeFix_Shape_swigregister(ShapeFix_Shape)

def ShapeFix_Shape_get_type_name(*args):
    """
    ShapeFix_Shape_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeFix.ShapeFix_Shape_get_type_name(*args)

def ShapeFix_Shape_get_type_descriptor(*args):
    """
    ShapeFix_Shape_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeFix.ShapeFix_Shape_get_type_descriptor(*args)

class ShapeFix_FaceConnect(object):
    """Rebuilds connectivity between faces in shell"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ShapeFix_FaceConnect self) -> ShapeFix_FaceConnect

        Rebuilds connectivity between faces in shell
        """
        this = _ShapeFix.new_ShapeFix_FaceConnect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args):
        """
        Add(ShapeFix_FaceConnect self, TopoDS_Face aFirst, TopoDS_Face aSecond) -> Standard_Boolean

        :type aFirst: OCC.wrapper.TopoDS.TopoDS_Face
        :type aSecond: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_FaceConnect_Add(self, *args)


    def Build(self, *args):
        """
        Build(ShapeFix_FaceConnect self, TopoDS_Shell shell, Standard_Real const sewtoler, Standard_Real const fixtoler) -> TopoDS_Shell

        :type shell: OCC.wrapper.TopoDS.TopoDS_Shell
        :type sewtoler: float
        :type fixtoler: float
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shell

        """
        return _ShapeFix.ShapeFix_FaceConnect_Build(self, *args)


    def Clear(self, *args):
        """
        Clear(ShapeFix_FaceConnect self)

        Clears internal data structure


        """
        return _ShapeFix.ShapeFix_FaceConnect_Clear(self, *args)

    __swig_destroy__ = _ShapeFix.delete_ShapeFix_FaceConnect
ShapeFix_FaceConnect_swigregister = _ShapeFix.ShapeFix_FaceConnect_swigregister
ShapeFix_FaceConnect_swigregister(ShapeFix_FaceConnect)

class ShapeFix_(object):
    """
    This package provides algorithms for fixing
    problematic (violating Open CASCADE requirements) shapes.
    Tools from package ShapeAnalysis are used for detecting the problems. The
    detecting and fixing is done taking in account various
    criteria implemented in BRepCheck package.
    Each class of package ShapeFix deals with one
    certain type of shapes or with some family of problems.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def SameParameter(*args):
        """
        SameParameter(TopoDS_Shape shape, Standard_Boolean const enforce, Standard_Real const preci=0.0, Handle_Message_ProgressIndicator theProgress=0, Handle_ShapeExtend_BasicMsgRegistrator theMsgReg=0) -> Standard_Boolean

        Runs SameParameter from BRepLib with these adaptations :
        <enforce> forces computations, else they are made only on
        Edges with flag SameParameter false
        <preci>, if not precised, is taken for each EDge as its own
        Tolerance
        Returns True when done, False if an exception has been raised
        In case of exception anyway, as many edges as possible have
        been processed. The passed progress indicator allows user
        to consult the current progress stage and abort algorithm
        if needed.

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type enforce: bool
        :type preci: float
        :type theProgress: OCC.wrapper.Message.Handle_Message_ProgressIndicator
        :type theMsgReg: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix__SameParameter(*args)

    SameParameter = staticmethod(SameParameter)

    def EncodeRegularity(*args):
        """
        EncodeRegularity(TopoDS_Shape shape, Standard_Real const tolang=1.0e-10)

        Runs EncodeRegularity from BRepLib taking into account
        shared components of assemblies, so that each component
        is processed only once

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type tolang: float

        """
        return _ShapeFix.ShapeFix__EncodeRegularity(*args)

    EncodeRegularity = staticmethod(EncodeRegularity)

    def RemoveSmallEdges(*args):
        """
        RemoveSmallEdges(TopoDS_Shape shape, Standard_Real const Tolerance, Handle_ShapeBuild_ReShape context) -> TopoDS_Shape

        Removes edges which are less than given tolerance from shape
        with help of ShapeFix_Wire::FixSmall()

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Tolerance: float
        :type context: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.ShapeFix__RemoveSmallEdges(*args)

    RemoveSmallEdges = staticmethod(RemoveSmallEdges)

    def FixVertexPosition(*args):
        """
        FixVertexPosition(TopoDS_Shape theshape, Standard_Real const theTolerance, Handle_ShapeBuild_ReShape thecontext) -> Standard_Boolean

        Fix position of the vertices having tolerance more tnan specified one.;

        :type theshape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theTolerance: float
        :type thecontext: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix__FixVertexPosition(*args)

    FixVertexPosition = staticmethod(FixVertexPosition)

    def LeastEdgeSize(*args):
        """
        LeastEdgeSize(TopoDS_Shape theshape) -> Standard_Real

        Calculate size of least edge;

        :type theshape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.ShapeFix__LeastEdgeSize(*args)

    LeastEdgeSize = staticmethod(LeastEdgeSize)

    def __init__(self):
        """
        This package provides algorithms for fixing
        problematic (violating Open CASCADE requirements) shapes.
        Tools from package ShapeAnalysis are used for detecting the problems. The
        detecting and fixing is done taking in account various
        criteria implemented in BRepCheck package.
        Each class of package ShapeFix deals with one
        certain type of shapes or with some family of problems.
        """
        this = _ShapeFix.new_ShapeFix_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ShapeFix.delete_ShapeFix_
ShapeFix__swigregister = _ShapeFix.ShapeFix__swigregister
ShapeFix__swigregister(ShapeFix_)

def ShapeFix__SameParameter(*args):
    """
    ShapeFix__SameParameter(TopoDS_Shape shape, Standard_Boolean const enforce, Standard_Real const preci=0.0, Handle_Message_ProgressIndicator theProgress=0, Handle_ShapeExtend_BasicMsgRegistrator theMsgReg=0) -> Standard_Boolean

    Runs SameParameter from BRepLib with these adaptations :
    <enforce> forces computations, else they are made only on
    Edges with flag SameParameter false
    <preci>, if not precised, is taken for each EDge as its own
    Tolerance
    Returns True when done, False if an exception has been raised
    In case of exception anyway, as many edges as possible have
    been processed. The passed progress indicator allows user
    to consult the current progress stage and abort algorithm
    if needed.

    :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type enforce: bool
    :type preci: float
    :type theProgress: OCC.wrapper.Message.Handle_Message_ProgressIndicator
    :type theMsgReg: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _ShapeFix.ShapeFix__SameParameter(*args)

def ShapeFix__EncodeRegularity(*args):
    """
    ShapeFix__EncodeRegularity(TopoDS_Shape shape, Standard_Real const tolang=1.0e-10)

    Runs EncodeRegularity from BRepLib taking into account
    shared components of assemblies, so that each component
    is processed only once

    :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type tolang: float

    """
    return _ShapeFix.ShapeFix__EncodeRegularity(*args)

def ShapeFix__RemoveSmallEdges(*args):
    """
    ShapeFix__RemoveSmallEdges(TopoDS_Shape shape, Standard_Real const Tolerance, Handle_ShapeBuild_ReShape context) -> TopoDS_Shape

    Removes edges which are less than given tolerance from shape
    with help of ShapeFix_Wire::FixSmall()

    :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type Tolerance: float
    :type context: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape
    :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _ShapeFix.ShapeFix__RemoveSmallEdges(*args)

def ShapeFix__FixVertexPosition(*args):
    """
    ShapeFix__FixVertexPosition(TopoDS_Shape theshape, Standard_Real const theTolerance, Handle_ShapeBuild_ReShape thecontext) -> Standard_Boolean

    Fix position of the vertices having tolerance more tnan specified one.;

    :type theshape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theTolerance: float
    :type thecontext: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _ShapeFix.ShapeFix__FixVertexPosition(*args)

def ShapeFix__LeastEdgeSize(*args):
    """
    ShapeFix__LeastEdgeSize(TopoDS_Shape theshape) -> Standard_Real

    Calculate size of least edge;

    :type theshape: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _ShapeFix.ShapeFix__LeastEdgeSize(*args)

class ShapeFix_SplitTool(object):
    """
    Tool for splitting and cutting edges; includes methods
    used in OverlappingTool and IntersectionTool
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ShapeFix_SplitTool self) -> ShapeFix_SplitTool

        Empty constructor


        """
        this = _ShapeFix.new_ShapeFix_SplitTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def CutEdge(self, *args):
        """
        CutEdge(ShapeFix_SplitTool self, TopoDS_Edge edge, Standard_Real const pend, Standard_Real const cut, TopoDS_Face face) -> Standard_Boolean

        Cut edge by parameters pend and cut

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type pend: float
        :type cut: float
        :type face: OCC.wrapper.TopoDS.TopoDS_Face
        :type iscutline: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_SplitTool_CutEdge(self, *args)


    def SplitEdge(self, *args):
        """
        SplitEdge(ShapeFix_SplitTool self, TopoDS_Edge edge, Standard_Real const param, TopoDS_Vertex vert, TopoDS_Face face, TopoDS_Edge newE1, TopoDS_Edge newE2, Standard_Real const tol3d, Standard_Real const tol2d) -> Standard_Boolean
        SplitEdge(ShapeFix_SplitTool self, TopoDS_Edge edge, Standard_Real const param1, Standard_Real const param2, TopoDS_Vertex vert, TopoDS_Face face, TopoDS_Edge newE1, TopoDS_Edge newE2, Standard_Real const tol3d, Standard_Real const tol2d) -> Standard_Boolean
        SplitEdge(ShapeFix_SplitTool self, TopoDS_Edge edge, Standard_Real const fp, TopoDS_Vertex V1, Standard_Real const lp, TopoDS_Vertex V2, TopoDS_Face face, NCollection_Sequence_TopoDS_Shape SeqE, Handle_ShapeBuild_ReShape context, Standard_Real const tol3d, Standard_Real const tol2d) -> Standard_Boolean

        Split edge on two new edges using two new vertex V1 and V2
        and two parameters for splitting - fp and lp correspondingly
        The "face" is necessary for pcurves and using TransferParameterProj
        aNum - number of edge in SeqE which corresponding to [fp,lp]

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type fp: float
        :type V1: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type lp: float
        :type V2: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type face: OCC.wrapper.TopoDS.TopoDS_Face
        :type SeqE: OCC.wrapper.TopTools.TopTools_SequenceOfShape
        :type aNum: int
        :type context: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape
        :type tol3d: float
        :type tol2d: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_SplitTool_SplitEdge(self, *args)

    __swig_destroy__ = _ShapeFix.delete_ShapeFix_SplitTool
ShapeFix_SplitTool_swigregister = _ShapeFix.ShapeFix_SplitTool_swigregister
ShapeFix_SplitTool_swigregister(ShapeFix_SplitTool)

class Handle_ShapeFix_Root(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeFix_Root self)

        Nullify the handle


        """
        return _ShapeFix.Handle_ShapeFix_Root_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeFix_Root self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeFix.Handle_ShapeFix_Root_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeFix_Root self, ShapeFix_Root thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeFix.Handle_ShapeFix_Root_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeFix_Root self, Handle_ShapeFix_Root theHandle) -> Handle_ShapeFix_Root
        assign(Handle_ShapeFix_Root self, ShapeFix_Root thePtr) -> Handle_ShapeFix_Root
        assign(Handle_ShapeFix_Root self, Handle_ShapeFix_Root theHandle) -> Handle_ShapeFix_Root

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeFix.Handle_ShapeFix_Root_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeFix_Root self) -> ShapeFix_Root

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeFix.Handle_ShapeFix_Root_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeFix_Root self) -> ShapeFix_Root

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeFix.Handle_ShapeFix_Root___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeFix_Root self) -> ShapeFix_Root

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeFix.Handle_ShapeFix_Root___ref__(self, *args)


    def __hash__(self):
        return _ShapeFix.Handle_ShapeFix_Root___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeFix.Handle_ShapeFix_Root___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeFix.new_Handle_ShapeFix_Root(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeFix.Handle_ShapeFix_Root_DownCast)
    __swig_destroy__ = _ShapeFix.delete_Handle_ShapeFix_Root

    def Set(self, *args):
        """
        Set(Handle_ShapeFix_Root self, Handle_ShapeFix_Root Root)

        Copy all fields from another Root object

        :type Root: OCC.wrapper.ShapeFix.Handle_ShapeFix_Root

        """
        return _ShapeFix.Handle_ShapeFix_Root_Set(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_ShapeFix_Root self, Handle_ShapeBuild_ReShape context)

        Sets context

        :type context: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeFix.Handle_ShapeFix_Root_SetContext(self, *args)


    def Context(self, *args):
        """
        Context(Handle_ShapeFix_Root self) -> Handle_ShapeBuild_ReShape

        Returns context

        :rtype: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeFix.Handle_ShapeFix_Root_Context(self, *args)


    def SetMsgRegistrator(self, *args):
        """
        SetMsgRegistrator(Handle_ShapeFix_Root self, Handle_ShapeExtend_BasicMsgRegistrator msgreg)

        Sets message registrator

        :type msgreg: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeFix.Handle_ShapeFix_Root_SetMsgRegistrator(self, *args)


    def MsgRegistrator(self, *args):
        """
        MsgRegistrator(Handle_ShapeFix_Root self) -> Handle_ShapeExtend_BasicMsgRegistrator

        Returns message registrator

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeFix.Handle_ShapeFix_Root_MsgRegistrator(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(Handle_ShapeFix_Root self, Standard_Real const preci)

        Sets basic precision value

        :type preci: float

        """
        return _ShapeFix.Handle_ShapeFix_Root_SetPrecision(self, *args)


    def Precision(self, *args):
        """
        Precision(Handle_ShapeFix_Root self) -> Standard_Real

        Returns basic precision value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_Root_Precision(self, *args)


    def SetMinTolerance(self, *args):
        """
        SetMinTolerance(Handle_ShapeFix_Root self, Standard_Real const mintol)

        Sets minimal allowed tolerance

        :type mintol: float

        """
        return _ShapeFix.Handle_ShapeFix_Root_SetMinTolerance(self, *args)


    def MinTolerance(self, *args):
        """
        MinTolerance(Handle_ShapeFix_Root self) -> Standard_Real

        Returns minimal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_Root_MinTolerance(self, *args)


    def SetMaxTolerance(self, *args):
        """
        SetMaxTolerance(Handle_ShapeFix_Root self, Standard_Real const maxtol)

        Sets maximal allowed tolerance

        :type maxtol: float

        """
        return _ShapeFix.Handle_ShapeFix_Root_SetMaxTolerance(self, *args)


    def MaxTolerance(self, *args):
        """
        MaxTolerance(Handle_ShapeFix_Root self) -> Standard_Real

        Returns maximal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_Root_MaxTolerance(self, *args)


    def LimitTolerance(self, *args):
        """
        LimitTolerance(Handle_ShapeFix_Root self, Standard_Real const toler) -> Standard_Real

        Returns tolerance limited by [myMinTol,myMaxTol]

        :type toler: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_Root_LimitTolerance(self, *args)


    def SendMsg(self, *args):
        """
        SendMsg(Handle_ShapeFix_Root self, TopoDS_Shape shape, Message_Msg message, Message_Gravity const gravity=Message_Info)
        SendMsg(Handle_ShapeFix_Root self, Message_Msg message, Message_Gravity const gravity=Message_Info)

        Sends a message to be attached to myShape.
        Calls previous method.

        :type message: OCC.wrapper.Message.Message_Msg
        :type gravity: OCC.wrapper.Message.Message_Gravity

        """
        return _ShapeFix.Handle_ShapeFix_Root_SendMsg(self, *args)


    def SendWarning(self, *args):
        """
        SendWarning(Handle_ShapeFix_Root self, TopoDS_Shape shape, Message_Msg message)
        SendWarning(Handle_ShapeFix_Root self, Message_Msg message)

        Calls previous method for myShape.

        :type message: OCC.wrapper.Message.Message_Msg

        """
        return _ShapeFix.Handle_ShapeFix_Root_SendWarning(self, *args)


    def SendFail(self, *args):
        """
        SendFail(Handle_ShapeFix_Root self, TopoDS_Shape shape, Message_Msg message)
        SendFail(Handle_ShapeFix_Root self, Message_Msg message)

        Calls previous method for myShape.

        :type message: OCC.wrapper.Message.Message_Msg

        """
        return _ShapeFix.Handle_ShapeFix_Root_SendFail(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeFix_Root self) -> char const *

        :rtype: const char *

        """
        return _ShapeFix.Handle_ShapeFix_Root_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.Handle_ShapeFix_Root_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.Handle_ShapeFix_Root_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_ShapeFix_Root self)

        Memory deallocator for transient classes


        """
        return _ShapeFix.Handle_ShapeFix_Root_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeFix_Root self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeFix_Root self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Root_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeFix_Root self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeFix_Root self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Root_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeFix_Root self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeFix.Handle_ShapeFix_Root_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeFix_Root self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Root_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeFix_Root self)

        Increments the reference counter of this object


        """
        return _ShapeFix.Handle_ShapeFix_Root_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeFix_Root self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Root_DecrementRefCounter(self, *args)

Handle_ShapeFix_Root_swigregister = _ShapeFix.Handle_ShapeFix_Root_swigregister
Handle_ShapeFix_Root_swigregister(Handle_ShapeFix_Root)

def Handle_ShapeFix_Root_DownCast(thing):
    return _ShapeFix.Handle_ShapeFix_Root_DownCast(thing)
Handle_ShapeFix_Root_DownCast = _ShapeFix.Handle_ShapeFix_Root_DownCast

class ShapeFix_EdgeConnect(object):
    """
    Rebuilds edges to connect with new vertices, was moved from ShapeBuild.
    Makes vertices to be shared to connect edges,
    updates positions and tolerances for shared vertices.
    Accepts edges bounded by two vertices each.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ShapeFix_EdgeConnect self) -> ShapeFix_EdgeConnect

        Rebuilds edges to connect with new vertices, was moved from ShapeBuild.
        Makes vertices to be shared to connect edges,
        updates positions and tolerances for shared vertices.
        Accepts edges bounded by two vertices each.
        """
        this = _ShapeFix.new_ShapeFix_EdgeConnect(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args):
        """
        Add(ShapeFix_EdgeConnect self, TopoDS_Edge aFirst, TopoDS_Edge aSecond)
        Add(ShapeFix_EdgeConnect self, TopoDS_Shape aShape)

        Adds connectivity information for the whole shape.
        Note: edges in wires must be well ordered
        Note: flag Closed should be set for closed wires

        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.ShapeFix_EdgeConnect_Add(self, *args)


    def Build(self, *args):
        """
        Build(ShapeFix_EdgeConnect self)

        Builds shared vertices, updates their positions and tolerances


        """
        return _ShapeFix.ShapeFix_EdgeConnect_Build(self, *args)


    def Clear(self, *args):
        """
        Clear(ShapeFix_EdgeConnect self)

        Clears internal data structure


        """
        return _ShapeFix.ShapeFix_EdgeConnect_Clear(self, *args)

    __swig_destroy__ = _ShapeFix.delete_ShapeFix_EdgeConnect
ShapeFix_EdgeConnect_swigregister = _ShapeFix.ShapeFix_EdgeConnect_swigregister
ShapeFix_EdgeConnect_swigregister(ShapeFix_EdgeConnect)

class ShapeFix_Solid(ShapeFix_Root):
    """
    Provides method to build a solid from a shells and
    orients them in order to have a valid solid with finite volume
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeFix_Solid
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeFix_Solid(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeFix_Solid self) -> ShapeFix_Solid
        __init__(ShapeFix_Solid self, TopoDS_Solid solid) -> ShapeFix_Solid

        Initializes by solid.

        :type solid: OCC.wrapper.TopoDS.TopoDS_Solid

        """
        this = _ShapeFix.new_ShapeFix_Solid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(ShapeFix_Solid self, TopoDS_Solid solid)

        Initializes by solid .

        :type solid: OCC.wrapper.TopoDS.TopoDS_Solid

        """
        return _ShapeFix.ShapeFix_Solid_Init(self, *args)


    def Perform(self, *args):
        """
        Perform(ShapeFix_Solid self, Handle_Message_ProgressIndicator theProgress=0) -> Standard_Boolean

        Iterates on shells and performs fixes
        (calls ShapeFix_Shell for each subshell). The passed
        progress indicator allows user to consult the current
        progress stage and abort algorithm if needed.

        :type theProgress: OCC.wrapper.Message.Handle_Message_ProgressIndicator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Solid_Perform(self, *args)


    def SolidFromShell(self, *args):
        """
        SolidFromShell(ShapeFix_Solid self, TopoDS_Shell shell) -> TopoDS_Solid

        Calls MakeSolid and orients the solid to be "not infinite"

        :type shell: OCC.wrapper.TopoDS.TopoDS_Shell
        :rtype: OCC.wrapper.TopoDS.TopoDS_Solid

        """
        return _ShapeFix.ShapeFix_Solid_SolidFromShell(self, *args)


    def Status(self, *args):
        """
        Status(ShapeFix_Solid self, ShapeExtend_Status const status) -> Standard_Boolean

        Returns the status of the last Fix.

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Solid_Status(self, *args)


    def Solid(self, *args):
        """
        Solid(ShapeFix_Solid self) -> TopoDS_Shape

        Returns resulting solid.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.ShapeFix_Solid_Solid(self, *args)


    def FixShellTool(self, *args):
        """
        FixShellTool(ShapeFix_Solid self) -> Handle_ShapeFix_Shell

        Returns tool for fixing shells.

        :rtype: OCC.wrapper.ShapeFix.Handle_ShapeFix_Shell

        """
        return _ShapeFix.ShapeFix_Solid_FixShellTool(self, *args)


    def SetMsgRegistrator(self, *args):
        """
        SetMsgRegistrator(ShapeFix_Solid self, Handle_ShapeExtend_BasicMsgRegistrator msgreg)

        Sets message registrator

        :type msgreg: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeFix.ShapeFix_Solid_SetMsgRegistrator(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(ShapeFix_Solid self, Standard_Real const preci)

        Sets basic precision value (also to FixShellTool)

        :type preci: float

        """
        return _ShapeFix.ShapeFix_Solid_SetPrecision(self, *args)


    def SetMinTolerance(self, *args):
        """
        SetMinTolerance(ShapeFix_Solid self, Standard_Real const mintol)

        Sets minimal allowed tolerance (also to FixShellTool)

        :type mintol: float

        """
        return _ShapeFix.ShapeFix_Solid_SetMinTolerance(self, *args)


    def SetMaxTolerance(self, *args):
        """
        SetMaxTolerance(ShapeFix_Solid self, Standard_Real const maxtol)

        Sets maximal allowed tolerance (also to FixShellTool)

        :type maxtol: float

        """
        return _ShapeFix.ShapeFix_Solid_SetMaxTolerance(self, *args)


    def FixShellMode(self, *args):
        """
        FixShellMode(ShapeFix_Solid self) -> Standard_Integer &

        Returns (modifiable) the mode for applying fixes of
        ShapeFix_Shell, by default True.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Solid_FixShellMode(self, *args)


    def FixShellOrientationMode(self, *args):
        """
        FixShellOrientationMode(ShapeFix_Solid self) -> Standard_Integer &

        Returns (modifiable) the mode for applying analysis and fixes of
        orientation of shells in the solid; by default True.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.ShapeFix_Solid_FixShellOrientationMode(self, *args)


    def CreateOpenSolidMode(self, *args):
        """
        CreateOpenSolidMode(ShapeFix_Solid self) -> Standard_Boolean &

        Returns (modifiable) the mode for creation of solids.
        If mode myCreateOpenSolidMode is equal to true
        solids are created from open shells
        else solids are created  from closed shells only.
        ShapeFix_Shell, by default False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_Solid_CreateOpenSolidMode(self, *args)


    def Shape(self, *args):
        """
        Shape(ShapeFix_Solid self) -> TopoDS_Shape

        In case of multiconnexity returns compound of fixed solids
        else returns one solid.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.ShapeFix_Solid_Shape(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeFix.ShapeFix_Solid_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeFix.ShapeFix_Solid_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.ShapeFix_Solid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeFix.delete_ShapeFix_Solid
ShapeFix_Solid_swigregister = _ShapeFix.ShapeFix_Solid_swigregister
ShapeFix_Solid_swigregister(ShapeFix_Solid)

def ShapeFix_Solid_get_type_name(*args):
    """
    ShapeFix_Solid_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeFix.ShapeFix_Solid_get_type_name(*args)

def ShapeFix_Solid_get_type_descriptor(*args):
    """
    ShapeFix_Solid_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeFix.ShapeFix_Solid_get_type_descriptor(*args)

class ShapeFix_FreeBounds(object):
    """
    This class is intended to output free bounds of the shape
    (free bounds are the wires consisting of edges referenced by the
    only face).
    For building free bounds it uses ShapeAnalysis_FreeBounds class.
    This class complements it with the feature to reduce the number
    of open wires.
    This reduction is performed with help of connecting several
    adjacent open wires one to another what can lead to:
    1. making an open wire with greater length out of several
    open wires
    2. making closed wire out of several open wires

    The connecting open wires is performed with a user-given
    tolerance.

    When connecting several open wires into one wire their previous
    end vertices are replaced with new connecting vertices. After
    that all the edges in the shape sharing previous vertices inside
    the shape are updated with new vertices. Thus source shape can
    be modified.

    Since interface of this class is the same as one of
    ShapeAnalysis_FreeBounds refer to its CDL for details.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ShapeFix_FreeBounds self) -> ShapeFix_FreeBounds
        __init__(ShapeFix_FreeBounds self, TopoDS_Shape shape, Standard_Real const sewtoler, Standard_Real const closetoler, Standard_Boolean const splitclosed, Standard_Boolean const splitopen) -> ShapeFix_FreeBounds
        __init__(ShapeFix_FreeBounds self, TopoDS_Shape shape, Standard_Real const closetoler, Standard_Boolean const splitclosed, Standard_Boolean const splitopen) -> ShapeFix_FreeBounds

        Builds actual free bounds of the <shape> and connects
        open wires with tolerance <closetoler>.
        <shape> should be a compound of shells.

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type closetoler: float
        :type splitclosed: bool
        :type splitopen: bool

        """
        this = _ShapeFix.new_ShapeFix_FreeBounds(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetClosedWires(self, *args):
        """
        Returns compound of closed wires out of free edges.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Compound

        """
        res = _ShapeFix.ShapeFix_FreeBounds_GetClosedWires(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetOpenWires(self, *args):
        """
        Returns compound of open wires out of free edges.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Compound

        """
        res = _ShapeFix.ShapeFix_FreeBounds_GetOpenWires(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetShape(self, *args):
        """
        Returns modified source shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _ShapeFix.ShapeFix_FreeBounds_GetShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeFix.delete_ShapeFix_FreeBounds
ShapeFix_FreeBounds_swigregister = _ShapeFix.ShapeFix_FreeBounds_swigregister
ShapeFix_FreeBounds_swigregister(ShapeFix_FreeBounds)

class ShapeFix_FixSmallSolid(ShapeFix_Root):
    """Fixing solids with small size"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeFix_FixSmallSolid
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeFix_FixSmallSolid(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeFix_FixSmallSolid self) -> ShapeFix_FixSmallSolid

        Construct


        """
        this = _ShapeFix.new_ShapeFix_FixSmallSolid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetFixMode(self, *args):
        """
        SetFixMode(ShapeFix_FixSmallSolid self, Standard_Integer const theMode)

        Set working mode for operator:
        - theMode = 0 use both WidthFactorThreshold and VolumeThreshold parameters
        - theMode = 1 use only WidthFactorThreshold parameter
        - theMode = 2 use only VolumeThreshold parameter

        :type theMode: int

        """
        return _ShapeFix.ShapeFix_FixSmallSolid_SetFixMode(self, *args)


    def SetVolumeThreshold(self, *args):
        """
        SetVolumeThreshold(ShapeFix_FixSmallSolid self, Standard_Real const theThreshold=-1.0)

        Set or clear volume threshold for small solids

        :type theThreshold: float

        """
        return _ShapeFix.ShapeFix_FixSmallSolid_SetVolumeThreshold(self, *args)


    def SetWidthFactorThreshold(self, *args):
        """
        SetWidthFactorThreshold(ShapeFix_FixSmallSolid self, Standard_Real const theThreshold=-1.0)

        Set or clear width factor threshold for small solids

        :type theThreshold: float

        """
        return _ShapeFix.ShapeFix_FixSmallSolid_SetWidthFactorThreshold(self, *args)


    def Remove(self, *args):
        """
        Remove(ShapeFix_FixSmallSolid self, TopoDS_Shape theShape, Handle_ShapeBuild_ReShape theContext) -> TopoDS_Shape

        Remove small solids from the given shape

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theContext: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.ShapeFix_FixSmallSolid_Remove(self, *args)


    def Merge(self, *args):
        """
        Merge(ShapeFix_FixSmallSolid self, TopoDS_Shape theShape, Handle_ShapeBuild_ReShape theContext) -> TopoDS_Shape

        Merge small solids in the given shape to adjacent non-small ones

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theContext: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.ShapeFix_FixSmallSolid_Merge(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeFix.ShapeFix_FixSmallSolid_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeFix.ShapeFix_FixSmallSolid_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.ShapeFix_FixSmallSolid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeFix.delete_ShapeFix_FixSmallSolid
ShapeFix_FixSmallSolid_swigregister = _ShapeFix.ShapeFix_FixSmallSolid_swigregister
ShapeFix_FixSmallSolid_swigregister(ShapeFix_FixSmallSolid)

def ShapeFix_FixSmallSolid_get_type_name(*args):
    """
    ShapeFix_FixSmallSolid_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeFix.ShapeFix_FixSmallSolid_get_type_name(*args)

def ShapeFix_FixSmallSolid_get_type_descriptor(*args):
    """
    ShapeFix_FixSmallSolid_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeFix.ShapeFix_FixSmallSolid_get_type_descriptor(*args)

class NCollection_Sequence_ShapeFix_WireSegment(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_ShapeFix_WireSegment self) -> NCollection_Sequence< ShapeFix_WireSegment >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _ShapeFix.NCollection_Sequence_ShapeFix_WireSegment_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_ShapeFix_WireSegment self) -> NCollection_Sequence< ShapeFix_WireSegment >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _ShapeFix.NCollection_Sequence_ShapeFix_WireSegment_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_ShapeFix_WireSegment self) -> NCollection_Sequence< ShapeFix_WireSegment >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _ShapeFix.NCollection_Sequence_ShapeFix_WireSegment_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_ShapeFix_WireSegment self) -> NCollection_Sequence< ShapeFix_WireSegment >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _ShapeFix.NCollection_Sequence_ShapeFix_WireSegment_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _ShapeFix.new_NCollection_Sequence_ShapeFix_WireSegment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_ShapeFix_WireSegment self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.NCollection_Sequence_ShapeFix_WireSegment_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_ShapeFix_WireSegment self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.NCollection_Sequence_ShapeFix_WireSegment_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_ShapeFix_WireSegment self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.NCollection_Sequence_ShapeFix_WireSegment_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_ShapeFix_WireSegment self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.NCollection_Sequence_ShapeFix_WireSegment_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_ShapeFix_WireSegment self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.NCollection_Sequence_ShapeFix_WireSegment_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_ShapeFix_WireSegment self)

        Reverse sequence


        """
        return _ShapeFix.NCollection_Sequence_ShapeFix_WireSegment_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_ShapeFix_WireSegment self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _ShapeFix.NCollection_Sequence_ShapeFix_WireSegment_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _ShapeFix.NCollection_Sequence_ShapeFix_WireSegment_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_ShapeFix_WireSegment self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _ShapeFix.NCollection_Sequence_ShapeFix_WireSegment_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_ShapeFix_WireSegment self, NCollection_Sequence_ShapeFix_WireSegment theOther) -> NCollection_Sequence_ShapeFix_WireSegment

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ShapeFix.NCollection_Sequence_ShapeFix_WireSegment_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_ShapeFix_WireSegment self, NCollection_Sequence_ShapeFix_WireSegment theOther) -> NCollection_Sequence_ShapeFix_WireSegment

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ShapeFix.NCollection_Sequence_ShapeFix_WireSegment_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_ShapeFix_WireSegment self, NCollection_Sequence< ShapeFix_WireSegment >::Iterator & thePosition)
        Remove(NCollection_Sequence_ShapeFix_WireSegment self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_ShapeFix_WireSegment self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _ShapeFix.NCollection_Sequence_ShapeFix_WireSegment_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_ShapeFix_WireSegment self, ShapeFix_WireSegment theItem)
        Append(NCollection_Sequence_ShapeFix_WireSegment self, NCollection_Sequence_ShapeFix_WireSegment theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ShapeFix.NCollection_Sequence_ShapeFix_WireSegment_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_ShapeFix_WireSegment self, ShapeFix_WireSegment theItem)
        Prepend(NCollection_Sequence_ShapeFix_WireSegment self, NCollection_Sequence_ShapeFix_WireSegment theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ShapeFix.NCollection_Sequence_ShapeFix_WireSegment_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_ShapeFix_WireSegment self, Standard_Integer const theIndex, ShapeFix_WireSegment theItem)
        InsertBefore(NCollection_Sequence_ShapeFix_WireSegment self, Standard_Integer const theIndex, NCollection_Sequence_ShapeFix_WireSegment theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ShapeFix.NCollection_Sequence_ShapeFix_WireSegment_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_ShapeFix_WireSegment self, NCollection_Sequence< ShapeFix_WireSegment >::Iterator & thePosition, ShapeFix_WireSegment theItem)
        InsertAfter(NCollection_Sequence_ShapeFix_WireSegment self, Standard_Integer const theIndex, NCollection_Sequence_ShapeFix_WireSegment theSeq)
        InsertAfter(NCollection_Sequence_ShapeFix_WireSegment self, Standard_Integer const theIndex, ShapeFix_WireSegment theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _ShapeFix.NCollection_Sequence_ShapeFix_WireSegment_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_ShapeFix_WireSegment self, Standard_Integer const theIndex, NCollection_Sequence_ShapeFix_WireSegment theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _ShapeFix.NCollection_Sequence_ShapeFix_WireSegment_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _ShapeFix.NCollection_Sequence_ShapeFix_WireSegment_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_ShapeFix_WireSegment self) -> ShapeFix_WireSegment

        First item access

        :rtype: TheItemType &

        """
        return _ShapeFix.NCollection_Sequence_ShapeFix_WireSegment_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _ShapeFix.NCollection_Sequence_ShapeFix_WireSegment_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_ShapeFix_WireSegment self) -> ShapeFix_WireSegment

        Last item access

        :rtype: TheItemType &

        """
        return _ShapeFix.NCollection_Sequence_ShapeFix_WireSegment_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _ShapeFix.NCollection_Sequence_ShapeFix_WireSegment_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_ShapeFix_WireSegment self, Standard_Integer const theIndex) -> ShapeFix_WireSegment

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _ShapeFix.NCollection_Sequence_ShapeFix_WireSegment_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _ShapeFix.NCollection_Sequence_ShapeFix_WireSegment___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_ShapeFix_WireSegment self, Standard_Integer const theIndex, ShapeFix_WireSegment theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _ShapeFix.NCollection_Sequence_ShapeFix_WireSegment_SetValue(self, *args)


    def __iter__(self):
        return _ShapeFix.NCollection_Sequence_ShapeFix_WireSegment___iter__(self)
    __swig_destroy__ = _ShapeFix.delete_NCollection_Sequence_ShapeFix_WireSegment
NCollection_Sequence_ShapeFix_WireSegment_swigregister = _ShapeFix.NCollection_Sequence_ShapeFix_WireSegment_swigregister
NCollection_Sequence_ShapeFix_WireSegment_swigregister(NCollection_Sequence_ShapeFix_WireSegment)

def NCollection_Sequence_ShapeFix_WireSegment_delNode(*args):
    """
    NCollection_Sequence_ShapeFix_WireSegment_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _ShapeFix.NCollection_Sequence_ShapeFix_WireSegment_delNode(*args)

class NCollection_Sequence_ShapeFix_WireSegment_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _ShapeFix.new_NCollection_Sequence_ShapeFix_WireSegment_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ShapeFix.delete_NCollection_Sequence_ShapeFix_WireSegment_IteratorHelper

    def __next__(self):
        return _ShapeFix.NCollection_Sequence_ShapeFix_WireSegment_IteratorHelper___next__(self)
NCollection_Sequence_ShapeFix_WireSegment_IteratorHelper_swigregister = _ShapeFix.NCollection_Sequence_ShapeFix_WireSegment_IteratorHelper_swigregister
NCollection_Sequence_ShapeFix_WireSegment_IteratorHelper_swigregister(NCollection_Sequence_ShapeFix_WireSegment_IteratorHelper)


try:
	ShapeFix_SequenceOfWireSegment = NCollection_Sequence_ShapeFix_WireSegment
except NameError:
	pass # does not exist, probably ignored

class Handle_ShapeFix_FixSmallFace(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeFix_FixSmallFace self)

        Nullify the handle


        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeFix_FixSmallFace self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeFix_FixSmallFace self, ShapeFix_FixSmallFace thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeFix_FixSmallFace self, Handle_ShapeFix_FixSmallFace theHandle) -> Handle_ShapeFix_FixSmallFace
        assign(Handle_ShapeFix_FixSmallFace self, ShapeFix_FixSmallFace thePtr) -> Handle_ShapeFix_FixSmallFace
        assign(Handle_ShapeFix_FixSmallFace self, Handle_ShapeFix_FixSmallFace theHandle) -> Handle_ShapeFix_FixSmallFace

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeFix_FixSmallFace self) -> ShapeFix_FixSmallFace

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeFix_FixSmallFace self) -> ShapeFix_FixSmallFace

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeFix_FixSmallFace self) -> ShapeFix_FixSmallFace

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace___ref__(self, *args)


    def __hash__(self):
        return _ShapeFix.Handle_ShapeFix_FixSmallFace___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeFix.Handle_ShapeFix_FixSmallFace___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeFix.new_Handle_ShapeFix_FixSmallFace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeFix.Handle_ShapeFix_FixSmallFace_DownCast)
    __swig_destroy__ = _ShapeFix.delete_Handle_ShapeFix_FixSmallFace

    def Init(self, *args):
        """
        Init(Handle_ShapeFix_FixSmallFace self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_Init(self, *args)


    def Perform(self, *args):
        """
        Perform(Handle_ShapeFix_FixSmallFace self)

        Fixing case of spot face


        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_Perform(self, *args)


    def FixSpotFace(self, *args):
        """
        FixSpotFace(Handle_ShapeFix_FixSmallFace self) -> TopoDS_Shape

        Fixing case of spot face, if tol = -1 used local tolerance.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_FixSpotFace(self, *args)


    def ReplaceVerticesInCaseOfSpot(self, *args):
        """
        ReplaceVerticesInCaseOfSpot(Handle_ShapeFix_FixSmallFace self, TopoDS_Face F, Standard_Real const tol) -> Standard_Boolean

        Compute average vertex and replacing vertices by new one.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_ReplaceVerticesInCaseOfSpot(self, *args)


    def RemoveFacesInCaseOfSpot(self, *args):
        """
        RemoveFacesInCaseOfSpot(Handle_ShapeFix_FixSmallFace self, TopoDS_Face F) -> Standard_Boolean

        Remove spot face from compound

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_RemoveFacesInCaseOfSpot(self, *args)


    def FixStripFace(self, *args):
        """
        FixStripFace(Handle_ShapeFix_FixSmallFace self, Standard_Boolean const wasdone) -> TopoDS_Shape

        Fixing case of strip face, if tol = -1 used local tolerance

        :type wasdone: bool
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_FixStripFace(self, *args)


    def ReplaceInCaseOfStrip(self, *args):
        """
        ReplaceInCaseOfStrip(Handle_ShapeFix_FixSmallFace self, TopoDS_Face F, TopoDS_Edge E1, TopoDS_Edge E2, Standard_Real const tol) -> Standard_Boolean

        Replace veretces and edges.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type E1: OCC.wrapper.TopoDS.TopoDS_Edge
        :type E2: OCC.wrapper.TopoDS.TopoDS_Edge
        :type tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_ReplaceInCaseOfStrip(self, *args)


    def RemoveFacesInCaseOfStrip(self, *args):
        """
        RemoveFacesInCaseOfStrip(Handle_ShapeFix_FixSmallFace self, TopoDS_Face F) -> Standard_Boolean

        Remove strip face from compound.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_RemoveFacesInCaseOfStrip(self, *args)


    def ComputeSharedEdgeForStripFace(self, *args):
        """
        ComputeSharedEdgeForStripFace(Handle_ShapeFix_FixSmallFace self, TopoDS_Face F, TopoDS_Edge E1, TopoDS_Edge E2, TopoDS_Face F1, Standard_Real const tol) -> TopoDS_Edge

        Compute average edge for strip face

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type E1: OCC.wrapper.TopoDS.TopoDS_Edge
        :type E2: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type tol: float
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_ComputeSharedEdgeForStripFace(self, *args)


    def FixSplitFace(self, *args):
        """
        FixSplitFace(Handle_ShapeFix_FixSmallFace self, TopoDS_Shape S) -> TopoDS_Shape

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_FixSplitFace(self, *args)


    def SplitOneFace(self, *args):
        """
        SplitOneFace(Handle_ShapeFix_FixSmallFace self, TopoDS_Face F, TopoDS_Compound theSplittedFaces) -> Standard_Boolean

        Compute data for face splitting.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type theSplittedFaces: OCC.wrapper.TopoDS.TopoDS_Compound
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_SplitOneFace(self, *args)


    def FixFace(self, *args):
        """
        FixFace(Handle_ShapeFix_FixSmallFace self, TopoDS_Face F) -> TopoDS_Face

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_FixFace(self, *args)


    def FixShape(self, *args):
        """
        FixShape(Handle_ShapeFix_FixSmallFace self) -> TopoDS_Shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_FixShape(self, *args)


    def Shape(self, *args):
        """
        Shape(Handle_ShapeFix_FixSmallFace self) -> TopoDS_Shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_Shape(self, *args)


    def FixPinFace(self, *args):
        """
        FixPinFace(Handle_ShapeFix_FixSmallFace self, TopoDS_Face F) -> Standard_Boolean

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_FixPinFace(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeFix_FixSmallFace self) -> char const *

        :rtype: const char *

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.Handle_ShapeFix_FixSmallFace_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.Handle_ShapeFix_FixSmallFace_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_ShapeFix_FixSmallFace self, Handle_ShapeFix_Root Root)

        Copy all fields from another Root object

        :type Root: OCC.wrapper.ShapeFix.Handle_ShapeFix_Root

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_Set(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_ShapeFix_FixSmallFace self, Handle_ShapeBuild_ReShape context)

        Sets context

        :type context: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_SetContext(self, *args)


    def Context(self, *args):
        """
        Context(Handle_ShapeFix_FixSmallFace self) -> Handle_ShapeBuild_ReShape

        Returns context

        :rtype: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_Context(self, *args)


    def SetMsgRegistrator(self, *args):
        """
        SetMsgRegistrator(Handle_ShapeFix_FixSmallFace self, Handle_ShapeExtend_BasicMsgRegistrator msgreg)

        Sets message registrator

        :type msgreg: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_SetMsgRegistrator(self, *args)


    def MsgRegistrator(self, *args):
        """
        MsgRegistrator(Handle_ShapeFix_FixSmallFace self) -> Handle_ShapeExtend_BasicMsgRegistrator

        Returns message registrator

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_MsgRegistrator(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(Handle_ShapeFix_FixSmallFace self, Standard_Real const preci)

        Sets basic precision value

        :type preci: float

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_SetPrecision(self, *args)


    def Precision(self, *args):
        """
        Precision(Handle_ShapeFix_FixSmallFace self) -> Standard_Real

        Returns basic precision value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_Precision(self, *args)


    def SetMinTolerance(self, *args):
        """
        SetMinTolerance(Handle_ShapeFix_FixSmallFace self, Standard_Real const mintol)

        Sets minimal allowed tolerance

        :type mintol: float

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_SetMinTolerance(self, *args)


    def MinTolerance(self, *args):
        """
        MinTolerance(Handle_ShapeFix_FixSmallFace self) -> Standard_Real

        Returns minimal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_MinTolerance(self, *args)


    def SetMaxTolerance(self, *args):
        """
        SetMaxTolerance(Handle_ShapeFix_FixSmallFace self, Standard_Real const maxtol)

        Sets maximal allowed tolerance

        :type maxtol: float

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_SetMaxTolerance(self, *args)


    def MaxTolerance(self, *args):
        """
        MaxTolerance(Handle_ShapeFix_FixSmallFace self) -> Standard_Real

        Returns maximal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_MaxTolerance(self, *args)


    def LimitTolerance(self, *args):
        """
        LimitTolerance(Handle_ShapeFix_FixSmallFace self, Standard_Real const toler) -> Standard_Real

        Returns tolerance limited by [myMinTol,myMaxTol]

        :type toler: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_LimitTolerance(self, *args)


    def SendMsg(self, *args):
        """
        SendMsg(Handle_ShapeFix_FixSmallFace self, TopoDS_Shape shape, Message_Msg message, Message_Gravity const gravity=Message_Info)
        SendMsg(Handle_ShapeFix_FixSmallFace self, Message_Msg message, Message_Gravity const gravity=Message_Info)

        Sends a message to be attached to myShape.
        Calls previous method.

        :type message: OCC.wrapper.Message.Message_Msg
        :type gravity: OCC.wrapper.Message.Message_Gravity

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_SendMsg(self, *args)


    def SendWarning(self, *args):
        """
        SendWarning(Handle_ShapeFix_FixSmallFace self, TopoDS_Shape shape, Message_Msg message)
        SendWarning(Handle_ShapeFix_FixSmallFace self, Message_Msg message)

        Calls previous method for myShape.

        :type message: OCC.wrapper.Message.Message_Msg

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_SendWarning(self, *args)


    def SendFail(self, *args):
        """
        SendFail(Handle_ShapeFix_FixSmallFace self, TopoDS_Shape shape, Message_Msg message)
        SendFail(Handle_ShapeFix_FixSmallFace self, Message_Msg message)

        Calls previous method for myShape.

        :type message: OCC.wrapper.Message.Message_Msg

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_SendFail(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeFix_FixSmallFace self)

        Memory deallocator for transient classes


        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeFix_FixSmallFace self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeFix_FixSmallFace self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeFix_FixSmallFace self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeFix_FixSmallFace self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeFix_FixSmallFace self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeFix_FixSmallFace self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeFix_FixSmallFace self)

        Increments the reference counter of this object


        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeFix_FixSmallFace self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallFace_DecrementRefCounter(self, *args)

Handle_ShapeFix_FixSmallFace_swigregister = _ShapeFix.Handle_ShapeFix_FixSmallFace_swigregister
Handle_ShapeFix_FixSmallFace_swigregister(Handle_ShapeFix_FixSmallFace)

def Handle_ShapeFix_FixSmallFace_DownCast(thing):
    return _ShapeFix.Handle_ShapeFix_FixSmallFace_DownCast(thing)
Handle_ShapeFix_FixSmallFace_DownCast = _ShapeFix.Handle_ShapeFix_FixSmallFace_DownCast

class Handle_ShapeFix_FixSmallSolid(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeFix_FixSmallSolid self)

        Nullify the handle


        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeFix_FixSmallSolid self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeFix_FixSmallSolid self, ShapeFix_FixSmallSolid thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeFix_FixSmallSolid self, Handle_ShapeFix_FixSmallSolid theHandle) -> Handle_ShapeFix_FixSmallSolid
        assign(Handle_ShapeFix_FixSmallSolid self, ShapeFix_FixSmallSolid thePtr) -> Handle_ShapeFix_FixSmallSolid
        assign(Handle_ShapeFix_FixSmallSolid self, Handle_ShapeFix_FixSmallSolid theHandle) -> Handle_ShapeFix_FixSmallSolid

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeFix_FixSmallSolid self) -> ShapeFix_FixSmallSolid

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeFix_FixSmallSolid self) -> ShapeFix_FixSmallSolid

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeFix_FixSmallSolid self) -> ShapeFix_FixSmallSolid

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid___ref__(self, *args)


    def __hash__(self):
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeFix.Handle_ShapeFix_FixSmallSolid___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeFix.new_Handle_ShapeFix_FixSmallSolid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeFix.Handle_ShapeFix_FixSmallSolid_DownCast)
    __swig_destroy__ = _ShapeFix.delete_Handle_ShapeFix_FixSmallSolid

    def SetFixMode(self, *args):
        """
        SetFixMode(Handle_ShapeFix_FixSmallSolid self, Standard_Integer const theMode)

        Set working mode for operator:
        - theMode = 0 use both WidthFactorThreshold and VolumeThreshold parameters
        - theMode = 1 use only WidthFactorThreshold parameter
        - theMode = 2 use only VolumeThreshold parameter

        :type theMode: int

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid_SetFixMode(self, *args)


    def SetVolumeThreshold(self, *args):
        """
        SetVolumeThreshold(Handle_ShapeFix_FixSmallSolid self, Standard_Real const theThreshold=-1.0)

        Set or clear volume threshold for small solids

        :type theThreshold: float

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid_SetVolumeThreshold(self, *args)


    def SetWidthFactorThreshold(self, *args):
        """
        SetWidthFactorThreshold(Handle_ShapeFix_FixSmallSolid self, Standard_Real const theThreshold=-1.0)

        Set or clear width factor threshold for small solids

        :type theThreshold: float

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid_SetWidthFactorThreshold(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_ShapeFix_FixSmallSolid self, TopoDS_Shape theShape, Handle_ShapeBuild_ReShape theContext) -> TopoDS_Shape

        Remove small solids from the given shape

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theContext: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid_Remove(self, *args)


    def Merge(self, *args):
        """
        Merge(Handle_ShapeFix_FixSmallSolid self, TopoDS_Shape theShape, Handle_ShapeBuild_ReShape theContext) -> TopoDS_Shape

        Merge small solids in the given shape to adjacent non-small ones

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theContext: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid_Merge(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeFix_FixSmallSolid self) -> char const *

        :rtype: const char *

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.Handle_ShapeFix_FixSmallSolid_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.Handle_ShapeFix_FixSmallSolid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_ShapeFix_FixSmallSolid self, Handle_ShapeFix_Root Root)

        Copy all fields from another Root object

        :type Root: OCC.wrapper.ShapeFix.Handle_ShapeFix_Root

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid_Set(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_ShapeFix_FixSmallSolid self, Handle_ShapeBuild_ReShape context)

        Sets context

        :type context: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid_SetContext(self, *args)


    def Context(self, *args):
        """
        Context(Handle_ShapeFix_FixSmallSolid self) -> Handle_ShapeBuild_ReShape

        Returns context

        :rtype: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid_Context(self, *args)


    def SetMsgRegistrator(self, *args):
        """
        SetMsgRegistrator(Handle_ShapeFix_FixSmallSolid self, Handle_ShapeExtend_BasicMsgRegistrator msgreg)

        Sets message registrator

        :type msgreg: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid_SetMsgRegistrator(self, *args)


    def MsgRegistrator(self, *args):
        """
        MsgRegistrator(Handle_ShapeFix_FixSmallSolid self) -> Handle_ShapeExtend_BasicMsgRegistrator

        Returns message registrator

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid_MsgRegistrator(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(Handle_ShapeFix_FixSmallSolid self, Standard_Real const preci)

        Sets basic precision value

        :type preci: float

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid_SetPrecision(self, *args)


    def Precision(self, *args):
        """
        Precision(Handle_ShapeFix_FixSmallSolid self) -> Standard_Real

        Returns basic precision value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid_Precision(self, *args)


    def SetMinTolerance(self, *args):
        """
        SetMinTolerance(Handle_ShapeFix_FixSmallSolid self, Standard_Real const mintol)

        Sets minimal allowed tolerance

        :type mintol: float

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid_SetMinTolerance(self, *args)


    def MinTolerance(self, *args):
        """
        MinTolerance(Handle_ShapeFix_FixSmallSolid self) -> Standard_Real

        Returns minimal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid_MinTolerance(self, *args)


    def SetMaxTolerance(self, *args):
        """
        SetMaxTolerance(Handle_ShapeFix_FixSmallSolid self, Standard_Real const maxtol)

        Sets maximal allowed tolerance

        :type maxtol: float

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid_SetMaxTolerance(self, *args)


    def MaxTolerance(self, *args):
        """
        MaxTolerance(Handle_ShapeFix_FixSmallSolid self) -> Standard_Real

        Returns maximal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid_MaxTolerance(self, *args)


    def LimitTolerance(self, *args):
        """
        LimitTolerance(Handle_ShapeFix_FixSmallSolid self, Standard_Real const toler) -> Standard_Real

        Returns tolerance limited by [myMinTol,myMaxTol]

        :type toler: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid_LimitTolerance(self, *args)


    def SendMsg(self, *args):
        """
        SendMsg(Handle_ShapeFix_FixSmallSolid self, TopoDS_Shape shape, Message_Msg message, Message_Gravity const gravity=Message_Info)
        SendMsg(Handle_ShapeFix_FixSmallSolid self, Message_Msg message, Message_Gravity const gravity=Message_Info)

        Sends a message to be attached to myShape.
        Calls previous method.

        :type message: OCC.wrapper.Message.Message_Msg
        :type gravity: OCC.wrapper.Message.Message_Gravity

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid_SendMsg(self, *args)


    def SendWarning(self, *args):
        """
        SendWarning(Handle_ShapeFix_FixSmallSolid self, TopoDS_Shape shape, Message_Msg message)
        SendWarning(Handle_ShapeFix_FixSmallSolid self, Message_Msg message)

        Calls previous method for myShape.

        :type message: OCC.wrapper.Message.Message_Msg

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid_SendWarning(self, *args)


    def SendFail(self, *args):
        """
        SendFail(Handle_ShapeFix_FixSmallSolid self, TopoDS_Shape shape, Message_Msg message)
        SendFail(Handle_ShapeFix_FixSmallSolid self, Message_Msg message)

        Calls previous method for myShape.

        :type message: OCC.wrapper.Message.Message_Msg

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid_SendFail(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeFix_FixSmallSolid self)

        Memory deallocator for transient classes


        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeFix_FixSmallSolid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeFix_FixSmallSolid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeFix_FixSmallSolid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeFix_FixSmallSolid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeFix_FixSmallSolid self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeFix_FixSmallSolid self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeFix_FixSmallSolid self)

        Increments the reference counter of this object


        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeFix_FixSmallSolid self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_FixSmallSolid_DecrementRefCounter(self, *args)

Handle_ShapeFix_FixSmallSolid_swigregister = _ShapeFix.Handle_ShapeFix_FixSmallSolid_swigregister
Handle_ShapeFix_FixSmallSolid_swigregister(Handle_ShapeFix_FixSmallSolid)

def Handle_ShapeFix_FixSmallSolid_DownCast(thing):
    return _ShapeFix.Handle_ShapeFix_FixSmallSolid_DownCast(thing)
Handle_ShapeFix_FixSmallSolid_DownCast = _ShapeFix.Handle_ShapeFix_FixSmallSolid_DownCast

class Handle_ShapeFix_Solid(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeFix_Solid self)

        Nullify the handle


        """
        return _ShapeFix.Handle_ShapeFix_Solid_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeFix_Solid self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeFix.Handle_ShapeFix_Solid_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeFix_Solid self, ShapeFix_Solid thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeFix.Handle_ShapeFix_Solid_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeFix_Solid self, Handle_ShapeFix_Solid theHandle) -> Handle_ShapeFix_Solid
        assign(Handle_ShapeFix_Solid self, ShapeFix_Solid thePtr) -> Handle_ShapeFix_Solid
        assign(Handle_ShapeFix_Solid self, Handle_ShapeFix_Solid theHandle) -> Handle_ShapeFix_Solid

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeFix.Handle_ShapeFix_Solid_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeFix_Solid self) -> ShapeFix_Solid

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeFix.Handle_ShapeFix_Solid_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeFix_Solid self) -> ShapeFix_Solid

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeFix.Handle_ShapeFix_Solid___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeFix_Solid self) -> ShapeFix_Solid

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeFix.Handle_ShapeFix_Solid___ref__(self, *args)


    def __hash__(self):
        return _ShapeFix.Handle_ShapeFix_Solid___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeFix.Handle_ShapeFix_Solid___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeFix.new_Handle_ShapeFix_Solid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeFix.Handle_ShapeFix_Solid_DownCast)
    __swig_destroy__ = _ShapeFix.delete_Handle_ShapeFix_Solid

    def Init(self, *args):
        """
        Init(Handle_ShapeFix_Solid self, TopoDS_Solid solid)

        Initializes by solid .

        :type solid: OCC.wrapper.TopoDS.TopoDS_Solid

        """
        return _ShapeFix.Handle_ShapeFix_Solid_Init(self, *args)


    def Perform(self, *args):
        """
        Perform(Handle_ShapeFix_Solid self, Handle_Message_ProgressIndicator theProgress=0) -> Standard_Boolean

        Iterates on shells and performs fixes
        (calls ShapeFix_Shell for each subshell). The passed
        progress indicator allows user to consult the current
        progress stage and abort algorithm if needed.

        :type theProgress: OCC.wrapper.Message.Handle_Message_ProgressIndicator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Solid_Perform(self, *args)


    def SolidFromShell(self, *args):
        """
        SolidFromShell(Handle_ShapeFix_Solid self, TopoDS_Shell shell) -> TopoDS_Solid

        Calls MakeSolid and orients the solid to be "not infinite"

        :type shell: OCC.wrapper.TopoDS.TopoDS_Shell
        :rtype: OCC.wrapper.TopoDS.TopoDS_Solid

        """
        return _ShapeFix.Handle_ShapeFix_Solid_SolidFromShell(self, *args)


    def Status(self, *args):
        """
        Status(Handle_ShapeFix_Solid self, ShapeExtend_Status const status) -> Standard_Boolean

        Returns the status of the last Fix.

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Solid_Status(self, *args)


    def Solid(self, *args):
        """
        Solid(Handle_ShapeFix_Solid self) -> TopoDS_Shape

        Returns resulting solid.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.Handle_ShapeFix_Solid_Solid(self, *args)


    def FixShellTool(self, *args):
        """
        FixShellTool(Handle_ShapeFix_Solid self) -> Handle_ShapeFix_Shell

        Returns tool for fixing shells.

        :rtype: OCC.wrapper.ShapeFix.Handle_ShapeFix_Shell

        """
        return _ShapeFix.Handle_ShapeFix_Solid_FixShellTool(self, *args)


    def SetMsgRegistrator(self, *args):
        """
        SetMsgRegistrator(Handle_ShapeFix_Solid self, Handle_ShapeExtend_BasicMsgRegistrator msgreg)

        Sets message registrator

        :type msgreg: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeFix.Handle_ShapeFix_Solid_SetMsgRegistrator(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(Handle_ShapeFix_Solid self, Standard_Real const preci)

        Sets basic precision value (also to FixShellTool)

        :type preci: float

        """
        return _ShapeFix.Handle_ShapeFix_Solid_SetPrecision(self, *args)


    def SetMinTolerance(self, *args):
        """
        SetMinTolerance(Handle_ShapeFix_Solid self, Standard_Real const mintol)

        Sets minimal allowed tolerance (also to FixShellTool)

        :type mintol: float

        """
        return _ShapeFix.Handle_ShapeFix_Solid_SetMinTolerance(self, *args)


    def SetMaxTolerance(self, *args):
        """
        SetMaxTolerance(Handle_ShapeFix_Solid self, Standard_Real const maxtol)

        Sets maximal allowed tolerance (also to FixShellTool)

        :type maxtol: float

        """
        return _ShapeFix.Handle_ShapeFix_Solid_SetMaxTolerance(self, *args)


    def FixShellMode(self, *args):
        """
        FixShellMode(Handle_ShapeFix_Solid self) -> Standard_Integer &

        Returns (modifiable) the mode for applying fixes of
        ShapeFix_Shell, by default True.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Solid_FixShellMode(self, *args)


    def FixShellOrientationMode(self, *args):
        """
        FixShellOrientationMode(Handle_ShapeFix_Solid self) -> Standard_Integer &

        Returns (modifiable) the mode for applying analysis and fixes of
        orientation of shells in the solid; by default True.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Solid_FixShellOrientationMode(self, *args)


    def CreateOpenSolidMode(self, *args):
        """
        CreateOpenSolidMode(Handle_ShapeFix_Solid self) -> Standard_Boolean &

        Returns (modifiable) the mode for creation of solids.
        If mode myCreateOpenSolidMode is equal to true
        solids are created from open shells
        else solids are created  from closed shells only.
        ShapeFix_Shell, by default False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Solid_CreateOpenSolidMode(self, *args)


    def Shape(self, *args):
        """
        Shape(Handle_ShapeFix_Solid self) -> TopoDS_Shape

        In case of multiconnexity returns compound of fixed solids
        else returns one solid.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.Handle_ShapeFix_Solid_Shape(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeFix_Solid self) -> char const *

        :rtype: const char *

        """
        return _ShapeFix.Handle_ShapeFix_Solid_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.Handle_ShapeFix_Solid_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.Handle_ShapeFix_Solid_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_ShapeFix_Solid self, Handle_ShapeFix_Root Root)

        Copy all fields from another Root object

        :type Root: OCC.wrapper.ShapeFix.Handle_ShapeFix_Root

        """
        return _ShapeFix.Handle_ShapeFix_Solid_Set(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_ShapeFix_Solid self, Handle_ShapeBuild_ReShape context)

        Sets context

        :type context: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeFix.Handle_ShapeFix_Solid_SetContext(self, *args)


    def Context(self, *args):
        """
        Context(Handle_ShapeFix_Solid self) -> Handle_ShapeBuild_ReShape

        Returns context

        :rtype: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeFix.Handle_ShapeFix_Solid_Context(self, *args)


    def MsgRegistrator(self, *args):
        """
        MsgRegistrator(Handle_ShapeFix_Solid self) -> Handle_ShapeExtend_BasicMsgRegistrator

        Returns message registrator

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeFix.Handle_ShapeFix_Solid_MsgRegistrator(self, *args)


    def Precision(self, *args):
        """
        Precision(Handle_ShapeFix_Solid self) -> Standard_Real

        Returns basic precision value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_Solid_Precision(self, *args)


    def MinTolerance(self, *args):
        """
        MinTolerance(Handle_ShapeFix_Solid self) -> Standard_Real

        Returns minimal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_Solid_MinTolerance(self, *args)


    def MaxTolerance(self, *args):
        """
        MaxTolerance(Handle_ShapeFix_Solid self) -> Standard_Real

        Returns maximal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_Solid_MaxTolerance(self, *args)


    def LimitTolerance(self, *args):
        """
        LimitTolerance(Handle_ShapeFix_Solid self, Standard_Real const toler) -> Standard_Real

        Returns tolerance limited by [myMinTol,myMaxTol]

        :type toler: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_Solid_LimitTolerance(self, *args)


    def SendMsg(self, *args):
        """
        SendMsg(Handle_ShapeFix_Solid self, TopoDS_Shape shape, Message_Msg message, Message_Gravity const gravity=Message_Info)
        SendMsg(Handle_ShapeFix_Solid self, Message_Msg message, Message_Gravity const gravity=Message_Info)

        Sends a message to be attached to myShape.
        Calls previous method.

        :type message: OCC.wrapper.Message.Message_Msg
        :type gravity: OCC.wrapper.Message.Message_Gravity

        """
        return _ShapeFix.Handle_ShapeFix_Solid_SendMsg(self, *args)


    def SendWarning(self, *args):
        """
        SendWarning(Handle_ShapeFix_Solid self, TopoDS_Shape shape, Message_Msg message)
        SendWarning(Handle_ShapeFix_Solid self, Message_Msg message)

        Calls previous method for myShape.

        :type message: OCC.wrapper.Message.Message_Msg

        """
        return _ShapeFix.Handle_ShapeFix_Solid_SendWarning(self, *args)


    def SendFail(self, *args):
        """
        SendFail(Handle_ShapeFix_Solid self, TopoDS_Shape shape, Message_Msg message)
        SendFail(Handle_ShapeFix_Solid self, Message_Msg message)

        Calls previous method for myShape.

        :type message: OCC.wrapper.Message.Message_Msg

        """
        return _ShapeFix.Handle_ShapeFix_Solid_SendFail(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeFix_Solid self)

        Memory deallocator for transient classes


        """
        return _ShapeFix.Handle_ShapeFix_Solid_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeFix_Solid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeFix_Solid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Solid_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeFix_Solid self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeFix_Solid self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Solid_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeFix_Solid self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeFix.Handle_ShapeFix_Solid_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeFix_Solid self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Solid_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeFix_Solid self)

        Increments the reference counter of this object


        """
        return _ShapeFix.Handle_ShapeFix_Solid_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeFix_Solid self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Solid_DecrementRefCounter(self, *args)

Handle_ShapeFix_Solid_swigregister = _ShapeFix.Handle_ShapeFix_Solid_swigregister
Handle_ShapeFix_Solid_swigregister(Handle_ShapeFix_Solid)

def Handle_ShapeFix_Solid_DownCast(thing):
    return _ShapeFix.Handle_ShapeFix_Solid_DownCast(thing)
Handle_ShapeFix_Solid_DownCast = _ShapeFix.Handle_ShapeFix_Solid_DownCast

class Handle_ShapeFix_Face(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeFix_Face self)

        Nullify the handle


        """
        return _ShapeFix.Handle_ShapeFix_Face_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeFix_Face self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeFix.Handle_ShapeFix_Face_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeFix_Face self, ShapeFix_Face thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeFix.Handle_ShapeFix_Face_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeFix_Face self, Handle_ShapeFix_Face theHandle) -> Handle_ShapeFix_Face
        assign(Handle_ShapeFix_Face self, ShapeFix_Face thePtr) -> Handle_ShapeFix_Face
        assign(Handle_ShapeFix_Face self, Handle_ShapeFix_Face theHandle) -> Handle_ShapeFix_Face

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeFix.Handle_ShapeFix_Face_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeFix_Face self) -> ShapeFix_Face

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeFix.Handle_ShapeFix_Face_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeFix_Face self) -> ShapeFix_Face

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeFix.Handle_ShapeFix_Face___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeFix_Face self) -> ShapeFix_Face

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeFix.Handle_ShapeFix_Face___ref__(self, *args)


    def __hash__(self):
        return _ShapeFix.Handle_ShapeFix_Face___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeFix.Handle_ShapeFix_Face___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeFix.new_Handle_ShapeFix_Face(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeFix.Handle_ShapeFix_Face_DownCast)
    __swig_destroy__ = _ShapeFix.delete_Handle_ShapeFix_Face

    def ClearModes(self, *args):
        """
        ClearModes(Handle_ShapeFix_Face self)

        Sets all modes to default


        """
        return _ShapeFix.Handle_ShapeFix_Face_ClearModes(self, *args)


    def Init(self, *args):
        """
        Init(Handle_ShapeFix_Face self, TopoDS_Face face)
        Init(Handle_ShapeFix_Face self, Handle_Geom_Surface surf, Standard_Real const preci, Standard_Boolean const fwd)
        Init(Handle_ShapeFix_Face self, Handle_ShapeAnalysis_Surface surf, Standard_Real const preci, Standard_Boolean const fwd)

        Starts the creation of the face
        By default it will be FORWARD, or REVERSED if <fwd> is False

        :type surf: OCC.wrapper.ShapeAnalysis.Handle_ShapeAnalysis_Surface
        :type preci: float
        :type fwd: bool

        """
        return _ShapeFix.Handle_ShapeFix_Face_Init(self, *args)


    def SetMsgRegistrator(self, *args):
        """
        SetMsgRegistrator(Handle_ShapeFix_Face self, Handle_ShapeExtend_BasicMsgRegistrator msgreg)

        Sets message registrator

        :type msgreg: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeFix.Handle_ShapeFix_Face_SetMsgRegistrator(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(Handle_ShapeFix_Face self, Standard_Real const preci)

        Sets basic precision value (also to FixWireTool)

        :type preci: float

        """
        return _ShapeFix.Handle_ShapeFix_Face_SetPrecision(self, *args)


    def SetMinTolerance(self, *args):
        """
        SetMinTolerance(Handle_ShapeFix_Face self, Standard_Real const mintol)

        Sets minimal allowed tolerance (also to FixWireTool)

        :type mintol: float

        """
        return _ShapeFix.Handle_ShapeFix_Face_SetMinTolerance(self, *args)


    def SetMaxTolerance(self, *args):
        """
        SetMaxTolerance(Handle_ShapeFix_Face self, Standard_Real const maxtol)

        Sets maximal allowed tolerance (also to FixWireTool)

        :type maxtol: float

        """
        return _ShapeFix.Handle_ShapeFix_Face_SetMaxTolerance(self, *args)


    def FixWireMode(self, *args):
        """
        FixWireMode(Handle_ShapeFix_Face self) -> Standard_Integer &

        Returns (modifiable) the mode for applying fixes of
        ShapeFix_Wire, by default True.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Face_FixWireMode(self, *args)


    def FixOrientationMode(self, *args):
        """
        FixOrientationMode(Handle_ShapeFix_Face self) -> Standard_Integer &

        Returns (modifiable) the fix orientation mode, by default
        True. If True, wires oriented to border limited square.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Face_FixOrientationMode(self, *args)


    def FixAddNaturalBoundMode(self, *args):
        """
        FixAddNaturalBoundMode(Handle_ShapeFix_Face self) -> Standard_Integer &

        Returns (modifiable) the add natural bound mode.
        If true, natural boundary is added on faces that miss them.
        Default is False for faces with single wire (they are
        handled by FixOrientation in that case) and True for others.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Face_FixAddNaturalBoundMode(self, *args)


    def FixMissingSeamMode(self, *args):
        """
        FixMissingSeamMode(Handle_ShapeFix_Face self) -> Standard_Integer &

        Returns (modifiable) the fix missing seam mode, by default
        True. If True, tries to insert seam is missed.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Face_FixMissingSeamMode(self, *args)


    def FixSmallAreaWireMode(self, *args):
        """
        FixSmallAreaWireMode(Handle_ShapeFix_Face self) -> Standard_Integer &

        Returns (modifiable) the fix small area wire mode, by default
        False. If True, drops small wires.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Face_FixSmallAreaWireMode(self, *args)


    def RemoveSmallAreaFaceMode(self, *args):
        """
        RemoveSmallAreaFaceMode(Handle_ShapeFix_Face self) -> Standard_Integer &

        Returns (modifiable) the remove face with small area, by default
        False. If True, drops faces with small outer wires.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Face_RemoveSmallAreaFaceMode(self, *args)


    def FixIntersectingWiresMode(self, *args):
        """
        FixIntersectingWiresMode(Handle_ShapeFix_Face self) -> Standard_Integer &

        Returns (modifiable) the fix intersecting wires mode
        by default True.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Face_FixIntersectingWiresMode(self, *args)


    def FixLoopWiresMode(self, *args):
        """
        FixLoopWiresMode(Handle_ShapeFix_Face self) -> Standard_Integer &

        Returns (modifiable) the fix loop wires mode
        by default True.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Face_FixLoopWiresMode(self, *args)


    def FixSplitFaceMode(self, *args):
        """
        FixSplitFaceMode(Handle_ShapeFix_Face self) -> Standard_Integer &

        Returns (modifiable) the fix split face mode
        by default True.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Face_FixSplitFaceMode(self, *args)


    def AutoCorrectPrecisionMode(self, *args):
        """
        AutoCorrectPrecisionMode(Handle_ShapeFix_Face self) -> Standard_Integer &

        Returns (modifiable) the auto-correct precision mode
        by default False.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Face_AutoCorrectPrecisionMode(self, *args)


    def FixPeriodicDegeneratedMode(self, *args):
        """
        FixPeriodicDegeneratedMode(Handle_ShapeFix_Face self) -> Standard_Integer &

        Returns (modifiable) the activation flag for periodic
        degenerated fix. False by default.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Face_FixPeriodicDegeneratedMode(self, *args)


    def Face(self, *args):
        """
        Face(Handle_ShapeFix_Face self) -> TopoDS_Face

        Returns a face which corresponds to the current state
        Warning: The finally produced face may be another one ... but with the
        same support

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _ShapeFix.Handle_ShapeFix_Face_Face(self, *args)


    def Result(self, *args):
        """
        Result(Handle_ShapeFix_Face self) -> TopoDS_Shape

        Returns resulting shape (Face or Shell if splitted)
        To be used instead of Face() if FixMissingSeam involved

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.Handle_ShapeFix_Face_Result(self, *args)


    def Add(self, *args):
        """
        Add(Handle_ShapeFix_Face self, TopoDS_Wire wire)

        Add a wire to current face using BRep_Builder.
        Wire is added without taking into account orientation of face
        (as if face were FORWARD).

        :type wire: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _ShapeFix.Handle_ShapeFix_Face_Add(self, *args)


    def Perform(self, *args):
        """
        Perform(Handle_ShapeFix_Face self) -> Standard_Boolean

        Performs all the fixes, depending on modes
        Function Status returns the status of last call to Perform()
        ShapeExtend_OK   : face was OK, nothing done
        ShapeExtend_DONE1: some wires are fixed
        ShapeExtend_DONE2: orientation of wires fixed
        ShapeExtend_DONE3: missing seam added
        ShapeExtend_DONE4: small area wire removed
        ShapeExtend_DONE5: natural bounds added
        ShapeExtend_FAIL1: some fails during fixing wires
        ShapeExtend_FAIL2: cannot fix orientation of wires
        ShapeExtend_FAIL3: cannot add missing seam
        ShapeExtend_FAIL4: cannot remove small area wire

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Face_Perform(self, *args)


    def FixOrientation(self, *args):
        """
        FixOrientation(Handle_ShapeFix_Face self) -> Standard_Boolean
        FixOrientation(Handle_ShapeFix_Face self, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher MapWires) -> Standard_Boolean

        Fixes orientation of wires on the face
        It tries to make all wires lie outside all others (according
        to orientation) by reversing orientation of some of them.
        If face lying on sphere or torus has single wire and
        AddNaturalBoundMode is True, that wire is not reversed in
        any case (supposing that natural bound will be added).
        Returns True if wires were reversed
        OutWires return information about out wires + list of
        internal wires for each (for performing split face).

        :type MapWires: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Face_FixOrientation(self, *args)


    def FixAddNaturalBound(self, *args):
        """
        FixAddNaturalBound(Handle_ShapeFix_Face self) -> Standard_Boolean

        Adds natural boundary on face if it is missing.
        Two cases are supported:
        - face has no wires
        - face lies on geometrically double-closed surface
        (sphere or torus) and none of wires is left-oriented
        Returns True if natural boundary was added

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Face_FixAddNaturalBound(self, *args)


    def FixMissingSeam(self, *args):
        """
        FixMissingSeam(Handle_ShapeFix_Face self) -> Standard_Boolean

        Detects and fixes the special case when face on a closed
        surface is given by two wires closed in 3d but with gap in 2d.
        In that case it creates a new wire from the two, and adds a
        missing seam edge
        Returns True if missing seam was added

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Face_FixMissingSeam(self, *args)


    def FixSmallAreaWire(self, *args):
        """
        FixSmallAreaWire(Handle_ShapeFix_Face self, Standard_Boolean const theIsRemoveSmallFace) -> Standard_Boolean

        Detects wires with small area (that is less than
        100*Precision::PConfusion(). Removes these wires if they are internal.
        Returns : True if at least one small wire removed,
        False if does nothing.

        :type theIsRemoveSmallFace: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Face_FixSmallAreaWire(self, *args)


    def FixLoopWire(self, *args):
        """
        FixLoopWire(Handle_ShapeFix_Face self, NCollection_Sequence_TopoDS_Shape aResWires) -> Standard_Boolean

        Detects if wire has a loop and fixes this situation by splitting on the few parts.
        if wire has a loops and it was splitted Status was set to value ShapeExtend_DONE6.

        :type aResWires: OCC.wrapper.TopTools.TopTools_SequenceOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Face_FixLoopWire(self, *args)


    def FixIntersectingWires(self, *args):
        """
        FixIntersectingWires(Handle_ShapeFix_Face self) -> Standard_Boolean

        Detects and fixes the special case when face has more than one wire
        and this wires have intersection point

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Face_FixIntersectingWires(self, *args)


    def FixWiresTwoCoincEdges(self, *args):
        """
        FixWiresTwoCoincEdges(Handle_ShapeFix_Face self) -> Standard_Boolean

        If wire contains two coincidence edges it must be removed
        Queries on status after Perform()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Face_FixWiresTwoCoincEdges(self, *args)


    def FixSplitFace(self, *args):
        """
        FixSplitFace(Handle_ShapeFix_Face self, NCollection_DataMap_TopoDS_Shape_TopTools_ListOfShape_TopTools_ShapeMapHasher MapWires) -> Standard_Boolean

        Split face if there are more than one out wire
        using inrormation after FixOrientation()

        :type MapWires: OCC.wrapper.TopTools.TopTools_DataMapOfShapeListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Face_FixSplitFace(self, *args)


    def FixPeriodicDegenerated(self, *args):
        """
        FixPeriodicDegenerated(Handle_ShapeFix_Face self) -> Standard_Boolean

        Fixes topology for a specific case when face is composed
        by a single wire belting a periodic surface. In that case
        a degenerated edge is reconstructed in the degenerated pole
        of the surface. Initial wire gets consistent orientation.
        Must be used in couple and before FixMissingSeam routine

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Face_FixPeriodicDegenerated(self, *args)


    def Status(self, *args):
        """
        Status(Handle_ShapeFix_Face self, ShapeExtend_Status const status) -> Standard_Boolean

        Returns the status of last call to Perform()
        ShapeExtend_OK   : face was OK, nothing done
        ShapeExtend_DONE1: some wires are fixed
        ShapeExtend_DONE2: orientation of wires fixed
        ShapeExtend_DONE3: missing seam added
        ShapeExtend_DONE4: small area wire removed
        ShapeExtend_DONE5: natural bounds added
        ShapeExtend_DONE8: face may be splited
        ShapeExtend_FAIL1: some fails during fixing wires
        ShapeExtend_FAIL2: cannot fix orientation of wires
        ShapeExtend_FAIL3: cannot add missing seam
        ShapeExtend_FAIL4: cannot remove small area wire

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Face_Status(self, *args)


    def FixWireTool(self, *args):
        """
        FixWireTool(Handle_ShapeFix_Face self) -> Handle_ShapeFix_Wire

        Returns tool for fixing wires.

        :rtype: OCC.wrapper.ShapeFix.Handle_ShapeFix_Wire

        """
        return _ShapeFix.Handle_ShapeFix_Face_FixWireTool(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeFix_Face self) -> char const *

        :rtype: const char *

        """
        return _ShapeFix.Handle_ShapeFix_Face_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.Handle_ShapeFix_Face_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.Handle_ShapeFix_Face_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_ShapeFix_Face self, Handle_ShapeFix_Root Root)

        Copy all fields from another Root object

        :type Root: OCC.wrapper.ShapeFix.Handle_ShapeFix_Root

        """
        return _ShapeFix.Handle_ShapeFix_Face_Set(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_ShapeFix_Face self, Handle_ShapeBuild_ReShape context)

        Sets context

        :type context: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeFix.Handle_ShapeFix_Face_SetContext(self, *args)


    def Context(self, *args):
        """
        Context(Handle_ShapeFix_Face self) -> Handle_ShapeBuild_ReShape

        Returns context

        :rtype: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeFix.Handle_ShapeFix_Face_Context(self, *args)


    def MsgRegistrator(self, *args):
        """
        MsgRegistrator(Handle_ShapeFix_Face self) -> Handle_ShapeExtend_BasicMsgRegistrator

        Returns message registrator

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeFix.Handle_ShapeFix_Face_MsgRegistrator(self, *args)


    def Precision(self, *args):
        """
        Precision(Handle_ShapeFix_Face self) -> Standard_Real

        Returns basic precision value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_Face_Precision(self, *args)


    def MinTolerance(self, *args):
        """
        MinTolerance(Handle_ShapeFix_Face self) -> Standard_Real

        Returns minimal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_Face_MinTolerance(self, *args)


    def MaxTolerance(self, *args):
        """
        MaxTolerance(Handle_ShapeFix_Face self) -> Standard_Real

        Returns maximal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_Face_MaxTolerance(self, *args)


    def LimitTolerance(self, *args):
        """
        LimitTolerance(Handle_ShapeFix_Face self, Standard_Real const toler) -> Standard_Real

        Returns tolerance limited by [myMinTol,myMaxTol]

        :type toler: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_Face_LimitTolerance(self, *args)


    def SendMsg(self, *args):
        """
        SendMsg(Handle_ShapeFix_Face self, TopoDS_Shape shape, Message_Msg message, Message_Gravity const gravity=Message_Info)
        SendMsg(Handle_ShapeFix_Face self, Message_Msg message, Message_Gravity const gravity=Message_Info)

        Sends a message to be attached to myShape.
        Calls previous method.

        :type message: OCC.wrapper.Message.Message_Msg
        :type gravity: OCC.wrapper.Message.Message_Gravity

        """
        return _ShapeFix.Handle_ShapeFix_Face_SendMsg(self, *args)


    def SendWarning(self, *args):
        """
        SendWarning(Handle_ShapeFix_Face self, TopoDS_Shape shape, Message_Msg message)
        SendWarning(Handle_ShapeFix_Face self, Message_Msg message)

        Calls previous method for myShape.

        :type message: OCC.wrapper.Message.Message_Msg

        """
        return _ShapeFix.Handle_ShapeFix_Face_SendWarning(self, *args)


    def SendFail(self, *args):
        """
        SendFail(Handle_ShapeFix_Face self, TopoDS_Shape shape, Message_Msg message)
        SendFail(Handle_ShapeFix_Face self, Message_Msg message)

        Calls previous method for myShape.

        :type message: OCC.wrapper.Message.Message_Msg

        """
        return _ShapeFix.Handle_ShapeFix_Face_SendFail(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeFix_Face self)

        Memory deallocator for transient classes


        """
        return _ShapeFix.Handle_ShapeFix_Face_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeFix_Face self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeFix_Face self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Face_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeFix_Face self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeFix_Face self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Face_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeFix_Face self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeFix.Handle_ShapeFix_Face_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeFix_Face self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Face_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeFix_Face self)

        Increments the reference counter of this object


        """
        return _ShapeFix.Handle_ShapeFix_Face_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeFix_Face self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Face_DecrementRefCounter(self, *args)

Handle_ShapeFix_Face_swigregister = _ShapeFix.Handle_ShapeFix_Face_swigregister
Handle_ShapeFix_Face_swigregister(Handle_ShapeFix_Face)

def Handle_ShapeFix_Face_DownCast(thing):
    return _ShapeFix.Handle_ShapeFix_Face_DownCast(thing)
Handle_ShapeFix_Face_DownCast = _ShapeFix.Handle_ShapeFix_Face_DownCast

class Handle_ShapeFix_Shape(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeFix_Shape self)

        Nullify the handle


        """
        return _ShapeFix.Handle_ShapeFix_Shape_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeFix_Shape self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeFix.Handle_ShapeFix_Shape_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeFix_Shape self, ShapeFix_Shape thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeFix.Handle_ShapeFix_Shape_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeFix_Shape self, Handle_ShapeFix_Shape theHandle) -> Handle_ShapeFix_Shape
        assign(Handle_ShapeFix_Shape self, ShapeFix_Shape thePtr) -> Handle_ShapeFix_Shape
        assign(Handle_ShapeFix_Shape self, Handle_ShapeFix_Shape theHandle) -> Handle_ShapeFix_Shape

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeFix.Handle_ShapeFix_Shape_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeFix_Shape self) -> ShapeFix_Shape

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeFix.Handle_ShapeFix_Shape_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeFix_Shape self) -> ShapeFix_Shape

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeFix.Handle_ShapeFix_Shape___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeFix_Shape self) -> ShapeFix_Shape

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeFix.Handle_ShapeFix_Shape___ref__(self, *args)


    def __hash__(self):
        return _ShapeFix.Handle_ShapeFix_Shape___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeFix.Handle_ShapeFix_Shape___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeFix.new_Handle_ShapeFix_Shape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeFix.Handle_ShapeFix_Shape_DownCast)
    __swig_destroy__ = _ShapeFix.delete_Handle_ShapeFix_Shape

    def Init(self, *args):
        """
        Init(Handle_ShapeFix_Shape self, TopoDS_Shape shape)

        Initislises by shape.

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.Handle_ShapeFix_Shape_Init(self, *args)


    def Perform(self, *args):
        """
        Perform(Handle_ShapeFix_Shape self, Handle_Message_ProgressIndicator theProgress=0) -> Standard_Boolean

        Iterates on sub- shape and performs fixes

        :type theProgress: OCC.wrapper.Message.Handle_Message_ProgressIndicator
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Shape_Perform(self, *args)


    def Shape(self, *args):
        """
        Shape(Handle_ShapeFix_Shape self) -> TopoDS_Shape

        Returns resulting shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.Handle_ShapeFix_Shape_Shape(self, *args)


    def FixSolidTool(self, *args):
        """
        FixSolidTool(Handle_ShapeFix_Shape self) -> Handle_ShapeFix_Solid

        Returns tool for fixing solids.

        :rtype: OCC.wrapper.ShapeFix.Handle_ShapeFix_Solid

        """
        return _ShapeFix.Handle_ShapeFix_Shape_FixSolidTool(self, *args)


    def FixShellTool(self, *args):
        """
        FixShellTool(Handle_ShapeFix_Shape self) -> Handle_ShapeFix_Shell

        Returns tool for fixing shells.

        :rtype: OCC.wrapper.ShapeFix.Handle_ShapeFix_Shell

        """
        return _ShapeFix.Handle_ShapeFix_Shape_FixShellTool(self, *args)


    def FixFaceTool(self, *args):
        """
        FixFaceTool(Handle_ShapeFix_Shape self) -> Handle_ShapeFix_Face

        Returns tool for fixing faces.

        :rtype: OCC.wrapper.ShapeFix.Handle_ShapeFix_Face

        """
        return _ShapeFix.Handle_ShapeFix_Shape_FixFaceTool(self, *args)


    def FixWireTool(self, *args):
        """
        FixWireTool(Handle_ShapeFix_Shape self) -> Handle_ShapeFix_Wire

        Returns tool for fixing wires.

        :rtype: OCC.wrapper.ShapeFix.Handle_ShapeFix_Wire

        """
        return _ShapeFix.Handle_ShapeFix_Shape_FixWireTool(self, *args)


    def FixEdgeTool(self, *args):
        """
        FixEdgeTool(Handle_ShapeFix_Shape self) -> Handle_ShapeFix_Edge

        Returns tool for fixing edges.

        :rtype: OCC.wrapper.ShapeFix.Handle_ShapeFix_Edge

        """
        return _ShapeFix.Handle_ShapeFix_Shape_FixEdgeTool(self, *args)


    def Status(self, *args):
        """
        Status(Handle_ShapeFix_Shape self, ShapeExtend_Status const status) -> Standard_Boolean

        Returns the status of the last Fix.
        This can be a combination of the following flags:
        ShapeExtend_DONE1: some free edges were fixed
        ShapeExtend_DONE2: some free wires were fixed
        ShapeExtend_DONE3: some free faces were fixed
        ShapeExtend_DONE4: some free shells were fixed
        ShapeExtend_DONE5: some free solids were fixed
        ShapeExtend_DONE6: shapes in compound(s) were fixed

        :type status: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Shape_Status(self, *args)


    def SetMsgRegistrator(self, *args):
        """
        SetMsgRegistrator(Handle_ShapeFix_Shape self, Handle_ShapeExtend_BasicMsgRegistrator msgreg)

        Sets message registrator

        :type msgreg: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeFix.Handle_ShapeFix_Shape_SetMsgRegistrator(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(Handle_ShapeFix_Shape self, Standard_Real const preci)

        Sets basic precision value (also to FixSolidTool)

        :type preci: float

        """
        return _ShapeFix.Handle_ShapeFix_Shape_SetPrecision(self, *args)


    def SetMinTolerance(self, *args):
        """
        SetMinTolerance(Handle_ShapeFix_Shape self, Standard_Real const mintol)

        Sets minimal allowed tolerance (also to FixSolidTool)

        :type mintol: float

        """
        return _ShapeFix.Handle_ShapeFix_Shape_SetMinTolerance(self, *args)


    def SetMaxTolerance(self, *args):
        """
        SetMaxTolerance(Handle_ShapeFix_Shape self, Standard_Real const maxtol)

        Sets maximal allowed tolerance (also to FixSolidTool)

        :type maxtol: float

        """
        return _ShapeFix.Handle_ShapeFix_Shape_SetMaxTolerance(self, *args)


    def FixSolidMode(self, *args):
        """
        FixSolidMode(Handle_ShapeFix_Shape self) -> Standard_Integer &

        Returns (modifiable) the mode for applying fixes of
        ShapeFix_Solid, by default True.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Shape_FixSolidMode(self, *args)


    def FixFreeShellMode(self, *args):
        """
        FixFreeShellMode(Handle_ShapeFix_Shape self) -> Standard_Integer &

        Returns (modifiable) the mode for applying fixes of
        ShapeFix_Shell, by default True.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Shape_FixFreeShellMode(self, *args)


    def FixFreeFaceMode(self, *args):
        """
        FixFreeFaceMode(Handle_ShapeFix_Shape self) -> Standard_Integer &

        Returns (modifiable) the mode for applying fixes of
        ShapeFix_Face, by default True.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Shape_FixFreeFaceMode(self, *args)


    def FixFreeWireMode(self, *args):
        """
        FixFreeWireMode(Handle_ShapeFix_Shape self) -> Standard_Integer &

        Returns (modifiable) the mode for applying fixes of
        ShapeFix_Wire, by default True.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Shape_FixFreeWireMode(self, *args)


    def FixSameParameterMode(self, *args):
        """
        FixSameParameterMode(Handle_ShapeFix_Shape self) -> Standard_Integer &

        Returns (modifiable) the mode for applying
        ShapeFix::SameParameter after all fixes, by default True.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Shape_FixSameParameterMode(self, *args)


    def FixVertexPositionMode(self, *args):
        """
        FixVertexPositionMode(Handle_ShapeFix_Shape self) -> Standard_Integer &

        Returns (modifiable) the mode for applying
        ShapeFix::FixVertexPosition before all fixes, by default False.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Shape_FixVertexPositionMode(self, *args)


    def FixVertexTolMode(self, *args):
        """
        FixVertexTolMode(Handle_ShapeFix_Shape self) -> Standard_Integer &

        Returns (modifiable) the mode for fixing tolerances of vertices on whole shape
        after performing all fixes

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Shape_FixVertexTolMode(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeFix_Shape self) -> char const *

        :rtype: const char *

        """
        return _ShapeFix.Handle_ShapeFix_Shape_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.Handle_ShapeFix_Shape_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.Handle_ShapeFix_Shape_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_ShapeFix_Shape self, Handle_ShapeFix_Root Root)

        Copy all fields from another Root object

        :type Root: OCC.wrapper.ShapeFix.Handle_ShapeFix_Root

        """
        return _ShapeFix.Handle_ShapeFix_Shape_Set(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_ShapeFix_Shape self, Handle_ShapeBuild_ReShape context)

        Sets context

        :type context: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeFix.Handle_ShapeFix_Shape_SetContext(self, *args)


    def Context(self, *args):
        """
        Context(Handle_ShapeFix_Shape self) -> Handle_ShapeBuild_ReShape

        Returns context

        :rtype: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeFix.Handle_ShapeFix_Shape_Context(self, *args)


    def MsgRegistrator(self, *args):
        """
        MsgRegistrator(Handle_ShapeFix_Shape self) -> Handle_ShapeExtend_BasicMsgRegistrator

        Returns message registrator

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeFix.Handle_ShapeFix_Shape_MsgRegistrator(self, *args)


    def Precision(self, *args):
        """
        Precision(Handle_ShapeFix_Shape self) -> Standard_Real

        Returns basic precision value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_Shape_Precision(self, *args)


    def MinTolerance(self, *args):
        """
        MinTolerance(Handle_ShapeFix_Shape self) -> Standard_Real

        Returns minimal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_Shape_MinTolerance(self, *args)


    def MaxTolerance(self, *args):
        """
        MaxTolerance(Handle_ShapeFix_Shape self) -> Standard_Real

        Returns maximal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_Shape_MaxTolerance(self, *args)


    def LimitTolerance(self, *args):
        """
        LimitTolerance(Handle_ShapeFix_Shape self, Standard_Real const toler) -> Standard_Real

        Returns tolerance limited by [myMinTol,myMaxTol]

        :type toler: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_Shape_LimitTolerance(self, *args)


    def SendMsg(self, *args):
        """
        SendMsg(Handle_ShapeFix_Shape self, TopoDS_Shape shape, Message_Msg message, Message_Gravity const gravity=Message_Info)
        SendMsg(Handle_ShapeFix_Shape self, Message_Msg message, Message_Gravity const gravity=Message_Info)

        Sends a message to be attached to myShape.
        Calls previous method.

        :type message: OCC.wrapper.Message.Message_Msg
        :type gravity: OCC.wrapper.Message.Message_Gravity

        """
        return _ShapeFix.Handle_ShapeFix_Shape_SendMsg(self, *args)


    def SendWarning(self, *args):
        """
        SendWarning(Handle_ShapeFix_Shape self, TopoDS_Shape shape, Message_Msg message)
        SendWarning(Handle_ShapeFix_Shape self, Message_Msg message)

        Calls previous method for myShape.

        :type message: OCC.wrapper.Message.Message_Msg

        """
        return _ShapeFix.Handle_ShapeFix_Shape_SendWarning(self, *args)


    def SendFail(self, *args):
        """
        SendFail(Handle_ShapeFix_Shape self, TopoDS_Shape shape, Message_Msg message)
        SendFail(Handle_ShapeFix_Shape self, Message_Msg message)

        Calls previous method for myShape.

        :type message: OCC.wrapper.Message.Message_Msg

        """
        return _ShapeFix.Handle_ShapeFix_Shape_SendFail(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeFix_Shape self)

        Memory deallocator for transient classes


        """
        return _ShapeFix.Handle_ShapeFix_Shape_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeFix_Shape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeFix_Shape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Shape_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeFix_Shape self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeFix_Shape self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_Shape_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeFix_Shape self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeFix.Handle_ShapeFix_Shape_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeFix_Shape self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Shape_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeFix_Shape self)

        Increments the reference counter of this object


        """
        return _ShapeFix.Handle_ShapeFix_Shape_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeFix_Shape self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_Shape_DecrementRefCounter(self, *args)

Handle_ShapeFix_Shape_swigregister = _ShapeFix.Handle_ShapeFix_Shape_swigregister
Handle_ShapeFix_Shape_swigregister(Handle_ShapeFix_Shape)

def Handle_ShapeFix_Shape_DownCast(thing):
    return _ShapeFix.Handle_ShapeFix_Shape_DownCast(thing)
Handle_ShapeFix_Shape_DownCast = _ShapeFix.Handle_ShapeFix_Shape_DownCast

class Handle_ShapeFix_SplitCommonVertex(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeFix_SplitCommonVertex self)

        Nullify the handle


        """
        return _ShapeFix.Handle_ShapeFix_SplitCommonVertex_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeFix_SplitCommonVertex self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeFix.Handle_ShapeFix_SplitCommonVertex_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeFix_SplitCommonVertex self, ShapeFix_SplitCommonVertex thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeFix.Handle_ShapeFix_SplitCommonVertex_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeFix_SplitCommonVertex self, Handle_ShapeFix_SplitCommonVertex theHandle) -> Handle_ShapeFix_SplitCommonVertex
        assign(Handle_ShapeFix_SplitCommonVertex self, ShapeFix_SplitCommonVertex thePtr) -> Handle_ShapeFix_SplitCommonVertex
        assign(Handle_ShapeFix_SplitCommonVertex self, Handle_ShapeFix_SplitCommonVertex theHandle) -> Handle_ShapeFix_SplitCommonVertex

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeFix.Handle_ShapeFix_SplitCommonVertex_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeFix_SplitCommonVertex self) -> ShapeFix_SplitCommonVertex

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeFix.Handle_ShapeFix_SplitCommonVertex_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeFix_SplitCommonVertex self) -> ShapeFix_SplitCommonVertex

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeFix.Handle_ShapeFix_SplitCommonVertex___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeFix_SplitCommonVertex self) -> ShapeFix_SplitCommonVertex

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeFix.Handle_ShapeFix_SplitCommonVertex___ref__(self, *args)


    def __hash__(self):
        return _ShapeFix.Handle_ShapeFix_SplitCommonVertex___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeFix.Handle_ShapeFix_SplitCommonVertex___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeFix.new_Handle_ShapeFix_SplitCommonVertex(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeFix.Handle_ShapeFix_SplitCommonVertex_DownCast)
    __swig_destroy__ = _ShapeFix.delete_Handle_ShapeFix_SplitCommonVertex

    def Init(self, *args):
        """
        Init(Handle_ShapeFix_SplitCommonVertex self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.Handle_ShapeFix_SplitCommonVertex_Init(self, *args)


    def Perform(self, *args):
        """Perform(Handle_ShapeFix_SplitCommonVertex self)"""
        return _ShapeFix.Handle_ShapeFix_SplitCommonVertex_Perform(self, *args)


    def Shape(self, *args):
        """
        Shape(Handle_ShapeFix_SplitCommonVertex self) -> TopoDS_Shape

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeFix.Handle_ShapeFix_SplitCommonVertex_Shape(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeFix_SplitCommonVertex self) -> char const *

        :rtype: const char *

        """
        return _ShapeFix.Handle_ShapeFix_SplitCommonVertex_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.Handle_ShapeFix_SplitCommonVertex_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeFix.Handle_ShapeFix_SplitCommonVertex_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_ShapeFix_SplitCommonVertex self, Handle_ShapeFix_Root Root)

        Copy all fields from another Root object

        :type Root: OCC.wrapper.ShapeFix.Handle_ShapeFix_Root

        """
        return _ShapeFix.Handle_ShapeFix_SplitCommonVertex_Set(self, *args)


    def SetContext(self, *args):
        """
        SetContext(Handle_ShapeFix_SplitCommonVertex self, Handle_ShapeBuild_ReShape context)

        Sets context

        :type context: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeFix.Handle_ShapeFix_SplitCommonVertex_SetContext(self, *args)


    def Context(self, *args):
        """
        Context(Handle_ShapeFix_SplitCommonVertex self) -> Handle_ShapeBuild_ReShape

        Returns context

        :rtype: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeFix.Handle_ShapeFix_SplitCommonVertex_Context(self, *args)


    def SetMsgRegistrator(self, *args):
        """
        SetMsgRegistrator(Handle_ShapeFix_SplitCommonVertex self, Handle_ShapeExtend_BasicMsgRegistrator msgreg)

        Sets message registrator

        :type msgreg: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeFix.Handle_ShapeFix_SplitCommonVertex_SetMsgRegistrator(self, *args)


    def MsgRegistrator(self, *args):
        """
        MsgRegistrator(Handle_ShapeFix_SplitCommonVertex self) -> Handle_ShapeExtend_BasicMsgRegistrator

        Returns message registrator

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeFix.Handle_ShapeFix_SplitCommonVertex_MsgRegistrator(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(Handle_ShapeFix_SplitCommonVertex self, Standard_Real const preci)

        Sets basic precision value

        :type preci: float

        """
        return _ShapeFix.Handle_ShapeFix_SplitCommonVertex_SetPrecision(self, *args)


    def Precision(self, *args):
        """
        Precision(Handle_ShapeFix_SplitCommonVertex self) -> Standard_Real

        Returns basic precision value

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_SplitCommonVertex_Precision(self, *args)


    def SetMinTolerance(self, *args):
        """
        SetMinTolerance(Handle_ShapeFix_SplitCommonVertex self, Standard_Real const mintol)

        Sets minimal allowed tolerance

        :type mintol: float

        """
        return _ShapeFix.Handle_ShapeFix_SplitCommonVertex_SetMinTolerance(self, *args)


    def MinTolerance(self, *args):
        """
        MinTolerance(Handle_ShapeFix_SplitCommonVertex self) -> Standard_Real

        Returns minimal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_SplitCommonVertex_MinTolerance(self, *args)


    def SetMaxTolerance(self, *args):
        """
        SetMaxTolerance(Handle_ShapeFix_SplitCommonVertex self, Standard_Real const maxtol)

        Sets maximal allowed tolerance

        :type maxtol: float

        """
        return _ShapeFix.Handle_ShapeFix_SplitCommonVertex_SetMaxTolerance(self, *args)


    def MaxTolerance(self, *args):
        """
        MaxTolerance(Handle_ShapeFix_SplitCommonVertex self) -> Standard_Real

        Returns maximal allowed tolerance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_SplitCommonVertex_MaxTolerance(self, *args)


    def LimitTolerance(self, *args):
        """
        LimitTolerance(Handle_ShapeFix_SplitCommonVertex self, Standard_Real const toler) -> Standard_Real

        Returns tolerance limited by [myMinTol,myMaxTol]

        :type toler: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeFix.Handle_ShapeFix_SplitCommonVertex_LimitTolerance(self, *args)


    def SendMsg(self, *args):
        """
        SendMsg(Handle_ShapeFix_SplitCommonVertex self, TopoDS_Shape shape, Message_Msg message, Message_Gravity const gravity=Message_Info)
        SendMsg(Handle_ShapeFix_SplitCommonVertex self, Message_Msg message, Message_Gravity const gravity=Message_Info)

        Sends a message to be attached to myShape.
        Calls previous method.

        :type message: OCC.wrapper.Message.Message_Msg
        :type gravity: OCC.wrapper.Message.Message_Gravity

        """
        return _ShapeFix.Handle_ShapeFix_SplitCommonVertex_SendMsg(self, *args)


    def SendWarning(self, *args):
        """
        SendWarning(Handle_ShapeFix_SplitCommonVertex self, TopoDS_Shape shape, Message_Msg message)
        SendWarning(Handle_ShapeFix_SplitCommonVertex self, Message_Msg message)

        Calls previous method for myShape.

        :type message: OCC.wrapper.Message.Message_Msg

        """
        return _ShapeFix.Handle_ShapeFix_SplitCommonVertex_SendWarning(self, *args)


    def SendFail(self, *args):
        """
        SendFail(Handle_ShapeFix_SplitCommonVertex self, TopoDS_Shape shape, Message_Msg message)
        SendFail(Handle_ShapeFix_SplitCommonVertex self, Message_Msg message)

        Calls previous method for myShape.

        :type message: OCC.wrapper.Message.Message_Msg

        """
        return _ShapeFix.Handle_ShapeFix_SplitCommonVertex_SendFail(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeFix_SplitCommonVertex self)

        Memory deallocator for transient classes


        """
        return _ShapeFix.Handle_ShapeFix_SplitCommonVertex_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeFix_SplitCommonVertex self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeFix_SplitCommonVertex self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_SplitCommonVertex_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeFix_SplitCommonVertex self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeFix_SplitCommonVertex self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.Handle_ShapeFix_SplitCommonVertex_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeFix_SplitCommonVertex self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeFix.Handle_ShapeFix_SplitCommonVertex_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeFix_SplitCommonVertex self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_SplitCommonVertex_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeFix_SplitCommonVertex self)

        Increments the reference counter of this object


        """
        return _ShapeFix.Handle_ShapeFix_SplitCommonVertex_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeFix_SplitCommonVertex self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeFix.Handle_ShapeFix_SplitCommonVertex_DecrementRefCounter(self, *args)

Handle_ShapeFix_SplitCommonVertex_swigregister = _ShapeFix.Handle_ShapeFix_SplitCommonVertex_swigregister
Handle_ShapeFix_SplitCommonVertex_swigregister(Handle_ShapeFix_SplitCommonVertex)

def Handle_ShapeFix_SplitCommonVertex_DownCast(thing):
    return _ShapeFix.Handle_ShapeFix_SplitCommonVertex_DownCast(thing)
Handle_ShapeFix_SplitCommonVertex_DownCast = _ShapeFix.Handle_ShapeFix_SplitCommonVertex_DownCast

class ShapeFix_IntersectionTool(object):
    """
    Tool for fixing selfintersecting wire
    and intersecting wires
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ShapeFix_IntersectionTool self, Handle_ShapeBuild_ReShape context, Standard_Real const preci, Standard_Real const maxtol=1.0) -> ShapeFix_IntersectionTool

        Constructor

        :type context: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape
        :type preci: float
        :type maxtol: float

        """
        this = _ShapeFix.new_ShapeFix_IntersectionTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Context(self, *args):
        """
        Context(ShapeFix_IntersectionTool self) -> Handle_ShapeBuild_ReShape

        Returns context

        :rtype: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape

        """
        return _ShapeFix.ShapeFix_IntersectionTool_Context(self, *args)


    def SplitEdge(self, *args):
        """
        SplitEdge(ShapeFix_IntersectionTool self, TopoDS_Edge edge, Standard_Real const param, TopoDS_Vertex vert, TopoDS_Face face, TopoDS_Edge newE1, TopoDS_Edge newE2, Standard_Real const preci) -> Standard_Boolean

        Split edge on two new edges using new vertex "vert"
        and "param" - parameter for splitting
        The "face" is necessary for pcurves and using TransferParameterProj

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type param: float
        :type vert: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type face: OCC.wrapper.TopoDS.TopoDS_Face
        :type newE1: OCC.wrapper.TopoDS.TopoDS_Edge
        :type newE2: OCC.wrapper.TopoDS.TopoDS_Edge
        :type preci: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_IntersectionTool_SplitEdge(self, *args)


    def CutEdge(self, *args):
        """
        CutEdge(ShapeFix_IntersectionTool self, TopoDS_Edge edge, Standard_Real const pend, Standard_Real const cut, TopoDS_Face face) -> Standard_Boolean

        Cut edge by parameters pend and cut

        :type edge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type pend: float
        :type cut: float
        :type face: OCC.wrapper.TopoDS.TopoDS_Face
        :type iscutline: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_IntersectionTool_CutEdge(self, *args)


    def FixSelfIntersectWire(self, *args):
        """
        FixSelfIntersectWire(ShapeFix_IntersectionTool self, Handle_ShapeExtend_WireData sewd, TopoDS_Face face) -> Standard_Boolean

        :type sewd: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_WireData
        :type face: OCC.wrapper.TopoDS.TopoDS_Face
        :type NbSplit: int
        :type NbCut: int
        :type NbRemoved: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_IntersectionTool_FixSelfIntersectWire(self, *args)


    def FixIntersectingWires(self, *args):
        """
        FixIntersectingWires(ShapeFix_IntersectionTool self, TopoDS_Face face) -> Standard_Boolean

        :type face: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeFix.ShapeFix_IntersectionTool_FixIntersectingWires(self, *args)

    __swig_destroy__ = _ShapeFix.delete_ShapeFix_IntersectionTool
ShapeFix_IntersectionTool_swigregister = _ShapeFix.ShapeFix_IntersectionTool_swigregister
ShapeFix_IntersectionTool_swigregister(ShapeFix_IntersectionTool)




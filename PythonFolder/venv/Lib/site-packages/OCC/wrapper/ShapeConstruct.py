# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_ShapeConstruct')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_ShapeConstruct')
    _ShapeConstruct = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ShapeConstruct', [dirname(__file__)])
        except ImportError:
            import _ShapeConstruct
            return _ShapeConstruct
        try:
            _mod = imp.load_module('_ShapeConstruct', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _ShapeConstruct = swig_import_helper()
    del swig_import_helper
else:
    import _ShapeConstruct
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ShapeConstruct.delete_SwigPyIterator

    def value(self):
        return _ShapeConstruct.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _ShapeConstruct.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _ShapeConstruct.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _ShapeConstruct.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _ShapeConstruct.SwigPyIterator_equal(self, x)

    def copy(self):
        return _ShapeConstruct.SwigPyIterator_copy(self)

    def next(self):
        return _ShapeConstruct.SwigPyIterator_next(self)

    def __next__(self):
        return _ShapeConstruct.SwigPyIterator___next__(self)

    def previous(self):
        return _ShapeConstruct.SwigPyIterator_previous(self)

    def advance(self, n):
        return _ShapeConstruct.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _ShapeConstruct.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _ShapeConstruct.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _ShapeConstruct.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _ShapeConstruct.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _ShapeConstruct.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _ShapeConstruct.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _ShapeConstruct.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _ShapeConstruct.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_ShapeConstruct.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _ShapeConstruct.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _ShapeConstruct.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ShapeConstruct.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _ShapeConstruct.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _ShapeConstruct.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _ShapeConstruct.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _ShapeConstruct.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_ShapeConstruct.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _ShapeConstruct.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _ShapeConstruct.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ShapeConstruct.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _ShapeConstruct.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _ShapeConstruct.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _ShapeConstruct.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _ShapeConstruct.ptr_to_number(item)
ptr_to_number = _ShapeConstruct.ptr_to_number

def HashCode(*args):
    return _ShapeConstruct.HashCode(*args)
HashCode = _ShapeConstruct.HashCode

def ptr_equal(a, b):
    return _ShapeConstruct.ptr_equal(a, b)
ptr_equal = _ShapeConstruct.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import ShapeAnalysis
else:
    import ShapeAnalysis
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntRes2d
else:
    import IntRes2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import ShapeExtend
else:
    import ShapeExtend
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColGeom
else:
    import TColGeom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepBuilderAPI
else:
    import BRepBuilderAPI
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepTools
else:
    import BRepTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Poly
else:
    import Poly
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TShort
else:
    import TShort
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRep
else:
    import BRep
del _swig_python_version_info
class ShapeConstruct_ProjectCurveOnSurface(Standard.Standard_Transient):
    """
    This tool provides a method for computing pcurve by projecting
    3d curve onto a surface.
    Projection is done by 23 or more points (this number is changed
    for B-Splines according to the following rule:
    the total number of the points is not less than number of spans *
    (degree + 1);
    it is increased recursively starting with 23 and is added with 22
    until the condition is fulfilled).
    Isoparametric cases (if curve corresponds to U=const or V=const on
    the surface) are recognized with the given precision.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeConstruct_ProjectCurveOnSurface
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeConstruct_ProjectCurveOnSurface(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeConstruct_ProjectCurveOnSurface self) -> ShapeConstruct_ProjectCurveOnSurface

        Empty constructor.


        """
        this = _ShapeConstruct.new_ShapeConstruct_ProjectCurveOnSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Init(self, *args):
        """
        Init(ShapeConstruct_ProjectCurveOnSurface self, Handle_Geom_Surface surf, Standard_Real const preci)
        Init(ShapeConstruct_ProjectCurveOnSurface self, Handle_ShapeAnalysis_Surface surf, Standard_Real const preci)

        Initializes the object with all necessary parameters,
        i.e. surface and precision

        :type surf: OCC.wrapper.ShapeAnalysis.Handle_ShapeAnalysis_Surface
        :type preci: float

        """
        return _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_Init(self, *args)


    def SetSurface(self, *args):
        """
        SetSurface(ShapeConstruct_ProjectCurveOnSurface self, Handle_Geom_Surface surf)
        SetSurface(ShapeConstruct_ProjectCurveOnSurface self, Handle_ShapeAnalysis_Surface surf)

        Loads a surface (in the form of ShapeAnalysis_Surface) to project on

        :type surf: OCC.wrapper.ShapeAnalysis.Handle_ShapeAnalysis_Surface

        """
        return _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_SetSurface(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(ShapeConstruct_ProjectCurveOnSurface self, Standard_Real const preci)

        Sets value for current precision

        :type preci: float

        """
        return _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_SetPrecision(self, *args)


    def BuildCurveMode(self, *args):
        """
        BuildCurveMode(ShapeConstruct_ProjectCurveOnSurface self) -> Standard_Boolean &

        Returns (modifiable) the build-curve-3d mode, by default False
        If True, if the projected curve has been recomputed by
        interpolation, the 3d curve is also rebuild by interpolation

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_BuildCurveMode(self, *args)


    def AdjustOverDegenMode(self, *args):
        """
        AdjustOverDegenMode(ShapeConstruct_ProjectCurveOnSurface self) -> Standard_Integer &

        Returns (modifiable) the flag specifying to which side of
        parametrical space adjust part of pcurve which lies on seam.
        This is required in very rare case when 3d curve which is
        to be projected goes partly along the seam on the closed
        surface with singularity (e.g. sphere), goes through the
        degenerated point and paerly lies on internal area of surface.

        If this flag is True, the seam part of such curve will be
        adjusted to the left side of parametric space (on sphere U=0),
        else to the right side (on sphere U=2*PI)
        Default value is True

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_AdjustOverDegenMode(self, *args)


    def Status(self, *args):
        """
        Status(ShapeConstruct_ProjectCurveOnSurface self, ShapeExtend_Status const theStatus) -> Standard_Boolean

        Returns the status of last Peform

        :type theStatus: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_Status(self, *args)


    def Perform(self, *args):
        """
        Perform(ShapeConstruct_ProjectCurveOnSurface self, Handle_Geom_Curve c3d, Standard_Real const First, Standard_Real const Last, Handle_Geom2d_Curve c2d, Standard_Real const TolFirst=-1, Standard_Real const TolLast=-1) -> Standard_Boolean

        Computes the projection of 3d curve onto a surface using the
        specialized algorithm. Returns False if projector fails,
        otherwise, if pcurve computed successfully, returns True.
        The output curve 2D is guaranteed to be same-parameter
        with input curve 3D on the interval [First, Last]. If the output curve
        lies on a direct line the infinite line is returned, in the case
        same-parameter condition is satisfied.
        TolFirst and TolLast are the tolerances at the ends of input curve 3D.

        :type c3d: OCC.wrapper.Geom.Handle_Geom_Curve
        :type First: float
        :type Last: float
        :type c2d: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type TolFirst: float
        :type TolLast: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_Perform(self, *args)


    def PerformByProjLib(self, *args):
        """
        PerformByProjLib(ShapeConstruct_ProjectCurveOnSurface self, Handle_Geom_Curve c3d, Standard_Real const First, Standard_Real const Last, Handle_Geom2d_Curve c2d, GeomAbs_Shape const continuity=GeomAbs_C1, Standard_Integer const maxdeg=12, Standard_Integer const nbinterval=-1) -> Standard_Boolean

        Computes the projection of 3d curve onto a surface using the
        standard algorithm from ProjLib. Returns False if standard
        projector fails or raises an exception or cuts the curve by
        parametrical bounds of the surface. Else, if pcurve computed
        successfully, returns True.
        The continuity, maxdeg and nbinterval are parameters of call
        to Approx_CurveOnSurface. If nbinterval is equal to -1
        (default), this value is computed depending on source 3d curve
        and surface.

        :type c3d: OCC.wrapper.Geom.Handle_Geom_Curve
        :type First: float
        :type Last: float
        :type c2d: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type continuity: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type maxdeg: int
        :type nbinterval: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_PerformByProjLib(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeConstruct.delete_ShapeConstruct_ProjectCurveOnSurface
ShapeConstruct_ProjectCurveOnSurface_swigregister = _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_swigregister
ShapeConstruct_ProjectCurveOnSurface_swigregister(ShapeConstruct_ProjectCurveOnSurface)

def ShapeConstruct_ProjectCurveOnSurface_get_type_name(*args):
    """
    ShapeConstruct_ProjectCurveOnSurface_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_get_type_name(*args)

def ShapeConstruct_ProjectCurveOnSurface_get_type_descriptor(*args):
    """
    ShapeConstruct_ProjectCurveOnSurface_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeConstruct.ShapeConstruct_ProjectCurveOnSurface_get_type_descriptor(*args)

class Handle_ShapeConstruct_ProjectCurveOnSurface(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeConstruct_ProjectCurveOnSurface self)

        Nullify the handle


        """
        return _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeConstruct_ProjectCurveOnSurface self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeConstruct_ProjectCurveOnSurface self, ShapeConstruct_ProjectCurveOnSurface thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeConstruct_ProjectCurveOnSurface self, Handle_ShapeConstruct_ProjectCurveOnSurface theHandle) -> Handle_ShapeConstruct_ProjectCurveOnSurface
        assign(Handle_ShapeConstruct_ProjectCurveOnSurface self, ShapeConstruct_ProjectCurveOnSurface thePtr) -> Handle_ShapeConstruct_ProjectCurveOnSurface
        assign(Handle_ShapeConstruct_ProjectCurveOnSurface self, Handle_ShapeConstruct_ProjectCurveOnSurface theHandle) -> Handle_ShapeConstruct_ProjectCurveOnSurface

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeConstruct_ProjectCurveOnSurface self) -> ShapeConstruct_ProjectCurveOnSurface

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeConstruct_ProjectCurveOnSurface self) -> ShapeConstruct_ProjectCurveOnSurface

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeConstruct_ProjectCurveOnSurface self) -> ShapeConstruct_ProjectCurveOnSurface

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface___ref__(self, *args)


    def __hash__(self):
        return _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeConstruct.new_Handle_ShapeConstruct_ProjectCurveOnSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_DownCast)
    __swig_destroy__ = _ShapeConstruct.delete_Handle_ShapeConstruct_ProjectCurveOnSurface

    def Init(self, *args):
        """
        Init(Handle_ShapeConstruct_ProjectCurveOnSurface self, Handle_Geom_Surface surf, Standard_Real const preci)
        Init(Handle_ShapeConstruct_ProjectCurveOnSurface self, Handle_ShapeAnalysis_Surface surf, Standard_Real const preci)

        Initializes the object with all necessary parameters,
        i.e. surface and precision

        :type surf: OCC.wrapper.ShapeAnalysis.Handle_ShapeAnalysis_Surface
        :type preci: float

        """
        return _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_Init(self, *args)


    def SetSurface(self, *args):
        """
        SetSurface(Handle_ShapeConstruct_ProjectCurveOnSurface self, Handle_Geom_Surface surf)
        SetSurface(Handle_ShapeConstruct_ProjectCurveOnSurface self, Handle_ShapeAnalysis_Surface surf)

        Loads a surface (in the form of ShapeAnalysis_Surface) to project on

        :type surf: OCC.wrapper.ShapeAnalysis.Handle_ShapeAnalysis_Surface

        """
        return _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_SetSurface(self, *args)


    def SetPrecision(self, *args):
        """
        SetPrecision(Handle_ShapeConstruct_ProjectCurveOnSurface self, Standard_Real const preci)

        Sets value for current precision

        :type preci: float

        """
        return _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_SetPrecision(self, *args)


    def BuildCurveMode(self, *args):
        """
        BuildCurveMode(Handle_ShapeConstruct_ProjectCurveOnSurface self) -> Standard_Boolean &

        Returns (modifiable) the build-curve-3d mode, by default False
        If True, if the projected curve has been recomputed by
        interpolation, the 3d curve is also rebuild by interpolation

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_BuildCurveMode(self, *args)


    def AdjustOverDegenMode(self, *args):
        """
        AdjustOverDegenMode(Handle_ShapeConstruct_ProjectCurveOnSurface self) -> Standard_Integer &

        Returns (modifiable) the flag specifying to which side of
        parametrical space adjust part of pcurve which lies on seam.
        This is required in very rare case when 3d curve which is
        to be projected goes partly along the seam on the closed
        surface with singularity (e.g. sphere), goes through the
        degenerated point and paerly lies on internal area of surface.

        If this flag is True, the seam part of such curve will be
        adjusted to the left side of parametric space (on sphere U=0),
        else to the right side (on sphere U=2*PI)
        Default value is True

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_AdjustOverDegenMode(self, *args)


    def Status(self, *args):
        """
        Status(Handle_ShapeConstruct_ProjectCurveOnSurface self, ShapeExtend_Status const theStatus) -> Standard_Boolean

        Returns the status of last Peform

        :type theStatus: OCC.wrapper.ShapeExtend.ShapeExtend_Status
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_Status(self, *args)


    def Perform(self, *args):
        """
        Perform(Handle_ShapeConstruct_ProjectCurveOnSurface self, Handle_Geom_Curve c3d, Standard_Real const First, Standard_Real const Last, Handle_Geom2d_Curve c2d, Standard_Real const TolFirst=-1, Standard_Real const TolLast=-1) -> Standard_Boolean

        Computes the projection of 3d curve onto a surface using the
        specialized algorithm. Returns False if projector fails,
        otherwise, if pcurve computed successfully, returns True.
        The output curve 2D is guaranteed to be same-parameter
        with input curve 3D on the interval [First, Last]. If the output curve
        lies on a direct line the infinite line is returned, in the case
        same-parameter condition is satisfied.
        TolFirst and TolLast are the tolerances at the ends of input curve 3D.

        :type c3d: OCC.wrapper.Geom.Handle_Geom_Curve
        :type First: float
        :type Last: float
        :type c2d: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type TolFirst: float
        :type TolLast: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_Perform(self, *args)


    def PerformByProjLib(self, *args):
        """
        PerformByProjLib(Handle_ShapeConstruct_ProjectCurveOnSurface self, Handle_Geom_Curve c3d, Standard_Real const First, Standard_Real const Last, Handle_Geom2d_Curve c2d, GeomAbs_Shape const continuity=GeomAbs_C1, Standard_Integer const maxdeg=12, Standard_Integer const nbinterval=-1) -> Standard_Boolean

        Computes the projection of 3d curve onto a surface using the
        standard algorithm from ProjLib. Returns False if standard
        projector fails or raises an exception or cuts the curve by
        parametrical bounds of the surface. Else, if pcurve computed
        successfully, returns True.
        The continuity, maxdeg and nbinterval are parameters of call
        to Approx_CurveOnSurface. If nbinterval is equal to -1
        (default), this value is computed depending on source 3d curve
        and surface.

        :type c3d: OCC.wrapper.Geom.Handle_Geom_Curve
        :type First: float
        :type Last: float
        :type c2d: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type continuity: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type maxdeg: int
        :type nbinterval: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_PerformByProjLib(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeConstruct_ProjectCurveOnSurface self) -> char const *

        :rtype: const char *

        """
        return _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_ShapeConstruct_ProjectCurveOnSurface self)

        Memory deallocator for transient classes


        """
        return _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeConstruct_ProjectCurveOnSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeConstruct_ProjectCurveOnSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeConstruct_ProjectCurveOnSurface self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeConstruct_ProjectCurveOnSurface self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeConstruct_ProjectCurveOnSurface self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeConstruct_ProjectCurveOnSurface self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeConstruct_ProjectCurveOnSurface self)

        Increments the reference counter of this object


        """
        return _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeConstruct_ProjectCurveOnSurface self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_DecrementRefCounter(self, *args)

Handle_ShapeConstruct_ProjectCurveOnSurface_swigregister = _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_swigregister
Handle_ShapeConstruct_ProjectCurveOnSurface_swigregister(Handle_ShapeConstruct_ProjectCurveOnSurface)

def Handle_ShapeConstruct_ProjectCurveOnSurface_DownCast(thing):
    return _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_DownCast(thing)
Handle_ShapeConstruct_ProjectCurveOnSurface_DownCast = _ShapeConstruct.Handle_ShapeConstruct_ProjectCurveOnSurface_DownCast

class ShapeConstruct_(object):
    """
    This package provides new algorithms for constructing
    new geometrical objects and topological shapes. It
    complements and extends algorithms available in Open
    CASCADE topological and geometrical toolkist.
    The functionality provided by this package are the
    following:
    projecting curves on surface,
    adjusting curve to have given start and end points. P
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ConvertCurveToBSpline(*args):
        """
        ConvertCurveToBSpline(Handle_Geom_Curve C3D, Standard_Real const First, Standard_Real const Last, Standard_Real const Tol3d, GeomAbs_Shape const Continuity, Standard_Integer const MaxSegments, Standard_Integer const MaxDegree) -> Handle_Geom_BSplineCurve
        ConvertCurveToBSpline(Handle_Geom2d_Curve C2D, Standard_Real const First, Standard_Real const Last, Standard_Real const Tol2d, GeomAbs_Shape const Continuity, Standard_Integer const MaxSegments, Standard_Integer const MaxDegree) -> Handle_Geom2d_BSplineCurve

        :type C2D: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type First: float
        :type Last: float
        :type Tol2d: float
        :type Continuity: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type MaxSegments: int
        :type MaxDegree: int
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

        """
        return _ShapeConstruct.ShapeConstruct__ConvertCurveToBSpline(*args)

    ConvertCurveToBSpline = staticmethod(ConvertCurveToBSpline)

    def ConvertSurfaceToBSpline(*args):
        """
        ConvertSurfaceToBSpline(Handle_Geom_Surface surf, Standard_Real const UF, Standard_Real const UL, Standard_Real const VF, Standard_Real const VL, Standard_Real const Tol3d, GeomAbs_Shape const Continuity, Standard_Integer const MaxSegments, Standard_Integer const MaxDegree) -> Handle_Geom_BSplineSurface

        :type surf: OCC.wrapper.Geom.Handle_Geom_Surface
        :type UF: float
        :type UL: float
        :type VF: float
        :type VL: float
        :type Tol3d: float
        :type Continuity: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type MaxSegments: int
        :type MaxDegree: int
        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineSurface

        """
        return _ShapeConstruct.ShapeConstruct__ConvertSurfaceToBSpline(*args)

    ConvertSurfaceToBSpline = staticmethod(ConvertSurfaceToBSpline)

    def JoinPCurves(*args):
        """
        JoinPCurves(Handle_TopTools_HSequenceOfShape theEdges, TopoDS_Face theFace, TopoDS_Edge theEdge) -> Standard_Boolean

        join pcurves of the <theEdge> on the <theFace>
        try to use pcurves from originas edges <theEdges>
        Returns false if cannot join pcurves

        :type theEdges: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeConstruct.ShapeConstruct__JoinPCurves(*args)

    JoinPCurves = staticmethod(JoinPCurves)

    def JoinCurves(*args):
        """
        JoinCurves(Handle_Geom_Curve c3d1, Handle_Geom_Curve ac3d2, TopAbs_Orientation const Orient1, TopAbs_Orientation const Orient2, Handle_Geom_Curve c3dOut) -> Standard_Boolean
        JoinCurves(Handle_Geom2d_Curve c2d1, Handle_Geom2d_Curve ac2d2, TopAbs_Orientation const Orient1, TopAbs_Orientation const Orient2, Handle_Geom2d_Curve c2dOut, Standard_Boolean const isError) -> Standard_Boolean

        Method for joininig curves 3D.
        Parameters : c3d1,ac3d2 - initial curves
        Orient1, Orient2 - initial edges orientations.
        first1,last1,first2,last2 - parameters for trimming curves
        (re-calculate with account of orientation edges)
        c3dOut - result curve
        isRev1,isRev2 - out parameters indicative on possible errors.
        isError - input parameter indicative possible errors due to that one from edges have one vertex
        Return value : True - if curves were joined successfully,
        else - False.

        :type c2d1: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type ac2d2: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Orient1: OCC.wrapper.TopAbs.TopAbs_Orientation
        :type Orient2: OCC.wrapper.TopAbs.TopAbs_Orientation
        :type first1: float
        :type last1: float
        :type first2: float
        :type last2: float
        :type c2dOut: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type isRev1: bool
        :type isRev2: bool
        :type isError: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeConstruct.ShapeConstruct__JoinCurves(*args)

    JoinCurves = staticmethod(JoinCurves)

    def __init__(self):
        """
        This package provides new algorithms for constructing
        new geometrical objects and topological shapes. It
        complements and extends algorithms available in Open
        CASCADE topological and geometrical toolkist.
        The functionality provided by this package are the
        following:
        projecting curves on surface,
        adjusting curve to have given start and end points. P
        """
        this = _ShapeConstruct.new_ShapeConstruct_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ShapeConstruct.delete_ShapeConstruct_
ShapeConstruct__swigregister = _ShapeConstruct.ShapeConstruct__swigregister
ShapeConstruct__swigregister(ShapeConstruct_)

def ShapeConstruct__ConvertCurveToBSpline(*args):
    """
    ConvertCurveToBSpline(Handle_Geom_Curve C3D, Standard_Real const First, Standard_Real const Last, Standard_Real const Tol3d, GeomAbs_Shape const Continuity, Standard_Integer const MaxSegments, Standard_Integer const MaxDegree) -> Handle_Geom_BSplineCurve
    ShapeConstruct__ConvertCurveToBSpline(Handle_Geom2d_Curve C2D, Standard_Real const First, Standard_Real const Last, Standard_Real const Tol2d, GeomAbs_Shape const Continuity, Standard_Integer const MaxSegments, Standard_Integer const MaxDegree) -> Handle_Geom2d_BSplineCurve

    :type C2D: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
    :type First: float
    :type Last: float
    :type Tol2d: float
    :type Continuity: OCC.wrapper.GeomAbs.GeomAbs_Shape
    :type MaxSegments: int
    :type MaxDegree: int
    :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

    """
    return _ShapeConstruct.ShapeConstruct__ConvertCurveToBSpline(*args)

def ShapeConstruct__ConvertSurfaceToBSpline(*args):
    """
    ShapeConstruct__ConvertSurfaceToBSpline(Handle_Geom_Surface surf, Standard_Real const UF, Standard_Real const UL, Standard_Real const VF, Standard_Real const VL, Standard_Real const Tol3d, GeomAbs_Shape const Continuity, Standard_Integer const MaxSegments, Standard_Integer const MaxDegree) -> Handle_Geom_BSplineSurface

    :type surf: OCC.wrapper.Geom.Handle_Geom_Surface
    :type UF: float
    :type UL: float
    :type VF: float
    :type VL: float
    :type Tol3d: float
    :type Continuity: OCC.wrapper.GeomAbs.GeomAbs_Shape
    :type MaxSegments: int
    :type MaxDegree: int
    :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineSurface

    """
    return _ShapeConstruct.ShapeConstruct__ConvertSurfaceToBSpline(*args)

def ShapeConstruct__JoinPCurves(*args):
    """
    ShapeConstruct__JoinPCurves(Handle_TopTools_HSequenceOfShape theEdges, TopoDS_Face theFace, TopoDS_Edge theEdge) -> Standard_Boolean

    join pcurves of the <theEdge> on the <theFace>
    try to use pcurves from originas edges <theEdges>
    Returns false if cannot join pcurves

    :type theEdges: OCC.wrapper.TopTools.Handle_TopTools_HSequenceOfShape
    :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
    :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _ShapeConstruct.ShapeConstruct__JoinPCurves(*args)

def ShapeConstruct__JoinCurves(*args):
    """
    JoinCurves(Handle_Geom_Curve c3d1, Handle_Geom_Curve ac3d2, TopAbs_Orientation const Orient1, TopAbs_Orientation const Orient2, Handle_Geom_Curve c3dOut) -> Standard_Boolean
    ShapeConstruct__JoinCurves(Handle_Geom2d_Curve c2d1, Handle_Geom2d_Curve ac2d2, TopAbs_Orientation const Orient1, TopAbs_Orientation const Orient2, Handle_Geom2d_Curve c2dOut, Standard_Boolean const isError) -> Standard_Boolean

    Method for joininig curves 3D.
    Parameters : c3d1,ac3d2 - initial curves
    Orient1, Orient2 - initial edges orientations.
    first1,last1,first2,last2 - parameters for trimming curves
    (re-calculate with account of orientation edges)
    c3dOut - result curve
    isRev1,isRev2 - out parameters indicative on possible errors.
    isError - input parameter indicative possible errors due to that one from edges have one vertex
    Return value : True - if curves were joined successfully,
    else - False.

    :type c2d1: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
    :type ac2d2: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
    :type Orient1: OCC.wrapper.TopAbs.TopAbs_Orientation
    :type Orient2: OCC.wrapper.TopAbs.TopAbs_Orientation
    :type first1: float
    :type last1: float
    :type first2: float
    :type last2: float
    :type c2dOut: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
    :type isRev1: bool
    :type isRev2: bool
    :type isError: bool
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _ShapeConstruct.ShapeConstruct__JoinCurves(*args)

class ShapeConstruct_MakeTriangulation(BRepBuilderAPI.BRepBuilderAPI_MakeShape):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ShapeConstruct_MakeTriangulation self, NCollection_Array1_gp_Pnt pnts, Standard_Real const prec=0.0) -> ShapeConstruct_MakeTriangulation
        __init__(ShapeConstruct_MakeTriangulation self, TopoDS_Wire wire, Standard_Real const prec=0.0) -> ShapeConstruct_MakeTriangulation

        :type wire: OCC.wrapper.TopoDS.TopoDS_Wire
        :type prec: float

        """
        this = _ShapeConstruct.new_ShapeConstruct_MakeTriangulation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Build(self, *args):
        """
        Build(ShapeConstruct_MakeTriangulation self)

        This is  called by  Shape().  It does  nothing but
        may be redefined.


        """
        return _ShapeConstruct.ShapeConstruct_MakeTriangulation_Build(self, *args)


    def IsDone(self, *args):
        """
        IsDone(ShapeConstruct_MakeTriangulation self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeConstruct.ShapeConstruct_MakeTriangulation_IsDone(self, *args)

    __swig_destroy__ = _ShapeConstruct.delete_ShapeConstruct_MakeTriangulation
ShapeConstruct_MakeTriangulation_swigregister = _ShapeConstruct.ShapeConstruct_MakeTriangulation_swigregister
ShapeConstruct_MakeTriangulation_swigregister(ShapeConstruct_MakeTriangulation)

class ShapeConstruct_Curve(object):
    """
    Adjusts curve to have start and end points at the given
    points (currently works on lines and B-Splines only)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AdjustCurve(self, *args):
        """
        AdjustCurve(ShapeConstruct_Curve self, Handle_Geom_Curve C3D, gp_Pnt P1, gp_Pnt P2, Standard_Boolean const take1, Standard_Boolean const take2) -> Standard_Boolean

        Modifies a curve in order to make its bounds confused with
        given points.
        Works only on lines and B-Splines, returns True in this case,
        else returns False.
        For line considers both bounding points, for B-Splines only
        specified.

        Warning : Does not check if curve should be reversed

        :type C3D: OCC.wrapper.Geom.Handle_Geom_Curve
        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :type take1: bool
        :type take2: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeConstruct.ShapeConstruct_Curve_AdjustCurve(self, *args)


    def AdjustCurveSegment(self, *args):
        """
        AdjustCurveSegment(ShapeConstruct_Curve self, Handle_Geom_Curve C3D, gp_Pnt P1, gp_Pnt P2, Standard_Real const U1, Standard_Real const U2) -> Standard_Boolean

        Modifies a curve in order to make its bounds confused with
        given points.
        Works only on lines and B-Splines.

        For lines works as previous method, B-Splines are segmented
        at the given values and then are adjusted to the points.

        :type C3D: OCC.wrapper.Geom.Handle_Geom_Curve
        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :type U1: float
        :type U2: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeConstruct.ShapeConstruct_Curve_AdjustCurveSegment(self, *args)


    def AdjustCurve2d(self, *args):
        """
        AdjustCurve2d(ShapeConstruct_Curve self, Handle_Geom2d_Curve C2D, gp_Pnt2d P1, gp_Pnt2d P2, Standard_Boolean const take1, Standard_Boolean const take2) -> Standard_Boolean

        Modifies a curve in order to make its bounds confused with
        given points.
        Works only on lines and B-Splines, returns True in this case,
        else returns False.

        For line considers both bounding points, for B-Splines only
        specified.

        Warning : Does not check if curve should be reversed

        :type C2D: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d
        :type take1: bool
        :type take2: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeConstruct.ShapeConstruct_Curve_AdjustCurve2d(self, *args)


    def ConvertToBSpline(self, *args):
        """
        ConvertToBSpline(ShapeConstruct_Curve self, Handle_Geom_Curve C, Standard_Real const first, Standard_Real const last, Standard_Real const prec) -> Handle_Geom_BSplineCurve
        ConvertToBSpline(ShapeConstruct_Curve self, Handle_Geom2d_Curve C, Standard_Real const first, Standard_Real const last, Standard_Real const prec) -> Handle_Geom2d_BSplineCurve

        Converts a curve of any type (only part from first to last)
        to bspline. The method of conversion depends on the type
        of original curve:
        BSpline -> C.Segment(first,last)
        Bezier and Line -> GeomConvert::CurveToBSplineCurve(C).Segment(first,last)
        Conic and Other -> Approx_Curve2d(C[first,last],prec,C1,9,1000)

        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type first: float
        :type last: float
        :type prec: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

        """
        return _ShapeConstruct.ShapeConstruct_Curve_ConvertToBSpline(self, *args)


    def FixKnots(*args):
        """
        FixKnots(Handle_TColStd_HArray1OfReal knots) -> Standard_Boolean
        FixKnots(NCollection_Array1_Standard_Real knots) -> Standard_Boolean

        Fix bspline knots to ensure that there is enough
        gap between neighbouring values
        Returns True if something fixed (by shifting knot)

        :type knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeConstruct.ShapeConstruct_Curve_FixKnots(*args)

    FixKnots = staticmethod(FixKnots)

    def __init__(self):
        """
        Adjusts curve to have start and end points at the given
        points (currently works on lines and B-Splines only)
        """
        this = _ShapeConstruct.new_ShapeConstruct_Curve()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ShapeConstruct.delete_ShapeConstruct_Curve
ShapeConstruct_Curve_swigregister = _ShapeConstruct.ShapeConstruct_Curve_swigregister
ShapeConstruct_Curve_swigregister(ShapeConstruct_Curve)

def ShapeConstruct_Curve_FixKnots(*args):
    """
    FixKnots(Handle_TColStd_HArray1OfReal knots) -> Standard_Boolean
    ShapeConstruct_Curve_FixKnots(NCollection_Array1_Standard_Real knots) -> Standard_Boolean

    Fix bspline knots to ensure that there is enough
    gap between neighbouring values
    Returns True if something fixed (by shifting knot)

    :type knots: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _ShapeConstruct.ShapeConstruct_Curve_FixKnots(*args)




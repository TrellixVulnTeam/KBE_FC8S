# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BRepBndLib')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BRepBndLib')
    _BRepBndLib = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BRepBndLib', [dirname(__file__)])
        except ImportError:
            import _BRepBndLib
            return _BRepBndLib
        try:
            _mod = imp.load_module('_BRepBndLib', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BRepBndLib = swig_import_helper()
    del swig_import_helper
else:
    import _BRepBndLib
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BRepBndLib.delete_SwigPyIterator

    def value(self):
        return _BRepBndLib.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _BRepBndLib.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _BRepBndLib.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _BRepBndLib.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _BRepBndLib.SwigPyIterator_equal(self, x)

    def copy(self):
        return _BRepBndLib.SwigPyIterator_copy(self)

    def next(self):
        return _BRepBndLib.SwigPyIterator_next(self)

    def __next__(self):
        return _BRepBndLib.SwigPyIterator___next__(self)

    def previous(self):
        return _BRepBndLib.SwigPyIterator_previous(self)

    def advance(self, n):
        return _BRepBndLib.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _BRepBndLib.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _BRepBndLib.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _BRepBndLib.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _BRepBndLib.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _BRepBndLib.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _BRepBndLib.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _BRepBndLib.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepBndLib.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_BRepBndLib.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepBndLib.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepBndLib.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepBndLib.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _BRepBndLib.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _BRepBndLib.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _BRepBndLib.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepBndLib.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_BRepBndLib.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepBndLib.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepBndLib.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepBndLib.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _BRepBndLib.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _BRepBndLib.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _BRepBndLib.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _BRepBndLib.ptr_to_number(item)
ptr_to_number = _BRepBndLib.ptr_to_number

def HashCode(*args):
    return _BRepBndLib.HashCode(*args)
HashCode = _BRepBndLib.HashCode

def ptr_equal(a, b):
    return _BRepBndLib.ptr_equal(a, b)
ptr_equal = _BRepBndLib.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
class BRepBndLib_(object):
    """
    This package provides the bounding boxes for curves
    and surfaces from BRepAdaptor.
    Functions to add a topological shape to a bounding box
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args):
        """
        Add(TopoDS_Shape S, Bnd_Box B, Standard_Boolean const useTriangulation)

        Adds the shape S to the bounding box B.
        More precisely are successively added to B:
        -   each face of S; the triangulation of the face is used if it exists,
        -   then each edge of S which does not belong to a face,
        the polygon of the edge is used if it exists
        -   and last each vertex of S which does not belong to an edge.
        After each elementary operation, the bounding box B is
        enlarged by the tolerance value of the relative sub-shape.
        When working with the triangulation of a face this value of
        enlargement is the sum of the triangulation deflection and
        the face tolerance. When working with the
        polygon of an edge this value of enlargement is
        the sum of the polygon deflection and the edge tolerance.
        Warning
        -   This algorithm is time consuming if triangulation has not
        been inserted inside the data structure of the shape S.
        -   The resulting bounding box may be somewhat larger than the object.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type B: OCC.wrapper.Bnd.Bnd_Box
        :type useTriangulation: bool

        """
        return _BRepBndLib.BRepBndLib__Add(*args)

    Add = staticmethod(Add)

    def AddClose(*args):
        """
        AddClose(TopoDS_Shape S, Bnd_Box B)

        Adds the shape S to the bounding box B.
        This is a quick algorithm but only works if the shape S is
        composed of polygonal planar faces, as is the case if S is
        an approached polyhedral representation of an exact
        shape. Pay particular attention to this because this
        condition is not checked and, if it not respected, an error
        may occur in the algorithm for which the bounding box is built.
        Note that the resulting bounding box is not enlarged by the
        tolerance value of the sub-shapes as is the case with the
        Add function. So the added part of the resulting bounding
        box is closer to the shape S.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type B: OCC.wrapper.Bnd.Bnd_Box

        """
        return _BRepBndLib.BRepBndLib__AddClose(*args)

    AddClose = staticmethod(AddClose)

    def AddOptimal(*args):
        """
        AddOptimal(TopoDS_Shape S, Bnd_Box B, Standard_Boolean const useTriangulation, Standard_Boolean const useShapeTolerance)

        Adds the shape S to the bounding box B.
        This algorith builds precise bounding box,
        which differs from exact geometry boundaries of shape only on shape entities tolerances
        Algorithm is the same as for method Add(..), but uses more precise methods for building boxes 
        for geometry objects.
        If useShapeTolerance = True, bounding box is enlardged by shape tolerances and 
        these tolerances are used for numerical methods of bounding box size calculations, 
        otherwise bounding box is built according to sizes of uderlined geometrical entities,
        numerical calculation use tolerance Precision::Confusion().

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type B: OCC.wrapper.Bnd.Bnd_Box
        :type useTriangulation: bool
        :type useShapeTolerance: bool

        """
        return _BRepBndLib.BRepBndLib__AddOptimal(*args)

    AddOptimal = staticmethod(AddOptimal)

    def AddOBB(*args):
        """
        AddOBB(TopoDS_Shape theS, Bnd_OBB theOBB, Standard_Boolean const theIsTriangulationUsed, Standard_Boolean const theIsOptimal, Standard_Boolean const theIsShapeToleranceUsed)

        Computes the Oriented Bounding box for the shape <theS>.
        Two independent methods of computation are implemented:
        first method based on set of points (so, it demands the
        triangulated shape or shape with planar faces and linear edges).
        The second method is based on use of inertia axes and is called
        if use of the first method is impossible.
        If theIsTriangulationUsed == FALSE then the triangulation will
        be ignored at all. 
        If theIsShapeToleranceUsed == TRUE then resulting box will be
        extended on the tolerance of the shape.
        theIsOptimal flag defines the algorithm for construction of initial
        Bnd_Box for the second method (if theIsOptimal == TRUE then
        this box will be created by AddOptimal(...) method).

        :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theOBB: OCC.wrapper.Bnd.Bnd_OBB
        :type theIsTriangulationUsed: bool
        :type theIsOptimal: bool
        :type theIsShapeToleranceUsed: bool

        """
        return _BRepBndLib.BRepBndLib__AddOBB(*args)

    AddOBB = staticmethod(AddOBB)

    def __init__(self):
        """
        This package provides the bounding boxes for curves
        and surfaces from BRepAdaptor.
        Functions to add a topological shape to a bounding box
        """
        this = _BRepBndLib.new_BRepBndLib_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepBndLib.delete_BRepBndLib_
BRepBndLib__swigregister = _BRepBndLib.BRepBndLib__swigregister
BRepBndLib__swigregister(BRepBndLib_)

def BRepBndLib__Add(*args):
    """
    BRepBndLib__Add(TopoDS_Shape S, Bnd_Box B, Standard_Boolean const useTriangulation)

    Adds the shape S to the bounding box B.
    More precisely are successively added to B:
    -   each face of S; the triangulation of the face is used if it exists,
    -   then each edge of S which does not belong to a face,
    the polygon of the edge is used if it exists
    -   and last each vertex of S which does not belong to an edge.
    After each elementary operation, the bounding box B is
    enlarged by the tolerance value of the relative sub-shape.
    When working with the triangulation of a face this value of
    enlargement is the sum of the triangulation deflection and
    the face tolerance. When working with the
    polygon of an edge this value of enlargement is
    the sum of the polygon deflection and the edge tolerance.
    Warning
    -   This algorithm is time consuming if triangulation has not
    been inserted inside the data structure of the shape S.
    -   The resulting bounding box may be somewhat larger than the object.

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type B: OCC.wrapper.Bnd.Bnd_Box
    :type useTriangulation: bool

    """
    return _BRepBndLib.BRepBndLib__Add(*args)

def BRepBndLib__AddClose(*args):
    """
    BRepBndLib__AddClose(TopoDS_Shape S, Bnd_Box B)

    Adds the shape S to the bounding box B.
    This is a quick algorithm but only works if the shape S is
    composed of polygonal planar faces, as is the case if S is
    an approached polyhedral representation of an exact
    shape. Pay particular attention to this because this
    condition is not checked and, if it not respected, an error
    may occur in the algorithm for which the bounding box is built.
    Note that the resulting bounding box is not enlarged by the
    tolerance value of the sub-shapes as is the case with the
    Add function. So the added part of the resulting bounding
    box is closer to the shape S.

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type B: OCC.wrapper.Bnd.Bnd_Box

    """
    return _BRepBndLib.BRepBndLib__AddClose(*args)

def BRepBndLib__AddOptimal(*args):
    """
    BRepBndLib__AddOptimal(TopoDS_Shape S, Bnd_Box B, Standard_Boolean const useTriangulation, Standard_Boolean const useShapeTolerance)

    Adds the shape S to the bounding box B.
    This algorith builds precise bounding box,
    which differs from exact geometry boundaries of shape only on shape entities tolerances
    Algorithm is the same as for method Add(..), but uses more precise methods for building boxes 
    for geometry objects.
    If useShapeTolerance = True, bounding box is enlardged by shape tolerances and 
    these tolerances are used for numerical methods of bounding box size calculations, 
    otherwise bounding box is built according to sizes of uderlined geometrical entities,
    numerical calculation use tolerance Precision::Confusion().

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type B: OCC.wrapper.Bnd.Bnd_Box
    :type useTriangulation: bool
    :type useShapeTolerance: bool

    """
    return _BRepBndLib.BRepBndLib__AddOptimal(*args)

def BRepBndLib__AddOBB(*args):
    """
    BRepBndLib__AddOBB(TopoDS_Shape theS, Bnd_OBB theOBB, Standard_Boolean const theIsTriangulationUsed, Standard_Boolean const theIsOptimal, Standard_Boolean const theIsShapeToleranceUsed)

    Computes the Oriented Bounding box for the shape <theS>.
    Two independent methods of computation are implemented:
    first method based on set of points (so, it demands the
    triangulated shape or shape with planar faces and linear edges).
    The second method is based on use of inertia axes and is called
    if use of the first method is impossible.
    If theIsTriangulationUsed == FALSE then the triangulation will
    be ignored at all. 
    If theIsShapeToleranceUsed == TRUE then resulting box will be
    extended on the tolerance of the shape.
    theIsOptimal flag defines the algorithm for construction of initial
    Bnd_Box for the second method (if theIsOptimal == TRUE then
    this box will be created by AddOptimal(...) method).

    :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theOBB: OCC.wrapper.Bnd.Bnd_OBB
    :type theIsTriangulationUsed: bool
    :type theIsOptimal: bool
    :type theIsShapeToleranceUsed: bool

    """
    return _BRepBndLib.BRepBndLib__AddOBB(*args)




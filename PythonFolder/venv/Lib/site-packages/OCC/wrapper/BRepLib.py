# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BRepLib')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BRepLib')
    _BRepLib = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BRepLib', [dirname(__file__)])
        except ImportError:
            import _BRepLib
            return _BRepLib
        try:
            _mod = imp.load_module('_BRepLib', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BRepLib = swig_import_helper()
    del swig_import_helper
else:
    import _BRepLib
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BRepLib.delete_SwigPyIterator

    def value(self):
        return _BRepLib.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _BRepLib.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _BRepLib.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _BRepLib.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _BRepLib.SwigPyIterator_equal(self, x)

    def copy(self):
        return _BRepLib.SwigPyIterator_copy(self)

    def next(self):
        return _BRepLib.SwigPyIterator_next(self)

    def __next__(self):
        return _BRepLib.SwigPyIterator___next__(self)

    def previous(self):
        return _BRepLib.SwigPyIterator_previous(self)

    def advance(self, n):
        return _BRepLib.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _BRepLib.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _BRepLib.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _BRepLib.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _BRepLib.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _BRepLib.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _BRepLib.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _BRepLib.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepLib.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_BRepLib.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepLib.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepLib.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepLib.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _BRepLib.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _BRepLib.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _BRepLib.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepLib.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_BRepLib.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepLib.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepLib.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepLib.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _BRepLib.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _BRepLib.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _BRepLib.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _BRepLib.ptr_to_number(item)
ptr_to_number = _BRepLib.ptr_to_number

def HashCode(*args):
    return _BRepLib.HashCode(*args)
HashCode = _BRepLib.HashCode

def ptr_equal(a, b):
    return _BRepLib.ptr_equal(a, b)
ptr_equal = _BRepLib.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepTools
else:
    import BRepTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Poly
else:
    import Poly
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TShort
else:
    import TShort
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRep
else:
    import BRep
del _swig_python_version_info
BRepLib_EdgeDone = _BRepLib.BRepLib_EdgeDone
BRepLib_PointProjectionFailed = _BRepLib.BRepLib_PointProjectionFailed
BRepLib_ParameterOutOfRange = _BRepLib.BRepLib_ParameterOutOfRange
BRepLib_DifferentPointsOnClosedCurve = _BRepLib.BRepLib_DifferentPointsOnClosedCurve
BRepLib_PointWithInfiniteParameter = _BRepLib.BRepLib_PointWithInfiniteParameter
BRepLib_DifferentsPointAndParameter = _BRepLib.BRepLib_DifferentsPointAndParameter
BRepLib_LineThroughIdenticPoints = _BRepLib.BRepLib_LineThroughIdenticPoints
BRepLib_FaceDone = _BRepLib.BRepLib_FaceDone
BRepLib_NoFace = _BRepLib.BRepLib_NoFace
BRepLib_NotPlanar = _BRepLib.BRepLib_NotPlanar
BRepLib_CurveProjectionFailed = _BRepLib.BRepLib_CurveProjectionFailed
BRepLib_ParametersOutOfRange = _BRepLib.BRepLib_ParametersOutOfRange
BRepLib_Preserved = _BRepLib.BRepLib_Preserved
BRepLib_Deleted = _BRepLib.BRepLib_Deleted
BRepLib_Trimmed = _BRepLib.BRepLib_Trimmed
BRepLib_Merged = _BRepLib.BRepLib_Merged
BRepLib_BoundaryModified = _BRepLib.BRepLib_BoundaryModified
BRepLib_ShellDone = _BRepLib.BRepLib_ShellDone
BRepLib_EmptyShell = _BRepLib.BRepLib_EmptyShell
BRepLib_DisconnectedShell = _BRepLib.BRepLib_DisconnectedShell
BRepLib_ShellParametersOutOfRange = _BRepLib.BRepLib_ShellParametersOutOfRange
BRepLib_WireDone = _BRepLib.BRepLib_WireDone
BRepLib_EmptyWire = _BRepLib.BRepLib_EmptyWire
BRepLib_DisconnectedWire = _BRepLib.BRepLib_DisconnectedWire
BRepLib_NonManifoldWire = _BRepLib.BRepLib_NonManifoldWire
class BRepLib_Command(object):
    """
    Root class for all commands in BRepLib.

    Provides :

    * Managements of the notDone flag.

    * Catching of exceptions (not implemented).

    * Logging (not implemented).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def IsDone(self, *args):
        """
        IsDone(BRepLib_Command self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepLib.BRepLib_Command_IsDone(self, *args)


    def Check(self, *args):
        """
        Check(BRepLib_Command self)

        Raises NotDone if done is false.


        """
        return _BRepLib.BRepLib_Command_Check(self, *args)

    __swig_destroy__ = _BRepLib.delete_BRepLib_Command
BRepLib_Command_swigregister = _BRepLib.BRepLib_Command_swigregister
BRepLib_Command_swigregister(BRepLib_Command)

class BRepLib_MakeShape(BRepLib_Command):
    """
    This    is  the  root     class for     all  shape
    constructions.  It stores the result.

    It  provides deferred methods to trace the history
    of sub-shapes.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def Build(self, *args):
        """
        Build(BRepLib_MakeShape self)

        This is  called by  Shape().  It does  nothing but
        may be redefined.


        """
        return _BRepLib.BRepLib_MakeShape_Build(self, *args)


    def Shape(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepLib.BRepLib_MakeShape_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FaceStatus(self, *args):
        """
        FaceStatus(BRepLib_MakeShape self, TopoDS_Face F) -> BRepLib_ShapeModification

        returns the status of the Face after
        the shape creation.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.BRepLib.BRepLib_ShapeModification

        """
        return _BRepLib.BRepLib_MakeShape_FaceStatus(self, *args)


    def HasDescendants(self, *args):
        """
        HasDescendants(BRepLib_MakeShape self, TopoDS_Face F) -> Standard_Boolean

        Returns True if the Face generates new topology.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepLib.BRepLib_MakeShape_HasDescendants(self, *args)


    def DescendantFaces(self, *args):
        """
        returns the list of generated Faces.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepLib.BRepLib_MakeShape_DescendantFaces(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbSurfaces(self, *args):
        """
        NbSurfaces(BRepLib_MakeShape self) -> Standard_Integer

        returns the number of surfaces
        after the shape creation.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepLib.BRepLib_MakeShape_NbSurfaces(self, *args)


    def NewFaces(self, *args):
        """
        Return the faces created for surface I.

        :type I: int
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepLib.BRepLib_MakeShape_NewFaces(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FacesFromEdges(self, *args):
        """
        returns a list of the created faces
        from the edge <E>.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepLib.BRepLib_MakeShape_FacesFromEdges(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepLib.delete_BRepLib_MakeShape
BRepLib_MakeShape_swigregister = _BRepLib.BRepLib_MakeShape_swigregister
BRepLib_MakeShape_swigregister(BRepLib_MakeShape)

class BRepLib_MakeShell(BRepLib_MakeShape):
    """
    Provides methos to build shells.

    Build a shell from a set of faces.
    Build untied shell from a non C2 surface
    splitting it into C2-continuous parts.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepLib_MakeShell self) -> BRepLib_MakeShell
        __init__(BRepLib_MakeShell self, Handle_Geom_Surface S, Standard_Boolean const Segment) -> BRepLib_MakeShell
        __init__(BRepLib_MakeShell self, Handle_Geom_Surface S, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax, Standard_Boolean const Segment) -> BRepLib_MakeShell

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type UMin: float
        :type UMax: float
        :type VMin: float
        :type VMax: float
        :type Segment: bool

        """
        this = _BRepLib.new_BRepLib_MakeShell(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepLib_MakeShell self, Handle_Geom_Surface S, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax, Standard_Boolean const Segment)

        Creates the shell from the surface  and the min-max
        values.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type UMin: float
        :type UMax: float
        :type VMin: float
        :type VMax: float
        :type Segment: bool

        """
        return _BRepLib.BRepLib_MakeShell_Init(self, *args)


    def Error(self, *args):
        """
        Error(BRepLib_MakeShell self) -> BRepLib_ShellError

        :rtype: OCC.wrapper.BRepLib.BRepLib_ShellError

        """
        return _BRepLib.BRepLib_MakeShell_Error(self, *args)


    def Shell(self, *args):
        """
        Shell(BRepLib_MakeShell self) -> TopoDS_Shell

        Returns the new Shell.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shell

        """
        return _BRepLib.BRepLib_MakeShell_Shell(self, *args)

    __swig_destroy__ = _BRepLib.delete_BRepLib_MakeShell
BRepLib_MakeShell_swigregister = _BRepLib.BRepLib_MakeShell_swigregister
BRepLib_MakeShell_swigregister(BRepLib_MakeShell)

class BRepLib_MakeEdge(BRepLib_MakeShape):
    """
    Provides methods to build edges.

    The   methods have  the  following   syntax, where
    TheCurve is one of Lin, Circ, ...

    Create(C : TheCurve)

    Makes an edge on  the whole curve.  Add vertices
    on finite curves.

    Create(C : TheCurve; p1,p2 : Real)

    Make an edge  on the curve between parameters p1
    and p2. if p2 < p1 the edge will be REVERSED. If
    p1  or p2 is infinite the  curve will be open in
    that  direction. Vertices are created for finite
    values of p1 and p2.

    Create(C : TheCurve; P1, P2 : Pnt from gp)

    Make an edge on the curve  between the points P1
    and P2. The  points are projected on   the curve
    and the   previous method is  used. An  error is
    raised if the points are not on the curve.

    Create(C : TheCurve; V1, V2 : Vertex from TopoDS)

    Make an edge  on the curve  between the vertices
    V1 and V2. Same as the  previous but no vertices
    are created. If a vertex is  Null the curve will
    be open in this direction.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepLib_MakeEdge self) -> BRepLib_MakeEdge
        __init__(BRepLib_MakeEdge self, TopoDS_Vertex V1, TopoDS_Vertex V2) -> BRepLib_MakeEdge
        __init__(BRepLib_MakeEdge self, gp_Pnt P1, gp_Pnt P2) -> BRepLib_MakeEdge
        __init__(BRepLib_MakeEdge self, gp_Lin L) -> BRepLib_MakeEdge
        __init__(BRepLib_MakeEdge self, gp_Lin L, Standard_Real const p1, Standard_Real const p2) -> BRepLib_MakeEdge
        __init__(BRepLib_MakeEdge self, gp_Lin L, gp_Pnt P1, gp_Pnt P2) -> BRepLib_MakeEdge
        __init__(BRepLib_MakeEdge self, gp_Lin L, TopoDS_Vertex V1, TopoDS_Vertex V2) -> BRepLib_MakeEdge
        __init__(BRepLib_MakeEdge self, gp_Circ L) -> BRepLib_MakeEdge
        __init__(BRepLib_MakeEdge self, gp_Circ L, Standard_Real const p1, Standard_Real const p2) -> BRepLib_MakeEdge
        __init__(BRepLib_MakeEdge self, gp_Circ L, gp_Pnt P1, gp_Pnt P2) -> BRepLib_MakeEdge
        __init__(BRepLib_MakeEdge self, gp_Circ L, TopoDS_Vertex V1, TopoDS_Vertex V2) -> BRepLib_MakeEdge
        __init__(BRepLib_MakeEdge self, gp_Elips L) -> BRepLib_MakeEdge
        __init__(BRepLib_MakeEdge self, gp_Elips L, Standard_Real const p1, Standard_Real const p2) -> BRepLib_MakeEdge
        __init__(BRepLib_MakeEdge self, gp_Elips L, gp_Pnt P1, gp_Pnt P2) -> BRepLib_MakeEdge
        __init__(BRepLib_MakeEdge self, gp_Elips L, TopoDS_Vertex V1, TopoDS_Vertex V2) -> BRepLib_MakeEdge
        __init__(BRepLib_MakeEdge self, gp_Hypr L) -> BRepLib_MakeEdge
        __init__(BRepLib_MakeEdge self, gp_Hypr L, Standard_Real const p1, Standard_Real const p2) -> BRepLib_MakeEdge
        __init__(BRepLib_MakeEdge self, gp_Hypr L, gp_Pnt P1, gp_Pnt P2) -> BRepLib_MakeEdge
        __init__(BRepLib_MakeEdge self, gp_Hypr L, TopoDS_Vertex V1, TopoDS_Vertex V2) -> BRepLib_MakeEdge
        __init__(BRepLib_MakeEdge self, gp_Parab L) -> BRepLib_MakeEdge
        __init__(BRepLib_MakeEdge self, gp_Parab L, Standard_Real const p1, Standard_Real const p2) -> BRepLib_MakeEdge
        __init__(BRepLib_MakeEdge self, gp_Parab L, gp_Pnt P1, gp_Pnt P2) -> BRepLib_MakeEdge
        __init__(BRepLib_MakeEdge self, gp_Parab L, TopoDS_Vertex V1, TopoDS_Vertex V2) -> BRepLib_MakeEdge
        __init__(BRepLib_MakeEdge self, Handle_Geom_Curve L) -> BRepLib_MakeEdge
        __init__(BRepLib_MakeEdge self, Handle_Geom_Curve L, Standard_Real const p1, Standard_Real const p2) -> BRepLib_MakeEdge
        __init__(BRepLib_MakeEdge self, Handle_Geom_Curve L, gp_Pnt P1, gp_Pnt P2) -> BRepLib_MakeEdge
        __init__(BRepLib_MakeEdge self, Handle_Geom_Curve L, TopoDS_Vertex V1, TopoDS_Vertex V2) -> BRepLib_MakeEdge
        __init__(BRepLib_MakeEdge self, Handle_Geom_Curve L, gp_Pnt P1, gp_Pnt P2, Standard_Real const p1, Standard_Real const p2) -> BRepLib_MakeEdge
        __init__(BRepLib_MakeEdge self, Handle_Geom_Curve L, TopoDS_Vertex V1, TopoDS_Vertex V2, Standard_Real const p1, Standard_Real const p2) -> BRepLib_MakeEdge
        __init__(BRepLib_MakeEdge self, Handle_Geom2d_Curve L, Handle_Geom_Surface S) -> BRepLib_MakeEdge
        __init__(BRepLib_MakeEdge self, Handle_Geom2d_Curve L, Handle_Geom_Surface S, Standard_Real const p1, Standard_Real const p2) -> BRepLib_MakeEdge
        __init__(BRepLib_MakeEdge self, Handle_Geom2d_Curve L, Handle_Geom_Surface S, gp_Pnt P1, gp_Pnt P2) -> BRepLib_MakeEdge
        __init__(BRepLib_MakeEdge self, Handle_Geom2d_Curve L, Handle_Geom_Surface S, TopoDS_Vertex V1, TopoDS_Vertex V2) -> BRepLib_MakeEdge
        __init__(BRepLib_MakeEdge self, Handle_Geom2d_Curve L, Handle_Geom_Surface S, gp_Pnt P1, gp_Pnt P2, Standard_Real const p1, Standard_Real const p2) -> BRepLib_MakeEdge
        __init__(BRepLib_MakeEdge self, Handle_Geom2d_Curve L, Handle_Geom_Surface S, TopoDS_Vertex V1, TopoDS_Vertex V2, Standard_Real const p1, Standard_Real const p2) -> BRepLib_MakeEdge

        :type L: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type V1: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type V2: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type p1: float
        :type p2: float

        """
        this = _BRepLib.new_BRepLib_MakeEdge(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepLib_MakeEdge self, Handle_Geom_Curve C)
        Init(BRepLib_MakeEdge self, Handle_Geom_Curve C, Standard_Real const p1, Standard_Real const p2)
        Init(BRepLib_MakeEdge self, Handle_Geom_Curve C, gp_Pnt P1, gp_Pnt P2)
        Init(BRepLib_MakeEdge self, Handle_Geom_Curve C, TopoDS_Vertex V1, TopoDS_Vertex V2)
        Init(BRepLib_MakeEdge self, Handle_Geom_Curve C, gp_Pnt P1, gp_Pnt P2, Standard_Real const p1, Standard_Real const p2)
        Init(BRepLib_MakeEdge self, Handle_Geom_Curve C, TopoDS_Vertex V1, TopoDS_Vertex V2, Standard_Real const p1, Standard_Real const p2)
        Init(BRepLib_MakeEdge self, Handle_Geom2d_Curve C, Handle_Geom_Surface S)
        Init(BRepLib_MakeEdge self, Handle_Geom2d_Curve C, Handle_Geom_Surface S, Standard_Real const p1, Standard_Real const p2)
        Init(BRepLib_MakeEdge self, Handle_Geom2d_Curve C, Handle_Geom_Surface S, gp_Pnt P1, gp_Pnt P2)
        Init(BRepLib_MakeEdge self, Handle_Geom2d_Curve C, Handle_Geom_Surface S, TopoDS_Vertex V1, TopoDS_Vertex V2)
        Init(BRepLib_MakeEdge self, Handle_Geom2d_Curve C, Handle_Geom_Surface S, gp_Pnt P1, gp_Pnt P2, Standard_Real const p1, Standard_Real const p2)
        Init(BRepLib_MakeEdge self, Handle_Geom2d_Curve C, Handle_Geom_Surface S, TopoDS_Vertex V1, TopoDS_Vertex V2, Standard_Real const p1, Standard_Real const p2)

        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type V1: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type V2: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type p1: float
        :type p2: float

        """
        return _BRepLib.BRepLib_MakeEdge_Init(self, *args)


    def Error(self, *args):
        """
        Error(BRepLib_MakeEdge self) -> BRepLib_EdgeError

        Returns the error description when NotDone.

        :rtype: OCC.wrapper.BRepLib.BRepLib_EdgeError

        """
        return _BRepLib.BRepLib_MakeEdge_Error(self, *args)


    def Edge(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepLib.BRepLib_MakeEdge_Edge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Vertex1(self, *args):
        """
        Returns the first vertex of the edge. May be Null.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        res = _BRepLib.BRepLib_MakeEdge_Vertex1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Vertex2(self, *args):
        """
        Returns the second vertex of the edge. May be Null.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        res = _BRepLib.BRepLib_MakeEdge_Vertex2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepLib.delete_BRepLib_MakeEdge
BRepLib_MakeEdge_swigregister = _BRepLib.BRepLib_MakeEdge_swigregister
BRepLib_MakeEdge_swigregister(BRepLib_MakeEdge)

class BRepLib_FuseEdges(object):
    """
    This class can detect  vertices in a face that can
    be considered useless and then perform the fuse of
    the  edges and remove  the  useless vertices.  By
    useles vertices,  we mean :
    * vertices that  have  exactly two connex edges
    * the edges connex to the vertex must have
    exactly the same 2 connex faces .
    * The edges connex to the vertex must have the
    same geometric support.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepLib_FuseEdges self, TopoDS_Shape theShape, Standard_Boolean const PerformNow) -> BRepLib_FuseEdges

        Initialise members  and build  construction of map
        of ancestors.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type PerformNow: bool

        """
        this = _BRepLib.new_BRepLib_FuseEdges(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AvoidEdges(self, *args):
        """
        AvoidEdges(BRepLib_FuseEdges self, NCollection_IndexedMap_TopoDS_Shape_TopTools_ShapeMapHasher theMapEdg)

        set edges to avoid being fused

        :type theMapEdg: OCC.wrapper.TopTools.TopTools_IndexedMapOfShape

        """
        return _BRepLib.BRepLib_FuseEdges_AvoidEdges(self, *args)


    def SetConcatBSpl(self, *args):
        """
        SetConcatBSpl(BRepLib_FuseEdges self, Standard_Boolean const theConcatBSpl)

        set mode to enable concatenation G1 BSpline edges in one
        End  Modified  by  IFV  19.04.07

        :type theConcatBSpl: bool

        """
        return _BRepLib.BRepLib_FuseEdges_SetConcatBSpl(self, *args)


    def Edges(self, *args):
        """
        Edges(BRepLib_FuseEdges self, NCollection_DataMap_Standard_Integer_TopTools_ListOfShape_TColStd_MapIntegerHasher theMapLstEdg)

        returns  all the list of edges to be fused
        each list of the map represent a set of connex edges
        that can be fused.

        :type theMapLstEdg: OCC.wrapper.TopTools.TopTools_DataMapOfIntegerListOfShape

        """
        return _BRepLib.BRepLib_FuseEdges_Edges(self, *args)


    def ResultEdges(self, *args):
        """
        ResultEdges(BRepLib_FuseEdges self, NCollection_DataMap_Standard_Integer_TopoDS_Shape_TColStd_MapIntegerHasher theMapEdg)

        returns all the fused edges. each integer entry in
        the   map  corresponds  to  the  integer   in the
        DataMapOfIntegerListOfShape  we    get in  method
        Edges.   That is to say, to  the list  of edges in
        theMapLstEdg(i) corresponds the resulting edge theMapEdge(i)

        :type theMapEdg: OCC.wrapper.TopTools.TopTools_DataMapOfIntegerShape

        """
        return _BRepLib.BRepLib_FuseEdges_ResultEdges(self, *args)


    def Faces(self, *args):
        """
        Faces(BRepLib_FuseEdges self, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher theMapFac)

        returns the map of modified faces.

        :type theMapFac: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape

        """
        return _BRepLib.BRepLib_FuseEdges_Faces(self, *args)


    def Shape(self, *args):
        """
        Shape(BRepLib_FuseEdges self) -> TopoDS_Shape

        returns myShape modified with the list of internal
        edges removed from it.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepLib.BRepLib_FuseEdges_Shape(self, *args)


    def NbVertices(self, *args):
        """
        NbVertices(BRepLib_FuseEdges self) -> Standard_Integer

        returns the number of vertices candidate to be removed

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepLib.BRepLib_FuseEdges_NbVertices(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepLib_FuseEdges self)

        Using  map of list of connex  edges, fuse each list to
        one edge and then update myShape


        """
        return _BRepLib.BRepLib_FuseEdges_Perform(self, *args)

    __swig_destroy__ = _BRepLib.delete_BRepLib_FuseEdges
BRepLib_FuseEdges_swigregister = _BRepLib.BRepLib_FuseEdges_swigregister
BRepLib_FuseEdges_swigregister(BRepLib_FuseEdges)

class BRepLib_FindSurface(object):
    """
    Provides an  algorithm to find  a Surface  through a
    set of edges.

    The edges  of  the  shape  given  as  argument are
    explored if they are not coplanar at  the required
    tolerance  the method Found returns false.

    If a null tolerance is given the max of the  edges
    tolerances is used.

    The method Tolerance returns the true distance  of
    the edges to the Surface.

    The method Surface returns the Surface if found.

    The method Existed  returns returns  True  if  the
    Surface was already attached to some of the edges.

    When Existed  returns True  the  Surface  may have a
    location given by the Location method.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepLib_FindSurface self) -> BRepLib_FindSurface
        __init__(BRepLib_FindSurface self, TopoDS_Shape S, Standard_Real const Tol=-1, Standard_Boolean const OnlyPlane, Standard_Boolean const OnlyClosed) -> BRepLib_FindSurface

        Computes the Surface from the edges of  <S> with the
        given tolerance.
        if <OnlyPlane> is true, the computed surface will be
        a plane. If it is not possible to find a plane, the
        flag NotDone will be set.
        If <OnlyClosed> is true,  then  S  sould be a wire
        and the existing surface,  on  which wire S is not
        closed in 2D, will be ignored.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Tol: float
        :type OnlyPlane: bool
        :type OnlyClosed: bool

        """
        this = _BRepLib.new_BRepLib_FindSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepLib_FindSurface self, TopoDS_Shape S, Standard_Real const Tol=-1, Standard_Boolean const OnlyPlane, Standard_Boolean const OnlyClosed)

        Computes the Surface from the edges of  <S> with the
        given tolerance.
        if <OnlyPlane> is true, the computed surface will be
        a plane. If it is not possible to find a plane, the
        flag NotDone will be set.
        If <OnlyClosed> is true,  then  S  sould be a wire
        and the existing surface,  on  which wire S is not
        closed in 2D, will be ignored.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Tol: float
        :type OnlyPlane: bool
        :type OnlyClosed: bool

        """
        return _BRepLib.BRepLib_FindSurface_Init(self, *args)


    def Found(self, *args):
        """
        Found(BRepLib_FindSurface self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepLib.BRepLib_FindSurface_Found(self, *args)


    def Surface(self, *args):
        """
        Surface(BRepLib_FindSurface self) -> Handle_Geom_Surface

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _BRepLib.BRepLib_FindSurface_Surface(self, *args)


    def Tolerance(self, *args):
        """
        Tolerance(BRepLib_FindSurface self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepLib.BRepLib_FindSurface_Tolerance(self, *args)


    def ToleranceReached(self, *args):
        """
        ToleranceReached(BRepLib_FindSurface self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepLib.BRepLib_FindSurface_ToleranceReached(self, *args)


    def Existed(self, *args):
        """
        Existed(BRepLib_FindSurface self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepLib.BRepLib_FindSurface_Existed(self, *args)


    def Location(self, *args):
        """
        Location(BRepLib_FindSurface self) -> TopLoc_Location

        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _BRepLib.BRepLib_FindSurface_Location(self, *args)

    __swig_destroy__ = _BRepLib.delete_BRepLib_FindSurface
BRepLib_FindSurface_swigregister = _BRepLib.BRepLib_FindSurface_swigregister
BRepLib_FindSurface_swigregister(BRepLib_FindSurface)

class BRepLib_(object):
    """
    The BRepLib package provides general utilities for
    BRep.

    * FindSurface : Class to compute a surface through
    a set of edges.

    * Compute missing 3d curve on an edge.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Precision(*args):
        """
        Precision(Standard_Real const P)
        Precision() -> Standard_Real

        Returns the default precision.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepLib.BRepLib__Precision(*args)

    Precision = staticmethod(Precision)

    def Plane(*args):
        """
        Plane(Handle_Geom_Plane P)
        Plane() -> Handle_Geom_Plane

        Returns the current plane.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Plane

        """
        return _BRepLib.BRepLib__Plane(*args)

    Plane = staticmethod(Plane)

    def CheckSameRange(*args):
        """
        CheckSameRange(TopoDS_Edge E, Standard_Real const Confusion=1.0e-12) -> Standard_Boolean

        checks if the Edge is same range IGNORING
        the same range flag of the edge
        Confusion argument is to compare real numbers
        idenpendently of any model space tolerance

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type Confusion: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepLib.BRepLib__CheckSameRange(*args)

    CheckSameRange = staticmethod(CheckSameRange)

    def SameRange(*args):
        """
        SameRange(TopoDS_Edge E, Standard_Real const Tolerance=1.0e-5)

        will make all the curve representation have
        the same range domain for the parameters.
        This will IGNORE the same range flag value
        to proceed.
        If there is a 3D curve there it will the
        range of that curve. If not the first curve representation
        encountered in the list will give its range to
        the all the other curves.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type Tolerance: float

        """
        return _BRepLib.BRepLib__SameRange(*args)

    SameRange = staticmethod(SameRange)

    def BuildCurve3d(*args):
        """
        BuildCurve3d(TopoDS_Edge E, Standard_Real const Tolerance=1.0e-5, GeomAbs_Shape const Continuity=GeomAbs_C1, Standard_Integer const MaxDegree=14, Standard_Integer const MaxSegment=0) -> Standard_Boolean

        Computes the 3d curve for the edge  <E> if it does
        not exist. Returns True  if the curve was computed
        or  existed. Returns False  if there is no  planar
        pcurve or the computation failed.
        <MaxSegment> >= 30 in approximation

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type Tolerance: float
        :type Continuity: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type MaxDegree: int
        :type MaxSegment: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepLib.BRepLib__BuildCurve3d(*args)

    BuildCurve3d = staticmethod(BuildCurve3d)

    def BuildCurves3d(*args):
        """
        BuildCurves3d(TopoDS_Shape S, Standard_Real const Tolerance, GeomAbs_Shape const Continuity=GeomAbs_C1, Standard_Integer const MaxDegree=14, Standard_Integer const MaxSegment=0) -> Standard_Boolean
        BuildCurves3d(TopoDS_Shape S) -> Standard_Boolean

        Computes  the 3d curves  for all the  edges of <S>
        return False if one of the computation failed.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepLib.BRepLib__BuildCurves3d(*args)

    BuildCurves3d = staticmethod(BuildCurves3d)

    def BuildPCurveForEdgeOnPlane(*args):
        """
        BuildPCurveForEdgeOnPlane(TopoDS_Edge theE, TopoDS_Face theF)
        BuildPCurveForEdgeOnPlane(TopoDS_Edge theE, TopoDS_Face theF, Handle_Geom2d_Curve aC2D)

        Builds pcurve of edge on face if the surface is plane, but does not update the edge.
        The output are the pcurve and the flag telling that pcurve was built.

        :type theE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theF: OCC.wrapper.TopoDS.TopoDS_Face
        :type aC2D: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type bToUpdate: bool

        """
        return _BRepLib.BRepLib__BuildPCurveForEdgeOnPlane(*args)

    BuildPCurveForEdgeOnPlane = staticmethod(BuildPCurveForEdgeOnPlane)

    def UpdateEdgeTol(*args):
        """
        UpdateEdgeTol(TopoDS_Edge E, Standard_Real const MinToleranceRequest, Standard_Real const MaxToleranceToCheck) -> Standard_Boolean

        Checks if the edge has a  Tolerance smaller than -- --
        -- -- MaxToleranceToCheck  if  so it will compute  the
        radius    of  -- the   cylindrical  pipe  surface that
        MinToleranceRequest is the minimum tolerance before it
        is usefull to start testing. Usually it should be arround
        10e-5
        contains all  --  the curve represenation of  the edge
        returns True if the Edge tolerance had to be updated

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type MinToleranceRequest: float
        :type MaxToleranceToCheck: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepLib.BRepLib__UpdateEdgeTol(*args)

    UpdateEdgeTol = staticmethod(UpdateEdgeTol)

    def UpdateEdgeTolerance(*args):
        """
        UpdateEdgeTolerance(TopoDS_Shape S, Standard_Real const MinToleranceRequest, Standard_Real const MaxToleranceToCheck) -> Standard_Boolean

        -- Checks all the edges of the shape whose -- -- --
        Tolerance  is  smaller than  MaxToleranceToCheck --
        Returns True if at  least  one edge was updated --
        MinToleranceRequest is the minimum tolerance before
        --  it -- is  usefull to start  testing. Usually it
        should be arround -- 10e-5--

        Warning :The  method is  very  slow  as it  checks all.
        Use  only  in interfaces or  processing assimilate batch

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type MinToleranceRequest: float
        :type MaxToleranceToCheck: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepLib.BRepLib__UpdateEdgeTolerance(*args)

    UpdateEdgeTolerance = staticmethod(UpdateEdgeTolerance)

    def SameParameter(*args):
        """
        SameParameter(TopoDS_Edge theEdge, Standard_Real const Tolerance=1.0e-5)
        SameParameter(TopoDS_Edge theEdge, Standard_Real const theTolerance, Standard_Boolean const IsUseOldEdge) -> TopoDS_Edge
        SameParameter(TopoDS_Shape S, Standard_Real const Tolerance=1.0e-5, Standard_Boolean const forced)
        SameParameter(TopoDS_Shape S, BRepTools_ReShape theReshaper, Standard_Real const Tolerance=1.0e-5, Standard_Boolean const forced)

        Computes new 2d curve(s) for all the edges of  <S>
        to have the same parameter  as  the  3d curve.
        The algorithm is not done if the flag SameParameter
        was True  on an  Edge.<br>
        theReshaper is used to record the modifications of input shape <S> to prevent any 
        modifications on the shape itself.
        Thus the input shape (and its subshapes) will not be modified, instead the reshaper will 
        contain a modified empty-copies of original subshapes as substitutions.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theReshaper: OCC.wrapper.BRepTools.BRepTools_ReShape
        :type Tolerance: float
        :type forced: bool

        """
        return _BRepLib.BRepLib__SameParameter(*args)

    SameParameter = staticmethod(SameParameter)

    def UpdateTolerances(*args):
        """
        UpdateTolerances(TopoDS_Shape S, Standard_Boolean const verifyFaceTolerance)
        UpdateTolerances(TopoDS_Shape S, BRepTools_ReShape theReshaper, Standard_Boolean const verifyFaceTolerance)

        Replaces tolerance   of  FACE EDGE VERTEX  by  the
        tolerance Max of their connected handling shapes.
        It is not necessary to use this call after
        SameParameter. (called in)<br>
        theReshaper is used to record the modifications of input shape <S> to prevent any 
        modifications on the shape itself.
        Thus the input shape (and its subshapes) will not be modified, instead the reshaper will 
        contain a modified empty-copies of original subshapes as substitutions.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theReshaper: OCC.wrapper.BRepTools.BRepTools_ReShape
        :type verifyFaceTolerance: bool

        """
        return _BRepLib.BRepLib__UpdateTolerances(*args)

    UpdateTolerances = staticmethod(UpdateTolerances)

    def UpdateInnerTolerances(*args):
        """
        UpdateInnerTolerances(TopoDS_Shape S)

        Checks tolerances of edges (including inner points) and vertices
        of a shape and updates them to satisfy "SameParameter" condition

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepLib.BRepLib__UpdateInnerTolerances(*args)

    UpdateInnerTolerances = staticmethod(UpdateInnerTolerances)

    def OrientClosedSolid(*args):
        """
        OrientClosedSolid(TopoDS_Solid solid) -> Standard_Boolean

        Orients the solid forward  and the  shell with the
        orientation to have  matter in the solid. Returns
        False if the solid is unOrientable (open or incoherent)

        :type solid: OCC.wrapper.TopoDS.TopoDS_Solid
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepLib.BRepLib__OrientClosedSolid(*args)

    OrientClosedSolid = staticmethod(OrientClosedSolid)

    def EncodeRegularity(*args):
        """
        EncodeRegularity(TopoDS_Shape S, Standard_Real const TolAng=1.0e-10)
        EncodeRegularity(TopoDS_Shape S, NCollection_List_TopoDS_Shape LE, Standard_Real const TolAng=1.0e-10)
        EncodeRegularity(TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2, Standard_Real const TolAng=1.0e-10)

        Encodes the Regularity beetween <F1> and <F2> by <E>
        Warning: <TolAng> is an angular tolerance, expressed in Rad.
        Warning: If the edge's regularity is coded before, nothing
        is done.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :type TolAng: float

        """
        return _BRepLib.BRepLib__EncodeRegularity(*args)

    EncodeRegularity = staticmethod(EncodeRegularity)

    def SortFaces(*args):
        """
        SortFaces(TopoDS_Shape S, NCollection_List_TopoDS_Shape LF)

        Sorts in  LF the Faces of   S on the  complexity of
        their                  surfaces
        (Plane,Cylinder,Cone,Sphere,Torus,other)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type LF: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepLib.BRepLib__SortFaces(*args)

    SortFaces = staticmethod(SortFaces)

    def ReverseSortFaces(*args):
        """
        ReverseSortFaces(TopoDS_Shape S, NCollection_List_TopoDS_Shape LF)

        Sorts in  LF  the   Faces  of S   on the reverse
        complexity       of       their      surfaces
        (other,Torus,Sphere,Cone,Cylinder,Plane)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type LF: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepLib.BRepLib__ReverseSortFaces(*args)

    ReverseSortFaces = staticmethod(ReverseSortFaces)

    def EnsureNormalConsistency(*args):
        """
        EnsureNormalConsistency(TopoDS_Shape S, Standard_Real const theAngTol=0.001, Standard_Boolean const ForceComputeNormals) -> Standard_Boolean

        Corrects the normals in Poly_Triangulation of faces,
        in such way that normals at nodes lying along smooth
        edges have the same value on both adjacent triangulations.
        Returns TRUE if any correction is done.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theAngTol: float
        :type ForceComputeNormals: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepLib.BRepLib__EnsureNormalConsistency(*args)

    EnsureNormalConsistency = staticmethod(EnsureNormalConsistency)

    def BoundingVertex(*args):
        """
        BoundingVertex(NCollection_List_TopoDS_Shape theLV, gp_Pnt theNewCenter)

        Calculates the bounding sphere around the set of vertexes from the theLV list.
        Returns the center (theNewCenter) and the radius (theNewTol) of this sphere.
        This can be used to construct the new vertex which covers the given set of
        other vertices.

        :type theLV: OCC.wrapper.TopoDS.NCollection_List_TopoDS_Shape
        :type theNewCenter: OCC.wrapper.gp.gp_Pnt
        :type theNewTol: float

        """
        return _BRepLib.BRepLib__BoundingVertex(*args)

    BoundingVertex = staticmethod(BoundingVertex)

    def FindValidRange(*args):
        """
        FindValidRange(Adaptor3d_Curve theCurve, Standard_Real const theTolE, Standard_Real const theParV1, gp_Pnt thePntV1, Standard_Real const theTolV1, Standard_Real const theParV2, gp_Pnt thePntV2, Standard_Real const theTolV2) -> Standard_Boolean
        FindValidRange(TopoDS_Edge theEdge) -> Standard_Boolean

        Finds a range of 3d curve of the edge not covered by vertices tolerances.
        Returns false if there is no such range. Otherwise, sets theFirst and 
        theLast as its bounds.

        :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theFirst: float
        :type theLast: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepLib.BRepLib__FindValidRange(*args)

    FindValidRange = staticmethod(FindValidRange)

    def ExtendFace(*args):
        """
        ExtendFace(TopoDS_Face theF, Standard_Real const theExtVal, Standard_Boolean const theExtUMin, Standard_Boolean const theExtUMax, Standard_Boolean const theExtVMin, Standard_Boolean const theExtVMax, TopoDS_Face theFExtended)

        Enlarges the face on the given value.
        @param theF [in] The face to extend
        @param theExtVal [in] The extension value
        @param theExtUMin [in] Defines whether to extend the face in UMin direction
        @param theExtUMax [in] Defines whether to extend the face in UMax direction
        @param theExtVMin [in] Defines whether to extend the face in VMin direction
        @param theExtVMax [in] Defines whether to extend the face in VMax direction
        @param theFExtended [in] The extended face

        :type theF: OCC.wrapper.TopoDS.TopoDS_Face
        :type theExtVal: float
        :type theExtUMin: bool
        :type theExtUMax: bool
        :type theExtVMin: bool
        :type theExtVMax: bool
        :type theFExtended: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepLib.BRepLib__ExtendFace(*args)

    ExtendFace = staticmethod(ExtendFace)

    def __init__(self):
        """
        The BRepLib package provides general utilities for
        BRep.

        * FindSurface : Class to compute a surface through
        a set of edges.

        * Compute missing 3d curve on an edge.
        """
        this = _BRepLib.new_BRepLib_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepLib.delete_BRepLib_
BRepLib__swigregister = _BRepLib.BRepLib__swigregister
BRepLib__swigregister(BRepLib_)

def BRepLib__Precision(*args):
    """
    Precision(Standard_Real const P)
    BRepLib__Precision() -> Standard_Real

    Returns the default precision.

    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRepLib.BRepLib__Precision(*args)

def BRepLib__Plane(*args):
    """
    Plane(Handle_Geom_Plane P)
    BRepLib__Plane() -> Handle_Geom_Plane

    Returns the current plane.

    :rtype: OCC.wrapper.Geom.Handle_Geom_Plane

    """
    return _BRepLib.BRepLib__Plane(*args)

def BRepLib__CheckSameRange(*args):
    """
    BRepLib__CheckSameRange(TopoDS_Edge E, Standard_Real const Confusion=1.0e-12) -> Standard_Boolean

    checks if the Edge is same range IGNORING
    the same range flag of the edge
    Confusion argument is to compare real numbers
    idenpendently of any model space tolerance

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type Confusion: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepLib.BRepLib__CheckSameRange(*args)

def BRepLib__SameRange(*args):
    """
    BRepLib__SameRange(TopoDS_Edge E, Standard_Real const Tolerance=1.0e-5)

    will make all the curve representation have
    the same range domain for the parameters.
    This will IGNORE the same range flag value
    to proceed.
    If there is a 3D curve there it will the
    range of that curve. If not the first curve representation
    encountered in the list will give its range to
    the all the other curves.

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type Tolerance: float

    """
    return _BRepLib.BRepLib__SameRange(*args)

def BRepLib__BuildCurve3d(*args):
    """
    BRepLib__BuildCurve3d(TopoDS_Edge E, Standard_Real const Tolerance=1.0e-5, GeomAbs_Shape const Continuity=GeomAbs_C1, Standard_Integer const MaxDegree=14, Standard_Integer const MaxSegment=0) -> Standard_Boolean

    Computes the 3d curve for the edge  <E> if it does
    not exist. Returns True  if the curve was computed
    or  existed. Returns False  if there is no  planar
    pcurve or the computation failed.
    <MaxSegment> >= 30 in approximation

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type Tolerance: float
    :type Continuity: OCC.wrapper.GeomAbs.GeomAbs_Shape
    :type MaxDegree: int
    :type MaxSegment: int
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepLib.BRepLib__BuildCurve3d(*args)

def BRepLib__BuildCurves3d(*args):
    """
    BuildCurves3d(TopoDS_Shape S, Standard_Real const Tolerance, GeomAbs_Shape const Continuity=GeomAbs_C1, Standard_Integer const MaxDegree=14, Standard_Integer const MaxSegment=0) -> Standard_Boolean
    BRepLib__BuildCurves3d(TopoDS_Shape S) -> Standard_Boolean

    Computes  the 3d curves  for all the  edges of <S>
    return False if one of the computation failed.

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepLib.BRepLib__BuildCurves3d(*args)

def BRepLib__BuildPCurveForEdgeOnPlane(*args):
    """
    BuildPCurveForEdgeOnPlane(TopoDS_Edge theE, TopoDS_Face theF)
    BRepLib__BuildPCurveForEdgeOnPlane(TopoDS_Edge theE, TopoDS_Face theF, Handle_Geom2d_Curve aC2D)

    Builds pcurve of edge on face if the surface is plane, but does not update the edge.
    The output are the pcurve and the flag telling that pcurve was built.

    :type theE: OCC.wrapper.TopoDS.TopoDS_Edge
    :type theF: OCC.wrapper.TopoDS.TopoDS_Face
    :type aC2D: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
    :type bToUpdate: bool

    """
    return _BRepLib.BRepLib__BuildPCurveForEdgeOnPlane(*args)

def BRepLib__UpdateEdgeTol(*args):
    """
    BRepLib__UpdateEdgeTol(TopoDS_Edge E, Standard_Real const MinToleranceRequest, Standard_Real const MaxToleranceToCheck) -> Standard_Boolean

    Checks if the edge has a  Tolerance smaller than -- --
    -- -- MaxToleranceToCheck  if  so it will compute  the
    radius    of  -- the   cylindrical  pipe  surface that
    MinToleranceRequest is the minimum tolerance before it
    is usefull to start testing. Usually it should be arround
    10e-5
    contains all  --  the curve represenation of  the edge
    returns True if the Edge tolerance had to be updated

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type MinToleranceRequest: float
    :type MaxToleranceToCheck: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepLib.BRepLib__UpdateEdgeTol(*args)

def BRepLib__UpdateEdgeTolerance(*args):
    """
    BRepLib__UpdateEdgeTolerance(TopoDS_Shape S, Standard_Real const MinToleranceRequest, Standard_Real const MaxToleranceToCheck) -> Standard_Boolean

    -- Checks all the edges of the shape whose -- -- --
    Tolerance  is  smaller than  MaxToleranceToCheck --
    Returns True if at  least  one edge was updated --
    MinToleranceRequest is the minimum tolerance before
    --  it -- is  usefull to start  testing. Usually it
    should be arround -- 10e-5--

    Warning :The  method is  very  slow  as it  checks all.
    Use  only  in interfaces or  processing assimilate batch

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type MinToleranceRequest: float
    :type MaxToleranceToCheck: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepLib.BRepLib__UpdateEdgeTolerance(*args)

def BRepLib__SameParameter(*args):
    """
    SameParameter(TopoDS_Edge theEdge, Standard_Real const Tolerance=1.0e-5)
    SameParameter(TopoDS_Edge theEdge, Standard_Real const theTolerance, Standard_Boolean const IsUseOldEdge) -> TopoDS_Edge
    SameParameter(TopoDS_Shape S, Standard_Real const Tolerance=1.0e-5, Standard_Boolean const forced)
    BRepLib__SameParameter(TopoDS_Shape S, BRepTools_ReShape theReshaper, Standard_Real const Tolerance=1.0e-5, Standard_Boolean const forced)

    Computes new 2d curve(s) for all the edges of  <S>
    to have the same parameter  as  the  3d curve.
    The algorithm is not done if the flag SameParameter
    was True  on an  Edge.<br>
    theReshaper is used to record the modifications of input shape <S> to prevent any 
    modifications on the shape itself.
    Thus the input shape (and its subshapes) will not be modified, instead the reshaper will 
    contain a modified empty-copies of original subshapes as substitutions.

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theReshaper: OCC.wrapper.BRepTools.BRepTools_ReShape
    :type Tolerance: float
    :type forced: bool

    """
    return _BRepLib.BRepLib__SameParameter(*args)

def BRepLib__UpdateTolerances(*args):
    """
    UpdateTolerances(TopoDS_Shape S, Standard_Boolean const verifyFaceTolerance)
    BRepLib__UpdateTolerances(TopoDS_Shape S, BRepTools_ReShape theReshaper, Standard_Boolean const verifyFaceTolerance)

    Replaces tolerance   of  FACE EDGE VERTEX  by  the
    tolerance Max of their connected handling shapes.
    It is not necessary to use this call after
    SameParameter. (called in)<br>
    theReshaper is used to record the modifications of input shape <S> to prevent any 
    modifications on the shape itself.
    Thus the input shape (and its subshapes) will not be modified, instead the reshaper will 
    contain a modified empty-copies of original subshapes as substitutions.

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theReshaper: OCC.wrapper.BRepTools.BRepTools_ReShape
    :type verifyFaceTolerance: bool

    """
    return _BRepLib.BRepLib__UpdateTolerances(*args)

def BRepLib__UpdateInnerTolerances(*args):
    """
    BRepLib__UpdateInnerTolerances(TopoDS_Shape S)

    Checks tolerances of edges (including inner points) and vertices
    of a shape and updates them to satisfy "SameParameter" condition

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _BRepLib.BRepLib__UpdateInnerTolerances(*args)

def BRepLib__OrientClosedSolid(*args):
    """
    BRepLib__OrientClosedSolid(TopoDS_Solid solid) -> Standard_Boolean

    Orients the solid forward  and the  shell with the
    orientation to have  matter in the solid. Returns
    False if the solid is unOrientable (open or incoherent)

    :type solid: OCC.wrapper.TopoDS.TopoDS_Solid
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepLib.BRepLib__OrientClosedSolid(*args)

def BRepLib__EncodeRegularity(*args):
    """
    EncodeRegularity(TopoDS_Shape S, Standard_Real const TolAng=1.0e-10)
    EncodeRegularity(TopoDS_Shape S, NCollection_List_TopoDS_Shape LE, Standard_Real const TolAng=1.0e-10)
    BRepLib__EncodeRegularity(TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2, Standard_Real const TolAng=1.0e-10)

    Encodes the Regularity beetween <F1> and <F2> by <E>
    Warning: <TolAng> is an angular tolerance, expressed in Rad.
    Warning: If the edge's regularity is coded before, nothing
    is done.

    :type E: OCC.wrapper.TopoDS.TopoDS_Edge
    :type F1: OCC.wrapper.TopoDS.TopoDS_Face
    :type F2: OCC.wrapper.TopoDS.TopoDS_Face
    :type TolAng: float

    """
    return _BRepLib.BRepLib__EncodeRegularity(*args)

def BRepLib__SortFaces(*args):
    """
    BRepLib__SortFaces(TopoDS_Shape S, NCollection_List_TopoDS_Shape LF)

    Sorts in  LF the Faces of   S on the  complexity of
    their                  surfaces
    (Plane,Cylinder,Cone,Sphere,Torus,other)

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type LF: OCC.wrapper.TopTools.TopTools_ListOfShape

    """
    return _BRepLib.BRepLib__SortFaces(*args)

def BRepLib__ReverseSortFaces(*args):
    """
    BRepLib__ReverseSortFaces(TopoDS_Shape S, NCollection_List_TopoDS_Shape LF)

    Sorts in  LF  the   Faces  of S   on the reverse
    complexity       of       their      surfaces
    (other,Torus,Sphere,Cone,Cylinder,Plane)

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type LF: OCC.wrapper.TopTools.TopTools_ListOfShape

    """
    return _BRepLib.BRepLib__ReverseSortFaces(*args)

def BRepLib__EnsureNormalConsistency(*args):
    """
    BRepLib__EnsureNormalConsistency(TopoDS_Shape S, Standard_Real const theAngTol=0.001, Standard_Boolean const ForceComputeNormals) -> Standard_Boolean

    Corrects the normals in Poly_Triangulation of faces,
    in such way that normals at nodes lying along smooth
    edges have the same value on both adjacent triangulations.
    Returns TRUE if any correction is done.

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theAngTol: float
    :type ForceComputeNormals: bool
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepLib.BRepLib__EnsureNormalConsistency(*args)

def BRepLib__BoundingVertex(*args):
    """
    BRepLib__BoundingVertex(NCollection_List_TopoDS_Shape theLV, gp_Pnt theNewCenter)

    Calculates the bounding sphere around the set of vertexes from the theLV list.
    Returns the center (theNewCenter) and the radius (theNewTol) of this sphere.
    This can be used to construct the new vertex which covers the given set of
    other vertices.

    :type theLV: OCC.wrapper.TopoDS.NCollection_List_TopoDS_Shape
    :type theNewCenter: OCC.wrapper.gp.gp_Pnt
    :type theNewTol: float

    """
    return _BRepLib.BRepLib__BoundingVertex(*args)

def BRepLib__FindValidRange(*args):
    """
    FindValidRange(Adaptor3d_Curve theCurve, Standard_Real const theTolE, Standard_Real const theParV1, gp_Pnt thePntV1, Standard_Real const theTolV1, Standard_Real const theParV2, gp_Pnt thePntV2, Standard_Real const theTolV2) -> Standard_Boolean
    BRepLib__FindValidRange(TopoDS_Edge theEdge) -> Standard_Boolean

    Finds a range of 3d curve of the edge not covered by vertices tolerances.
    Returns false if there is no such range. Otherwise, sets theFirst and 
    theLast as its bounds.

    :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
    :type theFirst: float
    :type theLast: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepLib.BRepLib__FindValidRange(*args)

def BRepLib__ExtendFace(*args):
    """
    BRepLib__ExtendFace(TopoDS_Face theF, Standard_Real const theExtVal, Standard_Boolean const theExtUMin, Standard_Boolean const theExtUMax, Standard_Boolean const theExtVMin, Standard_Boolean const theExtVMax, TopoDS_Face theFExtended)

    Enlarges the face on the given value.
    @param theF [in] The face to extend
    @param theExtVal [in] The extension value
    @param theExtUMin [in] Defines whether to extend the face in UMin direction
    @param theExtUMax [in] Defines whether to extend the face in UMax direction
    @param theExtVMin [in] Defines whether to extend the face in VMin direction
    @param theExtVMax [in] Defines whether to extend the face in VMax direction
    @param theFExtended [in] The extended face

    :type theF: OCC.wrapper.TopoDS.TopoDS_Face
    :type theExtVal: float
    :type theExtUMin: bool
    :type theExtUMax: bool
    :type theExtVMin: bool
    :type theExtVMax: bool
    :type theFExtended: OCC.wrapper.TopoDS.TopoDS_Face

    """
    return _BRepLib.BRepLib__ExtendFace(*args)

class BRepLib_MakeEdge2d(BRepLib_MakeShape):
    """
    Provides methods to build edges.

    The   methods have  the  following   syntax, where
    TheCurve is one of Lin2d, Circ2d, ...

    Create(C : TheCurve)

    Makes an edge on  the whole curve.  Add vertices
    on finite curves.

    Create(C : TheCurve; p1,p2 : Real)

    Make an edge  on the curve between parameters p1
    and p2. if p2 < p1 the edge will be REVERSED. If
    p1  or p2 is infinite the  curve will be open in
    that  direction. Vertices are created for finite
    values of p1 and p2.

    Create(C : TheCurve; P1, P2 : Pnt2d from gp)

    Make an edge on the curve  between the points P1
    and P2. The  points are projected on   the curve
    and the   previous method is  used. An  error is
    raised if the points are not on the curve.

    Create(C : TheCurve; V1, V2 : Vertex from TopoDS)

    Make an edge  on the curve  between the vertices
    V1 and V2. Same as the  previous but no vertices
    are created. If a vertex is  Null the curve will
    be open in this direction.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepLib_MakeEdge2d self, TopoDS_Vertex V1, TopoDS_Vertex V2) -> BRepLib_MakeEdge2d
        __init__(BRepLib_MakeEdge2d self, gp_Pnt2d P1, gp_Pnt2d P2) -> BRepLib_MakeEdge2d
        __init__(BRepLib_MakeEdge2d self, gp_Lin2d L) -> BRepLib_MakeEdge2d
        __init__(BRepLib_MakeEdge2d self, gp_Lin2d L, Standard_Real const p1, Standard_Real const p2) -> BRepLib_MakeEdge2d
        __init__(BRepLib_MakeEdge2d self, gp_Lin2d L, gp_Pnt2d P1, gp_Pnt2d P2) -> BRepLib_MakeEdge2d
        __init__(BRepLib_MakeEdge2d self, gp_Lin2d L, TopoDS_Vertex V1, TopoDS_Vertex V2) -> BRepLib_MakeEdge2d
        __init__(BRepLib_MakeEdge2d self, gp_Circ2d L) -> BRepLib_MakeEdge2d
        __init__(BRepLib_MakeEdge2d self, gp_Circ2d L, Standard_Real const p1, Standard_Real const p2) -> BRepLib_MakeEdge2d
        __init__(BRepLib_MakeEdge2d self, gp_Circ2d L, gp_Pnt2d P1, gp_Pnt2d P2) -> BRepLib_MakeEdge2d
        __init__(BRepLib_MakeEdge2d self, gp_Circ2d L, TopoDS_Vertex V1, TopoDS_Vertex V2) -> BRepLib_MakeEdge2d
        __init__(BRepLib_MakeEdge2d self, gp_Elips2d L) -> BRepLib_MakeEdge2d
        __init__(BRepLib_MakeEdge2d self, gp_Elips2d L, Standard_Real const p1, Standard_Real const p2) -> BRepLib_MakeEdge2d
        __init__(BRepLib_MakeEdge2d self, gp_Elips2d L, gp_Pnt2d P1, gp_Pnt2d P2) -> BRepLib_MakeEdge2d
        __init__(BRepLib_MakeEdge2d self, gp_Elips2d L, TopoDS_Vertex V1, TopoDS_Vertex V2) -> BRepLib_MakeEdge2d
        __init__(BRepLib_MakeEdge2d self, gp_Hypr2d L) -> BRepLib_MakeEdge2d
        __init__(BRepLib_MakeEdge2d self, gp_Hypr2d L, Standard_Real const p1, Standard_Real const p2) -> BRepLib_MakeEdge2d
        __init__(BRepLib_MakeEdge2d self, gp_Hypr2d L, gp_Pnt2d P1, gp_Pnt2d P2) -> BRepLib_MakeEdge2d
        __init__(BRepLib_MakeEdge2d self, gp_Hypr2d L, TopoDS_Vertex V1, TopoDS_Vertex V2) -> BRepLib_MakeEdge2d
        __init__(BRepLib_MakeEdge2d self, gp_Parab2d L) -> BRepLib_MakeEdge2d
        __init__(BRepLib_MakeEdge2d self, gp_Parab2d L, Standard_Real const p1, Standard_Real const p2) -> BRepLib_MakeEdge2d
        __init__(BRepLib_MakeEdge2d self, gp_Parab2d L, gp_Pnt2d P1, gp_Pnt2d P2) -> BRepLib_MakeEdge2d
        __init__(BRepLib_MakeEdge2d self, gp_Parab2d L, TopoDS_Vertex V1, TopoDS_Vertex V2) -> BRepLib_MakeEdge2d
        __init__(BRepLib_MakeEdge2d self, Handle_Geom2d_Curve L) -> BRepLib_MakeEdge2d
        __init__(BRepLib_MakeEdge2d self, Handle_Geom2d_Curve L, Standard_Real const p1, Standard_Real const p2) -> BRepLib_MakeEdge2d
        __init__(BRepLib_MakeEdge2d self, Handle_Geom2d_Curve L, gp_Pnt2d P1, gp_Pnt2d P2) -> BRepLib_MakeEdge2d
        __init__(BRepLib_MakeEdge2d self, Handle_Geom2d_Curve L, TopoDS_Vertex V1, TopoDS_Vertex V2) -> BRepLib_MakeEdge2d
        __init__(BRepLib_MakeEdge2d self, Handle_Geom2d_Curve L, gp_Pnt2d P1, gp_Pnt2d P2, Standard_Real const p1, Standard_Real const p2) -> BRepLib_MakeEdge2d
        __init__(BRepLib_MakeEdge2d self, Handle_Geom2d_Curve L, TopoDS_Vertex V1, TopoDS_Vertex V2, Standard_Real const p1, Standard_Real const p2) -> BRepLib_MakeEdge2d

        :type L: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type V1: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type V2: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type p1: float
        :type p2: float

        """
        this = _BRepLib.new_BRepLib_MakeEdge2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepLib_MakeEdge2d self, Handle_Geom2d_Curve C)
        Init(BRepLib_MakeEdge2d self, Handle_Geom2d_Curve C, Standard_Real const p1, Standard_Real const p2)
        Init(BRepLib_MakeEdge2d self, Handle_Geom2d_Curve C, gp_Pnt2d P1, gp_Pnt2d P2)
        Init(BRepLib_MakeEdge2d self, Handle_Geom2d_Curve C, TopoDS_Vertex V1, TopoDS_Vertex V2)
        Init(BRepLib_MakeEdge2d self, Handle_Geom2d_Curve C, gp_Pnt2d P1, gp_Pnt2d P2, Standard_Real const p1, Standard_Real const p2)
        Init(BRepLib_MakeEdge2d self, Handle_Geom2d_Curve C, TopoDS_Vertex V1, TopoDS_Vertex V2, Standard_Real const p1, Standard_Real const p2)

        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type V1: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type V2: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type p1: float
        :type p2: float

        """
        return _BRepLib.BRepLib_MakeEdge2d_Init(self, *args)


    def Error(self, *args):
        """
        Error(BRepLib_MakeEdge2d self) -> BRepLib_EdgeError

        Returns the error description when NotDone.

        :rtype: OCC.wrapper.BRepLib.BRepLib_EdgeError

        """
        return _BRepLib.BRepLib_MakeEdge2d_Error(self, *args)


    def Edge(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepLib.BRepLib_MakeEdge2d_Edge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Vertex1(self, *args):
        """
        Returns the first vertex of the edge. May be Null.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        res = _BRepLib.BRepLib_MakeEdge2d_Vertex1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Vertex2(self, *args):
        """
        Returns the second vertex of the edge. May be Null.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        res = _BRepLib.BRepLib_MakeEdge2d_Vertex2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepLib.delete_BRepLib_MakeEdge2d
BRepLib_MakeEdge2d_swigregister = _BRepLib.BRepLib_MakeEdge2d_swigregister
BRepLib_MakeEdge2d_swigregister(BRepLib_MakeEdge2d)

class BRepLib_MakeWire(BRepLib_MakeShape):
    """
    Provides methods to build wires.

    A wire may be built :

    * From a single edge.

    * From a wire and an edge.

    - A new wire  is created with the edges  of  the
    wire + the edge.

    - If the edge is not connnected  to the wire the
    flag NotDone   is set and  the  method Wire will
    raise an error.

    - The connection may be :

    . Through an existing vertex. The edge is shared.

    . Through a geometric coincidence of vertices.
    The edge is  copied  and the vertices from the
    edge are  replaced  by  the vertices from  the
    wire.

    . The new edge and the connection vertices are
    kept by the algorithm.

    * From 2, 3, 4 edges.

    - A wire is  created from  the first edge, the
    following edges are added.

    * From many edges.

    - The following syntax may be used :

    BRepLib_MakeWire MW;

    // for all the edges ...
    MW.Add(anEdge);

    TopoDS_Wire W = MW;
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepLib_MakeWire self) -> BRepLib_MakeWire
        __init__(BRepLib_MakeWire self, TopoDS_Edge E) -> BRepLib_MakeWire
        __init__(BRepLib_MakeWire self, TopoDS_Edge E1, TopoDS_Edge E2) -> BRepLib_MakeWire
        __init__(BRepLib_MakeWire self, TopoDS_Edge E1, TopoDS_Edge E2, TopoDS_Edge E3) -> BRepLib_MakeWire
        __init__(BRepLib_MakeWire self, TopoDS_Edge E1, TopoDS_Edge E2, TopoDS_Edge E3, TopoDS_Edge E4) -> BRepLib_MakeWire
        __init__(BRepLib_MakeWire self, TopoDS_Wire W) -> BRepLib_MakeWire
        __init__(BRepLib_MakeWire self, TopoDS_Wire W, TopoDS_Edge E) -> BRepLib_MakeWire

        Add an edge to a wire.

        :type W: OCC.wrapper.TopoDS.TopoDS_Wire
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        this = _BRepLib.new_BRepLib_MakeWire(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args):
        """
        Add(BRepLib_MakeWire self, TopoDS_Edge E)
        Add(BRepLib_MakeWire self, TopoDS_Wire W)
        Add(BRepLib_MakeWire self, NCollection_List_TopoDS_Shape L)

        Add the edges of <L> to the current wire.
        The edges are not to be consecutive.  But they are
        to be all connected geometrically or topologically.

        :type L: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepLib.BRepLib_MakeWire_Add(self, *args)


    def Error(self, *args):
        """
        Error(BRepLib_MakeWire self) -> BRepLib_WireError

        :rtype: OCC.wrapper.BRepLib.BRepLib_WireError

        """
        return _BRepLib.BRepLib_MakeWire_Error(self, *args)


    def Wire(self, *args):
        """
        Wire(BRepLib_MakeWire self) -> TopoDS_Wire

        Returns the new wire.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _BRepLib.BRepLib_MakeWire_Wire(self, *args)


    def Edge(self, *args):
        """
        Returns the last edge added to the wire.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepLib.BRepLib_MakeWire_Edge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Vertex(self, *args):
        """
        Returns the last connecting vertex.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        res = _BRepLib.BRepLib_MakeWire_Vertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepLib.delete_BRepLib_MakeWire
BRepLib_MakeWire_swigregister = _BRepLib.BRepLib_MakeWire_swigregister
BRepLib_MakeWire_swigregister(BRepLib_MakeWire)

class BRepLib_MakeVertex(BRepLib_MakeShape):
    """Provides methods to build vertices."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepLib_MakeVertex self, gp_Pnt P) -> BRepLib_MakeVertex

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        this = _BRepLib.new_BRepLib_MakeVertex(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Vertex(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        res = _BRepLib.BRepLib_MakeVertex_Vertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepLib.delete_BRepLib_MakeVertex
BRepLib_MakeVertex_swigregister = _BRepLib.BRepLib_MakeVertex_swigregister
BRepLib_MakeVertex_swigregister(BRepLib_MakeVertex)

class BRepLib_MakeFace(BRepLib_MakeShape):
    """
    Provides methods to build faces.

    A face may be built :

    * From a surface.

    - Elementary surface from gp.

    - Surface from Geom.

    * From a surface and U,V values.

    * From a wire.

    - Find the surface automatically if possible.

    * From a surface and a wire.

    - A flag Inside is given, when this flag is True
    the  wire is  oriented to bound a finite area on
    the surface.

    * From a face and a wire.

    - The new wire is a perforation.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepLib_MakeFace self) -> BRepLib_MakeFace
        __init__(BRepLib_MakeFace self, TopoDS_Face F) -> BRepLib_MakeFace
        __init__(BRepLib_MakeFace self, gp_Pln P) -> BRepLib_MakeFace
        __init__(BRepLib_MakeFace self, gp_Cylinder C) -> BRepLib_MakeFace
        __init__(BRepLib_MakeFace self, gp_Cone C) -> BRepLib_MakeFace
        __init__(BRepLib_MakeFace self, gp_Sphere S) -> BRepLib_MakeFace
        __init__(BRepLib_MakeFace self, gp_Torus C) -> BRepLib_MakeFace
        __init__(BRepLib_MakeFace self, Handle_Geom_Surface S, Standard_Real const TolDegen) -> BRepLib_MakeFace
        __init__(BRepLib_MakeFace self, gp_Pln P, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax) -> BRepLib_MakeFace
        __init__(BRepLib_MakeFace self, gp_Cylinder C, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax) -> BRepLib_MakeFace
        __init__(BRepLib_MakeFace self, gp_Cone C, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax) -> BRepLib_MakeFace
        __init__(BRepLib_MakeFace self, gp_Sphere S, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax) -> BRepLib_MakeFace
        __init__(BRepLib_MakeFace self, gp_Torus C, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax) -> BRepLib_MakeFace
        __init__(BRepLib_MakeFace self, Handle_Geom_Surface S, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax, Standard_Real const TolDegen) -> BRepLib_MakeFace
        __init__(BRepLib_MakeFace self, TopoDS_Wire W, Standard_Boolean const OnlyPlane) -> BRepLib_MakeFace
        __init__(BRepLib_MakeFace self, gp_Pln P, TopoDS_Wire W, Standard_Boolean const Inside) -> BRepLib_MakeFace
        __init__(BRepLib_MakeFace self, gp_Cylinder C, TopoDS_Wire W, Standard_Boolean const Inside) -> BRepLib_MakeFace
        __init__(BRepLib_MakeFace self, gp_Cone C, TopoDS_Wire W, Standard_Boolean const Inside) -> BRepLib_MakeFace
        __init__(BRepLib_MakeFace self, gp_Sphere S, TopoDS_Wire W, Standard_Boolean const Inside) -> BRepLib_MakeFace
        __init__(BRepLib_MakeFace self, gp_Torus C, TopoDS_Wire W, Standard_Boolean const Inside) -> BRepLib_MakeFace
        __init__(BRepLib_MakeFace self, Handle_Geom_Surface S, TopoDS_Wire W, Standard_Boolean const Inside) -> BRepLib_MakeFace
        __init__(BRepLib_MakeFace self, TopoDS_Face F, TopoDS_Wire W) -> BRepLib_MakeFace

        Adds the wire <W> in the face <F>

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type W: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        this = _BRepLib.new_BRepLib_MakeFace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepLib_MakeFace self, TopoDS_Face F)
        Init(BRepLib_MakeFace self, Handle_Geom_Surface S, Standard_Boolean const Bound, Standard_Real const TolDegen)
        Init(BRepLib_MakeFace self, Handle_Geom_Surface S, Standard_Real const UMin, Standard_Real const UMax, Standard_Real const VMin, Standard_Real const VMax, Standard_Real const TolDegen)

        Creates the face from the surface and the min-max
        values. Accepts tolerance value (TolDegen) for resolution
        of degenerated edges.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type UMin: float
        :type UMax: float
        :type VMin: float
        :type VMax: float
        :type TolDegen: float

        """
        return _BRepLib.BRepLib_MakeFace_Init(self, *args)


    def Add(self, *args):
        """
        Add(BRepLib_MakeFace self, TopoDS_Wire W)

        Adds the wire <W> in the current face.

        :type W: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _BRepLib.BRepLib_MakeFace_Add(self, *args)


    def Error(self, *args):
        """
        Error(BRepLib_MakeFace self) -> BRepLib_FaceError

        :rtype: OCC.wrapper.BRepLib.BRepLib_FaceError

        """
        return _BRepLib.BRepLib_MakeFace_Error(self, *args)


    def Face(self, *args):
        """
        Face(BRepLib_MakeFace self) -> TopoDS_Face

        Returns the new face.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepLib.BRepLib_MakeFace_Face(self, *args)


    def IsDegenerated(*args):
        """
        IsDegenerated(Handle_Geom_Curve theCurve, Standard_Real const theMaxTol) -> Standard_Boolean

        Checks the specified curve is degenerated
        according to specified tolerance.
        Returns <theActTol> less than <theMaxTol>, which shows
        actual tolerance to decide the curve is degenerated.
        Warning: For internal use of BRepLib_MakeFace and BRepLib_MakeShell.

        :type theCurve: OCC.wrapper.Geom.Handle_Geom_Curve
        :type theMaxTol: float
        :type theActTol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepLib.BRepLib_MakeFace_IsDegenerated(*args)

    IsDegenerated = staticmethod(IsDegenerated)
    __swig_destroy__ = _BRepLib.delete_BRepLib_MakeFace
BRepLib_MakeFace_swigregister = _BRepLib.BRepLib_MakeFace_swigregister
BRepLib_MakeFace_swigregister(BRepLib_MakeFace)

def BRepLib_MakeFace_IsDegenerated(*args):
    """
    BRepLib_MakeFace_IsDegenerated(Handle_Geom_Curve theCurve, Standard_Real const theMaxTol) -> Standard_Boolean

    Checks the specified curve is degenerated
    according to specified tolerance.
    Returns <theActTol> less than <theMaxTol>, which shows
    actual tolerance to decide the curve is degenerated.
    Warning: For internal use of BRepLib_MakeFace and BRepLib_MakeShell.

    :type theCurve: OCC.wrapper.Geom.Handle_Geom_Curve
    :type theMaxTol: float
    :type theActTol: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepLib.BRepLib_MakeFace_IsDegenerated(*args)

class BRepLib_MakePolygon(BRepLib_MakeShape):
    """
    Class to build polygonal wires.

    A polygonal wire may be build from

    - 2,4,3 points.

    - 2,3,4 vertices.

    - any number of points.

    - any number of vertices.

    When a point or vertex is added to the  polygon if
    it is identic  to the previous  point no  edge  is
    built. The method added can be used to test it.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepLib_MakePolygon self) -> BRepLib_MakePolygon
        __init__(BRepLib_MakePolygon self, gp_Pnt P1, gp_Pnt P2) -> BRepLib_MakePolygon
        __init__(BRepLib_MakePolygon self, gp_Pnt P1, gp_Pnt P2, gp_Pnt P3, Standard_Boolean const Close) -> BRepLib_MakePolygon
        __init__(BRepLib_MakePolygon self, gp_Pnt P1, gp_Pnt P2, gp_Pnt P3, gp_Pnt P4, Standard_Boolean const Close) -> BRepLib_MakePolygon
        __init__(BRepLib_MakePolygon self, TopoDS_Vertex V1, TopoDS_Vertex V2) -> BRepLib_MakePolygon
        __init__(BRepLib_MakePolygon self, TopoDS_Vertex V1, TopoDS_Vertex V2, TopoDS_Vertex V3, Standard_Boolean const Close) -> BRepLib_MakePolygon
        __init__(BRepLib_MakePolygon self, TopoDS_Vertex V1, TopoDS_Vertex V2, TopoDS_Vertex V3, TopoDS_Vertex V4, Standard_Boolean const Close) -> BRepLib_MakePolygon

        :type V1: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type V2: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type V3: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type V4: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type Close: bool

        """
        this = _BRepLib.new_BRepLib_MakePolygon(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args):
        """
        Add(BRepLib_MakePolygon self, gp_Pnt P)
        Add(BRepLib_MakePolygon self, TopoDS_Vertex V)

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _BRepLib.BRepLib_MakePolygon_Add(self, *args)


    def Added(self, *args):
        """
        Added(BRepLib_MakePolygon self) -> Standard_Boolean

        Returns  True if  the last   vertex  or point  was
        succesfully added.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepLib.BRepLib_MakePolygon_Added(self, *args)


    def Close(self, *args):
        """Close(BRepLib_MakePolygon self)"""
        return _BRepLib.BRepLib_MakePolygon_Close(self, *args)


    def FirstVertex(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        res = _BRepLib.BRepLib_MakePolygon_FirstVertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LastVertex(self, *args):
        """
        :rtype: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        res = _BRepLib.BRepLib_MakePolygon_LastVertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Edge(self, *args):
        """
        Returns the last edge added to the polygon.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        res = _BRepLib.BRepLib_MakePolygon_Edge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Wire(self, *args):
        """
        Wire(BRepLib_MakePolygon self) -> TopoDS_Wire

        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _BRepLib.BRepLib_MakePolygon_Wire(self, *args)

    __swig_destroy__ = _BRepLib.delete_BRepLib_MakePolygon
BRepLib_MakePolygon_swigregister = _BRepLib.BRepLib_MakePolygon_swigregister
BRepLib_MakePolygon_swigregister(BRepLib_MakePolygon)

class BRepLib_CheckCurveOnSurface(object):
    """
    Computes the max distance between edge and its
    2d representation on the face.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepLib_CheckCurveOnSurface self) -> BRepLib_CheckCurveOnSurface
        __init__(BRepLib_CheckCurveOnSurface self, TopoDS_Edge theEdge, TopoDS_Face theFace) -> BRepLib_CheckCurveOnSurface

        Contructor

        :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face

        """
        this = _BRepLib.new_BRepLib_CheckCurveOnSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepLib_CheckCurveOnSurface self, TopoDS_Edge theEdge, TopoDS_Face theFace)

        Sets the data for the algorithm

        :type theEdge: OCC.wrapper.TopoDS.TopoDS_Edge
        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepLib.BRepLib_CheckCurveOnSurface_Init(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepLib_CheckCurveOnSurface self, Standard_Boolean const isTheMultyTheradDisabled)

        Performs the calculation
        If isTheMultyTheadDisabled == TRUE then computation will be made
        without any parallelization.

        :type isTheMultyTheradDisabled: bool

        """
        return _BRepLib.BRepLib_CheckCurveOnSurface_Perform(self, *args)


    def Curve(self, *args):
        """
        Returns source 3D-Curve

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _BRepLib.BRepLib_CheckCurveOnSurface_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PCurve(self, *args):
        """
        Returns mine 2D-Curve

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRepLib.BRepLib_CheckCurveOnSurface_PCurve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PCurve2(self, *args):
        """
        Returns 2nd 2D-Curve (if it exists, e.g. for seam-edge)

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        res = _BRepLib.BRepLib_CheckCurveOnSurface_PCurve2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Surface(self, *args):
        """
        Returns source surface

        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        res = _BRepLib.BRepLib_CheckCurveOnSurface_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Range(self, *args):
        """
        Range(BRepLib_CheckCurveOnSurface self)

        Returns first and last parameter of the curves
        (2D- and 3D-curves are considered to have same range)

        :type theFirst: float
        :type theLast: float

        """
        return _BRepLib.BRepLib_CheckCurveOnSurface_Range(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepLib_CheckCurveOnSurface self) -> Standard_Boolean

        Returns true if the max distance has been found

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepLib.BRepLib_CheckCurveOnSurface_IsDone(self, *args)


    def MaxDistance(self, *args):
        """
        MaxDistance(BRepLib_CheckCurveOnSurface self) -> Standard_Real

        Returns max distance

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepLib.BRepLib_CheckCurveOnSurface_MaxDistance(self, *args)


    def MaxParameter(self, *args):
        """
        MaxParameter(BRepLib_CheckCurveOnSurface self) -> Standard_Real

        Returns parameter in which the distance is maximal

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepLib.BRepLib_CheckCurveOnSurface_MaxParameter(self, *args)

    __swig_destroy__ = _BRepLib.delete_BRepLib_CheckCurveOnSurface
BRepLib_CheckCurveOnSurface_swigregister = _BRepLib.BRepLib_CheckCurveOnSurface_swigregister
BRepLib_CheckCurveOnSurface_swigregister(BRepLib_CheckCurveOnSurface)

class BRepLib_MakeSolid(BRepLib_MakeShape):
    """Makes a solid from compsolid  or  shells."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepLib_MakeSolid self) -> BRepLib_MakeSolid
        __init__(BRepLib_MakeSolid self, TopoDS_CompSolid S) -> BRepLib_MakeSolid
        __init__(BRepLib_MakeSolid self, TopoDS_Shell S) -> BRepLib_MakeSolid
        __init__(BRepLib_MakeSolid self, TopoDS_Shell S1, TopoDS_Shell S2) -> BRepLib_MakeSolid
        __init__(BRepLib_MakeSolid self, TopoDS_Shell S1, TopoDS_Shell S2, TopoDS_Shell S3) -> BRepLib_MakeSolid
        __init__(BRepLib_MakeSolid self, TopoDS_Solid So) -> BRepLib_MakeSolid
        __init__(BRepLib_MakeSolid self, TopoDS_Solid So, TopoDS_Shell S) -> BRepLib_MakeSolid

        Add a shell to a solid.

        :type So: OCC.wrapper.TopoDS.TopoDS_Solid
        :type S: OCC.wrapper.TopoDS.TopoDS_Shell

        """
        this = _BRepLib.new_BRepLib_MakeSolid(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args):
        """
        Add(BRepLib_MakeSolid self, TopoDS_Shell S)

        Add the shell to the current solid.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shell

        """
        return _BRepLib.BRepLib_MakeSolid_Add(self, *args)


    def Solid(self, *args):
        """
        Solid(BRepLib_MakeSolid self) -> TopoDS_Solid

        Returns the new Solid.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Solid

        """
        return _BRepLib.BRepLib_MakeSolid_Solid(self, *args)


    def FaceStatus(self, *args):
        """
        FaceStatus(BRepLib_MakeSolid self, TopoDS_Face F) -> BRepLib_ShapeModification

        returns the status of the Face after
        the shape creation.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.BRepLib.BRepLib_ShapeModification

        """
        return _BRepLib.BRepLib_MakeSolid_FaceStatus(self, *args)

    __swig_destroy__ = _BRepLib.delete_BRepLib_MakeSolid
BRepLib_MakeSolid_swigregister = _BRepLib.BRepLib_MakeSolid_swigregister
BRepLib_MakeSolid_swigregister(BRepLib_MakeSolid)




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_TopTrans')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_TopTrans')
    _TopTrans = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_TopTrans', [dirname(__file__)])
        except ImportError:
            import _TopTrans
            return _TopTrans
        try:
            _mod = imp.load_module('_TopTrans', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _TopTrans = swig_import_helper()
    del swig_import_helper
else:
    import _TopTrans
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _TopTrans.delete_SwigPyIterator

    def value(self):
        return _TopTrans.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _TopTrans.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _TopTrans.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _TopTrans.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _TopTrans.SwigPyIterator_equal(self, x)

    def copy(self):
        return _TopTrans.SwigPyIterator_copy(self)

    def next(self):
        return _TopTrans.SwigPyIterator_next(self)

    def __next__(self):
        return _TopTrans.SwigPyIterator___next__(self)

    def previous(self):
        return _TopTrans.SwigPyIterator_previous(self)

    def advance(self, n):
        return _TopTrans.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _TopTrans.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _TopTrans.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _TopTrans.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _TopTrans.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _TopTrans.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _TopTrans.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _TopTrans.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _TopTrans.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_TopTrans.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _TopTrans.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _TopTrans.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopTrans.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _TopTrans.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _TopTrans.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _TopTrans.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _TopTrans.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_TopTrans.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _TopTrans.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _TopTrans.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopTrans.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _TopTrans.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _TopTrans.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _TopTrans.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _TopTrans.ptr_to_number(item)
ptr_to_number = _TopTrans.ptr_to_number

def HashCode(*args):
    return _TopTrans.HashCode(*args)
HashCode = _TopTrans.HashCode

def ptr_equal(a, b):
    return _TopTrans.ptr_equal(a, b)
ptr_equal = _TopTrans.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
class TopTrans_CurveTransition(object):
    """
    This algorithm  is used to  compute the transition
    of a Curve intersecting a curvilinear boundary.

    The geometric  elements  are described locally  at
    the   intersection   point  by    a   second order
    development.

    The curve is described  by the intersection point,
    the tangent vector and the curvature.

    The  boundary  is described  by   a set  of  curve
    elements, a curve element is either :

    - A curve.

    - A curve and an orientation  called a half-curve,
    the boundary  of the curve is  before or after the
    intersection point depending on the orientation.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopTrans_CurveTransition self) -> TopTrans_CurveTransition

        Create an empty  Curve Transition.


        """
        this = _TopTrans.new_TopTrans_CurveTransition(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Reset(self, *args):
        """
        Reset(TopTrans_CurveTransition self, gp_Dir Tgt, gp_Dir Norm, Standard_Real const Curv)
        Reset(TopTrans_CurveTransition self, gp_Dir Tgt)

        Initialize a Transition with the local description
        of a straigth line.

        :type Tgt: OCC.wrapper.gp.gp_Dir

        """
        return _TopTrans.TopTrans_CurveTransition_Reset(self, *args)


    def Compare(self, *args):
        """
        Compare(TopTrans_CurveTransition self, Standard_Real const Tole, gp_Dir Tang, gp_Dir Norm, Standard_Real const Curv, TopAbs_Orientation const S, TopAbs_Orientation const Or)

        Add  a curve element to the  boundary.    If Or is
        REVERSED  the curve  is   before the intersection,
        else if  Or  is FORWARD  the   curv  is after  the
        intersection   and    if   Or  is   INTERNAL   the
        intersection is in the middle of the curv.

        :type Tole: float
        :type Tang: OCC.wrapper.gp.gp_Dir
        :type Norm: OCC.wrapper.gp.gp_Dir
        :type Curv: float
        :type S: OCC.wrapper.TopAbs.TopAbs_Orientation
        :type Or: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _TopTrans.TopTrans_CurveTransition_Compare(self, *args)


    def StateBefore(self, *args):
        """
        StateBefore(TopTrans_CurveTransition self) -> TopAbs_State

        returns   the  state   of  the   curve  before the
        intersection, this is the position relative to the
        boundary of a point very close to the intersection
        on the negative side of the tangent.

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _TopTrans.TopTrans_CurveTransition_StateBefore(self, *args)


    def StateAfter(self, *args):
        """
        StateAfter(TopTrans_CurveTransition self) -> TopAbs_State

        returns  the    state of  the  curve   after   the
        intersection, this is the position relative to the
        boundary of a point very close to the intersection
        on the positive side of the tangent.

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _TopTrans.TopTrans_CurveTransition_StateAfter(self, *args)

    __swig_destroy__ = _TopTrans.delete_TopTrans_CurveTransition
TopTrans_CurveTransition_swigregister = _TopTrans.TopTrans_CurveTransition_swigregister
TopTrans_CurveTransition_swigregister(TopTrans_CurveTransition)

class TopTrans_SurfaceTransition(object):
    """
    This algorithm  is used to  compute the transition
    of a 3D surface intersecting a topological surfacic
    boundary on a 3D curve ( intersection curve ).
    The  boundary is  described  by a  set of faces
    each face is described by
    - its support surface,
    - an orientation defining its matter side.
    The geometric elements are described locally at the
    intersection point by a second order development.
    A surface is described by the normal vector, the
    principal directions and the principal curvatures.
    A curve is described  by the  tangent, the normal
    and the curvature.
    The  algorithm  keeps track of the two faces elements
    closest to the part of the curve "before" and "after"
    the intersection,  these  two elements are updated
    for each new face.
    The position of the  curve can be computed when at
    least  one surface  element has   been given, this
    position is "In","Out" or "On" for the part of the
    curve "Before" or "After" the intersection.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopTrans_SurfaceTransition self) -> TopTrans_SurfaceTransition

        Create an empty Surface Transition.


        """
        this = _TopTrans.new_TopTrans_SurfaceTransition(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Reset(self, *args):
        """
        Reset(TopTrans_SurfaceTransition self, gp_Dir Tgt, gp_Dir Norm, gp_Dir MaxD, gp_Dir MinD, Standard_Real const MaxCurv, Standard_Real const MinCurv)
        Reset(TopTrans_SurfaceTransition self, gp_Dir Tgt, gp_Dir Norm)

        Initialize  a  Surface Transition  with the  local
        description of a straight line.

        :type Tgt: OCC.wrapper.gp.gp_Dir
        :type Norm: OCC.wrapper.gp.gp_Dir

        """
        return _TopTrans.TopTrans_SurfaceTransition_Reset(self, *args)


    def Compare(self, *args):
        """
        Compare(TopTrans_SurfaceTransition self, Standard_Real const Tole, gp_Dir Norm, gp_Dir MaxD, gp_Dir MinD, Standard_Real const MaxCurv, Standard_Real const MinCurv, TopAbs_Orientation const S, TopAbs_Orientation const O)
        Compare(TopTrans_SurfaceTransition self, Standard_Real const Tole, gp_Dir Norm, TopAbs_Orientation const S, TopAbs_Orientation const O)

        Add a plane or a cylindric face to the boundary.

        :type Tole: float
        :type Norm: OCC.wrapper.gp.gp_Dir
        :type S: OCC.wrapper.TopAbs.TopAbs_Orientation
        :type O: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _TopTrans.TopTrans_SurfaceTransition_Compare(self, *args)


    def StateBefore(self, *args):
        """
        StateBefore(TopTrans_SurfaceTransition self) -> TopAbs_State

        Returns the state of the reference surface before
        the interference, this is the position relative to
        the surface of a  point very close to the intersection
        on the negative side of the tangent.

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _TopTrans.TopTrans_SurfaceTransition_StateBefore(self, *args)


    def StateAfter(self, *args):
        """
        StateAfter(TopTrans_SurfaceTransition self) -> TopAbs_State

        Returns the state of the reference surface after
        interference, this is the position relative to the
        surface of a point very  close to the intersection
        on the positive side of the tangent.

        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _TopTrans.TopTrans_SurfaceTransition_StateAfter(self, *args)


    def GetBefore(*args):
        """
        GetBefore(TopAbs_Orientation const Tran) -> TopAbs_State

        :type Tran: OCC.wrapper.TopAbs.TopAbs_Orientation
        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _TopTrans.TopTrans_SurfaceTransition_GetBefore(*args)

    GetBefore = staticmethod(GetBefore)

    def GetAfter(*args):
        """
        GetAfter(TopAbs_Orientation const Tran) -> TopAbs_State

        :type Tran: OCC.wrapper.TopAbs.TopAbs_Orientation
        :rtype: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _TopTrans.TopTrans_SurfaceTransition_GetAfter(*args)

    GetAfter = staticmethod(GetAfter)
    __swig_destroy__ = _TopTrans.delete_TopTrans_SurfaceTransition
TopTrans_SurfaceTransition_swigregister = _TopTrans.TopTrans_SurfaceTransition_swigregister
TopTrans_SurfaceTransition_swigregister(TopTrans_SurfaceTransition)

def TopTrans_SurfaceTransition_GetBefore(*args):
    """
    TopTrans_SurfaceTransition_GetBefore(TopAbs_Orientation const Tran) -> TopAbs_State

    :type Tran: OCC.wrapper.TopAbs.TopAbs_Orientation
    :rtype: OCC.wrapper.TopAbs.TopAbs_State

    """
    return _TopTrans.TopTrans_SurfaceTransition_GetBefore(*args)

def TopTrans_SurfaceTransition_GetAfter(*args):
    """
    TopTrans_SurfaceTransition_GetAfter(TopAbs_Orientation const Tran) -> TopAbs_State

    :type Tran: OCC.wrapper.TopAbs.TopAbs_Orientation
    :rtype: OCC.wrapper.TopAbs.TopAbs_State

    """
    return _TopTrans.TopTrans_SurfaceTransition_GetAfter(*args)

class NCollection_Array2_TopAbs_Orientation(object):
    """
    Purpose:   The class Array2 represents bi-dimensional arrays 
    of fixed size known at run time. 
    The ranges of indices are user defined.

    Warning:   Programs clients of such class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.LowerRow(); i <= A.UpperRow(); i++)
    for (j = A.LowerCol(); j <= A.UpperCol(); j++)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        Purpose:   The class Array2 represents bi-dimensional arrays 
        of fixed size known at run time. 
        The ranges of indices are user defined.

        Warning:   Programs clients of such class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.LowerRow(); i <= A.UpperRow(); i++)
        for (j = A.LowerCol(); j <= A.UpperCol(); j++)
        """
        this = _TopTrans.new_NCollection_Array2_TopAbs_Orientation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array2_TopAbs_Orientation self, TopAbs_Orientation const & theValue)

        Initialise the values

        :type theValue: const TheItemType &

        """
        return _TopTrans.NCollection_Array2_TopAbs_Orientation_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array2_TopAbs_Orientation self) -> Standard_Integer

        Size (number of items)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTrans.NCollection_Array2_TopAbs_Orientation_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array2_TopAbs_Orientation self) -> Standard_Integer

        Length (number of items)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTrans.NCollection_Array2_TopAbs_Orientation_Length(self, *args)


    def RowLength(self, *args):
        """
        RowLength(NCollection_Array2_TopAbs_Orientation self) -> Standard_Integer

        Returns length of the row, i.e. number of columns

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTrans.NCollection_Array2_TopAbs_Orientation_RowLength(self, *args)


    def ColLength(self, *args):
        """
        ColLength(NCollection_Array2_TopAbs_Orientation self) -> Standard_Integer

        Returns length of the column, i.e. number of rows

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTrans.NCollection_Array2_TopAbs_Orientation_ColLength(self, *args)


    def LowerRow(self, *args):
        """
        LowerRow(NCollection_Array2_TopAbs_Orientation self) -> Standard_Integer

        LowerRow

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTrans.NCollection_Array2_TopAbs_Orientation_LowerRow(self, *args)


    def UpperRow(self, *args):
        """
        UpperRow(NCollection_Array2_TopAbs_Orientation self) -> Standard_Integer

        UpperRow

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTrans.NCollection_Array2_TopAbs_Orientation_UpperRow(self, *args)


    def LowerCol(self, *args):
        """
        LowerCol(NCollection_Array2_TopAbs_Orientation self) -> Standard_Integer

        LowerCol

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTrans.NCollection_Array2_TopAbs_Orientation_LowerCol(self, *args)


    def UpperCol(self, *args):
        """
        UpperCol(NCollection_Array2_TopAbs_Orientation self) -> Standard_Integer

        UpperCol

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopTrans.NCollection_Array2_TopAbs_Orientation_UpperCol(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array2_TopAbs_Orientation self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopTrans.NCollection_Array2_TopAbs_Orientation_IsDeletable(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array2_TopAbs_Orientation self, NCollection_Array2_TopAbs_Orientation theOther) -> NCollection_Array2_TopAbs_Orientation

        Assignment

        :type theOther: OCC.wrapper.NCollection.NCollection_Array2
        :rtype: OCC.wrapper.NCollection.NCollection_Array2

        """
        return _TopTrans.NCollection_Array2_TopAbs_Orientation_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array2_TopAbs_Orientation self, NCollection_Array2_TopAbs_Orientation theOther) -> NCollection_Array2_TopAbs_Orientation

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Array2
        :rtype: OCC.wrapper.NCollection.NCollection_Array2

        """
        return _TopTrans.NCollection_Array2_TopAbs_Orientation_assign(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theRow: int
        :type theCol: int
        :rtype: const TheItemType &

        """
        res = _TopTrans.NCollection_Array2_TopAbs_Orientation_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array2_TopAbs_Orientation self, Standard_Integer const theRow, Standard_Integer const theCol) -> TopAbs_Orientation &

        Variable value access

        :type theRow: int
        :type theCol: int
        :rtype: TheItemType &

        """
        return _TopTrans.NCollection_Array2_TopAbs_Orientation_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to ChangeValue

        :type theRow: int
        :type theCol: int
        :rtype: const TheItemType &

        """
        res = _TopTrans.NCollection_Array2_TopAbs_Orientation___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array2_TopAbs_Orientation self, Standard_Integer const theRow, Standard_Integer const theCol, TopAbs_Orientation const & theItem)

        SetValue

        :type theRow: int
        :type theCol: int
        :type theItem: const TheItemType &

        """
        return _TopTrans.NCollection_Array2_TopAbs_Orientation_SetValue(self, *args)

    __swig_destroy__ = _TopTrans.delete_NCollection_Array2_TopAbs_Orientation
NCollection_Array2_TopAbs_Orientation_swigregister = _TopTrans.NCollection_Array2_TopAbs_Orientation_swigregister
NCollection_Array2_TopAbs_Orientation_swigregister(NCollection_Array2_TopAbs_Orientation)


try:
	TopTrans_Array2OfOrientation = NCollection_Array2_TopAbs_Orientation
except NameError:
	pass # does not exist, probably ignored




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_LocalAnalysis')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_LocalAnalysis')
    _LocalAnalysis = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_LocalAnalysis', [dirname(__file__)])
        except ImportError:
            import _LocalAnalysis
            return _LocalAnalysis
        try:
            _mod = imp.load_module('_LocalAnalysis', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _LocalAnalysis = swig_import_helper()
    del swig_import_helper
else:
    import _LocalAnalysis
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _LocalAnalysis.delete_SwigPyIterator

    def value(self):
        return _LocalAnalysis.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _LocalAnalysis.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _LocalAnalysis.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _LocalAnalysis.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _LocalAnalysis.SwigPyIterator_equal(self, x)

    def copy(self):
        return _LocalAnalysis.SwigPyIterator_copy(self)

    def next(self):
        return _LocalAnalysis.SwigPyIterator_next(self)

    def __next__(self):
        return _LocalAnalysis.SwigPyIterator___next__(self)

    def previous(self):
        return _LocalAnalysis.SwigPyIterator_previous(self)

    def advance(self, n):
        return _LocalAnalysis.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _LocalAnalysis.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _LocalAnalysis.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _LocalAnalysis.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _LocalAnalysis.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _LocalAnalysis.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _LocalAnalysis.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _LocalAnalysis.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _LocalAnalysis.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_LocalAnalysis.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _LocalAnalysis.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _LocalAnalysis.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _LocalAnalysis.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _LocalAnalysis.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _LocalAnalysis.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _LocalAnalysis.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _LocalAnalysis.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_LocalAnalysis.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _LocalAnalysis.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _LocalAnalysis.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _LocalAnalysis.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _LocalAnalysis.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _LocalAnalysis.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _LocalAnalysis.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _LocalAnalysis.ptr_to_number(item)
ptr_to_number = _LocalAnalysis.ptr_to_number

def HashCode(*args):
    return _LocalAnalysis.HashCode(*args)
HashCode = _LocalAnalysis.HashCode

def ptr_equal(a, b):
    return _LocalAnalysis.ptr_equal(a, b)
ptr_equal = _LocalAnalysis.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomLProp
else:
    import GeomLProp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
LocalAnalysis_NullFirstDerivative = _LocalAnalysis.LocalAnalysis_NullFirstDerivative
LocalAnalysis_NullSecondDerivative = _LocalAnalysis.LocalAnalysis_NullSecondDerivative
LocalAnalysis_TangentNotDefined = _LocalAnalysis.LocalAnalysis_TangentNotDefined
LocalAnalysis_NormalNotDefined = _LocalAnalysis.LocalAnalysis_NormalNotDefined
LocalAnalysis_CurvatureNotDefined = _LocalAnalysis.LocalAnalysis_CurvatureNotDefined
class LocalAnalysis_(object):
    """
    This package gives tools to check the local continuity
    between two  points situated  on two curves or two surfaces.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Dump(*args):
        """
        Dump(LocalAnalysis_SurfaceContinuity surfconti, Standard_OStream & o)
        Dump(LocalAnalysis_CurveContinuity curvconti, Standard_OStream & o)

        This fonction gives informations  about a variable SurfaceContinuity

        :type curvconti: OCC.wrapper.LocalAnalysis.LocalAnalysis_CurveContinuity
        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _LocalAnalysis.LocalAnalysis__Dump(*args)

    Dump = staticmethod(Dump)

    def __init__(self):
        """
        This package gives tools to check the local continuity
        between two  points situated  on two curves or two surfaces.
        """
        this = _LocalAnalysis.new_LocalAnalysis_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _LocalAnalysis.delete_LocalAnalysis_
LocalAnalysis__swigregister = _LocalAnalysis.LocalAnalysis__swigregister
LocalAnalysis__swigregister(LocalAnalysis_)

def LocalAnalysis__Dump(*args):
    """
    Dump(LocalAnalysis_SurfaceContinuity surfconti, Standard_OStream & o)
    LocalAnalysis__Dump(LocalAnalysis_CurveContinuity curvconti, Standard_OStream & o)

    This fonction gives informations  about a variable SurfaceContinuity

    :type curvconti: OCC.wrapper.LocalAnalysis.LocalAnalysis_CurveContinuity
    :type o: OCC.wrapper.Standard.Standard_OStream

    """
    return _LocalAnalysis.LocalAnalysis__Dump(*args)

class LocalAnalysis_CurveContinuity(object):
    """
    This class gives tools to check local continuity C0
    C1 C2 G1 G2 between  two points situated on two curves
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(LocalAnalysis_CurveContinuity self, Handle_Geom_Curve Curv1, Standard_Real const u1, Handle_Geom_Curve Curv2, Standard_Real const u2, GeomAbs_Shape const Order, Standard_Real const EpsNul=0.001, Standard_Real const EpsC0=0.001, Standard_Real const EpsC1=0.001, Standard_Real const EpsC2=0.001, Standard_Real const EpsG1=0.001, Standard_Real const EpsG2=0.001, Standard_Real const Percent=0.01, Standard_Real const Maxlen=10000) -> LocalAnalysis_CurveContinuity

        -u1 is the parameter of the point on Curv1
        -u2 is the  parameter of the point on  Curv2
        -Order is the required continuity:
        GeomAbs_C0    GeomAbs_C1  GeomAbs_C2
        GeomAbs_G1 GeomAbs_G2

        -EpsNul  is  used to  detect a  a vector with nul
        magnitude (in mm)

        -EpsC0 is used for C0  continuity to confuse two
        points (in mm)

        -EpsC1 is  an angular  tolerance in radians  used
        for C1 continuity  to compare the angle between
        the first derivatives

        -EpsC2 is an   angular tolerance in radians  used
        for C2  continuity to  compare the angle  between
        the second derivatives

        -EpsG1 is an  angular  tolerance in radians  used
        for G1  continuity to compare  the angle  between
        the tangents

        -EpsG2 is  an angular  tolerance in radians  used
        for  G2 continuity to  compare  the angle between
        the normals

        - percent  : percentage of  curvature variation (unitless)
        used for G2 continuity

        - Maxlen is the maximum length of Curv1 or Curv2 in
        meters used to detect nul curvature (in mm)

        the constructor computes the quantities  which are
        necessary to check the continuity in the following cases:

        case  C0
        --------
        - the distance between P1 and P2  with P1=Curv1 (u1)  and
        P2=Curv2(u2)

        case C1
        -------

        - the angle  between  the first derivatives
        dCurv1(u1)           dCurv2(u2)
        --------     and     ---------
        du                   du

        - the ratio   between  the magnitudes  of the first
        derivatives

        the angle value is between 0 and PI/2

        case  C2
        -------
        - the angle  between the second derivatives
        2                   2
        d  Curv1(u1)       d Curv2(u2)
        ----------        ----------
        2                   2
        du                  du

        the angle value is between 0 and PI/2

        - the ratio between the magnitudes of  the second
        derivatives

        case G1
        -------
        the angle between  the tangents at each point

        the angle value is between 0 and PI/2

        case G2
        -------
        -the angle between the normals at each point

        the angle value is between 0 and PI/2

        - the relative variation of curvature:
        |curvat1-curvat2|
        ------------------
        1/2
        (curvat1*curvat2)

        where curvat1 is the curvature at the first point
        and curvat2 the curvature at the second point

        :type Curv1: OCC.wrapper.Geom.Handle_Geom_Curve
        :type u1: float
        :type Curv2: OCC.wrapper.Geom.Handle_Geom_Curve
        :type u2: float
        :type Order: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type EpsNul: float
        :type EpsC0: float
        :type EpsC1: float
        :type EpsC2: float
        :type EpsG1: float
        :type EpsG2: float
        :type Percent: float
        :type Maxlen: float

        """
        this = _LocalAnalysis.new_LocalAnalysis_CurveContinuity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsDone(self, *args):
        """
        IsDone(LocalAnalysis_CurveContinuity self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocalAnalysis.LocalAnalysis_CurveContinuity_IsDone(self, *args)


    def StatusError(self, *args):
        """
        StatusError(LocalAnalysis_CurveContinuity self) -> LocalAnalysis_StatusErrorType

        :rtype: OCC.wrapper.LocalAnalysis.LocalAnalysis_StatusErrorType

        """
        return _LocalAnalysis.LocalAnalysis_CurveContinuity_StatusError(self, *args)


    def ContinuityStatus(self, *args):
        """
        ContinuityStatus(LocalAnalysis_CurveContinuity self) -> GeomAbs_Shape

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _LocalAnalysis.LocalAnalysis_CurveContinuity_ContinuityStatus(self, *args)


    def C0Value(self, *args):
        """
        C0Value(LocalAnalysis_CurveContinuity self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _LocalAnalysis.LocalAnalysis_CurveContinuity_C0Value(self, *args)


    def C1Angle(self, *args):
        """
        C1Angle(LocalAnalysis_CurveContinuity self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _LocalAnalysis.LocalAnalysis_CurveContinuity_C1Angle(self, *args)


    def C1Ratio(self, *args):
        """
        C1Ratio(LocalAnalysis_CurveContinuity self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _LocalAnalysis.LocalAnalysis_CurveContinuity_C1Ratio(self, *args)


    def C2Angle(self, *args):
        """
        C2Angle(LocalAnalysis_CurveContinuity self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _LocalAnalysis.LocalAnalysis_CurveContinuity_C2Angle(self, *args)


    def C2Ratio(self, *args):
        """
        C2Ratio(LocalAnalysis_CurveContinuity self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _LocalAnalysis.LocalAnalysis_CurveContinuity_C2Ratio(self, *args)


    def G1Angle(self, *args):
        """
        G1Angle(LocalAnalysis_CurveContinuity self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _LocalAnalysis.LocalAnalysis_CurveContinuity_G1Angle(self, *args)


    def G2Angle(self, *args):
        """
        G2Angle(LocalAnalysis_CurveContinuity self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _LocalAnalysis.LocalAnalysis_CurveContinuity_G2Angle(self, *args)


    def G2CurvatureVariation(self, *args):
        """
        G2CurvatureVariation(LocalAnalysis_CurveContinuity self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _LocalAnalysis.LocalAnalysis_CurveContinuity_G2CurvatureVariation(self, *args)


    def IsC0(self, *args):
        """
        IsC0(LocalAnalysis_CurveContinuity self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocalAnalysis.LocalAnalysis_CurveContinuity_IsC0(self, *args)


    def IsC1(self, *args):
        """
        IsC1(LocalAnalysis_CurveContinuity self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocalAnalysis.LocalAnalysis_CurveContinuity_IsC1(self, *args)


    def IsC2(self, *args):
        """
        IsC2(LocalAnalysis_CurveContinuity self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocalAnalysis.LocalAnalysis_CurveContinuity_IsC2(self, *args)


    def IsG1(self, *args):
        """
        IsG1(LocalAnalysis_CurveContinuity self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocalAnalysis.LocalAnalysis_CurveContinuity_IsG1(self, *args)


    def IsG2(self, *args):
        """
        IsG2(LocalAnalysis_CurveContinuity self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocalAnalysis.LocalAnalysis_CurveContinuity_IsG2(self, *args)

    __swig_destroy__ = _LocalAnalysis.delete_LocalAnalysis_CurveContinuity
LocalAnalysis_CurveContinuity_swigregister = _LocalAnalysis.LocalAnalysis_CurveContinuity_swigregister
LocalAnalysis_CurveContinuity_swigregister(LocalAnalysis_CurveContinuity)

class LocalAnalysis_SurfaceContinuity(object):
    """
    This class gives tools to check local continuity C0
    C1 C2 G1 G2 between  two points situated on two surfaces
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(LocalAnalysis_SurfaceContinuity self, Handle_Geom_Surface Surf1, Standard_Real const u1, Standard_Real const v1, Handle_Geom_Surface Surf2, Standard_Real const u2, Standard_Real const v2, GeomAbs_Shape const Order, Standard_Real const EpsNul=0.001, Standard_Real const EpsC0=0.001, Standard_Real const EpsC1=0.001, Standard_Real const EpsC2=0.001, Standard_Real const EpsG1=0.001, Standard_Real const Percent=0.01, Standard_Real const Maxlen=10000) -> LocalAnalysis_SurfaceContinuity
        __init__(LocalAnalysis_SurfaceContinuity self, Handle_Geom2d_Curve curv1, Handle_Geom2d_Curve curv2, Standard_Real const U, Handle_Geom_Surface Surf1, Handle_Geom_Surface Surf2, GeomAbs_Shape const Order, Standard_Real const EpsNul=0.001, Standard_Real const EpsC0=0.001, Standard_Real const EpsC1=0.001, Standard_Real const EpsC2=0.001, Standard_Real const EpsG1=0.001, Standard_Real const Percent=0.01, Standard_Real const Maxlen=10000) -> LocalAnalysis_SurfaceContinuity
        __init__(LocalAnalysis_SurfaceContinuity self, Standard_Real const EpsNul=0.001, Standard_Real const EpsC0=0.001, Standard_Real const EpsC1=0.001, Standard_Real const EpsC2=0.001, Standard_Real const EpsG1=0.001, Standard_Real const Percent=0.01, Standard_Real const Maxlen=10000) -> LocalAnalysis_SurfaceContinuity

        This  constructor  is  used  when  we  want  to compute  many  analysis.
        After  we  use  the  method  ComputeAnalysis

        :type EpsNul: float
        :type EpsC0: float
        :type EpsC1: float
        :type EpsC2: float
        :type EpsG1: float
        :type Percent: float
        :type Maxlen: float

        """
        this = _LocalAnalysis.new_LocalAnalysis_SurfaceContinuity(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def ComputeAnalysis(self, *args):
        """
        ComputeAnalysis(LocalAnalysis_SurfaceContinuity self, GeomLProp_SLProps Surf1, GeomLProp_SLProps Surf2, GeomAbs_Shape const Order)

        :type Surf1: OCC.wrapper.GeomLProp.GeomLProp_SLProps
        :type Surf2: OCC.wrapper.GeomLProp.GeomLProp_SLProps
        :type Order: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_ComputeAnalysis(self, *args)


    def IsDone(self, *args):
        """
        IsDone(LocalAnalysis_SurfaceContinuity self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_IsDone(self, *args)


    def ContinuityStatus(self, *args):
        """
        ContinuityStatus(LocalAnalysis_SurfaceContinuity self) -> GeomAbs_Shape

        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_ContinuityStatus(self, *args)


    def StatusError(self, *args):
        """
        StatusError(LocalAnalysis_SurfaceContinuity self) -> LocalAnalysis_StatusErrorType

        :rtype: OCC.wrapper.LocalAnalysis.LocalAnalysis_StatusErrorType

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_StatusError(self, *args)


    def C0Value(self, *args):
        """
        C0Value(LocalAnalysis_SurfaceContinuity self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_C0Value(self, *args)


    def C1UAngle(self, *args):
        """
        C1UAngle(LocalAnalysis_SurfaceContinuity self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_C1UAngle(self, *args)


    def C1URatio(self, *args):
        """
        C1URatio(LocalAnalysis_SurfaceContinuity self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_C1URatio(self, *args)


    def C1VAngle(self, *args):
        """
        C1VAngle(LocalAnalysis_SurfaceContinuity self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_C1VAngle(self, *args)


    def C1VRatio(self, *args):
        """
        C1VRatio(LocalAnalysis_SurfaceContinuity self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_C1VRatio(self, *args)


    def C2UAngle(self, *args):
        """
        C2UAngle(LocalAnalysis_SurfaceContinuity self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_C2UAngle(self, *args)


    def C2URatio(self, *args):
        """
        C2URatio(LocalAnalysis_SurfaceContinuity self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_C2URatio(self, *args)


    def C2VAngle(self, *args):
        """
        C2VAngle(LocalAnalysis_SurfaceContinuity self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_C2VAngle(self, *args)


    def C2VRatio(self, *args):
        """
        C2VRatio(LocalAnalysis_SurfaceContinuity self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_C2VRatio(self, *args)


    def G1Angle(self, *args):
        """
        G1Angle(LocalAnalysis_SurfaceContinuity self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_G1Angle(self, *args)


    def G2CurvatureGap(self, *args):
        """
        G2CurvatureGap(LocalAnalysis_SurfaceContinuity self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_G2CurvatureGap(self, *args)


    def IsC0(self, *args):
        """
        IsC0(LocalAnalysis_SurfaceContinuity self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_IsC0(self, *args)


    def IsC1(self, *args):
        """
        IsC1(LocalAnalysis_SurfaceContinuity self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_IsC1(self, *args)


    def IsC2(self, *args):
        """
        IsC2(LocalAnalysis_SurfaceContinuity self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_IsC2(self, *args)


    def IsG1(self, *args):
        """
        IsG1(LocalAnalysis_SurfaceContinuity self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_IsG1(self, *args)


    def IsG2(self, *args):
        """
        IsG2(LocalAnalysis_SurfaceContinuity self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _LocalAnalysis.LocalAnalysis_SurfaceContinuity_IsG2(self, *args)

    __swig_destroy__ = _LocalAnalysis.delete_LocalAnalysis_SurfaceContinuity
LocalAnalysis_SurfaceContinuity_swigregister = _LocalAnalysis.LocalAnalysis_SurfaceContinuity_swigregister
LocalAnalysis_SurfaceContinuity_swigregister(LocalAnalysis_SurfaceContinuity)




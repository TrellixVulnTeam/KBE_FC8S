# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_TDataStd')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_TDataStd')
    _TDataStd = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_TDataStd', [dirname(__file__)])
        except ImportError:
            import _TDataStd
            return _TDataStd
        try:
            _mod = imp.load_module('_TDataStd', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _TDataStd = swig_import_helper()
    del swig_import_helper
else:
    import _TDataStd
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _TDataStd.delete_SwigPyIterator

    def value(self):
        return _TDataStd.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _TDataStd.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _TDataStd.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _TDataStd.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _TDataStd.SwigPyIterator_equal(self, x)

    def copy(self):
        return _TDataStd.SwigPyIterator_copy(self)

    def next(self):
        return _TDataStd.SwigPyIterator_next(self)

    def __next__(self):
        return _TDataStd.SwigPyIterator___next__(self)

    def previous(self):
        return _TDataStd.SwigPyIterator_previous(self)

    def advance(self, n):
        return _TDataStd.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _TDataStd.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _TDataStd.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _TDataStd.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _TDataStd.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _TDataStd.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _TDataStd.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _TDataStd.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _TDataStd.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_TDataStd.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _TDataStd.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _TDataStd.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDataStd.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _TDataStd.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _TDataStd.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _TDataStd.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _TDataStd.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_TDataStd.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _TDataStd.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _TDataStd.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDataStd.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _TDataStd.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _TDataStd.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _TDataStd.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _TDataStd.ptr_to_number(item)
ptr_to_number = _TDataStd.ptr_to_number

def HashCode(*args):
    return _TDataStd.HashCode(*args)
HashCode = _TDataStd.HashCode

def ptr_equal(a, b):
    return _TDataStd.ptr_equal(a, b)
ptr_equal = _TDataStd.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TDF
else:
    import TDF
del _swig_python_version_info
TDataStd_SCALAR = _TDataStd.TDataStd_SCALAR
TDataStd_LENGTH = _TDataStd.TDataStd_LENGTH
TDataStd_ANGULAR = _TDataStd.TDataStd_ANGULAR
class TDataStd_RealList(TDF.TDF_Attribute):
    """Contains a list of doubles."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_RealList
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_RealList(self) 
            return h


    def GetID(*args):
        """
        GetID() -> Standard_GUID

        Static methods
        ==============
        Returns the ID of the list of doubles attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.TDataStd_RealList_GetID(*args)

    GetID = staticmethod(GetID)

    def Set(*args):
        """
        Set(TDF_Label label) -> Handle_TDataStd_RealList
        Set(TDF_Label label, Standard_GUID theGuid) -> Handle_TDataStd_RealList

        Finds or creates a list of double values attribute with explicit user defined <guid>.

        :type label: OCC.wrapper.TDF.TDF_Label
        :type theGuid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_RealList

        """
        return _TDataStd.TDataStd_RealList_Set(*args)

    Set = staticmethod(Set)

    def __init__(self, *args):
        """
        __init__(TDataStd_RealList self) -> TDataStd_RealList

        Contains a list of doubles.
        """
        this = _TDataStd.new_TDataStd_RealList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsEmpty(self, *args):
        """
        IsEmpty(TDataStd_RealList self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_RealList_IsEmpty(self, *args)


    def Extent(self, *args):
        """
        Extent(TDataStd_RealList self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.TDataStd_RealList_Extent(self, *args)


    def Prepend(self, *args):
        """
        Prepend(TDataStd_RealList self, Standard_Real const value)

        :type value: float

        """
        return _TDataStd.TDataStd_RealList_Prepend(self, *args)


    def Append(self, *args):
        """
        Append(TDataStd_RealList self, Standard_Real const value)

        :type value: float

        """
        return _TDataStd.TDataStd_RealList_Append(self, *args)


    def SetID(self, *args):
        """
        SetID(TDataStd_RealList self, Standard_GUID theGuid)
        SetID(TDataStd_RealList self)

        Sets default GUID for the attribute.


        """
        return _TDataStd.TDataStd_RealList_SetID(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(TDataStd_RealList self, Standard_Real const value, Standard_Real const before_value) -> Standard_Boolean

        Inserts the <value> before the first meet of <before_value>.

        :type value: float
        :type before_value: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_RealList_InsertBefore(self, *args)


    def InsertBeforeByIndex(self, *args):
        """
        InsertBeforeByIndex(TDataStd_RealList self, Standard_Integer const index, Standard_Real const before_value) -> Standard_Boolean

        Inserts the <value> before the <index> position.
        The indices start with 1 .. Extent().

        :type index: int
        :type before_value: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_RealList_InsertBeforeByIndex(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(TDataStd_RealList self, Standard_Real const value, Standard_Real const after_value) -> Standard_Boolean

        Inserts the <value> after the first meet of <after_value>.

        :type value: float
        :type after_value: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_RealList_InsertAfter(self, *args)


    def InsertAfterByIndex(self, *args):
        """
        InsertAfterByIndex(TDataStd_RealList self, Standard_Integer const index, Standard_Real const after_value) -> Standard_Boolean

        Inserts the <value> after the <index> position.
        The indices start with 1 .. Extent().

        :type index: int
        :type after_value: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_RealList_InsertAfterByIndex(self, *args)


    def Remove(self, *args):
        """
        Remove(TDataStd_RealList self, Standard_Real const value) -> Standard_Boolean

        Removes the first meet of the <value>.

        :type value: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_RealList_Remove(self, *args)


    def RemoveByIndex(self, *args):
        """
        RemoveByIndex(TDataStd_RealList self, Standard_Integer const index) -> Standard_Boolean

        Removes a value at <index> position.

        :type index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_RealList_RemoveByIndex(self, *args)


    def Clear(self, *args):
        """Clear(TDataStd_RealList self)"""
        return _TDataStd.TDataStd_RealList_Clear(self, *args)


    def First(self, *args):
        """
        First(TDataStd_RealList self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TDataStd.TDataStd_RealList_First(self, *args)


    def Last(self, *args):
        """
        Last(TDataStd_RealList self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TDataStd.TDataStd_RealList_Last(self, *args)


    def List(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_ListOfReal

        """
        res = _TDataStd.TDataStd_RealList_List(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.TDataStd_RealList_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TDataStd_RealList self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_RealList_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TDataStd_RealList self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_RealList_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TDataStd_RealList self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.TDataStd_RealList_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(TDataStd_RealList self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.TDataStd_RealList_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_RealList_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_RealList_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_RealList_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDataStd.delete_TDataStd_RealList
TDataStd_RealList_swigregister = _TDataStd.TDataStd_RealList_swigregister
TDataStd_RealList_swigregister(TDataStd_RealList)

def TDataStd_RealList_GetID(*args):
    """
    TDataStd_RealList_GetID() -> Standard_GUID

    Static methods
    ==============
    Returns the ID of the list of doubles attribute.

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TDataStd.TDataStd_RealList_GetID(*args)

def TDataStd_RealList_Set(*args):
    """
    Set(TDF_Label label) -> Handle_TDataStd_RealList
    TDataStd_RealList_Set(TDF_Label label, Standard_GUID theGuid) -> Handle_TDataStd_RealList

    Finds or creates a list of double values attribute with explicit user defined <guid>.

    :type label: OCC.wrapper.TDF.TDF_Label
    :type theGuid: OCC.wrapper.Standard.Standard_GUID
    :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_RealList

    """
    return _TDataStd.TDataStd_RealList_Set(*args)

def TDataStd_RealList_get_type_name(*args):
    """
    TDataStd_RealList_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_RealList_get_type_name(*args)

def TDataStd_RealList_get_type_descriptor(*args):
    """
    TDataStd_RealList_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_RealList_get_type_descriptor(*args)

class TDataStd_DeltaOnModificationOfExtStringArray(TDF.TDF_DeltaOnModification):
    """
    This class provides default services for an
    AttributeDelta on a MODIFICATION action.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_DeltaOnModificationOfExtStringArray
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_DeltaOnModificationOfExtStringArray(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TDataStd_DeltaOnModificationOfExtStringArray self, Handle_TDataStd_ExtStringArray Arr) -> TDataStd_DeltaOnModificationOfExtStringArray

        Initializes a TDF_DeltaOnModification.

        :type Arr: OCC.wrapper.TDataStd.Handle_TDataStd_ExtStringArray

        """
        this = _TDataStd.new_TDataStd_DeltaOnModificationOfExtStringArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Apply(self, *args):
        """
        Apply(TDataStd_DeltaOnModificationOfExtStringArray self)

        Applies the delta to the attribute.


        """
        return _TDataStd.TDataStd_DeltaOnModificationOfExtStringArray_Apply(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_DeltaOnModificationOfExtStringArray_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_DeltaOnModificationOfExtStringArray_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_DeltaOnModificationOfExtStringArray_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDataStd.delete_TDataStd_DeltaOnModificationOfExtStringArray
TDataStd_DeltaOnModificationOfExtStringArray_swigregister = _TDataStd.TDataStd_DeltaOnModificationOfExtStringArray_swigregister
TDataStd_DeltaOnModificationOfExtStringArray_swigregister(TDataStd_DeltaOnModificationOfExtStringArray)

def TDataStd_DeltaOnModificationOfExtStringArray_get_type_name(*args):
    """
    TDataStd_DeltaOnModificationOfExtStringArray_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_DeltaOnModificationOfExtStringArray_get_type_name(*args)

def TDataStd_DeltaOnModificationOfExtStringArray_get_type_descriptor(*args):
    """
    TDataStd_DeltaOnModificationOfExtStringArray_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_DeltaOnModificationOfExtStringArray_get_type_descriptor(*args)

class TDataStd_NoteBook(TDF.TDF_Attribute):
    """NoteBook Object attribute"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_NoteBook
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_NoteBook(self) 
            return h


    def Find(*args):
        """
        Find(TDF_Label current, Handle_TDataStd_NoteBook N) -> Standard_Boolean

        class methods
        =============
        try to retrieve a NoteBook attribute at <current> label
        or in  fathers  label of  <current>. Returns True  if
        found and set <N>.

        :type current: OCC.wrapper.TDF.TDF_Label
        :type N: OCC.wrapper.TDataStd.Handle_TDataStd_NoteBook
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_NoteBook_Find(*args)

    Find = staticmethod(Find)

    def New(*args):
        """
        New(TDF_Label label) -> Handle_TDataStd_NoteBook

        Create  an  enpty   NoteBook attribute,  located  at
        <label>. Raises if <label> has attribute

        :type label: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_NoteBook

        """
        return _TDataStd.TDataStd_NoteBook_New(*args)

    New = staticmethod(New)

    def GetID(*args):
        """
        GetID() -> Standard_GUID

        NoteBook methods
        ===============

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.TDataStd_NoteBook_GetID(*args)

    GetID = staticmethod(GetID)

    def __init__(self, *args):
        """
        __init__(TDataStd_NoteBook self) -> TDataStd_NoteBook

        NoteBook Object attribute
        """
        this = _TDataStd.new_TDataStd_NoteBook(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Append(self, *args):
        """
        Append(TDataStd_NoteBook self, Standard_Real const value, Standard_Boolean const isExported) -> Handle_TDataStd_Real
        Append(TDataStd_NoteBook self, Standard_Integer const value, Standard_Boolean const isExported) -> Handle_TDataStd_Integer

        Tool to Create  an Real attribute from <value>, Insert
        it  in a new son label  of <me>. The Integer attribute
        is returned.

        :type value: int
        :type isExported: bool
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_Integer

        """
        return _TDataStd.TDataStd_NoteBook_Append(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.TDataStd_NoteBook_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TDataStd_NoteBook self, Handle_TDF_Attribute arg2)

        :type with: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_NoteBook_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TDataStd_NoteBook self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_NoteBook_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TDataStd_NoteBook self, Handle_TDF_Attribute into, Handle_TDF_RelocationTable RT)

        :type into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.TDataStd_NoteBook_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(TDataStd_NoteBook self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.TDataStd_NoteBook_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_NoteBook_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_NoteBook_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_NoteBook_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDataStd.delete_TDataStd_NoteBook
TDataStd_NoteBook_swigregister = _TDataStd.TDataStd_NoteBook_swigregister
TDataStd_NoteBook_swigregister(TDataStd_NoteBook)

def TDataStd_NoteBook_Find(*args):
    """
    TDataStd_NoteBook_Find(TDF_Label current, Handle_TDataStd_NoteBook N) -> Standard_Boolean

    class methods
    =============
    try to retrieve a NoteBook attribute at <current> label
    or in  fathers  label of  <current>. Returns True  if
    found and set <N>.

    :type current: OCC.wrapper.TDF.TDF_Label
    :type N: OCC.wrapper.TDataStd.Handle_TDataStd_NoteBook
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TDataStd.TDataStd_NoteBook_Find(*args)

def TDataStd_NoteBook_New(*args):
    """
    TDataStd_NoteBook_New(TDF_Label label) -> Handle_TDataStd_NoteBook

    Create  an  enpty   NoteBook attribute,  located  at
    <label>. Raises if <label> has attribute

    :type label: OCC.wrapper.TDF.TDF_Label
    :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_NoteBook

    """
    return _TDataStd.TDataStd_NoteBook_New(*args)

def TDataStd_NoteBook_GetID(*args):
    """
    TDataStd_NoteBook_GetID() -> Standard_GUID

    NoteBook methods
    ===============

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TDataStd.TDataStd_NoteBook_GetID(*args)

def TDataStd_NoteBook_get_type_name(*args):
    """
    TDataStd_NoteBook_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_NoteBook_get_type_name(*args)

def TDataStd_NoteBook_get_type_descriptor(*args):
    """
    TDataStd_NoteBook_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_NoteBook_get_type_descriptor(*args)

class TDataStd_Directory(TDF.TDF_Attribute):
    """
    Associates a directory in the data framework with
    a TDataStd_TagSource attribute.
    You can create a new directory label and add
    sub-directory or object labels to it,
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_Directory
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_Directory(self) 
            return h


    def Find(*args):
        """
        Find(TDF_Label current, Handle_TDataStd_Directory D) -> Standard_Boolean

        class methods
        =============
        Searches for a directory attribute on the label
        current, or on one of the father labels of current.
        If a directory attribute is found, true is returned,
        and the attribute found is set as D.

        :type current: OCC.wrapper.TDF.TDF_Label
        :type D: OCC.wrapper.TDataStd.Handle_TDataStd_Directory
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_Directory_Find(*args)

    Find = staticmethod(Find)

    def New(*args):
        """
        New(TDF_Label label) -> Handle_TDataStd_Directory

        Creates  an  enpty   Directory attribute,  located  at
        <label>. Raises if <label> has attribute

        :type label: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_Directory

        """
        return _TDataStd.TDataStd_Directory_New(*args)

    New = staticmethod(New)

    def AddDirectory(*args):
        """
        AddDirectory(Handle_TDataStd_Directory dir) -> Handle_TDataStd_Directory

        Creates a new sub-label and sets the
        sub-directory dir on that label.

        :type dir: OCC.wrapper.TDataStd.Handle_TDataStd_Directory
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_Directory

        """
        return _TDataStd.TDataStd_Directory_AddDirectory(*args)

    AddDirectory = staticmethod(AddDirectory)

    def MakeObjectLabel(*args):
        """
        MakeObjectLabel(Handle_TDataStd_Directory dir) -> TDF_Label

        Makes new label and returns it to insert
        other object attributes (sketch,part...etc...)

        :type dir: OCC.wrapper.TDataStd.Handle_TDataStd_Directory
        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.TDataStd_Directory_MakeObjectLabel(*args)

    MakeObjectLabel = staticmethod(MakeObjectLabel)

    def GetID(*args):
        """
        GetID() -> Standard_GUID

        Directory methods
        ===============

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.TDataStd_Directory_GetID(*args)

    GetID = staticmethod(GetID)

    def __init__(self, *args):
        """
        __init__(TDataStd_Directory self) -> TDataStd_Directory

        Associates a directory in the data framework with
        a TDataStd_TagSource attribute.
        You can create a new directory label and add
        sub-directory or object labels to it,
        """
        this = _TDataStd.new_TDataStd_Directory(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.TDataStd_Directory_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TDataStd_Directory self, Handle_TDF_Attribute arg2)

        :type with: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_Directory_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TDataStd_Directory self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_Directory_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TDataStd_Directory self, Handle_TDF_Attribute into, Handle_TDF_RelocationTable RT)

        :type into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.TDataStd_Directory_Paste(self, *args)


    def References(self, *args):
        """
        References(TDataStd_Directory self, Handle_TDF_DataSet DS)

        :type DS: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDataStd.TDataStd_Directory_References(self, *args)


    def Dump(self, *args):
        """
        Dump(TDataStd_Directory self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.TDataStd_Directory_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_Directory_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_Directory_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_Directory_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDataStd.delete_TDataStd_Directory
TDataStd_Directory_swigregister = _TDataStd.TDataStd_Directory_swigregister
TDataStd_Directory_swigregister(TDataStd_Directory)

def TDataStd_Directory_Find(*args):
    """
    TDataStd_Directory_Find(TDF_Label current, Handle_TDataStd_Directory D) -> Standard_Boolean

    class methods
    =============
    Searches for a directory attribute on the label
    current, or on one of the father labels of current.
    If a directory attribute is found, true is returned,
    and the attribute found is set as D.

    :type current: OCC.wrapper.TDF.TDF_Label
    :type D: OCC.wrapper.TDataStd.Handle_TDataStd_Directory
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TDataStd.TDataStd_Directory_Find(*args)

def TDataStd_Directory_New(*args):
    """
    TDataStd_Directory_New(TDF_Label label) -> Handle_TDataStd_Directory

    Creates  an  enpty   Directory attribute,  located  at
    <label>. Raises if <label> has attribute

    :type label: OCC.wrapper.TDF.TDF_Label
    :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_Directory

    """
    return _TDataStd.TDataStd_Directory_New(*args)

def TDataStd_Directory_AddDirectory(*args):
    """
    TDataStd_Directory_AddDirectory(Handle_TDataStd_Directory dir) -> Handle_TDataStd_Directory

    Creates a new sub-label and sets the
    sub-directory dir on that label.

    :type dir: OCC.wrapper.TDataStd.Handle_TDataStd_Directory
    :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_Directory

    """
    return _TDataStd.TDataStd_Directory_AddDirectory(*args)

def TDataStd_Directory_MakeObjectLabel(*args):
    """
    TDataStd_Directory_MakeObjectLabel(Handle_TDataStd_Directory dir) -> TDF_Label

    Makes new label and returns it to insert
    other object attributes (sketch,part...etc...)

    :type dir: OCC.wrapper.TDataStd.Handle_TDataStd_Directory
    :rtype: OCC.wrapper.TDF.TDF_Label

    """
    return _TDataStd.TDataStd_Directory_MakeObjectLabel(*args)

def TDataStd_Directory_GetID(*args):
    """
    TDataStd_Directory_GetID() -> Standard_GUID

    Directory methods
    ===============

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TDataStd.TDataStd_Directory_GetID(*args)

def TDataStd_Directory_get_type_name(*args):
    """
    TDataStd_Directory_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_Directory_get_type_name(*args)

def TDataStd_Directory_get_type_descriptor(*args):
    """
    TDataStd_Directory_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_Directory_get_type_descriptor(*args)

class TDataStd_NamedData(TDF.TDF_Attribute):
    """Contains a named data."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_NamedData
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_NamedData(self) 
            return h


    def GetID(*args):
        """
        GetID() -> Standard_GUID

        Static methods
        ==============
        Returns the ID of the named data attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.TDataStd_NamedData_GetID(*args)

    GetID = staticmethod(GetID)

    def Set(*args):
        """
        Set(TDF_Label label) -> Handle_TDataStd_NamedData

        Finds or creates a named data attribute.

        :type label: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_NamedData

        """
        return _TDataStd.TDataStd_NamedData_Set(*args)

    Set = staticmethod(Set)

    def __init__(self, *args):
        """
        __init__(TDataStd_NamedData self) -> TDataStd_NamedData

        Contains a named data.
        """
        this = _TDataStd.new_TDataStd_NamedData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def HasIntegers(self, *args):
        """
        HasIntegers(TDataStd_NamedData self) -> Standard_Boolean

        Returns true if at least one named integer value is
        kept in the attribute.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_NamedData_HasIntegers(self, *args)


    def HasInteger(self, *args):
        """
        HasInteger(TDataStd_NamedData self, TCollection_ExtendedString theName) -> Standard_Boolean

        Returns true if the attribute contains specified by Name
        integer value.

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_NamedData_HasInteger(self, *args)


    def GetInteger(self, *args):
        """
        GetInteger(TDataStd_NamedData self, TCollection_ExtendedString theName) -> Standard_Integer

        Returns the integer value specified by the Name.
        It returns 0 if internal map doesn't contain the specified
        integer (use HasInteger() to check before).

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.TDataStd_NamedData_GetInteger(self, *args)


    def SetInteger(self, *args):
        """
        SetInteger(TDataStd_NamedData self, TCollection_ExtendedString theName, Standard_Integer const theInteger)

        Defines a named integer.
        If the integer already exists, it changes its value to <theInteger>.

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type theInteger: int

        """
        return _TDataStd.TDataStd_NamedData_SetInteger(self, *args)


    def GetIntegersContainer(self, *args):
        """
        Returns the internal container of named integers.

        :rtype: OCC.wrapper.TColStd.TColStd_DataMapOfStringInteger

        """
        res = _TDataStd.TDataStd_NamedData_GetIntegersContainer(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeIntegers(self, *args):
        """
        ChangeIntegers(TDataStd_NamedData self, NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString theIntegers)

        Replace the container content by new content of the <theIntegers>.

        :type theIntegers: OCC.wrapper.TColStd.TColStd_DataMapOfStringInteger

        """
        return _TDataStd.TDataStd_NamedData_ChangeIntegers(self, *args)


    def HasReals(self, *args):
        """
        HasReals(TDataStd_NamedData self) -> Standard_Boolean

        Returns true if at least one named real value is
        kept in the attribute.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_NamedData_HasReals(self, *args)


    def HasReal(self, *args):
        """
        HasReal(TDataStd_NamedData self, TCollection_ExtendedString theName) -> Standard_Boolean

        Returns true if the attribute contains a real specified by Name.

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_NamedData_HasReal(self, *args)


    def GetReal(self, *args):
        """
        GetReal(TDataStd_NamedData self, TCollection_ExtendedString theName) -> Standard_Real

        Returns the named real.
        It returns 0.0 if there is no such a named real
        (use HasReal()).

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TDataStd.TDataStd_NamedData_GetReal(self, *args)


    def SetReal(self, *args):
        """
        SetReal(TDataStd_NamedData self, TCollection_ExtendedString theName, Standard_Real const theReal)

        Defines a named real.
        If the real already exists, it changes its value to <theReal>.

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type theReal: float

        """
        return _TDataStd.TDataStd_NamedData_SetReal(self, *args)


    def GetRealsContainer(self, *args):
        """
        Returns the internal container of named reals.

        :rtype: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringReal

        """
        res = _TDataStd.TDataStd_NamedData_GetRealsContainer(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeReals(self, *args):
        """
        ChangeReals(TDataStd_NamedData self, NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString theReals)

        Replace the container content by new content of the <theReals>.

        :type theReals: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringReal

        """
        return _TDataStd.TDataStd_NamedData_ChangeReals(self, *args)


    def HasStrings(self, *args):
        """
        HasStrings(TDataStd_NamedData self) -> Standard_Boolean

        Returns true if there are some named strings in the attribute.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_NamedData_HasStrings(self, *args)


    def HasString(self, *args):
        """
        HasString(TDataStd_NamedData self, TCollection_ExtendedString theName) -> Standard_Boolean

        Returns true if the attribute contains this named string.

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_NamedData_HasString(self, *args)


    def GetString(self, *args):
        """
        Returns the named string.
        It returns an empty string if there is no such a named string
        (use HasString()).

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _TDataStd.TDataStd_NamedData_GetString(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetString(self, *args):
        """
        SetString(TDataStd_NamedData self, TCollection_ExtendedString theName, TCollection_ExtendedString theString)

        Defines a named string.
        If the string already exists, it changes its value to <theString>.

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type theString: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDataStd.TDataStd_NamedData_SetString(self, *args)


    def GetStringsContainer(self, *args):
        """
        Returns the internal container of named strings.

        :rtype: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringString

        """
        res = _TDataStd.TDataStd_NamedData_GetStringsContainer(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeStrings(self, *args):
        """
        ChangeStrings(TDataStd_NamedData self, NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString theStrings)

        Replace the container content by new content of the <theStrings>.

        :type theStrings: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringString

        """
        return _TDataStd.TDataStd_NamedData_ChangeStrings(self, *args)


    def HasBytes(self, *args):
        """
        HasBytes(TDataStd_NamedData self) -> Standard_Boolean

        Returns true if there are some named bytes in the attribute.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_NamedData_HasBytes(self, *args)


    def HasByte(self, *args):
        """
        HasByte(TDataStd_NamedData self, TCollection_ExtendedString theName) -> Standard_Boolean

        Returns true if the attribute contains this named byte.

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_NamedData_HasByte(self, *args)


    def GetByte(self, *args):
        """
        GetByte(TDataStd_NamedData self, TCollection_ExtendedString theName) -> Standard_Byte

        Returns the named byte.
        It returns 0 if there is no such a named byte
        (use HasByte()).

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Byte

        """
        return _TDataStd.TDataStd_NamedData_GetByte(self, *args)


    def SetByte(self, *args):
        """
        SetByte(TDataStd_NamedData self, TCollection_ExtendedString theName, Standard_Byte const theByte)

        Defines a named byte.
        If the byte already exists, it changes its value to <theByte>.

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type theByte: int

        """
        return _TDataStd.TDataStd_NamedData_SetByte(self, *args)


    def GetBytesContainer(self, *args):
        """
        Returns the internal container of named bytes.

        :rtype: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringByte

        """
        res = _TDataStd.TDataStd_NamedData_GetBytesContainer(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeBytes(self, *args):
        """
        ChangeBytes(TDataStd_NamedData self, NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString theBytes)

        Replace the container content by new content of the <theBytes>.

        :type theBytes: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringByte

        """
        return _TDataStd.TDataStd_NamedData_ChangeBytes(self, *args)


    def HasArraysOfIntegers(self, *args):
        """
        HasArraysOfIntegers(TDataStd_NamedData self) -> Standard_Boolean

        Returns true if there are some named arrays of integer values in the attribute.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_NamedData_HasArraysOfIntegers(self, *args)


    def HasArrayOfIntegers(self, *args):
        """
        HasArrayOfIntegers(TDataStd_NamedData self, TCollection_ExtendedString theName) -> Standard_Boolean

        Returns true if the attribute contains this named array of integer values.

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_NamedData_HasArrayOfIntegers(self, *args)


    def GetArrayOfIntegers(self, *args):
        """
        Returns the named array of integer values.
        It returns a NULL Handle if there is no such a named array of integers
        (use HasArrayOfIntegers()).

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfInteger

        """
        res = _TDataStd.TDataStd_NamedData_GetArrayOfIntegers(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetArrayOfIntegers(self, *args):
        """
        SetArrayOfIntegers(TDataStd_NamedData self, TCollection_ExtendedString theName, Handle_TColStd_HArray1OfInteger theArrayOfIntegers)

        Defines a named array of integer values.
        If the array already exists, it changes its value to <theArrayOfIntegers>.

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type theArrayOfIntegers: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfInteger

        """
        return _TDataStd.TDataStd_NamedData_SetArrayOfIntegers(self, *args)


    def GetArraysOfIntegersContainer(self, *args):
        """
        Returns the internal container of named arrays of integer values.

        :rtype: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringHArray1OfInteger

        """
        res = _TDataStd.TDataStd_NamedData_GetArraysOfIntegersContainer(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArraysOfIntegers(self, *args):
        """
        ChangeArraysOfIntegers(TDataStd_NamedData self, NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString theArraysOfIntegers)

        Replace the container content by new content of the <theArraysOfIntegers>.

        :type theArraysOfIntegers: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringHArray1OfInteger

        """
        return _TDataStd.TDataStd_NamedData_ChangeArraysOfIntegers(self, *args)


    def HasArraysOfReals(self, *args):
        """
        HasArraysOfReals(TDataStd_NamedData self) -> Standard_Boolean

        Returns true if there are some named arrays of real values in the attribute.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_NamedData_HasArraysOfReals(self, *args)


    def HasArrayOfReals(self, *args):
        """
        HasArrayOfReals(TDataStd_NamedData self, TCollection_ExtendedString theName) -> Standard_Boolean

        Returns true if the attribute contains this named array of real values.

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_NamedData_HasArrayOfReals(self, *args)


    def GetArrayOfReals(self, *args):
        """
        Returns the named array of real values.
        It returns a NULL Handle if there is no such a named array of reals
        (use HasArrayOfReals()).

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        res = _TDataStd.TDataStd_NamedData_GetArrayOfReals(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetArrayOfReals(self, *args):
        """
        SetArrayOfReals(TDataStd_NamedData self, TCollection_ExtendedString theName, Handle_TColStd_HArray1OfReal theArrayOfReals)

        Defines a named array of real values.
        If the array already exists, it changes its value to <theArrayOfReals>.

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type theArrayOfReals: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _TDataStd.TDataStd_NamedData_SetArrayOfReals(self, *args)


    def GetArraysOfRealsContainer(self, *args):
        """
        Returns the internal container of named arrays of real values.

        :rtype: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringHArray1OfReal

        """
        res = _TDataStd.TDataStd_NamedData_GetArraysOfRealsContainer(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArraysOfReals(self, *args):
        """
        ChangeArraysOfReals(TDataStd_NamedData self, NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString theArraysOfReals)

        Replace the container content by new content of the <theArraysOfReals>.

        :type theArraysOfReals: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringHArray1OfReal

        """
        return _TDataStd.TDataStd_NamedData_ChangeArraysOfReals(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.TDataStd_NamedData_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TDataStd_NamedData self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_NamedData_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TDataStd_NamedData self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_NamedData_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TDataStd_NamedData self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.TDataStd_NamedData_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(TDataStd_NamedData self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.TDataStd_NamedData_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_NamedData_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_NamedData_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_NamedData_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDataStd.delete_TDataStd_NamedData
TDataStd_NamedData_swigregister = _TDataStd.TDataStd_NamedData_swigregister
TDataStd_NamedData_swigregister(TDataStd_NamedData)

def TDataStd_NamedData_GetID(*args):
    """
    TDataStd_NamedData_GetID() -> Standard_GUID

    Static methods
    ==============
    Returns the ID of the named data attribute.

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TDataStd.TDataStd_NamedData_GetID(*args)

def TDataStd_NamedData_Set(*args):
    """
    TDataStd_NamedData_Set(TDF_Label label) -> Handle_TDataStd_NamedData

    Finds or creates a named data attribute.

    :type label: OCC.wrapper.TDF.TDF_Label
    :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_NamedData

    """
    return _TDataStd.TDataStd_NamedData_Set(*args)

def TDataStd_NamedData_get_type_name(*args):
    """
    TDataStd_NamedData_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_NamedData_get_type_name(*args)

def TDataStd_NamedData_get_type_descriptor(*args):
    """
    TDataStd_NamedData_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_NamedData_get_type_descriptor(*args)

class TDataStd_DeltaOnModificationOfByteArray(TDF.TDF_DeltaOnModification):
    """
    This class provides default services for an
    AttributeDelta on a MODIFICATION action.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_DeltaOnModificationOfByteArray
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_DeltaOnModificationOfByteArray(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TDataStd_DeltaOnModificationOfByteArray self, Handle_TDataStd_ByteArray Arr) -> TDataStd_DeltaOnModificationOfByteArray

        Initializes a TDF_DeltaOnModification.

        :type Arr: OCC.wrapper.TDataStd.Handle_TDataStd_ByteArray

        """
        this = _TDataStd.new_TDataStd_DeltaOnModificationOfByteArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Apply(self, *args):
        """
        Apply(TDataStd_DeltaOnModificationOfByteArray self)

        Applies the delta to the attribute.


        """
        return _TDataStd.TDataStd_DeltaOnModificationOfByteArray_Apply(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_DeltaOnModificationOfByteArray_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_DeltaOnModificationOfByteArray_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_DeltaOnModificationOfByteArray_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDataStd.delete_TDataStd_DeltaOnModificationOfByteArray
TDataStd_DeltaOnModificationOfByteArray_swigregister = _TDataStd.TDataStd_DeltaOnModificationOfByteArray_swigregister
TDataStd_DeltaOnModificationOfByteArray_swigregister(TDataStd_DeltaOnModificationOfByteArray)

def TDataStd_DeltaOnModificationOfByteArray_get_type_name(*args):
    """
    TDataStd_DeltaOnModificationOfByteArray_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_DeltaOnModificationOfByteArray_get_type_name(*args)

def TDataStd_DeltaOnModificationOfByteArray_get_type_descriptor(*args):
    """
    TDataStd_DeltaOnModificationOfByteArray_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_DeltaOnModificationOfByteArray_get_type_descriptor(*args)

class TDataStd_Comment(TDF.TDF_Attribute):
    """
    Comment attribute. may be  associated to any label
    to store user comment.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_Comment
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_Comment(self) 
            return h


    def GetID(*args):
        """
        GetID() -> Standard_GUID

        class methods
        =============
        Returns the GUID for comments.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.TDataStd_Comment_GetID(*args)

    GetID = staticmethod(GetID)

    def __init__(self, *args):
        """
        __init__(TDataStd_Comment self) -> TDataStd_Comment

        Comment attribute. may be  associated to any label
        to store user comment.
        """
        this = _TDataStd.new_TDataStd_Comment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Set(self, *args):
        """
        Set(TDataStd_Comment self, TDF_Label label) -> Handle_TDataStd_Comment
        Set(TDataStd_Comment self, TDF_Label label, TCollection_ExtendedString string) -> Handle_TDataStd_Comment
        Set(TDataStd_Comment self, TCollection_ExtendedString S)

        :type S: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDataStd.TDataStd_Comment_Set(self, *args)


    def Get(self, *args):
        """
        Returns the comment attribute.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _TDataStd.TDataStd_Comment_Get(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.TDataStd_Comment_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TDataStd_Comment self, Handle_TDF_Attribute arg2)

        :type with: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_Comment_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TDataStd_Comment self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_Comment_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TDataStd_Comment self, Handle_TDF_Attribute into, Handle_TDF_RelocationTable RT)

        :type into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.TDataStd_Comment_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(TDataStd_Comment self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.TDataStd_Comment_Dump(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(TDataStd_Comment self, Standard_Boolean const forceIt) -> Standard_Boolean

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_Comment_AfterRetrieval(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_Comment_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_Comment_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_Comment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDataStd.delete_TDataStd_Comment
TDataStd_Comment_swigregister = _TDataStd.TDataStd_Comment_swigregister
TDataStd_Comment_swigregister(TDataStd_Comment)

def TDataStd_Comment_GetID(*args):
    """
    TDataStd_Comment_GetID() -> Standard_GUID

    class methods
    =============
    Returns the GUID for comments.

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TDataStd.TDataStd_Comment_GetID(*args)

def TDataStd_Comment_get_type_name(*args):
    """
    TDataStd_Comment_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_Comment_get_type_name(*args)

def TDataStd_Comment_get_type_descriptor(*args):
    """
    TDataStd_Comment_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_Comment_get_type_descriptor(*args)

class TDataStd_Tick(TDF.TDF_Attribute):
    """
    Defines a boolean attribute.
    If it exists at a label - true,
    Otherwise - false.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_Tick
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_Tick(self) 
            return h


    def GetID(*args):
        """
        GetID() -> Standard_GUID

        Static methods
        ==============

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.TDataStd_Tick_GetID(*args)

    GetID = staticmethod(GetID)

    def Set(*args):
        """
        Set(TDF_Label label) -> Handle_TDataStd_Tick

        Find, or create, a Tick attribute.
        Tick methods
        ============

        :type label: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_Tick

        """
        return _TDataStd.TDataStd_Tick_Set(*args)

    Set = staticmethod(Set)

    def __init__(self, *args):
        """
        __init__(TDataStd_Tick self) -> TDataStd_Tick

        Defines a boolean attribute.
        If it exists at a label - true,
        Otherwise - false.
        """
        this = _TDataStd.new_TDataStd_Tick(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.TDataStd_Tick_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TDataStd_Tick self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_Tick_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TDataStd_Tick self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_Tick_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TDataStd_Tick self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.TDataStd_Tick_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(TDataStd_Tick self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.TDataStd_Tick_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_Tick_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_Tick_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_Tick_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDataStd.delete_TDataStd_Tick
TDataStd_Tick_swigregister = _TDataStd.TDataStd_Tick_swigregister
TDataStd_Tick_swigregister(TDataStd_Tick)

def TDataStd_Tick_GetID(*args):
    """
    TDataStd_Tick_GetID() -> Standard_GUID

    Static methods
    ==============

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TDataStd.TDataStd_Tick_GetID(*args)

def TDataStd_Tick_Set(*args):
    """
    TDataStd_Tick_Set(TDF_Label label) -> Handle_TDataStd_Tick

    Find, or create, a Tick attribute.
    Tick methods
    ============

    :type label: OCC.wrapper.TDF.TDF_Label
    :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_Tick

    """
    return _TDataStd.TDataStd_Tick_Set(*args)

def TDataStd_Tick_get_type_name(*args):
    """
    TDataStd_Tick_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_Tick_get_type_name(*args)

def TDataStd_Tick_get_type_descriptor(*args):
    """
    TDataStd_Tick_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_Tick_get_type_descriptor(*args)

class TDataStd_Current(TDF.TDF_Attribute):
    """
    this attribute,  located at root label,  manage an
    access to a current label.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_Current
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_Current(self) 
            return h


    def GetID(*args):
        """
        GetID() -> Standard_GUID

        class methods
        =============

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.TDataStd_Current_GetID(*args)

    GetID = staticmethod(GetID)

    def Set(*args):
        """
        Set(TDF_Label L)

        Set <L> as current of <L> Framework.

        :type L: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.TDataStd_Current_Set(*args)

    Set = staticmethod(Set)

    def Get(*args):
        """
        Get(TDF_Label acces) -> TDF_Label

        returns current of <acces> Framework. raise if (!Has)

        :type acces: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.TDataStd_Current_Get(*args)

    Get = staticmethod(Get)

    def Has(*args):
        """
        Has(TDF_Label acces) -> Standard_Boolean

        returns True if a  current label is managed in <acces>
        Framework.
        class methods
        =============

        :type acces: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_Current_Has(*args)

    Has = staticmethod(Has)

    def __init__(self, *args):
        """
        __init__(TDataStd_Current self) -> TDataStd_Current

        this attribute,  located at root label,  manage an
        access to a current label.
        """
        this = _TDataStd.new_TDataStd_Current(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetLabel(self, *args):
        """
        SetLabel(TDataStd_Current self, TDF_Label current)

        :type current: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.TDataStd_Current_SetLabel(self, *args)


    def GetLabel(self, *args):
        """
        GetLabel(TDataStd_Current self) -> TDF_Label

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.TDataStd_Current_GetLabel(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.TDataStd_Current_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TDataStd_Current self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_Current_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TDataStd_Current self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_Current_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TDataStd_Current self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.TDataStd_Current_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(TDataStd_Current self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.TDataStd_Current_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_Current_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_Current_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_Current_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDataStd.delete_TDataStd_Current
TDataStd_Current_swigregister = _TDataStd.TDataStd_Current_swigregister
TDataStd_Current_swigregister(TDataStd_Current)

def TDataStd_Current_GetID(*args):
    """
    TDataStd_Current_GetID() -> Standard_GUID

    class methods
    =============

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TDataStd.TDataStd_Current_GetID(*args)

def TDataStd_Current_Set(*args):
    """
    TDataStd_Current_Set(TDF_Label L)

    Set <L> as current of <L> Framework.

    :type L: OCC.wrapper.TDF.TDF_Label

    """
    return _TDataStd.TDataStd_Current_Set(*args)

def TDataStd_Current_Get(*args):
    """
    TDataStd_Current_Get(TDF_Label acces) -> TDF_Label

    returns current of <acces> Framework. raise if (!Has)

    :type acces: OCC.wrapper.TDF.TDF_Label
    :rtype: OCC.wrapper.TDF.TDF_Label

    """
    return _TDataStd.TDataStd_Current_Get(*args)

def TDataStd_Current_Has(*args):
    """
    TDataStd_Current_Has(TDF_Label acces) -> Standard_Boolean

    returns True if a  current label is managed in <acces>
    Framework.
    class methods
    =============

    :type acces: OCC.wrapper.TDF.TDF_Label
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TDataStd.TDataStd_Current_Has(*args)

def TDataStd_Current_get_type_name(*args):
    """
    TDataStd_Current_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_Current_get_type_name(*args)

def TDataStd_Current_get_type_descriptor(*args):
    """
    TDataStd_Current_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_Current_get_type_descriptor(*args)

class TDataStd_ExtStringList(TDF.TDF_Attribute):
    """Contains a list of ExtendedString."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_ExtStringList
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_ExtStringList(self) 
            return h


    def GetID(*args):
        """
        GetID() -> Standard_GUID

        Static methods
        ==============
        Returns the ID of the list of strings attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.TDataStd_ExtStringList_GetID(*args)

    GetID = staticmethod(GetID)

    def Set(*args):
        """
        Set(TDF_Label label) -> Handle_TDataStd_ExtStringList
        Set(TDF_Label label, Standard_GUID theGuid) -> Handle_TDataStd_ExtStringList

        Finds or creates a list of string values attribute.

        :type label: OCC.wrapper.TDF.TDF_Label
        :type theGuid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_ExtStringList

        """
        return _TDataStd.TDataStd_ExtStringList_Set(*args)

    Set = staticmethod(Set)

    def __init__(self, *args):
        """
        __init__(TDataStd_ExtStringList self) -> TDataStd_ExtStringList

        Contains a list of ExtendedString.
        """
        this = _TDataStd.new_TDataStd_ExtStringList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsEmpty(self, *args):
        """
        IsEmpty(TDataStd_ExtStringList self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_ExtStringList_IsEmpty(self, *args)


    def Extent(self, *args):
        """
        Extent(TDataStd_ExtStringList self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.TDataStd_ExtStringList_Extent(self, *args)


    def Prepend(self, *args):
        """
        Prepend(TDataStd_ExtStringList self, TCollection_ExtendedString value)

        :type value: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDataStd.TDataStd_ExtStringList_Prepend(self, *args)


    def Append(self, *args):
        """
        Append(TDataStd_ExtStringList self, TCollection_ExtendedString value)

        :type value: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDataStd.TDataStd_ExtStringList_Append(self, *args)


    def SetID(self, *args):
        """
        SetID(TDataStd_ExtStringList self, Standard_GUID theGuid)
        SetID(TDataStd_ExtStringList self)

        Sets default GUID for the attribute.


        """
        return _TDataStd.TDataStd_ExtStringList_SetID(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(TDataStd_ExtStringList self, TCollection_ExtendedString value, TCollection_ExtendedString before_value) -> Standard_Boolean
        InsertBefore(TDataStd_ExtStringList self, Standard_Integer const index, TCollection_ExtendedString before_value) -> Standard_Boolean

        Inserts the <value> before the <index> position.
        The indices start with 1 .. Extent().

        :type index: int
        :type before_value: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_ExtStringList_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(TDataStd_ExtStringList self, TCollection_ExtendedString value, TCollection_ExtendedString after_value) -> Standard_Boolean
        InsertAfter(TDataStd_ExtStringList self, Standard_Integer const index, TCollection_ExtendedString after_value) -> Standard_Boolean

        Inserts the <value> after the <index> position.
        The indices start with 1 .. Extent().

        :type index: int
        :type after_value: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_ExtStringList_InsertAfter(self, *args)


    def Remove(self, *args):
        """
        Remove(TDataStd_ExtStringList self, TCollection_ExtendedString value) -> Standard_Boolean
        Remove(TDataStd_ExtStringList self, Standard_Integer const index) -> Standard_Boolean

        Removes a value at <index> position.

        :type index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_ExtStringList_Remove(self, *args)


    def Clear(self, *args):
        """Clear(TDataStd_ExtStringList self)"""
        return _TDataStd.TDataStd_ExtStringList_Clear(self, *args)


    def First(self, *args):
        """
        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _TDataStd.TDataStd_ExtStringList_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _TDataStd.TDataStd_ExtStringList_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def List(self, *args):
        """
        :rtype: OCC.wrapper.TDataStd.TDataStd_ListOfExtendedString

        """
        res = _TDataStd.TDataStd_ExtStringList_List(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.TDataStd_ExtStringList_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TDataStd_ExtStringList self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_ExtStringList_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TDataStd_ExtStringList self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_ExtStringList_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TDataStd_ExtStringList self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.TDataStd_ExtStringList_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(TDataStd_ExtStringList self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.TDataStd_ExtStringList_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_ExtStringList_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_ExtStringList_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_ExtStringList_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDataStd.delete_TDataStd_ExtStringList
TDataStd_ExtStringList_swigregister = _TDataStd.TDataStd_ExtStringList_swigregister
TDataStd_ExtStringList_swigregister(TDataStd_ExtStringList)

def TDataStd_ExtStringList_GetID(*args):
    """
    TDataStd_ExtStringList_GetID() -> Standard_GUID

    Static methods
    ==============
    Returns the ID of the list of strings attribute.

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TDataStd.TDataStd_ExtStringList_GetID(*args)

def TDataStd_ExtStringList_Set(*args):
    """
    Set(TDF_Label label) -> Handle_TDataStd_ExtStringList
    TDataStd_ExtStringList_Set(TDF_Label label, Standard_GUID theGuid) -> Handle_TDataStd_ExtStringList

    Finds or creates a list of string values attribute.

    :type label: OCC.wrapper.TDF.TDF_Label
    :type theGuid: OCC.wrapper.Standard.Standard_GUID
    :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_ExtStringList

    """
    return _TDataStd.TDataStd_ExtStringList_Set(*args)

def TDataStd_ExtStringList_get_type_name(*args):
    """
    TDataStd_ExtStringList_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_ExtStringList_get_type_name(*args)

def TDataStd_ExtStringList_get_type_descriptor(*args):
    """
    TDataStd_ExtStringList_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_ExtStringList_get_type_descriptor(*args)

class TDataStd_DeltaOnModificationOfIntPackedMap(TDF.TDF_DeltaOnModification):
    """
    This class provides default services for an
    AttributeDelta on a MODIFICATION action.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_DeltaOnModificationOfIntPackedMap
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_DeltaOnModificationOfIntPackedMap(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TDataStd_DeltaOnModificationOfIntPackedMap self, Handle_TDataStd_IntPackedMap Arr) -> TDataStd_DeltaOnModificationOfIntPackedMap

        Initializes a TDF_DeltaOnModification.

        :type Arr: OCC.wrapper.TDataStd.Handle_TDataStd_IntPackedMap

        """
        this = _TDataStd.new_TDataStd_DeltaOnModificationOfIntPackedMap(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Apply(self, *args):
        """
        Apply(TDataStd_DeltaOnModificationOfIntPackedMap self)

        Applies the delta to the attribute.


        """
        return _TDataStd.TDataStd_DeltaOnModificationOfIntPackedMap_Apply(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_DeltaOnModificationOfIntPackedMap_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_DeltaOnModificationOfIntPackedMap_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_DeltaOnModificationOfIntPackedMap_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDataStd.delete_TDataStd_DeltaOnModificationOfIntPackedMap
TDataStd_DeltaOnModificationOfIntPackedMap_swigregister = _TDataStd.TDataStd_DeltaOnModificationOfIntPackedMap_swigregister
TDataStd_DeltaOnModificationOfIntPackedMap_swigregister(TDataStd_DeltaOnModificationOfIntPackedMap)

def TDataStd_DeltaOnModificationOfIntPackedMap_get_type_name(*args):
    """
    TDataStd_DeltaOnModificationOfIntPackedMap_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_DeltaOnModificationOfIntPackedMap_get_type_name(*args)

def TDataStd_DeltaOnModificationOfIntPackedMap_get_type_descriptor(*args):
    """
    TDataStd_DeltaOnModificationOfIntPackedMap_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_DeltaOnModificationOfIntPackedMap_get_type_descriptor(*args)

class TDataStd_Relation(TDF.TDF_Attribute):
    """
    Relation attribute.
    ==================

    *  Data Structure of  the  Expression is stored in a
    string and references to variables used by the string

    Warning:  To be consistent,  each  Variable  referenced by  the
    relation must have its equivalent in the string
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_Relation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_Relation(self) 
            return h


    def GetID(*args):
        """
        GetID() -> Standard_GUID

        class methods
        =============

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.TDataStd_Relation_GetID(*args)

    GetID = staticmethod(GetID)

    def Set(*args):
        """
        Set(TDF_Label label) -> Handle_TDataStd_Relation

        Find, or create, an Relation attribute.
        Real methods
        ============

        :type label: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_Relation

        """
        return _TDataStd.TDataStd_Relation_Set(*args)

    Set = staticmethod(Set)

    def __init__(self, *args):
        """
        __init__(TDataStd_Relation self) -> TDataStd_Relation

        Relation attribute.
        ==================

        *  Data Structure of  the  Expression is stored in a
        string and references to variables used by the string

        Warning:  To be consistent,  each  Variable  referenced by  the
        relation must have its equivalent in the string
        """
        this = _TDataStd.new_TDataStd_Relation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Name(self, *args):
        """
        Name(TDataStd_Relation self) -> TCollection_ExtendedString

        build and return the relation name

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDataStd.TDataStd_Relation_Name(self, *args)


    def SetRelation(self, *args):
        """
        SetRelation(TDataStd_Relation self, TCollection_ExtendedString E)

        :type E: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDataStd.TDataStd_Relation_SetRelation(self, *args)


    def GetRelation(self, *args):
        """
        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _TDataStd.TDataStd_Relation_GetRelation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetVariables(self, *args):
        """
        GetVariables(TDataStd_Relation self) -> NCollection_List_Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.TDF_AttributeList

        """
        return _TDataStd.TDataStd_Relation_GetVariables(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.TDataStd_Relation_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TDataStd_Relation self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_Relation_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TDataStd_Relation self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_Relation_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TDataStd_Relation self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.TDataStd_Relation_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(TDataStd_Relation self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.TDataStd_Relation_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_Relation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_Relation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_Relation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDataStd.delete_TDataStd_Relation
TDataStd_Relation_swigregister = _TDataStd.TDataStd_Relation_swigregister
TDataStd_Relation_swigregister(TDataStd_Relation)

def TDataStd_Relation_GetID(*args):
    """
    TDataStd_Relation_GetID() -> Standard_GUID

    class methods
    =============

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TDataStd.TDataStd_Relation_GetID(*args)

def TDataStd_Relation_Set(*args):
    """
    TDataStd_Relation_Set(TDF_Label label) -> Handle_TDataStd_Relation

    Find, or create, an Relation attribute.
    Real methods
    ============

    :type label: OCC.wrapper.TDF.TDF_Label
    :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_Relation

    """
    return _TDataStd.TDataStd_Relation_Set(*args)

def TDataStd_Relation_get_type_name(*args):
    """
    TDataStd_Relation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_Relation_get_type_name(*args)

def TDataStd_Relation_get_type_descriptor(*args):
    """
    TDataStd_Relation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_Relation_get_type_descriptor(*args)

class TDataStd_ReferenceList(TDF.TDF_Attribute):
    """Contains a list of references."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_ReferenceList
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_ReferenceList(self) 
            return h


    def GetID(*args):
        """
        GetID() -> Standard_GUID

        Static methods
        ==============
        Returns the ID of the list of references (labels) attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.TDataStd_ReferenceList_GetID(*args)

    GetID = staticmethod(GetID)

    def Set(*args):
        """
        Set(TDF_Label label) -> Handle_TDataStd_ReferenceList
        Set(TDF_Label label, Standard_GUID theGuid) -> Handle_TDataStd_ReferenceList

        Finds or creates a list of reference values (labels) attribute with explicit user defined <guid>.

        :type label: OCC.wrapper.TDF.TDF_Label
        :type theGuid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_ReferenceList

        """
        return _TDataStd.TDataStd_ReferenceList_Set(*args)

    Set = staticmethod(Set)

    def __init__(self, *args):
        """
        __init__(TDataStd_ReferenceList self) -> TDataStd_ReferenceList

        Contains a list of references.
        """
        this = _TDataStd.new_TDataStd_ReferenceList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsEmpty(self, *args):
        """
        IsEmpty(TDataStd_ReferenceList self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_ReferenceList_IsEmpty(self, *args)


    def Extent(self, *args):
        """
        Extent(TDataStd_ReferenceList self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.TDataStd_ReferenceList_Extent(self, *args)


    def Prepend(self, *args):
        """
        Prepend(TDataStd_ReferenceList self, TDF_Label value)

        :type value: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.TDataStd_ReferenceList_Prepend(self, *args)


    def Append(self, *args):
        """
        Append(TDataStd_ReferenceList self, TDF_Label value)

        :type value: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.TDataStd_ReferenceList_Append(self, *args)


    def SetID(self, *args):
        """
        SetID(TDataStd_ReferenceList self, Standard_GUID theGuid)
        SetID(TDataStd_ReferenceList self)

        Sets default GUID for the attribute.


        """
        return _TDataStd.TDataStd_ReferenceList_SetID(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(TDataStd_ReferenceList self, TDF_Label value, TDF_Label before_value) -> Standard_Boolean
        InsertBefore(TDataStd_ReferenceList self, Standard_Integer const index, TDF_Label before_value) -> Standard_Boolean

        Inserts the label before the <index> position.
        The indices start with 1 .. Extent().

        :type index: int
        :type before_value: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_ReferenceList_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(TDataStd_ReferenceList self, TDF_Label value, TDF_Label after_value) -> Standard_Boolean
        InsertAfter(TDataStd_ReferenceList self, Standard_Integer const index, TDF_Label after_value) -> Standard_Boolean

        Inserts the label after the <index> position.
        The indices start with 1 .. Extent().

        :type index: int
        :type after_value: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_ReferenceList_InsertAfter(self, *args)


    def Remove(self, *args):
        """
        Remove(TDataStd_ReferenceList self, TDF_Label value) -> Standard_Boolean
        Remove(TDataStd_ReferenceList self, Standard_Integer const index) -> Standard_Boolean

        Removes a label at "index" position.

        :type index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_ReferenceList_Remove(self, *args)


    def Clear(self, *args):
        """Clear(TDataStd_ReferenceList self)"""
        return _TDataStd.TDataStd_ReferenceList_Clear(self, *args)


    def First(self, *args):
        """
        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        res = _TDataStd.TDataStd_ReferenceList_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        res = _TDataStd.TDataStd_ReferenceList_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def List(self, *args):
        """
        :rtype: OCC.wrapper.TDF.TDF_LabelList

        """
        res = _TDataStd.TDataStd_ReferenceList_List(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.TDataStd_ReferenceList_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TDataStd_ReferenceList self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_ReferenceList_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TDataStd_ReferenceList self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_ReferenceList_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TDataStd_ReferenceList self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.TDataStd_ReferenceList_Paste(self, *args)


    def References(self, *args):
        """
        References(TDataStd_ReferenceList self, Handle_TDF_DataSet DS)

        :type DS: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDataStd.TDataStd_ReferenceList_References(self, *args)


    def Dump(self, *args):
        """
        Dump(TDataStd_ReferenceList self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.TDataStd_ReferenceList_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_ReferenceList_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_ReferenceList_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_ReferenceList_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDataStd.delete_TDataStd_ReferenceList
TDataStd_ReferenceList_swigregister = _TDataStd.TDataStd_ReferenceList_swigregister
TDataStd_ReferenceList_swigregister(TDataStd_ReferenceList)

def TDataStd_ReferenceList_GetID(*args):
    """
    TDataStd_ReferenceList_GetID() -> Standard_GUID

    Static methods
    ==============
    Returns the ID of the list of references (labels) attribute.

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TDataStd.TDataStd_ReferenceList_GetID(*args)

def TDataStd_ReferenceList_Set(*args):
    """
    Set(TDF_Label label) -> Handle_TDataStd_ReferenceList
    TDataStd_ReferenceList_Set(TDF_Label label, Standard_GUID theGuid) -> Handle_TDataStd_ReferenceList

    Finds or creates a list of reference values (labels) attribute with explicit user defined <guid>.

    :type label: OCC.wrapper.TDF.TDF_Label
    :type theGuid: OCC.wrapper.Standard.Standard_GUID
    :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_ReferenceList

    """
    return _TDataStd.TDataStd_ReferenceList_Set(*args)

def TDataStd_ReferenceList_get_type_name(*args):
    """
    TDataStd_ReferenceList_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_ReferenceList_get_type_name(*args)

def TDataStd_ReferenceList_get_type_descriptor(*args):
    """
    TDataStd_ReferenceList_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_ReferenceList_get_type_descriptor(*args)

class TDataStd_RealArray(TDF.TDF_Attribute):
    """A framework for an attribute composed of a real number array."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_RealArray
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_RealArray(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_RealArray_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_RealArray_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_RealArray_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetID(*args):
        """
        GetID() -> Standard_GUID

        class methods
        =============
        Returns the GUID for arrays of reals.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.TDataStd_RealArray_GetID(*args)

    GetID = staticmethod(GetID)

    def Set(*args):
        """
        Set(TDF_Label label, Standard_Integer const lower, Standard_Integer const upper, Standard_Boolean const isDelta) -> Handle_TDataStd_RealArray
        Set(TDF_Label label, Standard_GUID theGuid, Standard_Integer const lower, Standard_Integer const upper, Standard_Boolean const isDelta) -> Handle_TDataStd_RealArray

        Finds, or creates, an RealArray attribute with explicit user defined <guid>.
        The RealArray attribute  is  returned.

        :type label: OCC.wrapper.TDF.TDF_Label
        :type theGuid: OCC.wrapper.Standard.Standard_GUID
        :type lower: int
        :type upper: int
        :type isDelta: bool
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_RealArray

        """
        return _TDataStd.TDataStd_RealArray_Set(*args)

    Set = staticmethod(Set)

    def Init(self, *args):
        """
        Init(TDataStd_RealArray self, Standard_Integer const lower, Standard_Integer const upper)

        Initialize the inner array with bounds from <lower> to <upper>

        :type lower: int
        :type upper: int

        """
        return _TDataStd.TDataStd_RealArray_Init(self, *args)


    def SetID(self, *args):
        """
        SetID(TDataStd_RealArray self, Standard_GUID theGuid)
        SetID(TDataStd_RealArray self)

        Sets default GUID for the attribute.


        """
        return _TDataStd.TDataStd_RealArray_SetID(self, *args)


    def SetValue(self, *args):
        """
        SetValue(TDataStd_RealArray self, Standard_Integer const Index, Standard_Real const Value)

        Sets  the   <Index>th  element  of   the  array to <Value>
        OutOfRange exception is raised if <Index> doesn't respect Lower and Upper bounds of the internal  array.

        :type Index: int
        :type Value: float

        """
        return _TDataStd.TDataStd_RealArray_SetValue(self, *args)


    def Value(self, *args):
        """
        Value(TDataStd_RealArray self, Standard_Integer const Index) -> Standard_Real

        Return the value of  the  <Index>th element of the array

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TDataStd.TDataStd_RealArray_Value(self, *args)


    def __call__(self, *args):
        """
        __call__(TDataStd_RealArray self, Standard_Integer const Index) -> Standard_Real

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TDataStd.TDataStd_RealArray___call__(self, *args)


    def Lower(self, *args):
        """
        Lower(TDataStd_RealArray self) -> Standard_Integer

        Returns the lower boundary of the array.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.TDataStd_RealArray_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(TDataStd_RealArray self) -> Standard_Integer

        Returns the upper boundary of the array.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.TDataStd_RealArray_Upper(self, *args)


    def Length(self, *args):
        """
        Length(TDataStd_RealArray self) -> Standard_Integer

        Returns the number of elements of the array of reals
        in terms of the number of elements it contains.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.TDataStd_RealArray_Length(self, *args)


    def ChangeArray(self, *args):
        """
        ChangeArray(TDataStd_RealArray self, Handle_TColStd_HArray1OfReal newArray, Standard_Boolean const isCheckItems)

        Sets the inner array <myValue> of the RealArray attribute
        to <newArray>. If value of <newArray> differs from <myValue>,
        Backup performed and myValue refers to new instance of HArray1OfReal
        that holds <newArray> values
        If <isCheckItems> equal True each item of <newArray> will be checked with each
        item of <myValue> for coincidence (to avoid backup).

        :type newArray: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal
        :type isCheckItems: bool

        """
        return _TDataStd.TDataStd_RealArray_ChangeArray(self, *args)


    def Array(self, *args):
        """
        Returns the handle of this array of reals.

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        res = _TDataStd.TDataStd_RealArray_Array(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetDelta(self, *args):
        """
        GetDelta(TDataStd_RealArray self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_RealArray_GetDelta(self, *args)


    def SetDelta(self, *args):
        """
        SetDelta(TDataStd_RealArray self, Standard_Boolean const isDelta)

        for  internal  use  only!

        :type isDelta: bool

        """
        return _TDataStd.TDataStd_RealArray_SetDelta(self, *args)


    def __init__(self, *args):
        """
        __init__(TDataStd_RealArray self) -> TDataStd_RealArray

        A framework for an attribute composed of a real number array.
        """
        this = _TDataStd.new_TDataStd_RealArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.TDataStd_RealArray_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TDataStd_RealArray self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_RealArray_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TDataStd_RealArray self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_RealArray_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TDataStd_RealArray self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        Note. Uses inside ChangeArray() method

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.TDataStd_RealArray_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(TDataStd_RealArray self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.TDataStd_RealArray_Dump(self, *args)

    __swig_destroy__ = _TDataStd.delete_TDataStd_RealArray
TDataStd_RealArray_swigregister = _TDataStd.TDataStd_RealArray_swigregister
TDataStd_RealArray_swigregister(TDataStd_RealArray)

def TDataStd_RealArray_get_type_name(*args):
    """
    TDataStd_RealArray_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_RealArray_get_type_name(*args)

def TDataStd_RealArray_get_type_descriptor(*args):
    """
    TDataStd_RealArray_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_RealArray_get_type_descriptor(*args)

def TDataStd_RealArray_GetID(*args):
    """
    TDataStd_RealArray_GetID() -> Standard_GUID

    class methods
    =============
    Returns the GUID for arrays of reals.

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TDataStd.TDataStd_RealArray_GetID(*args)

def TDataStd_RealArray_Set(*args):
    """
    Set(TDF_Label label, Standard_Integer const lower, Standard_Integer const upper, Standard_Boolean const isDelta) -> Handle_TDataStd_RealArray
    TDataStd_RealArray_Set(TDF_Label label, Standard_GUID theGuid, Standard_Integer const lower, Standard_Integer const upper, Standard_Boolean const isDelta) -> Handle_TDataStd_RealArray

    Finds, or creates, an RealArray attribute with explicit user defined <guid>.
    The RealArray attribute  is  returned.

    :type label: OCC.wrapper.TDF.TDF_Label
    :type theGuid: OCC.wrapper.Standard.Standard_GUID
    :type lower: int
    :type upper: int
    :type isDelta: bool
    :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_RealArray

    """
    return _TDataStd.TDataStd_RealArray_Set(*args)

class TDataStd_Variable(TDF.TDF_Attribute):
    """
    Variable attribute.
    ==================

    * A variable is  associated to a TDataStd_Real (which
    contains its    current  value) and  a   TDataStd_Name
    attribute (which  contains  its name).  It  contains a
    constant flag, and a Unit

    * An  expression may  be assigned  to a variable.   In
    thatcase the expression  is handled by the  associated
    Expression Attribute  and the Variable returns True to
    the method <IsAssigned>.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_Variable
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_Variable(self) 
            return h


    def GetID(*args):
        """
        GetID() -> Standard_GUID

        class methods
        =============

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.TDataStd_Variable_GetID(*args)

    GetID = staticmethod(GetID)

    def __init__(self, *args):
        """
        __init__(TDataStd_Variable self) -> TDataStd_Variable

        Variable attribute.
        ==================

        * A variable is  associated to a TDataStd_Real (which
        contains its    current  value) and  a   TDataStd_Name
        attribute (which  contains  its name).  It  contains a
        constant flag, and a Unit

        * An  expression may  be assigned  to a variable.   In
        thatcase the expression  is handled by the  associated
        Expression Attribute  and the Variable returns True to
        the method <IsAssigned>.
        """
        this = _TDataStd.new_TDataStd_Variable(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Name(self, *args):
        """
        returns    string   stored  in   the  associated  Name
        attribute.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _TDataStd.TDataStd_Variable_Name(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(TDataStd_Variable self, TDF_Label label) -> Handle_TDataStd_Variable
        Set(TDataStd_Variable self, Standard_Real const value)
        Set(TDataStd_Variable self, Standard_Real const value, TDataStd_RealEnum const dimension)

        Obsolete method that will be removed in next versions.
        The dimension argument is not supported in the persistence mechanism.

        :type value: float
        :type dimension: OCC.wrapper.TDataStd.TDataStd_RealEnum

        """
        return _TDataStd.TDataStd_Variable_Set(self, *args)


    def IsValued(self, *args):
        """
        IsValued(TDataStd_Variable self) -> Standard_Boolean

        returns True if a Real attribute is associated.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_Variable_IsValued(self, *args)


    def Get(self, *args):
        """
        Get(TDataStd_Variable self) -> Standard_Real

        returns value stored in associated Real attribute.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TDataStd.TDataStd_Variable_Get(self, *args)


    def Real(self, *args):
        """
        Real(TDataStd_Variable self) -> Handle_TDataStd_Real

        returns associated Real attribute.

        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_Real

        """
        return _TDataStd.TDataStd_Variable_Real(self, *args)


    def IsAssigned(self, *args):
        """
        IsAssigned(TDataStd_Variable self) -> Standard_Boolean

        returns True if an Expression attribute is associated.
        create(if doesn't exist), set and returns the assigned
        expression attribute.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_Variable_IsAssigned(self, *args)


    def Assign(self, *args):
        """
        Assign(TDataStd_Variable self) -> Handle_TDataStd_Expression

        create(if  doesn't exist)  and  returns  the  assigned
        expression  attribute. fill it after.

        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_Expression

        """
        return _TDataStd.TDataStd_Variable_Assign(self, *args)


    def Desassign(self, *args):
        """
        Desassign(TDataStd_Variable self)

        if <me> is  assigned delete the associated  expression
        attribute.


        """
        return _TDataStd.TDataStd_Variable_Desassign(self, *args)


    def Expression(self, *args):
        """
        Expression(TDataStd_Variable self) -> Handle_TDataStd_Expression

        if <me>  is  assigned, returns  associated  Expression
        attribute.

        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_Expression

        """
        return _TDataStd.TDataStd_Variable_Expression(self, *args)


    def IsCaptured(self, *args):
        """
        IsCaptured(TDataStd_Variable self) -> Standard_Boolean

        shortcut for <Real()->IsCaptured()>

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_Variable_IsCaptured(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(TDataStd_Variable self) -> Standard_Boolean

        A constant value is not modified by regeneration.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_Variable_IsConstant(self, *args)


    def Unit(self, *args):
        """
        to read/write fields
        ===================

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _TDataStd.TDataStd_Variable_Unit(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Constant(self, *args):
        """
        Constant(TDataStd_Variable self, Standard_Boolean const status)

        if  <status> is   True, this  variable  will not   be
        modified by the solver.

        :type status: bool

        """
        return _TDataStd.TDataStd_Variable_Constant(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.TDataStd_Variable_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TDataStd_Variable self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_Variable_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TDataStd_Variable self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_Variable_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TDataStd_Variable self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.TDataStd_Variable_Paste(self, *args)


    def References(self, *args):
        """
        References(TDataStd_Variable self, Handle_TDF_DataSet DS)

        to export reference to the associated Name attribute.

        :type DS: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDataStd.TDataStd_Variable_References(self, *args)


    def Dump(self, *args):
        """
        Dump(TDataStd_Variable self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.TDataStd_Variable_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_Variable_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_Variable_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_Variable_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDataStd.delete_TDataStd_Variable
TDataStd_Variable_swigregister = _TDataStd.TDataStd_Variable_swigregister
TDataStd_Variable_swigregister(TDataStd_Variable)

def TDataStd_Variable_GetID(*args):
    """
    TDataStd_Variable_GetID() -> Standard_GUID

    class methods
    =============

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TDataStd.TDataStd_Variable_GetID(*args)

def TDataStd_Variable_get_type_name(*args):
    """
    TDataStd_Variable_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_Variable_get_type_name(*args)

def TDataStd_Variable_get_type_descriptor(*args):
    """
    TDataStd_Variable_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_Variable_get_type_descriptor(*args)

class TDataStd_HDataMapOfStringHArray1OfReal(Standard.Standard_Transient):
    """
    Extension of TDataStd_DataMapOfStringHArray1OfReal class
    to be manipulated by handle.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_HDataMapOfStringHArray1OfReal
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_HDataMapOfStringHArray1OfReal(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_HDataMapOfStringHArray1OfReal_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_HDataMapOfStringHArray1OfReal_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_HDataMapOfStringHArray1OfReal_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(TDataStd_HDataMapOfStringHArray1OfReal self, Standard_Integer const NbBuckets=1) -> TDataStd_HDataMapOfStringHArray1OfReal
        __init__(TDataStd_HDataMapOfStringHArray1OfReal self, NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString theOther) -> TDataStd_HDataMapOfStringHArray1OfReal

        :type theOther: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringHArray1OfReal

        """
        this = _TDataStd.new_TDataStd_HDataMapOfStringHArray1OfReal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Map(self, *args):
        """
        :rtype: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringHArray1OfReal

        """
        res = _TDataStd.TDataStd_HDataMapOfStringHArray1OfReal_Map(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeMap(self, *args):
        """
        ChangeMap(TDataStd_HDataMapOfStringHArray1OfReal self) -> NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString

        :rtype: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringHArray1OfReal

        """
        return _TDataStd.TDataStd_HDataMapOfStringHArray1OfReal_ChangeMap(self, *args)

    __swig_destroy__ = _TDataStd.delete_TDataStd_HDataMapOfStringHArray1OfReal
TDataStd_HDataMapOfStringHArray1OfReal_swigregister = _TDataStd.TDataStd_HDataMapOfStringHArray1OfReal_swigregister
TDataStd_HDataMapOfStringHArray1OfReal_swigregister(TDataStd_HDataMapOfStringHArray1OfReal)

def TDataStd_HDataMapOfStringHArray1OfReal_get_type_name(*args):
    """
    TDataStd_HDataMapOfStringHArray1OfReal_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_HDataMapOfStringHArray1OfReal_get_type_name(*args)

def TDataStd_HDataMapOfStringHArray1OfReal_get_type_descriptor(*args):
    """
    TDataStd_HDataMapOfStringHArray1OfReal_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_HDataMapOfStringHArray1OfReal_get_type_descriptor(*args)

class TDataStd_Real(TDF.TDF_Attribute):
    """The basis to define a real number attribute."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_Real
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_Real(self) 
            return h


    def GetID(*args):
        """
        GetID() -> Standard_GUID

        class methods
        =============
        Returns the default GUID for real numbers.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.TDataStd_Real_GetID(*args)

    GetID = staticmethod(GetID)

    def __init__(self, *args):
        """
        __init__(TDataStd_Real self) -> TDataStd_Real

        The basis to define a real number attribute.
        """
        this = _TDataStd.new_TDataStd_Real(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetDimension(self, *args):
        """
        SetDimension(TDataStd_Real self, TDataStd_RealEnum const DIM)

        Obsolete method that will be removed in next versions.
        This field is not supported in the persistence mechanism.

        :type DIM: OCC.wrapper.TDataStd.TDataStd_RealEnum

        """
        return _TDataStd.TDataStd_Real_SetDimension(self, *args)


    def GetDimension(self, *args):
        """
        GetDimension(TDataStd_Real self) -> TDataStd_RealEnum

        Obsolete method that will be removed in next versions.
        This field is not supported in the persistence mechanism.

        :rtype: OCC.wrapper.TDataStd.TDataStd_RealEnum

        """
        return _TDataStd.TDataStd_Real_GetDimension(self, *args)


    def Set(self, *args):
        """
        Set(TDataStd_Real self, TDF_Label label, Standard_Real const value) -> Handle_TDataStd_Real
        Set(TDataStd_Real self, TDF_Label label, Standard_GUID guid, Standard_Real const value) -> Handle_TDataStd_Real
        Set(TDataStd_Real self, Standard_Real const V)

        Sets the real number V.

        :type V: float

        """
        return _TDataStd.TDataStd_Real_Set(self, *args)


    def SetID(self, *args):
        """
        SetID(TDataStd_Real self, Standard_GUID guid)
        SetID(TDataStd_Real self)

        Sets default GUID for the attribute.


        """
        return _TDataStd.TDataStd_Real_SetID(self, *args)


    def Get(self, *args):
        """
        Get(TDataStd_Real self) -> Standard_Real

        Returns the real number value contained in the attribute.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TDataStd.TDataStd_Real_Get(self, *args)


    def IsCaptured(self, *args):
        """
        IsCaptured(TDataStd_Real self) -> Standard_Boolean

        Returns True if there is a reference on the same label

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_Real_IsCaptured(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.TDataStd_Real_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TDataStd_Real self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_Real_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TDataStd_Real self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_Real_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TDataStd_Real self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.TDataStd_Real_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(TDataStd_Real self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.TDataStd_Real_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_Real_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_Real_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_Real_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDataStd.delete_TDataStd_Real
TDataStd_Real_swigregister = _TDataStd.TDataStd_Real_swigregister
TDataStd_Real_swigregister(TDataStd_Real)

def TDataStd_Real_GetID(*args):
    """
    TDataStd_Real_GetID() -> Standard_GUID

    class methods
    =============
    Returns the default GUID for real numbers.

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TDataStd.TDataStd_Real_GetID(*args)

def TDataStd_Real_get_type_name(*args):
    """
    TDataStd_Real_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_Real_get_type_name(*args)

def TDataStd_Real_get_type_descriptor(*args):
    """
    TDataStd_Real_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_Real_get_type_descriptor(*args)

class TDataStd_IntegerArray(TDF.TDF_Attribute):
    """Contains an array of integers."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_IntegerArray
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_IntegerArray(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_IntegerArray_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_IntegerArray_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_IntegerArray_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetID(*args):
        """
        GetID() -> Standard_GUID

        class methods
        =============
        Returns the GUID for arrays of integers.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.TDataStd_IntegerArray_GetID(*args)

    GetID = staticmethod(GetID)

    def Set(*args):
        """
        Set(TDF_Label label, Standard_Integer const lower, Standard_Integer const upper, Standard_Boolean const isDelta) -> Handle_TDataStd_IntegerArray
        Set(TDF_Label label, Standard_GUID theGuid, Standard_Integer const lower, Standard_Integer const upper, Standard_Boolean const isDelta) -> Handle_TDataStd_IntegerArray

        Finds, or creates, an IntegerArray attribute with explicit user defined <guid>.
        The IntegerArray attribute  is  returned.

        :type label: OCC.wrapper.TDF.TDF_Label
        :type theGuid: OCC.wrapper.Standard.Standard_GUID
        :type lower: int
        :type upper: int
        :type isDelta: bool
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_IntegerArray

        """
        return _TDataStd.TDataStd_IntegerArray_Set(*args)

    Set = staticmethod(Set)

    def Init(self, *args):
        """
        Init(TDataStd_IntegerArray self, Standard_Integer const lower, Standard_Integer const upper)

        Initialize the inner array with bounds from <lower> to <upper>

        :type lower: int
        :type upper: int

        """
        return _TDataStd.TDataStd_IntegerArray_Init(self, *args)


    def SetValue(self, *args):
        """
        SetValue(TDataStd_IntegerArray self, Standard_Integer const Index, Standard_Integer const Value)

        Sets  the   <Index>th  element  of   the  array to <Value>
        OutOfRange exception is raised if <Index> doesn't respect Lower and Upper bounds of the internal  array.

        :type Index: int
        :type Value: int

        """
        return _TDataStd.TDataStd_IntegerArray_SetValue(self, *args)


    def SetID(self, *args):
        """
        SetID(TDataStd_IntegerArray self, Standard_GUID theGuid)
        SetID(TDataStd_IntegerArray self)

        Sets default GUID for the attribute.


        """
        return _TDataStd.TDataStd_IntegerArray_SetID(self, *args)


    def Value(self, *args):
        """
        Value(TDataStd_IntegerArray self, Standard_Integer const Index) -> Standard_Integer

        Return the value of  the  <Index>th element of the array

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.TDataStd_IntegerArray_Value(self, *args)


    def __call__(self, *args):
        """
        __call__(TDataStd_IntegerArray self, Standard_Integer const Index) -> Standard_Integer

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.TDataStd_IntegerArray___call__(self, *args)


    def Lower(self, *args):
        """
        Lower(TDataStd_IntegerArray self) -> Standard_Integer

        Returns the lower boundary of this array of integers.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.TDataStd_IntegerArray_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(TDataStd_IntegerArray self) -> Standard_Integer

        Return the upper boundary of this array of integers.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.TDataStd_IntegerArray_Upper(self, *args)


    def Length(self, *args):
        """
        Length(TDataStd_IntegerArray self) -> Standard_Integer

        Returns the length of this array of integers in
        terms of the number of elements it contains.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.TDataStd_IntegerArray_Length(self, *args)


    def ChangeArray(self, *args):
        """
        ChangeArray(TDataStd_IntegerArray self, Handle_TColStd_HArray1OfInteger newArray, Standard_Boolean const isCheckItems)

        Sets the inner array <myValue>  of the IntegerArray attribute to
        <newArray>. If value of <newArray> differs from <myValue>, Backup performed
        and myValue refers to new instance of HArray1OfInteger that holds <newArray>
        values
        If <isCheckItems> equal True each item of <newArray> will be checked with each
        item of <myValue> for coincidence (to avoid backup).

        :type newArray: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfInteger
        :type isCheckItems: bool

        """
        return _TDataStd.TDataStd_IntegerArray_ChangeArray(self, *args)


    def Array(self, *args):
        """
        Return the inner array of the IntegerArray attribute

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfInteger

        """
        res = _TDataStd.TDataStd_IntegerArray_Array(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetDelta(self, *args):
        """
        GetDelta(TDataStd_IntegerArray self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_IntegerArray_GetDelta(self, *args)


    def SetDelta(self, *args):
        """
        SetDelta(TDataStd_IntegerArray self, Standard_Boolean const isDelta)

        for  internal  use  only!

        :type isDelta: bool

        """
        return _TDataStd.TDataStd_IntegerArray_SetDelta(self, *args)


    def __init__(self, *args):
        """
        __init__(TDataStd_IntegerArray self) -> TDataStd_IntegerArray

        Contains an array of integers.
        """
        this = _TDataStd.new_TDataStd_IntegerArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.TDataStd_IntegerArray_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TDataStd_IntegerArray self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_IntegerArray_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TDataStd_IntegerArray self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_IntegerArray_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TDataStd_IntegerArray self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        Note. Uses inside ChangeArray() method

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.TDataStd_IntegerArray_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(TDataStd_IntegerArray self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.TDataStd_IntegerArray_Dump(self, *args)

    __swig_destroy__ = _TDataStd.delete_TDataStd_IntegerArray
TDataStd_IntegerArray_swigregister = _TDataStd.TDataStd_IntegerArray_swigregister
TDataStd_IntegerArray_swigregister(TDataStd_IntegerArray)

def TDataStd_IntegerArray_get_type_name(*args):
    """
    TDataStd_IntegerArray_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_IntegerArray_get_type_name(*args)

def TDataStd_IntegerArray_get_type_descriptor(*args):
    """
    TDataStd_IntegerArray_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_IntegerArray_get_type_descriptor(*args)

def TDataStd_IntegerArray_GetID(*args):
    """
    TDataStd_IntegerArray_GetID() -> Standard_GUID

    class methods
    =============
    Returns the GUID for arrays of integers.

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TDataStd.TDataStd_IntegerArray_GetID(*args)

def TDataStd_IntegerArray_Set(*args):
    """
    Set(TDF_Label label, Standard_Integer const lower, Standard_Integer const upper, Standard_Boolean const isDelta) -> Handle_TDataStd_IntegerArray
    TDataStd_IntegerArray_Set(TDF_Label label, Standard_GUID theGuid, Standard_Integer const lower, Standard_Integer const upper, Standard_Boolean const isDelta) -> Handle_TDataStd_IntegerArray

    Finds, or creates, an IntegerArray attribute with explicit user defined <guid>.
    The IntegerArray attribute  is  returned.

    :type label: OCC.wrapper.TDF.TDF_Label
    :type theGuid: OCC.wrapper.Standard.Standard_GUID
    :type lower: int
    :type upper: int
    :type isDelta: bool
    :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_IntegerArray

    """
    return _TDataStd.TDataStd_IntegerArray_Set(*args)

class TDataStd_DeltaOnModificationOfIntArray(TDF.TDF_DeltaOnModification):
    """
    This class provides default services for an
    AttributeDelta on a MODIFICATION action.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_DeltaOnModificationOfIntArray
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_DeltaOnModificationOfIntArray(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TDataStd_DeltaOnModificationOfIntArray self, Handle_TDataStd_IntegerArray Arr) -> TDataStd_DeltaOnModificationOfIntArray

        Initializes a TDF_DeltaOnModification.

        :type Arr: OCC.wrapper.TDataStd.Handle_TDataStd_IntegerArray

        """
        this = _TDataStd.new_TDataStd_DeltaOnModificationOfIntArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Apply(self, *args):
        """
        Apply(TDataStd_DeltaOnModificationOfIntArray self)

        Applies the delta to the attribute.


        """
        return _TDataStd.TDataStd_DeltaOnModificationOfIntArray_Apply(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_DeltaOnModificationOfIntArray_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_DeltaOnModificationOfIntArray_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_DeltaOnModificationOfIntArray_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDataStd.delete_TDataStd_DeltaOnModificationOfIntArray
TDataStd_DeltaOnModificationOfIntArray_swigregister = _TDataStd.TDataStd_DeltaOnModificationOfIntArray_swigregister
TDataStd_DeltaOnModificationOfIntArray_swigregister(TDataStd_DeltaOnModificationOfIntArray)

def TDataStd_DeltaOnModificationOfIntArray_get_type_name(*args):
    """
    TDataStd_DeltaOnModificationOfIntArray_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_DeltaOnModificationOfIntArray_get_type_name(*args)

def TDataStd_DeltaOnModificationOfIntArray_get_type_descriptor(*args):
    """
    TDataStd_DeltaOnModificationOfIntArray_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_DeltaOnModificationOfIntArray_get_type_descriptor(*args)

class TDataStd_AsciiString(TDF.TDF_Attribute):
    """Used to define an AsciiString attribute containing a TCollection_AsciiString"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_AsciiString
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_AsciiString(self) 
            return h


    def GetID(*args):
        """
        GetID() -> Standard_GUID

        class methods
        =============
        Returns the GUID of the attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.TDataStd_AsciiString_GetID(*args)

    GetID = staticmethod(GetID)

    def __init__(self, *args):
        """
        __init__(TDataStd_AsciiString self) -> TDataStd_AsciiString

        Used to define an AsciiString attribute containing a TCollection_AsciiString
        """
        this = _TDataStd.new_TDataStd_AsciiString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Set(self, *args):
        """
        Set(TDataStd_AsciiString self, TDF_Label label, TCollection_AsciiString string) -> Handle_TDataStd_AsciiString
        Set(TDataStd_AsciiString self, TDF_Label label, Standard_GUID guid, TCollection_AsciiString string) -> Handle_TDataStd_AsciiString
        Set(TDataStd_AsciiString self, TCollection_AsciiString S)

        :type S: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _TDataStd.TDataStd_AsciiString_Set(self, *args)


    def SetID(self, *args):
        """
        SetID(TDataStd_AsciiString self, Standard_GUID guid)
        SetID(TDataStd_AsciiString self)

        Sets default GUID for the attribute.


        """
        return _TDataStd.TDataStd_AsciiString_SetID(self, *args)


    def Get(self, *args):
        """
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _TDataStd.TDataStd_AsciiString_Get(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsEmpty(self, *args):
        """
        IsEmpty(TDataStd_AsciiString self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_AsciiString_IsEmpty(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.TDataStd_AsciiString_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TDataStd_AsciiString self, Handle_TDF_Attribute arg2)

        :type with: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_AsciiString_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TDataStd_AsciiString self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_AsciiString_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TDataStd_AsciiString self, Handle_TDF_Attribute into, Handle_TDF_RelocationTable RT)

        :type into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.TDataStd_AsciiString_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(TDataStd_AsciiString self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.TDataStd_AsciiString_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_AsciiString_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_AsciiString_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_AsciiString_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDataStd.delete_TDataStd_AsciiString
TDataStd_AsciiString_swigregister = _TDataStd.TDataStd_AsciiString_swigregister
TDataStd_AsciiString_swigregister(TDataStd_AsciiString)

def TDataStd_AsciiString_GetID(*args):
    """
    TDataStd_AsciiString_GetID() -> Standard_GUID

    class methods
    =============
    Returns the GUID of the attribute.

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TDataStd.TDataStd_AsciiString_GetID(*args)

def TDataStd_AsciiString_get_type_name(*args):
    """
    TDataStd_AsciiString_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_AsciiString_get_type_name(*args)

def TDataStd_AsciiString_get_type_descriptor(*args):
    """
    TDataStd_AsciiString_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_AsciiString_get_type_descriptor(*args)

class TDataStd_IntegerList(TDF.TDF_Attribute):
    """Contains a list of integers."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_IntegerList
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_IntegerList(self) 
            return h


    def GetID(*args):
        """
        GetID() -> Standard_GUID

        Static methods
        ==============
        Returns the ID of the list of integer attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.TDataStd_IntegerList_GetID(*args)

    GetID = staticmethod(GetID)

    def Set(*args):
        """
        Set(TDF_Label label) -> Handle_TDataStd_IntegerList
        Set(TDF_Label label, Standard_GUID theGuid) -> Handle_TDataStd_IntegerList

        Finds or creates a list of integer values attribute with explicit user defined <guid>.

        :type label: OCC.wrapper.TDF.TDF_Label
        :type theGuid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_IntegerList

        """
        return _TDataStd.TDataStd_IntegerList_Set(*args)

    Set = staticmethod(Set)

    def __init__(self, *args):
        """
        __init__(TDataStd_IntegerList self) -> TDataStd_IntegerList

        Contains a list of integers.
        """
        this = _TDataStd.new_TDataStd_IntegerList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsEmpty(self, *args):
        """
        IsEmpty(TDataStd_IntegerList self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_IntegerList_IsEmpty(self, *args)


    def Extent(self, *args):
        """
        Extent(TDataStd_IntegerList self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.TDataStd_IntegerList_Extent(self, *args)


    def Prepend(self, *args):
        """
        Prepend(TDataStd_IntegerList self, Standard_Integer const value)

        :type value: int

        """
        return _TDataStd.TDataStd_IntegerList_Prepend(self, *args)


    def Append(self, *args):
        """
        Append(TDataStd_IntegerList self, Standard_Integer const value)

        :type value: int

        """
        return _TDataStd.TDataStd_IntegerList_Append(self, *args)


    def SetID(self, *args):
        """
        SetID(TDataStd_IntegerList self, Standard_GUID theGuid)
        SetID(TDataStd_IntegerList self)

        Sets default GUID for the attribute.


        """
        return _TDataStd.TDataStd_IntegerList_SetID(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(TDataStd_IntegerList self, Standard_Integer const value, Standard_Integer const before_value) -> Standard_Boolean

        Inserts the <value> before the first meet of <before_value>.

        :type value: int
        :type before_value: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_IntegerList_InsertBefore(self, *args)


    def InsertBeforeByIndex(self, *args):
        """
        InsertBeforeByIndex(TDataStd_IntegerList self, Standard_Integer const index, Standard_Integer const before_value) -> Standard_Boolean

        Inserts the <value> before the <index> position.
        The indices start with 1 .. Extent().

        :type index: int
        :type before_value: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_IntegerList_InsertBeforeByIndex(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(TDataStd_IntegerList self, Standard_Integer const value, Standard_Integer const after_value) -> Standard_Boolean

        Inserts the <value> after the first meet of <after_value>.

        :type value: int
        :type after_value: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_IntegerList_InsertAfter(self, *args)


    def InsertAfterByIndex(self, *args):
        """
        InsertAfterByIndex(TDataStd_IntegerList self, Standard_Integer const index, Standard_Integer const after_value) -> Standard_Boolean

        Inserts the <value> after the <index> position.
        The indices start with 1 .. Extent().

        :type index: int
        :type after_value: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_IntegerList_InsertAfterByIndex(self, *args)


    def Remove(self, *args):
        """
        Remove(TDataStd_IntegerList self, Standard_Integer const value) -> Standard_Boolean

        Removes the first meet of the <value>.

        :type value: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_IntegerList_Remove(self, *args)


    def RemoveByIndex(self, *args):
        """
        RemoveByIndex(TDataStd_IntegerList self, Standard_Integer const index) -> Standard_Boolean

        Removes a value at <index> position.

        :type index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_IntegerList_RemoveByIndex(self, *args)


    def Clear(self, *args):
        """Clear(TDataStd_IntegerList self)"""
        return _TDataStd.TDataStd_IntegerList_Clear(self, *args)


    def First(self, *args):
        """
        First(TDataStd_IntegerList self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.TDataStd_IntegerList_First(self, *args)


    def Last(self, *args):
        """
        Last(TDataStd_IntegerList self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.TDataStd_IntegerList_Last(self, *args)


    def List(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        res = _TDataStd.TDataStd_IntegerList_List(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.TDataStd_IntegerList_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TDataStd_IntegerList self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_IntegerList_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TDataStd_IntegerList self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_IntegerList_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TDataStd_IntegerList self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.TDataStd_IntegerList_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(TDataStd_IntegerList self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.TDataStd_IntegerList_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_IntegerList_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_IntegerList_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_IntegerList_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDataStd.delete_TDataStd_IntegerList
TDataStd_IntegerList_swigregister = _TDataStd.TDataStd_IntegerList_swigregister
TDataStd_IntegerList_swigregister(TDataStd_IntegerList)

def TDataStd_IntegerList_GetID(*args):
    """
    TDataStd_IntegerList_GetID() -> Standard_GUID

    Static methods
    ==============
    Returns the ID of the list of integer attribute.

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TDataStd.TDataStd_IntegerList_GetID(*args)

def TDataStd_IntegerList_Set(*args):
    """
    Set(TDF_Label label) -> Handle_TDataStd_IntegerList
    TDataStd_IntegerList_Set(TDF_Label label, Standard_GUID theGuid) -> Handle_TDataStd_IntegerList

    Finds or creates a list of integer values attribute with explicit user defined <guid>.

    :type label: OCC.wrapper.TDF.TDF_Label
    :type theGuid: OCC.wrapper.Standard.Standard_GUID
    :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_IntegerList

    """
    return _TDataStd.TDataStd_IntegerList_Set(*args)

def TDataStd_IntegerList_get_type_name(*args):
    """
    TDataStd_IntegerList_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_IntegerList_get_type_name(*args)

def TDataStd_IntegerList_get_type_descriptor(*args):
    """
    TDataStd_IntegerList_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_IntegerList_get_type_descriptor(*args)

class TDataStd_HLabelArray1(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_HLabelArray1
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_HLabelArray1(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TDataStd_HLabelArray1 self, Standard_Integer const theLower, Standard_Integer const theUpper) -> TDataStd_HLabelArray1
        __init__(TDataStd_HLabelArray1 self, Standard_Integer const theLower, Standard_Integer const theUpper, TDF_Label theValue) -> TDataStd_HLabelArray1
        __init__(TDataStd_HLabelArray1 self, NCollection_Array1_TDF_Label theOther) -> TDataStd_HLabelArray1

        :type theOther: OCC.wrapper.TDataStd.TDataStd_LabelArray1

        """
        this = _TDataStd.new_TDataStd_HLabelArray1(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.TDataStd.TDataStd_LabelArray1

        """
        res = _TDataStd.TDataStd_HLabelArray1_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(TDataStd_HLabelArray1 self) -> NCollection_Array1_TDF_Label

        :rtype: OCC.wrapper.TDataStd.TDataStd_LabelArray1

        """
        return _TDataStd.TDataStd_HLabelArray1_ChangeArray1(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_HLabelArray1_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_HLabelArray1_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_HLabelArray1_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDataStd.delete_TDataStd_HLabelArray1
TDataStd_HLabelArray1_swigregister = _TDataStd.TDataStd_HLabelArray1_swigregister
TDataStd_HLabelArray1_swigregister(TDataStd_HLabelArray1)

def TDataStd_HLabelArray1_get_type_name(*args):
    """
    TDataStd_HLabelArray1_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_HLabelArray1_get_type_name(*args)

def TDataStd_HLabelArray1_get_type_descriptor(*args):
    """
    TDataStd_HLabelArray1_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_HLabelArray1_get_type_descriptor(*args)

class TDataStd_ExtStringArray(TDF.TDF_Attribute):
    """ExtStringArray Attribute. Handles an array of UNICODE strings (represented by the TCollection_ExtendedString class)."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_ExtStringArray
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_ExtStringArray(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_ExtStringArray_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_ExtStringArray_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_ExtStringArray_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetID(*args):
        """
        GetID() -> Standard_GUID

        class methods
        =============
        Returns the GUID for the attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.TDataStd_ExtStringArray_GetID(*args)

    GetID = staticmethod(GetID)

    def Set(*args):
        """
        Set(TDF_Label label, Standard_Integer const lower, Standard_Integer const upper, Standard_Boolean const isDelta) -> Handle_TDataStd_ExtStringArray
        Set(TDF_Label label, Standard_GUID theGuid, Standard_Integer const lower, Standard_Integer const upper, Standard_Boolean const isDelta) -> Handle_TDataStd_ExtStringArray

        Finds, or creates, an ExtStringArray attribute with explicit user defined <guid>.
        The ExtStringArray attribute  is  returned.

        :type label: OCC.wrapper.TDF.TDF_Label
        :type theGuid: OCC.wrapper.Standard.Standard_GUID
        :type lower: int
        :type upper: int
        :type isDelta: bool
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_ExtStringArray

        """
        return _TDataStd.TDataStd_ExtStringArray_Set(*args)

    Set = staticmethod(Set)

    def Init(self, *args):
        """
        Init(TDataStd_ExtStringArray self, Standard_Integer const lower, Standard_Integer const upper)

        Initializes the inner array with bounds from <lower> to <upper>

        :type lower: int
        :type upper: int

        """
        return _TDataStd.TDataStd_ExtStringArray_Init(self, *args)


    def SetValue(self, *args):
        """
        SetValue(TDataStd_ExtStringArray self, Standard_Integer const Index, TCollection_ExtendedString Value)

        Sets  the   <Index>th  element  of   the  array to <Value>
        OutOfRange exception is raised if <Index> doesn't respect Lower and Upper bounds of the internal  array.

        :type Index: int
        :type Value: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDataStd.TDataStd_ExtStringArray_SetValue(self, *args)


    def SetID(self, *args):
        """
        SetID(TDataStd_ExtStringArray self, Standard_GUID theGuid)
        SetID(TDataStd_ExtStringArray self)

        Sets default GUID for the attribute.


        """
        return _TDataStd.TDataStd_ExtStringArray_SetID(self, *args)


    def Value(self, *args):
        """
        Returns the value of  the  <Index>th element of the array

        :type Index: int
        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _TDataStd.TDataStd_ExtStringArray_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __call__(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _TDataStd.TDataStd_ExtStringArray___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Lower(self, *args):
        """
        Lower(TDataStd_ExtStringArray self) -> Standard_Integer

        Return the lower bound.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.TDataStd_ExtStringArray_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(TDataStd_ExtStringArray self) -> Standard_Integer

        Return the upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.TDataStd_ExtStringArray_Upper(self, *args)


    def Length(self, *args):
        """
        Length(TDataStd_ExtStringArray self) -> Standard_Integer

        Return the number of elements of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.TDataStd_ExtStringArray_Length(self, *args)


    def ChangeArray(self, *args):
        """
        ChangeArray(TDataStd_ExtStringArray self, Handle_TColStd_HArray1OfExtendedString newArray, Standard_Boolean const isCheckItems)

        Sets the inner array <myValue> of the ExtStringArray attribute to <newArray>.
        If value of <newArray> differs from <myValue>, Backup performed and myValue
        refers to new instance of HArray1OfExtendedString that holds <newArray> values
        If <isCheckItems> equal True each item of <newArray> will be checked with each
        item of <myValue> for coincidence (to avoid backup).

        :type newArray: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfExtendedString
        :type isCheckItems: bool

        """
        return _TDataStd.TDataStd_ExtStringArray_ChangeArray(self, *args)


    def Array(self, *args):
        """
        Return the inner array of the ExtStringArray attribute

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfExtendedString

        """
        res = _TDataStd.TDataStd_ExtStringArray_Array(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetDelta(self, *args):
        """
        GetDelta(TDataStd_ExtStringArray self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_ExtStringArray_GetDelta(self, *args)


    def SetDelta(self, *args):
        """
        SetDelta(TDataStd_ExtStringArray self, Standard_Boolean const isDelta)

        for  internal  use  only!

        :type isDelta: bool

        """
        return _TDataStd.TDataStd_ExtStringArray_SetDelta(self, *args)


    def __init__(self, *args):
        """
        __init__(TDataStd_ExtStringArray self) -> TDataStd_ExtStringArray

        ExtStringArray Attribute. Handles an array of UNICODE strings (represented by the TCollection_ExtendedString class).
        """
        this = _TDataStd.new_TDataStd_ExtStringArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.TDataStd_ExtStringArray_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TDataStd_ExtStringArray self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_ExtStringArray_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TDataStd_ExtStringArray self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_ExtStringArray_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TDataStd_ExtStringArray self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.TDataStd_ExtStringArray_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(TDataStd_ExtStringArray self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.TDataStd_ExtStringArray_Dump(self, *args)

    __swig_destroy__ = _TDataStd.delete_TDataStd_ExtStringArray
TDataStd_ExtStringArray_swigregister = _TDataStd.TDataStd_ExtStringArray_swigregister
TDataStd_ExtStringArray_swigregister(TDataStd_ExtStringArray)

def TDataStd_ExtStringArray_get_type_name(*args):
    """
    TDataStd_ExtStringArray_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_ExtStringArray_get_type_name(*args)

def TDataStd_ExtStringArray_get_type_descriptor(*args):
    """
    TDataStd_ExtStringArray_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_ExtStringArray_get_type_descriptor(*args)

def TDataStd_ExtStringArray_GetID(*args):
    """
    TDataStd_ExtStringArray_GetID() -> Standard_GUID

    class methods
    =============
    Returns the GUID for the attribute.

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TDataStd.TDataStd_ExtStringArray_GetID(*args)

def TDataStd_ExtStringArray_Set(*args):
    """
    Set(TDF_Label label, Standard_Integer const lower, Standard_Integer const upper, Standard_Boolean const isDelta) -> Handle_TDataStd_ExtStringArray
    TDataStd_ExtStringArray_Set(TDF_Label label, Standard_GUID theGuid, Standard_Integer const lower, Standard_Integer const upper, Standard_Boolean const isDelta) -> Handle_TDataStd_ExtStringArray

    Finds, or creates, an ExtStringArray attribute with explicit user defined <guid>.
    The ExtStringArray attribute  is  returned.

    :type label: OCC.wrapper.TDF.TDF_Label
    :type theGuid: OCC.wrapper.Standard.Standard_GUID
    :type lower: int
    :type upper: int
    :type isDelta: bool
    :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_ExtStringArray

    """
    return _TDataStd.TDataStd_ExtStringArray_Set(*args)

class NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString self) -> NCollection_DataMap< TCollection_ExtendedString,TCollection_ExtendedString,TCollection_ExtendedString >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString self) -> NCollection_DataMap< TCollection_ExtendedString,TCollection_ExtendedString,TCollection_ExtendedString >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString self) -> NCollection_DataMap< TCollection_ExtendedString,TCollection_ExtendedString,TCollection_ExtendedString >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString self) -> NCollection_DataMap< TCollection_ExtendedString,TCollection_ExtendedString,TCollection_ExtendedString >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TDataStd.new_NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString self, NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString self, NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString theOther) -> NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString self, NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString theOther) -> NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString self, TCollection_ExtendedString theKey, TCollection_ExtendedString theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString self, TCollection_ExtendedString theKey, TCollection_ExtendedString theItem) -> TCollection_ExtendedString

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> TCollection_ExtendedString

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TDataStd.NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> TCollection_ExtendedString

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> TCollection_ExtendedString

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TDataStd.NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString_Size(self, *args)


    def __iter__(self):
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString___iter__(self)
    __swig_destroy__ = _TDataStd.delete_NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString
NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString_swigregister = _TDataStd.NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString_swigregister
NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString_swigregister(NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString)

class NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TDataStd.new_NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDataStd.delete_NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString_IteratorHelper

    def __next__(self):
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString_IteratorHelper___next__(self)
NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString_IteratorHelper_swigregister = _TDataStd.NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString_IteratorHelper_swigregister
NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString_IteratorHelper_swigregister(NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString_IteratorHelper)


try:
	TDataStd_DataMapOfStringString = NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString
except NameError:
	pass # does not exist, probably ignored

class TDataStd_BooleanList(TDF.TDF_Attribute):
    """Contains a list of bolleans."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_BooleanList
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_BooleanList(self) 
            return h


    def GetID(*args):
        """
        GetID() -> Standard_GUID

        Static methods
        ==============
        Returns the ID of the list of booleans attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.TDataStd_BooleanList_GetID(*args)

    GetID = staticmethod(GetID)

    def Set(*args):
        """
        Set(TDF_Label label) -> Handle_TDataStd_BooleanList
        Set(TDF_Label label, Standard_GUID theGuid) -> Handle_TDataStd_BooleanList

        Finds or creates a list of boolean values attribute with explicit user defined <guid>.

        :type label: OCC.wrapper.TDF.TDF_Label
        :type theGuid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_BooleanList

        """
        return _TDataStd.TDataStd_BooleanList_Set(*args)

    Set = staticmethod(Set)

    def __init__(self, *args):
        """
        __init__(TDataStd_BooleanList self) -> TDataStd_BooleanList

        Contains a list of bolleans.
        """
        this = _TDataStd.new_TDataStd_BooleanList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def IsEmpty(self, *args):
        """
        IsEmpty(TDataStd_BooleanList self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_BooleanList_IsEmpty(self, *args)


    def Extent(self, *args):
        """
        Extent(TDataStd_BooleanList self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.TDataStd_BooleanList_Extent(self, *args)


    def Prepend(self, *args):
        """
        Prepend(TDataStd_BooleanList self, Standard_Boolean const value)

        :type value: bool

        """
        return _TDataStd.TDataStd_BooleanList_Prepend(self, *args)


    def Append(self, *args):
        """
        Append(TDataStd_BooleanList self, Standard_Boolean const value)

        :type value: bool

        """
        return _TDataStd.TDataStd_BooleanList_Append(self, *args)


    def Clear(self, *args):
        """Clear(TDataStd_BooleanList self)"""
        return _TDataStd.TDataStd_BooleanList_Clear(self, *args)


    def First(self, *args):
        """
        First(TDataStd_BooleanList self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_BooleanList_First(self, *args)


    def Last(self, *args):
        """
        Last(TDataStd_BooleanList self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_BooleanList_Last(self, *args)


    def List(self, *args):
        """
        1 - means TRUE,
        0 - means FALSE.

        :rtype: OCC.wrapper.TDataStd.TDataStd_ListOfByte

        """
        res = _TDataStd.TDataStd_BooleanList_List(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InsertBefore(self, *args):
        """
        InsertBefore(TDataStd_BooleanList self, Standard_Integer const index, Standard_Boolean const before_value) -> Standard_Boolean

        Inserts the <value> before the <index> position.
        The indices start with 1 .. Extent().

        :type index: int
        :type before_value: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_BooleanList_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(TDataStd_BooleanList self, Standard_Integer const index, Standard_Boolean const after_value) -> Standard_Boolean

        Inserts the <value> after the <index> position.
        The indices start with 1 .. Extent().

        :type index: int
        :type after_value: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_BooleanList_InsertAfter(self, *args)


    def Remove(self, *args):
        """
        Remove(TDataStd_BooleanList self, Standard_Integer const index) -> Standard_Boolean

        Removes a value at <index> position.

        :type index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_BooleanList_Remove(self, *args)


    def SetID(self, *args):
        """
        SetID(TDataStd_BooleanList self, Standard_GUID theGuid)
        SetID(TDataStd_BooleanList self)

        Sets default GUID for the attribute.


        """
        return _TDataStd.TDataStd_BooleanList_SetID(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.TDataStd_BooleanList_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TDataStd_BooleanList self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_BooleanList_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TDataStd_BooleanList self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_BooleanList_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TDataStd_BooleanList self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.TDataStd_BooleanList_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(TDataStd_BooleanList self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.TDataStd_BooleanList_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_BooleanList_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_BooleanList_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_BooleanList_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDataStd.delete_TDataStd_BooleanList
TDataStd_BooleanList_swigregister = _TDataStd.TDataStd_BooleanList_swigregister
TDataStd_BooleanList_swigregister(TDataStd_BooleanList)

def TDataStd_BooleanList_GetID(*args):
    """
    TDataStd_BooleanList_GetID() -> Standard_GUID

    Static methods
    ==============
    Returns the ID of the list of booleans attribute.

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TDataStd.TDataStd_BooleanList_GetID(*args)

def TDataStd_BooleanList_Set(*args):
    """
    Set(TDF_Label label) -> Handle_TDataStd_BooleanList
    TDataStd_BooleanList_Set(TDF_Label label, Standard_GUID theGuid) -> Handle_TDataStd_BooleanList

    Finds or creates a list of boolean values attribute with explicit user defined <guid>.

    :type label: OCC.wrapper.TDF.TDF_Label
    :type theGuid: OCC.wrapper.Standard.Standard_GUID
    :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_BooleanList

    """
    return _TDataStd.TDataStd_BooleanList_Set(*args)

def TDataStd_BooleanList_get_type_name(*args):
    """
    TDataStd_BooleanList_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_BooleanList_get_type_name(*args)

def TDataStd_BooleanList_get_type_descriptor(*args):
    """
    TDataStd_BooleanList_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_BooleanList_get_type_descriptor(*args)

class Handle_TDataStd_DeltaOnModificationOfIntArray(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_DeltaOnModificationOfIntArray self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntArray_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_DeltaOnModificationOfIntArray self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntArray_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_DeltaOnModificationOfIntArray self, TDataStd_DeltaOnModificationOfIntArray thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntArray_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_DeltaOnModificationOfIntArray self, Handle_TDataStd_DeltaOnModificationOfIntArray theHandle) -> Handle_TDataStd_DeltaOnModificationOfIntArray
        assign(Handle_TDataStd_DeltaOnModificationOfIntArray self, TDataStd_DeltaOnModificationOfIntArray thePtr) -> Handle_TDataStd_DeltaOnModificationOfIntArray
        assign(Handle_TDataStd_DeltaOnModificationOfIntArray self, Handle_TDataStd_DeltaOnModificationOfIntArray theHandle) -> Handle_TDataStd_DeltaOnModificationOfIntArray

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntArray_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_DeltaOnModificationOfIntArray self) -> TDataStd_DeltaOnModificationOfIntArray

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntArray_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_DeltaOnModificationOfIntArray self) -> TDataStd_DeltaOnModificationOfIntArray

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntArray___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_DeltaOnModificationOfIntArray self) -> TDataStd_DeltaOnModificationOfIntArray

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntArray___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntArray___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntArray___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_DeltaOnModificationOfIntArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_DeltaOnModificationOfIntArray_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_DeltaOnModificationOfIntArray

    def Apply(self, *args):
        """
        Apply(Handle_TDataStd_DeltaOnModificationOfIntArray self)

        Applies the delta to the attribute.


        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntArray_Apply(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_DeltaOnModificationOfIntArray self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntArray_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntArray_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntArray_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Label(self, *args):
        """
        Label(Handle_TDataStd_DeltaOnModificationOfIntArray self) -> TDF_Label

        Returns the label concerned by <me>.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntArray_Label(self, *args)


    def Attribute(self, *args):
        """
        Attribute(Handle_TDataStd_DeltaOnModificationOfIntArray self) -> Handle_TDF_Attribute

        Returns the reference attribute.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntArray_Attribute(self, *args)


    def ID(self, *args):
        """
        ID(Handle_TDataStd_DeltaOnModificationOfIntArray self) -> Standard_GUID

        Returns the ID of the attribute concerned by <me>.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntArray_ID(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDataStd_DeltaOnModificationOfIntArray self, Standard_OStream & OS) -> Standard_OStream &

        Dumps the contents.

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntArray_Dump(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDataStd_DeltaOnModificationOfIntArray self, Standard_OStream & OS) -> Standard_OStream &

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntArray___lshift__(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_DeltaOnModificationOfIntArray self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntArray_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_DeltaOnModificationOfIntArray self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_DeltaOnModificationOfIntArray self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntArray_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_DeltaOnModificationOfIntArray self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_DeltaOnModificationOfIntArray self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntArray_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_DeltaOnModificationOfIntArray self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntArray_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_DeltaOnModificationOfIntArray self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntArray_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_DeltaOnModificationOfIntArray self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntArray_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_DeltaOnModificationOfIntArray self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntArray_DecrementRefCounter(self, *args)

Handle_TDataStd_DeltaOnModificationOfIntArray_swigregister = _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntArray_swigregister
Handle_TDataStd_DeltaOnModificationOfIntArray_swigregister(Handle_TDataStd_DeltaOnModificationOfIntArray)

def Handle_TDataStd_DeltaOnModificationOfIntArray_DownCast(thing):
    return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntArray_DownCast(thing)
Handle_TDataStd_DeltaOnModificationOfIntArray_DownCast = _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntArray_DownCast

class NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString self) -> NCollection_DataMap< TCollection_ExtendedString,Standard_Byte,TCollection_ExtendedString >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString self) -> NCollection_DataMap< TCollection_ExtendedString,Standard_Byte,TCollection_ExtendedString >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString self) -> NCollection_DataMap< TCollection_ExtendedString,Standard_Byte,TCollection_ExtendedString >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString self) -> NCollection_DataMap< TCollection_ExtendedString,Standard_Byte,TCollection_ExtendedString >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TDataStd.new_NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString self, NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString self, NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString theOther) -> NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString self, NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString theOther) -> NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString self, TCollection_ExtendedString theKey, unsigned char const & theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString self, TCollection_ExtendedString theKey, unsigned char const & theItem) -> unsigned char *

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> unsigned char const *

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> unsigned char *

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> unsigned char &

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString_Size(self, *args)


    def __iter__(self):
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString___iter__(self)
    __swig_destroy__ = _TDataStd.delete_NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString
NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString_swigregister = _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString_swigregister
NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString_swigregister(NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString)

class NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TDataStd.new_NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDataStd.delete_NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString_IteratorHelper

    def __next__(self):
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString_IteratorHelper___next__(self)
NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString_IteratorHelper_swigregister = _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString_IteratorHelper_swigregister
NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString_IteratorHelper_swigregister(NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString_IteratorHelper)


try:
	TDataStd_DataMapOfStringByte = NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString
except NameError:
	pass # does not exist, probably ignored

class TDataStd_DeltaOnModificationOfRealArray(TDF.TDF_DeltaOnModification):
    """
    This class provides default services for an
    AttributeDelta on a MODIFICATION action
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_DeltaOnModificationOfRealArray
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_DeltaOnModificationOfRealArray(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TDataStd_DeltaOnModificationOfRealArray self, Handle_TDataStd_RealArray Arr) -> TDataStd_DeltaOnModificationOfRealArray

        Initializes a TDF_DeltaOnModification.

        :type Arr: OCC.wrapper.TDataStd.Handle_TDataStd_RealArray

        """
        this = _TDataStd.new_TDataStd_DeltaOnModificationOfRealArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Apply(self, *args):
        """
        Apply(TDataStd_DeltaOnModificationOfRealArray self)

        Applies the delta to the attribute.


        """
        return _TDataStd.TDataStd_DeltaOnModificationOfRealArray_Apply(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_DeltaOnModificationOfRealArray_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_DeltaOnModificationOfRealArray_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_DeltaOnModificationOfRealArray_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDataStd.delete_TDataStd_DeltaOnModificationOfRealArray
TDataStd_DeltaOnModificationOfRealArray_swigregister = _TDataStd.TDataStd_DeltaOnModificationOfRealArray_swigregister
TDataStd_DeltaOnModificationOfRealArray_swigregister(TDataStd_DeltaOnModificationOfRealArray)

def TDataStd_DeltaOnModificationOfRealArray_get_type_name(*args):
    """
    TDataStd_DeltaOnModificationOfRealArray_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_DeltaOnModificationOfRealArray_get_type_name(*args)

def TDataStd_DeltaOnModificationOfRealArray_get_type_descriptor(*args):
    """
    TDataStd_DeltaOnModificationOfRealArray_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_DeltaOnModificationOfRealArray_get_type_descriptor(*args)

class TDataStd_TreeNode(TDF.TDF_Attribute):
    """
    Allows you to define an explicit tree of labels
    which you can also edit.
    Without this class, the data structure cannot be fully edited.
    This service is required if for presentation
    purposes, you want to create an application with
    a tree which allows you to organize and link data
    as a function of application features.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_TreeNode
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_TreeNode(self) 
            return h


    def Find(*args):
        """
        Find(TDF_Label L, Handle_TDataStd_TreeNode T) -> Standard_Boolean

        class  methods working on the node
        ===================================
        Returns true if the tree node T is found on the label L.
        Otherwise, false is returned.

        :type L: OCC.wrapper.TDF.TDF_Label
        :type T: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_TreeNode_Find(*args)

    Find = staticmethod(Find)

    def Set(*args):
        """
        Set(TDF_Label L) -> Handle_TDataStd_TreeNode
        Set(TDF_Label L, Standard_GUID ExplicitTreeID) -> Handle_TDataStd_TreeNode

        Finds  or Creates a   TreeNode attribute on  the label
        <L>, with an   explicit tree ID.  <ExplicitTreeID>  is
        the  ID   returned by    <TDF_Attribute::ID>   method.
        Returns the found/created TreeNode attribute.

        :type L: OCC.wrapper.TDF.TDF_Label
        :type ExplicitTreeID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode

        """
        return _TDataStd.TDataStd_TreeNode_Set(*args)

    Set = staticmethod(Set)

    def GetDefaultTreeID(*args):
        """
        GetDefaultTreeID() -> Standard_GUID

        returns a default  tree ID.  this  ID is  used by the
        <Set> method without explicit tree ID.
        Instance methods:
        ================

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.TDataStd_TreeNode_GetDefaultTreeID(*args)

    GetDefaultTreeID = staticmethod(GetDefaultTreeID)

    def __init__(self, *args):
        """
        __init__(TDataStd_TreeNode self) -> TDataStd_TreeNode

        Allows you to define an explicit tree of labels
        which you can also edit.
        Without this class, the data structure cannot be fully edited.
        This service is required if for presentation
        purposes, you want to create an application with
        a tree which allows you to organize and link data
        as a function of application features.
        """
        this = _TDataStd.new_TDataStd_TreeNode(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Append(self, *args):
        """
        Append(TDataStd_TreeNode self, Handle_TDataStd_TreeNode Child) -> Standard_Boolean

        Insert the TreeNode <Child> as last  child of <me>. If
        the insertion is successful <me> becomes the Father of <Child>.

        :type Child: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_TreeNode_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(TDataStd_TreeNode self, Handle_TDataStd_TreeNode Child) -> Standard_Boolean

        Insert the   the TreeNode <Child>  as  first child of
        <me>. If the insertion is successful <me> becomes the Father of <Child>

        :type Child: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_TreeNode_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(TDataStd_TreeNode self, Handle_TDataStd_TreeNode Node) -> Standard_Boolean

        Inserts the TreeNode  <Node> before <me>. If insertion is successful <me>
        and <Node> belongs to the same Father.

        :type Node: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_TreeNode_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(TDataStd_TreeNode self, Handle_TDataStd_TreeNode Node) -> Standard_Boolean

        Inserts the TreeNode <Node>  after <me>. If insertion is successful  <me>
        and <Node> belongs to the same Father.

        :type Node: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_TreeNode_InsertAfter(self, *args)


    def Remove(self, *args):
        """
        Remove(TDataStd_TreeNode self) -> Standard_Boolean

        Removes this tree node attribute from its father
        node. The result is that this attribute becomes a root node.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_TreeNode_Remove(self, *args)


    def Depth(self, *args):
        """
        Depth(TDataStd_TreeNode self) -> Standard_Integer

        Returns the depth of this tree node in the overall tree node structure.
        In other words, the number of father tree nodes of this one is returned.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.TDataStd_TreeNode_Depth(self, *args)


    def NbChildren(self, *args):
        """
        NbChildren(TDataStd_TreeNode self, Standard_Boolean const allLevels) -> Standard_Integer

        Returns the number of child nodes.
        If <allLevels> is true, the method counts children of all levels
        (children of children ...)

        :type allLevels: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.TDataStd_TreeNode_NbChildren(self, *args)


    def IsAscendant(self, *args):
        """
        IsAscendant(TDataStd_TreeNode self, Handle_TDataStd_TreeNode of) -> Standard_Boolean

        Returns true if this tree node attribute is an
        ascendant of of. In other words, if it is a father or
        the father of a father of of.

        :type of: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_TreeNode_IsAscendant(self, *args)


    def IsDescendant(self, *args):
        """
        IsDescendant(TDataStd_TreeNode self, Handle_TDataStd_TreeNode of) -> Standard_Boolean

        Returns true if this tree node attribute is a
        descendant of of. In other words, if it is a child or
        the child of a child of of.

        :type of: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_TreeNode_IsDescendant(self, *args)


    def IsRoot(self, *args):
        """
        IsRoot(TDataStd_TreeNode self) -> Standard_Boolean

        Returns true if this tree node attribute is the
        ultimate father in the tree.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_TreeNode_IsRoot(self, *args)


    def Root(self, *args):
        """
        Root(TDataStd_TreeNode self) -> Handle_TDataStd_TreeNode

        Returns the ultimate father of this tree node attribute.

        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode

        """
        return _TDataStd.TDataStd_TreeNode_Root(self, *args)


    def IsFather(self, *args):
        """
        IsFather(TDataStd_TreeNode self, Handle_TDataStd_TreeNode of) -> Standard_Boolean

        Returns true if this tree node attribute is a father of of.

        :type of: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_TreeNode_IsFather(self, *args)


    def IsChild(self, *args):
        """
        IsChild(TDataStd_TreeNode self, Handle_TDataStd_TreeNode of) -> Standard_Boolean

        Returns true if this tree node attribute is a child of of.

        :type of: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_TreeNode_IsChild(self, *args)


    def HasFather(self, *args):
        """
        HasFather(TDataStd_TreeNode self) -> Standard_Boolean

        Returns true if this tree node attribute has a father tree node.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_TreeNode_HasFather(self, *args)


    def Father(self, *args):
        """
        Father(TDataStd_TreeNode self) -> Handle_TDataStd_TreeNode

        Returns the father TreeNode of <me>. Null if root.

        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode

        """
        return _TDataStd.TDataStd_TreeNode_Father(self, *args)


    def HasNext(self, *args):
        """
        HasNext(TDataStd_TreeNode self) -> Standard_Boolean

        Returns true if this tree node attribute has a next tree node.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_TreeNode_HasNext(self, *args)


    def Next(self, *args):
        """
        Next(TDataStd_TreeNode self) -> Handle_TDataStd_TreeNode

        Returns the next tree node in this tree node attribute.
        Warning
        This tree node is null if it is the last one in this
        tree node attribute.Returns the next TreeNode of <me>. Null if last.

        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode

        """
        return _TDataStd.TDataStd_TreeNode_Next(self, *args)


    def HasPrevious(self, *args):
        """
        HasPrevious(TDataStd_TreeNode self) -> Standard_Boolean

        Returns true if this tree node attribute has a previous tree node.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_TreeNode_HasPrevious(self, *args)


    def Previous(self, *args):
        """
        Previous(TDataStd_TreeNode self) -> Handle_TDataStd_TreeNode

        Returns the previous tree node of this tree node attribute.
        Warning
        This tree node is null if it is the first one in this tree node attribute.

        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode

        """
        return _TDataStd.TDataStd_TreeNode_Previous(self, *args)


    def HasFirst(self, *args):
        """
        HasFirst(TDataStd_TreeNode self) -> Standard_Boolean

        Returns true if this tree node attribute has a first child tree node.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_TreeNode_HasFirst(self, *args)


    def First(self, *args):
        """
        First(TDataStd_TreeNode self) -> Handle_TDataStd_TreeNode

        Returns the first child tree node in this tree node object.

        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode

        """
        return _TDataStd.TDataStd_TreeNode_First(self, *args)


    def HasLast(self, *args):
        """
        HasLast(TDataStd_TreeNode self) -> Standard_Boolean

        Returns true if this tree node attribute has a last child tree node.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_TreeNode_HasLast(self, *args)


    def Last(self, *args):
        """
        Last(TDataStd_TreeNode self) -> Handle_TDataStd_TreeNode

        Returns the last child tree node in this tree node object.

        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode

        """
        return _TDataStd.TDataStd_TreeNode_Last(self, *args)


    def FindLast(self, *args):
        """
        FindLast(TDataStd_TreeNode self) -> Handle_TDataStd_TreeNode

        Returns the last child tree node in this tree node object.
        to set fields
        =============

        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode

        """
        return _TDataStd.TDataStd_TreeNode_FindLast(self, *args)


    def SetTreeID(self, *args):
        """
        SetTreeID(TDataStd_TreeNode self, Standard_GUID explicitID)

        :type explicitID: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.TDataStd_TreeNode_SetTreeID(self, *args)


    def SetFather(self, *args):
        """
        SetFather(TDataStd_TreeNode self, Handle_TDataStd_TreeNode F)

        :type F: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode

        """
        return _TDataStd.TDataStd_TreeNode_SetFather(self, *args)


    def SetNext(self, *args):
        """
        SetNext(TDataStd_TreeNode self, Handle_TDataStd_TreeNode F)

        :type F: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode

        """
        return _TDataStd.TDataStd_TreeNode_SetNext(self, *args)


    def SetPrevious(self, *args):
        """
        SetPrevious(TDataStd_TreeNode self, Handle_TDataStd_TreeNode F)

        :type F: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode

        """
        return _TDataStd.TDataStd_TreeNode_SetPrevious(self, *args)


    def SetFirst(self, *args):
        """
        SetFirst(TDataStd_TreeNode self, Handle_TDataStd_TreeNode F)

        :type F: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode

        """
        return _TDataStd.TDataStd_TreeNode_SetFirst(self, *args)


    def SetLast(self, *args):
        """
        SetLast(TDataStd_TreeNode self, Handle_TDataStd_TreeNode F)

        TreeNode callback:
        ==================

        :type F: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode

        """
        return _TDataStd.TDataStd_TreeNode_SetLast(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(TDataStd_TreeNode self)

        Connect the TreeNode to its father child list


        """
        return _TDataStd.TDataStd_TreeNode_AfterAddition(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(TDataStd_TreeNode self)

        Disconnect the TreeNode from its Father child list


        """
        return _TDataStd.TDataStd_TreeNode_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(TDataStd_TreeNode self)

        Reconnect the TreeNode to its father child list.


        """
        return _TDataStd.TDataStd_TreeNode_AfterResume(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(TDataStd_TreeNode self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Disconnect the TreeNode, if necessary.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_TreeNode_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(TDataStd_TreeNode self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Reconnect the TreeNode, if necessary.
        Implementation of Attribute methods:
        ===================================

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_TreeNode_AfterUndo(self, *args)


    def ID(self, *args):
        """
        Returns the tree ID (default or explicit one depending
        onthe Set method used).

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.TDataStd_TreeNode_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TDataStd_TreeNode self, Handle_TDF_Attribute arg2)

        :type with: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_TreeNode_Restore(self, *args)


    def Paste(self, *args):
        """
        Paste(TDataStd_TreeNode self, Handle_TDF_Attribute into, Handle_TDF_RelocationTable RT)

        :type into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.TDataStd_TreeNode_Paste(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TDataStd_TreeNode self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_TreeNode_NewEmpty(self, *args)


    def References(self, *args):
        """
        References(TDataStd_TreeNode self, Handle_TDF_DataSet aDataSet)

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDataStd.TDataStd_TreeNode_References(self, *args)


    def Dump(self, *args):
        """
        Dump(TDataStd_TreeNode self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.TDataStd_TreeNode_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_TreeNode_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_TreeNode_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_TreeNode_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDataStd.delete_TDataStd_TreeNode
TDataStd_TreeNode_swigregister = _TDataStd.TDataStd_TreeNode_swigregister
TDataStd_TreeNode_swigregister(TDataStd_TreeNode)

def TDataStd_TreeNode_Find(*args):
    """
    TDataStd_TreeNode_Find(TDF_Label L, Handle_TDataStd_TreeNode T) -> Standard_Boolean

    class  methods working on the node
    ===================================
    Returns true if the tree node T is found on the label L.
    Otherwise, false is returned.

    :type L: OCC.wrapper.TDF.TDF_Label
    :type T: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TDataStd.TDataStd_TreeNode_Find(*args)

def TDataStd_TreeNode_Set(*args):
    """
    Set(TDF_Label L) -> Handle_TDataStd_TreeNode
    TDataStd_TreeNode_Set(TDF_Label L, Standard_GUID ExplicitTreeID) -> Handle_TDataStd_TreeNode

    Finds  or Creates a   TreeNode attribute on  the label
    <L>, with an   explicit tree ID.  <ExplicitTreeID>  is
    the  ID   returned by    <TDF_Attribute::ID>   method.
    Returns the found/created TreeNode attribute.

    :type L: OCC.wrapper.TDF.TDF_Label
    :type ExplicitTreeID: OCC.wrapper.Standard.Standard_GUID
    :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode

    """
    return _TDataStd.TDataStd_TreeNode_Set(*args)

def TDataStd_TreeNode_GetDefaultTreeID(*args):
    """
    TDataStd_TreeNode_GetDefaultTreeID() -> Standard_GUID

    returns a default  tree ID.  this  ID is  used by the
    <Set> method without explicit tree ID.
    Instance methods:
    ================

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TDataStd.TDataStd_TreeNode_GetDefaultTreeID(*args)

def TDataStd_TreeNode_get_type_name(*args):
    """
    TDataStd_TreeNode_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_TreeNode_get_type_name(*args)

def TDataStd_TreeNode_get_type_descriptor(*args):
    """
    TDataStd_TreeNode_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_TreeNode_get_type_descriptor(*args)

class Handle_TDataStd_Variable(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_Variable self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_Variable_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_Variable self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_Variable_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_Variable self, TDataStd_Variable thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_Variable_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_Variable self, Handle_TDataStd_Variable theHandle) -> Handle_TDataStd_Variable
        assign(Handle_TDataStd_Variable self, TDataStd_Variable thePtr) -> Handle_TDataStd_Variable
        assign(Handle_TDataStd_Variable self, Handle_TDataStd_Variable theHandle) -> Handle_TDataStd_Variable

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_Variable_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_Variable self) -> TDataStd_Variable

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_Variable_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_Variable self) -> TDataStd_Variable

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_Variable___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_Variable self) -> TDataStd_Variable

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_Variable___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_Variable___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_Variable___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_Variable(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_Variable_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_Variable

    def GetID(self, *args):
        """
        class methods
        =============

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_Variable_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_TDataStd_Variable self, TDF_Label label) -> Handle_TDataStd_Variable
        Set(Handle_TDataStd_Variable self, Standard_Real const value)
        Set(Handle_TDataStd_Variable self, Standard_Real const value, TDataStd_RealEnum const dimension)

        Obsolete method that will be removed in next versions.
        The dimension argument is not supported in the persistence mechanism.

        :type value: float
        :type dimension: OCC.wrapper.TDataStd.TDataStd_RealEnum

        """
        return _TDataStd.Handle_TDataStd_Variable_Set(self, *args)


    def Name(self, *args):
        """
        returns    string   stored  in   the  associated  Name
        attribute.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _TDataStd.Handle_TDataStd_Variable_Name(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsValued(self, *args):
        """
        IsValued(Handle_TDataStd_Variable self) -> Standard_Boolean

        returns True if a Real attribute is associated.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Variable_IsValued(self, *args)


    def Get(self, *args):
        """
        Get(Handle_TDataStd_Variable self) -> Standard_Real

        returns value stored in associated Real attribute.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TDataStd.Handle_TDataStd_Variable_Get(self, *args)


    def Real(self, *args):
        """
        Real(Handle_TDataStd_Variable self) -> Handle_TDataStd_Real

        returns associated Real attribute.

        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_Real

        """
        return _TDataStd.Handle_TDataStd_Variable_Real(self, *args)


    def IsAssigned(self, *args):
        """
        IsAssigned(Handle_TDataStd_Variable self) -> Standard_Boolean

        returns True if an Expression attribute is associated.
        create(if doesn't exist), set and returns the assigned
        expression attribute.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Variable_IsAssigned(self, *args)


    def Assign(self, *args):
        """
        Assign(Handle_TDataStd_Variable self) -> Handle_TDataStd_Expression

        create(if  doesn't exist)  and  returns  the  assigned
        expression  attribute. fill it after.

        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_Expression

        """
        return _TDataStd.Handle_TDataStd_Variable_Assign(self, *args)


    def Desassign(self, *args):
        """
        Desassign(Handle_TDataStd_Variable self)

        if <me> is  assigned delete the associated  expression
        attribute.


        """
        return _TDataStd.Handle_TDataStd_Variable_Desassign(self, *args)


    def Expression(self, *args):
        """
        Expression(Handle_TDataStd_Variable self) -> Handle_TDataStd_Expression

        if <me>  is  assigned, returns  associated  Expression
        attribute.

        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_Expression

        """
        return _TDataStd.Handle_TDataStd_Variable_Expression(self, *args)


    def IsCaptured(self, *args):
        """
        IsCaptured(Handle_TDataStd_Variable self) -> Standard_Boolean

        shortcut for <Real()->IsCaptured()>

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Variable_IsCaptured(self, *args)


    def IsConstant(self, *args):
        """
        IsConstant(Handle_TDataStd_Variable self) -> Standard_Boolean

        A constant value is not modified by regeneration.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Variable_IsConstant(self, *args)


    def Unit(self, *args):
        """
        to read/write fields
        ===================

        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _TDataStd.Handle_TDataStd_Variable_Unit(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Constant(self, *args):
        """
        Constant(Handle_TDataStd_Variable self, Standard_Boolean const status)

        if  <status> is   True, this  variable  will not   be
        modified by the solver.

        :type status: bool

        """
        return _TDataStd.Handle_TDataStd_Variable_Constant(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_Variable_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TDataStd_Variable self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Variable_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TDataStd_Variable self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Variable_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TDataStd_Variable self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.Handle_TDataStd_Variable_Paste(self, *args)


    def References(self, *args):
        """
        References(Handle_TDataStd_Variable self, Handle_TDF_DataSet DS)

        to export reference to the associated Name attribute.

        :type DS: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDataStd.Handle_TDataStd_Variable_References(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDataStd_Variable self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_Variable_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_Variable self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_Variable_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_Variable_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_Variable_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetID(self, *args):
        """
        SetID(Handle_TDataStd_Variable self, Standard_GUID arg2)
        SetID(Handle_TDataStd_Variable self)

        Sets default ID defined in nested class (to be used for attributes having User ID feature).


        """
        return _TDataStd.Handle_TDataStd_Variable_SetID(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TDataStd_Variable self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_Variable_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDataStd_Variable self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Variable_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TDataStd_Variable self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Variable_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDataStd_Variable self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Variable_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TDataStd_Variable self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Variable_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TDataStd_Variable self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Variable_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TDataStd_Variable self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Variable_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TDataStd_Variable self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Variable_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDataStd_Variable self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Variable_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TDataStd_Variable self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Variable_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TDataStd_Variable self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDataStd.Handle_TDataStd_Variable_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TDataStd_Variable self)

        Something to do after adding an Attribute to a label.


        """
        return _TDataStd.Handle_TDataStd_Variable_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TDataStd_Variable self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_Variable_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TDataStd_Variable self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TDataStd.Handle_TDataStd_Variable_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TDataStd_Variable self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_Variable_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TDataStd_Variable self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Variable_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TDataStd_Variable self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Variable_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TDataStd_Variable self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Variable_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TDataStd_Variable self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDataStd.Handle_TDataStd_Variable_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TDataStd_Variable self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDataStd.Handle_TDataStd_Variable_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TDataStd_Variable self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Variable_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TDataStd_Variable self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Variable_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TDataStd_Variable self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDataStd.Handle_TDataStd_Variable_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TDataStd_Variable self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDataStd.Handle_TDataStd_Variable_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TDataStd_Variable self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDataStd.Handle_TDataStd_Variable_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TDataStd_Variable self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDataStd.Handle_TDataStd_Variable_DeltaOnRemoval(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDataStd_Variable self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_Variable___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TDataStd_Variable self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDataStd.Handle_TDataStd_Variable_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TDataStd_Variable self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDataStd.Handle_TDataStd_Variable_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_Variable self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_Variable_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_Variable self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_Variable self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Variable_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_Variable self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_Variable self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Variable_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_Variable self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_Variable_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_Variable self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Variable_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_Variable self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_Variable_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_Variable self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Variable_DecrementRefCounter(self, *args)

Handle_TDataStd_Variable_swigregister = _TDataStd.Handle_TDataStd_Variable_swigregister
Handle_TDataStd_Variable_swigregister(Handle_TDataStd_Variable)

def Handle_TDataStd_Variable_DownCast(thing):
    return _TDataStd.Handle_TDataStd_Variable_DownCast(thing)
Handle_TDataStd_Variable_DownCast = _TDataStd.Handle_TDataStd_Variable_DownCast

class Handle_TDataStd_DeltaOnModificationOfExtStringArray(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_DeltaOnModificationOfExtStringArray self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfExtStringArray_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_DeltaOnModificationOfExtStringArray self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfExtStringArray_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_DeltaOnModificationOfExtStringArray self, TDataStd_DeltaOnModificationOfExtStringArray thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfExtStringArray_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_DeltaOnModificationOfExtStringArray self, Handle_TDataStd_DeltaOnModificationOfExtStringArray theHandle) -> Handle_TDataStd_DeltaOnModificationOfExtStringArray
        assign(Handle_TDataStd_DeltaOnModificationOfExtStringArray self, TDataStd_DeltaOnModificationOfExtStringArray thePtr) -> Handle_TDataStd_DeltaOnModificationOfExtStringArray
        assign(Handle_TDataStd_DeltaOnModificationOfExtStringArray self, Handle_TDataStd_DeltaOnModificationOfExtStringArray theHandle) -> Handle_TDataStd_DeltaOnModificationOfExtStringArray

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfExtStringArray_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_DeltaOnModificationOfExtStringArray self) -> TDataStd_DeltaOnModificationOfExtStringArray

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfExtStringArray_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_DeltaOnModificationOfExtStringArray self) -> TDataStd_DeltaOnModificationOfExtStringArray

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfExtStringArray___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_DeltaOnModificationOfExtStringArray self) -> TDataStd_DeltaOnModificationOfExtStringArray

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfExtStringArray___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfExtStringArray___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_DeltaOnModificationOfExtStringArray___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_DeltaOnModificationOfExtStringArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_DeltaOnModificationOfExtStringArray_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_DeltaOnModificationOfExtStringArray

    def Apply(self, *args):
        """
        Apply(Handle_TDataStd_DeltaOnModificationOfExtStringArray self)

        Applies the delta to the attribute.


        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfExtStringArray_Apply(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_DeltaOnModificationOfExtStringArray self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfExtStringArray_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_DeltaOnModificationOfExtStringArray_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_DeltaOnModificationOfExtStringArray_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Label(self, *args):
        """
        Label(Handle_TDataStd_DeltaOnModificationOfExtStringArray self) -> TDF_Label

        Returns the label concerned by <me>.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfExtStringArray_Label(self, *args)


    def Attribute(self, *args):
        """
        Attribute(Handle_TDataStd_DeltaOnModificationOfExtStringArray self) -> Handle_TDF_Attribute

        Returns the reference attribute.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfExtStringArray_Attribute(self, *args)


    def ID(self, *args):
        """
        ID(Handle_TDataStd_DeltaOnModificationOfExtStringArray self) -> Standard_GUID

        Returns the ID of the attribute concerned by <me>.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfExtStringArray_ID(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDataStd_DeltaOnModificationOfExtStringArray self, Standard_OStream & OS) -> Standard_OStream &

        Dumps the contents.

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfExtStringArray_Dump(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDataStd_DeltaOnModificationOfExtStringArray self, Standard_OStream & OS) -> Standard_OStream &

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfExtStringArray___lshift__(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_DeltaOnModificationOfExtStringArray self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfExtStringArray_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_DeltaOnModificationOfExtStringArray self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_DeltaOnModificationOfExtStringArray self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfExtStringArray_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_DeltaOnModificationOfExtStringArray self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_DeltaOnModificationOfExtStringArray self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfExtStringArray_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_DeltaOnModificationOfExtStringArray self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfExtStringArray_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_DeltaOnModificationOfExtStringArray self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfExtStringArray_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_DeltaOnModificationOfExtStringArray self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfExtStringArray_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_DeltaOnModificationOfExtStringArray self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfExtStringArray_DecrementRefCounter(self, *args)

Handle_TDataStd_DeltaOnModificationOfExtStringArray_swigregister = _TDataStd.Handle_TDataStd_DeltaOnModificationOfExtStringArray_swigregister
Handle_TDataStd_DeltaOnModificationOfExtStringArray_swigregister(Handle_TDataStd_DeltaOnModificationOfExtStringArray)

def Handle_TDataStd_DeltaOnModificationOfExtStringArray_DownCast(thing):
    return _TDataStd.Handle_TDataStd_DeltaOnModificationOfExtStringArray_DownCast(thing)
Handle_TDataStd_DeltaOnModificationOfExtStringArray_DownCast = _TDataStd.Handle_TDataStd_DeltaOnModificationOfExtStringArray_DownCast

class Handle_TDataStd_RealArray(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_RealArray self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_RealArray_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_RealArray self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_RealArray_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_RealArray self, TDataStd_RealArray thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_RealArray_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_RealArray self, Handle_TDataStd_RealArray theHandle) -> Handle_TDataStd_RealArray
        assign(Handle_TDataStd_RealArray self, TDataStd_RealArray thePtr) -> Handle_TDataStd_RealArray
        assign(Handle_TDataStd_RealArray self, Handle_TDataStd_RealArray theHandle) -> Handle_TDataStd_RealArray

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_RealArray_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_RealArray self) -> TDataStd_RealArray

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_RealArray_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_RealArray self) -> TDataStd_RealArray

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_RealArray___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_RealArray self) -> TDataStd_RealArray

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_RealArray___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_RealArray___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_RealArray___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_RealArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_RealArray_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_RealArray

    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_RealArray self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_RealArray_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_RealArray_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_RealArray_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetID(self, *args):
        """
        class methods
        =============
        Returns the GUID for arrays of reals.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_RealArray_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_TDataStd_RealArray self, TDF_Label label, Standard_Integer const lower, Standard_Integer const upper, Standard_Boolean const isDelta) -> Handle_TDataStd_RealArray
        Set(Handle_TDataStd_RealArray self, TDF_Label label, Standard_GUID theGuid, Standard_Integer const lower, Standard_Integer const upper, Standard_Boolean const isDelta) -> Handle_TDataStd_RealArray

        Finds, or creates, an RealArray attribute with explicit user defined <guid>.
        The RealArray attribute  is  returned.

        :type label: OCC.wrapper.TDF.TDF_Label
        :type theGuid: OCC.wrapper.Standard.Standard_GUID
        :type lower: int
        :type upper: int
        :type isDelta: bool
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_RealArray

        """
        return _TDataStd.Handle_TDataStd_RealArray_Set(self, *args)


    def Init(self, *args):
        """
        Init(Handle_TDataStd_RealArray self, Standard_Integer const lower, Standard_Integer const upper)

        Initialize the inner array with bounds from <lower> to <upper>

        :type lower: int
        :type upper: int

        """
        return _TDataStd.Handle_TDataStd_RealArray_Init(self, *args)


    def SetID(self, *args):
        """
        SetID(Handle_TDataStd_RealArray self, Standard_GUID theGuid)
        SetID(Handle_TDataStd_RealArray self)

        Sets default GUID for the attribute.


        """
        return _TDataStd.Handle_TDataStd_RealArray_SetID(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_TDataStd_RealArray self, Standard_Integer const Index, Standard_Real const Value)

        Sets  the   <Index>th  element  of   the  array to <Value>
        OutOfRange exception is raised if <Index> doesn't respect Lower and Upper bounds of the internal  array.

        :type Index: int
        :type Value: float

        """
        return _TDataStd.Handle_TDataStd_RealArray_SetValue(self, *args)


    def Value(self, *args):
        """
        Value(Handle_TDataStd_RealArray self, Standard_Integer const Index) -> Standard_Real

        Return the value of  the  <Index>th element of the array

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TDataStd.Handle_TDataStd_RealArray_Value(self, *args)


    def __call__(self, *args):
        """
        __call__(Handle_TDataStd_RealArray self, Standard_Integer const Index) -> Standard_Real

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TDataStd.Handle_TDataStd_RealArray___call__(self, *args)


    def Lower(self, *args):
        """
        Lower(Handle_TDataStd_RealArray self) -> Standard_Integer

        Returns the lower boundary of the array.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_RealArray_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(Handle_TDataStd_RealArray self) -> Standard_Integer

        Returns the upper boundary of the array.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_RealArray_Upper(self, *args)


    def Length(self, *args):
        """
        Length(Handle_TDataStd_RealArray self) -> Standard_Integer

        Returns the number of elements of the array of reals
        in terms of the number of elements it contains.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_RealArray_Length(self, *args)


    def ChangeArray(self, *args):
        """
        ChangeArray(Handle_TDataStd_RealArray self, Handle_TColStd_HArray1OfReal newArray, Standard_Boolean const isCheckItems)

        Sets the inner array <myValue> of the RealArray attribute
        to <newArray>. If value of <newArray> differs from <myValue>,
        Backup performed and myValue refers to new instance of HArray1OfReal
        that holds <newArray> values
        If <isCheckItems> equal True each item of <newArray> will be checked with each
        item of <myValue> for coincidence (to avoid backup).

        :type newArray: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal
        :type isCheckItems: bool

        """
        return _TDataStd.Handle_TDataStd_RealArray_ChangeArray(self, *args)


    def Array(self, *args):
        """
        Returns the handle of this array of reals.

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        res = _TDataStd.Handle_TDataStd_RealArray_Array(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetDelta(self, *args):
        """
        GetDelta(Handle_TDataStd_RealArray self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_RealArray_GetDelta(self, *args)


    def SetDelta(self, *args):
        """
        SetDelta(Handle_TDataStd_RealArray self, Standard_Boolean const isDelta)

        for  internal  use  only!

        :type isDelta: bool

        """
        return _TDataStd.Handle_TDataStd_RealArray_SetDelta(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_RealArray_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TDataStd_RealArray self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_RealArray_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TDataStd_RealArray self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_RealArray_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TDataStd_RealArray self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        Note. Uses inside ChangeArray() method

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.Handle_TDataStd_RealArray_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDataStd_RealArray self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_RealArray_Dump(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TDataStd_RealArray self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_RealArray_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDataStd_RealArray self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_RealArray_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TDataStd_RealArray self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_RealArray_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDataStd_RealArray self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_RealArray_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TDataStd_RealArray self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_RealArray_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TDataStd_RealArray self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_RealArray_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TDataStd_RealArray self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_RealArray_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TDataStd_RealArray self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_RealArray_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDataStd_RealArray self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_RealArray_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TDataStd_RealArray self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_RealArray_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TDataStd_RealArray self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDataStd.Handle_TDataStd_RealArray_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TDataStd_RealArray self)

        Something to do after adding an Attribute to a label.


        """
        return _TDataStd.Handle_TDataStd_RealArray_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TDataStd_RealArray self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_RealArray_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TDataStd_RealArray self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TDataStd.Handle_TDataStd_RealArray_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TDataStd_RealArray self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_RealArray_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TDataStd_RealArray self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_RealArray_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TDataStd_RealArray self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_RealArray_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TDataStd_RealArray self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_RealArray_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TDataStd_RealArray self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDataStd.Handle_TDataStd_RealArray_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TDataStd_RealArray self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDataStd.Handle_TDataStd_RealArray_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TDataStd_RealArray self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_RealArray_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TDataStd_RealArray self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_RealArray_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TDataStd_RealArray self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDataStd.Handle_TDataStd_RealArray_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TDataStd_RealArray self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDataStd.Handle_TDataStd_RealArray_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TDataStd_RealArray self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDataStd.Handle_TDataStd_RealArray_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TDataStd_RealArray self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDataStd.Handle_TDataStd_RealArray_DeltaOnRemoval(self, *args)


    def References(self, *args):
        """
        References(Handle_TDataStd_RealArray self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDataStd.Handle_TDataStd_RealArray_References(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDataStd_RealArray self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_RealArray___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TDataStd_RealArray self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDataStd.Handle_TDataStd_RealArray_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TDataStd_RealArray self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDataStd.Handle_TDataStd_RealArray_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_RealArray self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_RealArray_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_RealArray self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_RealArray self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_RealArray_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_RealArray self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_RealArray self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_RealArray_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_RealArray self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_RealArray_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_RealArray self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_RealArray_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_RealArray self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_RealArray_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_RealArray self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_RealArray_DecrementRefCounter(self, *args)

Handle_TDataStd_RealArray_swigregister = _TDataStd.Handle_TDataStd_RealArray_swigregister
Handle_TDataStd_RealArray_swigregister(Handle_TDataStd_RealArray)

def Handle_TDataStd_RealArray_DownCast(thing):
    return _TDataStd.Handle_TDataStd_RealArray_DownCast(thing)
Handle_TDataStd_RealArray_DownCast = _TDataStd.Handle_TDataStd_RealArray_DownCast

class Handle_TDataStd_RealList(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_RealList self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_RealList_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_RealList self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_RealList_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_RealList self, TDataStd_RealList thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_RealList_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_RealList self, Handle_TDataStd_RealList theHandle) -> Handle_TDataStd_RealList
        assign(Handle_TDataStd_RealList self, TDataStd_RealList thePtr) -> Handle_TDataStd_RealList
        assign(Handle_TDataStd_RealList self, Handle_TDataStd_RealList theHandle) -> Handle_TDataStd_RealList

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_RealList_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_RealList self) -> TDataStd_RealList

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_RealList_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_RealList self) -> TDataStd_RealList

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_RealList___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_RealList self) -> TDataStd_RealList

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_RealList___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_RealList___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_RealList___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_RealList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_RealList_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_RealList

    def GetID(self, *args):
        """
        Static methods
        ==============
        Returns the ID of the list of doubles attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_RealList_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_TDataStd_RealList self, TDF_Label label) -> Handle_TDataStd_RealList
        Set(Handle_TDataStd_RealList self, TDF_Label label, Standard_GUID theGuid) -> Handle_TDataStd_RealList

        Finds or creates a list of double values attribute with explicit user defined <guid>.

        :type label: OCC.wrapper.TDF.TDF_Label
        :type theGuid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_RealList

        """
        return _TDataStd.Handle_TDataStd_RealList_Set(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_TDataStd_RealList self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_RealList_IsEmpty(self, *args)


    def Extent(self, *args):
        """
        Extent(Handle_TDataStd_RealList self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_RealList_Extent(self, *args)


    def Prepend(self, *args):
        """
        Prepend(Handle_TDataStd_RealList self, Standard_Real const value)

        :type value: float

        """
        return _TDataStd.Handle_TDataStd_RealList_Prepend(self, *args)


    def Append(self, *args):
        """
        Append(Handle_TDataStd_RealList self, Standard_Real const value)

        :type value: float

        """
        return _TDataStd.Handle_TDataStd_RealList_Append(self, *args)


    def SetID(self, *args):
        """
        SetID(Handle_TDataStd_RealList self, Standard_GUID theGuid)
        SetID(Handle_TDataStd_RealList self)

        Sets default GUID for the attribute.


        """
        return _TDataStd.Handle_TDataStd_RealList_SetID(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(Handle_TDataStd_RealList self, Standard_Real const value, Standard_Real const before_value) -> Standard_Boolean

        Inserts the <value> before the first meet of <before_value>.

        :type value: float
        :type before_value: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_RealList_InsertBefore(self, *args)


    def InsertBeforeByIndex(self, *args):
        """
        InsertBeforeByIndex(Handle_TDataStd_RealList self, Standard_Integer const index, Standard_Real const before_value) -> Standard_Boolean

        Inserts the <value> before the <index> position.
        The indices start with 1 .. Extent().

        :type index: int
        :type before_value: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_RealList_InsertBeforeByIndex(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(Handle_TDataStd_RealList self, Standard_Real const value, Standard_Real const after_value) -> Standard_Boolean

        Inserts the <value> after the first meet of <after_value>.

        :type value: float
        :type after_value: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_RealList_InsertAfter(self, *args)


    def InsertAfterByIndex(self, *args):
        """
        InsertAfterByIndex(Handle_TDataStd_RealList self, Standard_Integer const index, Standard_Real const after_value) -> Standard_Boolean

        Inserts the <value> after the <index> position.
        The indices start with 1 .. Extent().

        :type index: int
        :type after_value: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_RealList_InsertAfterByIndex(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_TDataStd_RealList self, Standard_Real const value) -> Standard_Boolean

        Removes the first meet of the <value>.

        :type value: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_RealList_Remove(self, *args)


    def RemoveByIndex(self, *args):
        """
        RemoveByIndex(Handle_TDataStd_RealList self, Standard_Integer const index) -> Standard_Boolean

        Removes a value at <index> position.

        :type index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_RealList_RemoveByIndex(self, *args)


    def Clear(self, *args):
        """Clear(Handle_TDataStd_RealList self)"""
        return _TDataStd.Handle_TDataStd_RealList_Clear(self, *args)


    def First(self, *args):
        """
        First(Handle_TDataStd_RealList self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TDataStd.Handle_TDataStd_RealList_First(self, *args)


    def Last(self, *args):
        """
        Last(Handle_TDataStd_RealList self) -> Standard_Real

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TDataStd.Handle_TDataStd_RealList_Last(self, *args)


    def List(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_ListOfReal

        """
        res = _TDataStd.Handle_TDataStd_RealList_List(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_RealList_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TDataStd_RealList self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_RealList_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TDataStd_RealList self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_RealList_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TDataStd_RealList self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.Handle_TDataStd_RealList_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDataStd_RealList self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_RealList_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_RealList self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_RealList_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_RealList_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_RealList_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Label(self, *args):
        """
        Label(Handle_TDataStd_RealList self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_RealList_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDataStd_RealList self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_RealList_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TDataStd_RealList self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_RealList_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDataStd_RealList self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_RealList_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TDataStd_RealList self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_RealList_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TDataStd_RealList self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_RealList_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TDataStd_RealList self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_RealList_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TDataStd_RealList self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_RealList_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDataStd_RealList self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_RealList_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TDataStd_RealList self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_RealList_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TDataStd_RealList self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDataStd.Handle_TDataStd_RealList_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TDataStd_RealList self)

        Something to do after adding an Attribute to a label.


        """
        return _TDataStd.Handle_TDataStd_RealList_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TDataStd_RealList self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_RealList_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TDataStd_RealList self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TDataStd.Handle_TDataStd_RealList_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TDataStd_RealList self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_RealList_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TDataStd_RealList self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_RealList_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TDataStd_RealList self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_RealList_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TDataStd_RealList self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_RealList_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TDataStd_RealList self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDataStd.Handle_TDataStd_RealList_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TDataStd_RealList self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDataStd.Handle_TDataStd_RealList_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TDataStd_RealList self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_RealList_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TDataStd_RealList self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_RealList_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TDataStd_RealList self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDataStd.Handle_TDataStd_RealList_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TDataStd_RealList self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDataStd.Handle_TDataStd_RealList_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TDataStd_RealList self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDataStd.Handle_TDataStd_RealList_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TDataStd_RealList self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDataStd.Handle_TDataStd_RealList_DeltaOnRemoval(self, *args)


    def References(self, *args):
        """
        References(Handle_TDataStd_RealList self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDataStd.Handle_TDataStd_RealList_References(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDataStd_RealList self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_RealList___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TDataStd_RealList self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDataStd.Handle_TDataStd_RealList_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TDataStd_RealList self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDataStd.Handle_TDataStd_RealList_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_RealList self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_RealList_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_RealList self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_RealList self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_RealList_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_RealList self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_RealList self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_RealList_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_RealList self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_RealList_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_RealList self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_RealList_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_RealList self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_RealList_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_RealList self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_RealList_DecrementRefCounter(self, *args)

Handle_TDataStd_RealList_swigregister = _TDataStd.Handle_TDataStd_RealList_swigregister
Handle_TDataStd_RealList_swigregister(Handle_TDataStd_RealList)

def Handle_TDataStd_RealList_DownCast(thing):
    return _TDataStd.Handle_TDataStd_RealList_DownCast(thing)
Handle_TDataStd_RealList_DownCast = _TDataStd.Handle_TDataStd_RealList_DownCast

class Handle_TDataStd_AsciiString(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_AsciiString self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_AsciiString_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_AsciiString self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_AsciiString_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_AsciiString self, TDataStd_AsciiString thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_AsciiString_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_AsciiString self, Handle_TDataStd_AsciiString theHandle) -> Handle_TDataStd_AsciiString
        assign(Handle_TDataStd_AsciiString self, TDataStd_AsciiString thePtr) -> Handle_TDataStd_AsciiString
        assign(Handle_TDataStd_AsciiString self, Handle_TDataStd_AsciiString theHandle) -> Handle_TDataStd_AsciiString

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_AsciiString_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_AsciiString self) -> TDataStd_AsciiString

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_AsciiString_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_AsciiString self) -> TDataStd_AsciiString

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_AsciiString___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_AsciiString self) -> TDataStd_AsciiString

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_AsciiString___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_AsciiString___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_AsciiString___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_AsciiString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_AsciiString_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_AsciiString

    def GetID(self, *args):
        """
        class methods
        =============
        Returns the GUID of the attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_AsciiString_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_TDataStd_AsciiString self, TDF_Label label, TCollection_AsciiString string) -> Handle_TDataStd_AsciiString
        Set(Handle_TDataStd_AsciiString self, TDF_Label label, Standard_GUID guid, TCollection_AsciiString string) -> Handle_TDataStd_AsciiString
        Set(Handle_TDataStd_AsciiString self, TCollection_AsciiString S)

        :type S: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        return _TDataStd.Handle_TDataStd_AsciiString_Set(self, *args)


    def SetID(self, *args):
        """
        SetID(Handle_TDataStd_AsciiString self, Standard_GUID guid)
        SetID(Handle_TDataStd_AsciiString self)

        Sets default GUID for the attribute.


        """
        return _TDataStd.Handle_TDataStd_AsciiString_SetID(self, *args)


    def Get(self, *args):
        """
        :rtype: OCC.wrapper.TCollection.TCollection_AsciiString

        """
        res = _TDataStd.Handle_TDataStd_AsciiString_Get(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_TDataStd_AsciiString self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_AsciiString_IsEmpty(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_AsciiString_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TDataStd_AsciiString self, Handle_TDF_Attribute arg2)

        :type with: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_AsciiString_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TDataStd_AsciiString self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_AsciiString_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TDataStd_AsciiString self, Handle_TDF_Attribute into, Handle_TDF_RelocationTable RT)

        :type into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.Handle_TDataStd_AsciiString_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDataStd_AsciiString self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_AsciiString_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_AsciiString self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_AsciiString_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_AsciiString_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_AsciiString_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Label(self, *args):
        """
        Label(Handle_TDataStd_AsciiString self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_AsciiString_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDataStd_AsciiString self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_AsciiString_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TDataStd_AsciiString self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_AsciiString_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDataStd_AsciiString self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_AsciiString_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TDataStd_AsciiString self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_AsciiString_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TDataStd_AsciiString self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_AsciiString_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TDataStd_AsciiString self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_AsciiString_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TDataStd_AsciiString self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_AsciiString_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDataStd_AsciiString self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_AsciiString_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TDataStd_AsciiString self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_AsciiString_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TDataStd_AsciiString self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDataStd.Handle_TDataStd_AsciiString_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TDataStd_AsciiString self)

        Something to do after adding an Attribute to a label.


        """
        return _TDataStd.Handle_TDataStd_AsciiString_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TDataStd_AsciiString self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_AsciiString_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TDataStd_AsciiString self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TDataStd.Handle_TDataStd_AsciiString_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TDataStd_AsciiString self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_AsciiString_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TDataStd_AsciiString self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_AsciiString_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TDataStd_AsciiString self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_AsciiString_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TDataStd_AsciiString self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_AsciiString_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TDataStd_AsciiString self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDataStd.Handle_TDataStd_AsciiString_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TDataStd_AsciiString self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDataStd.Handle_TDataStd_AsciiString_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TDataStd_AsciiString self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_AsciiString_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TDataStd_AsciiString self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_AsciiString_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TDataStd_AsciiString self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDataStd.Handle_TDataStd_AsciiString_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TDataStd_AsciiString self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDataStd.Handle_TDataStd_AsciiString_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TDataStd_AsciiString self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDataStd.Handle_TDataStd_AsciiString_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TDataStd_AsciiString self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDataStd.Handle_TDataStd_AsciiString_DeltaOnRemoval(self, *args)


    def References(self, *args):
        """
        References(Handle_TDataStd_AsciiString self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDataStd.Handle_TDataStd_AsciiString_References(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDataStd_AsciiString self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_AsciiString___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TDataStd_AsciiString self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDataStd.Handle_TDataStd_AsciiString_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TDataStd_AsciiString self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDataStd.Handle_TDataStd_AsciiString_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_AsciiString self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_AsciiString_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_AsciiString self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_AsciiString self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_AsciiString_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_AsciiString self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_AsciiString self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_AsciiString_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_AsciiString self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_AsciiString_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_AsciiString self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_AsciiString_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_AsciiString self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_AsciiString_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_AsciiString self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_AsciiString_DecrementRefCounter(self, *args)

Handle_TDataStd_AsciiString_swigregister = _TDataStd.Handle_TDataStd_AsciiString_swigregister
Handle_TDataStd_AsciiString_swigregister(Handle_TDataStd_AsciiString)

def Handle_TDataStd_AsciiString_DownCast(thing):
    return _TDataStd.Handle_TDataStd_AsciiString_DownCast(thing)
Handle_TDataStd_AsciiString_DownCast = _TDataStd.Handle_TDataStd_AsciiString_DownCast

class TDataStd_ByteArray(TDF.TDF_Attribute):
    """An array of Byte (unsigned char) values."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_ByteArray
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_ByteArray(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_ByteArray_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_ByteArray_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_ByteArray_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetID(*args):
        """
        GetID() -> Standard_GUID

        Static methods
        ==============
        Returns an ID for array.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.TDataStd_ByteArray_GetID(*args)

    GetID = staticmethod(GetID)

    def Set(*args):
        """
        Set(TDF_Label label, Standard_Integer const lower, Standard_Integer const upper, Standard_Boolean const isDelta) -> Handle_TDataStd_ByteArray
        Set(TDF_Label label, Standard_GUID theGuid, Standard_Integer const lower, Standard_Integer const upper, Standard_Boolean const isDelta) -> Handle_TDataStd_ByteArray

        Finds or creates an attribute with byte array and explicit user defined <guid> on the specified label.

        :type label: OCC.wrapper.TDF.TDF_Label
        :type theGuid: OCC.wrapper.Standard.Standard_GUID
        :type lower: int
        :type upper: int
        :type isDelta: bool
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_ByteArray

        """
        return _TDataStd.TDataStd_ByteArray_Set(*args)

    Set = staticmethod(Set)

    def Init(self, *args):
        """
        Init(TDataStd_ByteArray self, Standard_Integer const lower, Standard_Integer const upper)

        Initialize the inner array with bounds from <lower> to <upper>

        :type lower: int
        :type upper: int

        """
        return _TDataStd.TDataStd_ByteArray_Init(self, *args)


    def SetValue(self, *args):
        """
        SetValue(TDataStd_ByteArray self, Standard_Integer const index, Standard_Byte const value)

        Sets the <Index>th element of the array to <Value>
        OutOfRange exception is raised if <Index> doesn't respect Lower and Upper bounds of the internal  array.

        :type index: int
        :type value: int

        """
        return _TDataStd.TDataStd_ByteArray_SetValue(self, *args)


    def SetID(self, *args):
        """
        SetID(TDataStd_ByteArray self, Standard_GUID theGuid)
        SetID(TDataStd_ByteArray self)

        Sets default GUID for the attribute.


        """
        return _TDataStd.TDataStd_ByteArray_SetID(self, *args)


    def Value(self, *args):
        """
        Value(TDataStd_ByteArray self, Standard_Integer const Index) -> Standard_Byte

        Return the value of the <Index>th element of the array.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Byte

        """
        return _TDataStd.TDataStd_ByteArray_Value(self, *args)


    def __call__(self, *args):
        """
        __call__(TDataStd_ByteArray self, Standard_Integer const Index) -> Standard_Byte

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Byte

        """
        return _TDataStd.TDataStd_ByteArray___call__(self, *args)


    def Lower(self, *args):
        """
        Lower(TDataStd_ByteArray self) -> Standard_Integer

        Returns the lower boundary of the array.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.TDataStd_ByteArray_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(TDataStd_ByteArray self) -> Standard_Integer

        Returns the upper boundary of the array.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.TDataStd_ByteArray_Upper(self, *args)


    def Length(self, *args):
        """
        Length(TDataStd_ByteArray self) -> Standard_Integer

        Returns the number of elements in the array.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.TDataStd_ByteArray_Length(self, *args)


    def InternalArray(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfByte

        """
        res = _TDataStd.TDataStd_ByteArray_InternalArray(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray(self, *args):
        """
        ChangeArray(TDataStd_ByteArray self, Handle_TColStd_HArray1OfByte newArray, Standard_Boolean const isCheckItems)

        Sets the inner array <myValue>  of the attribute to
        <newArray>. If value of <newArray> differs from <myValue>, Backup performed
        and myValue refers to new instance of HArray1OfInteger that holds <newArray>
        values.
        If <isCheckItems> equal True each item of <newArray> will be checked with each
        item of <myValue> for coincidence (to avoid backup).

        :type newArray: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfByte
        :type isCheckItems: bool

        """
        return _TDataStd.TDataStd_ByteArray_ChangeArray(self, *args)


    def GetDelta(self, *args):
        """
        GetDelta(TDataStd_ByteArray self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_ByteArray_GetDelta(self, *args)


    def SetDelta(self, *args):
        """
        SetDelta(TDataStd_ByteArray self, Standard_Boolean const isDelta)

        for internal  use  only!

        :type isDelta: bool

        """
        return _TDataStd.TDataStd_ByteArray_SetDelta(self, *args)


    def __init__(self, *args):
        """
        __init__(TDataStd_ByteArray self) -> TDataStd_ByteArray

        An array of Byte (unsigned char) values.
        """
        this = _TDataStd.new_TDataStd_ByteArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.TDataStd_ByteArray_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TDataStd_ByteArray self, Handle_TDF_Attribute arg2)

        :type with: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_ByteArray_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TDataStd_ByteArray self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_ByteArray_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TDataStd_ByteArray self, Handle_TDF_Attribute into, Handle_TDF_RelocationTable RT)

        :type into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.TDataStd_ByteArray_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(TDataStd_ByteArray self, Standard_OStream & OS) -> Standard_OStream &

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.TDataStd_ByteArray_Dump(self, *args)

    __swig_destroy__ = _TDataStd.delete_TDataStd_ByteArray
TDataStd_ByteArray_swigregister = _TDataStd.TDataStd_ByteArray_swigregister
TDataStd_ByteArray_swigregister(TDataStd_ByteArray)

def TDataStd_ByteArray_get_type_name(*args):
    """
    TDataStd_ByteArray_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_ByteArray_get_type_name(*args)

def TDataStd_ByteArray_get_type_descriptor(*args):
    """
    TDataStd_ByteArray_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_ByteArray_get_type_descriptor(*args)

def TDataStd_ByteArray_GetID(*args):
    """
    TDataStd_ByteArray_GetID() -> Standard_GUID

    Static methods
    ==============
    Returns an ID for array.

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TDataStd.TDataStd_ByteArray_GetID(*args)

def TDataStd_ByteArray_Set(*args):
    """
    Set(TDF_Label label, Standard_Integer const lower, Standard_Integer const upper, Standard_Boolean const isDelta) -> Handle_TDataStd_ByteArray
    TDataStd_ByteArray_Set(TDF_Label label, Standard_GUID theGuid, Standard_Integer const lower, Standard_Integer const upper, Standard_Boolean const isDelta) -> Handle_TDataStd_ByteArray

    Finds or creates an attribute with byte array and explicit user defined <guid> on the specified label.

    :type label: OCC.wrapper.TDF.TDF_Label
    :type theGuid: OCC.wrapper.Standard.Standard_GUID
    :type lower: int
    :type upper: int
    :type isDelta: bool
    :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_ByteArray

    """
    return _TDataStd.TDataStd_ByteArray_Set(*args)

class TDataStd_HDataMapOfStringHArray1OfInteger(Standard.Standard_Transient):
    """
    Extension of TDataStd_DataMapOfStringHArray1OfInteger class
    to be manipulated by handle.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_HDataMapOfStringHArray1OfInteger
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_HDataMapOfStringHArray1OfInteger(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_HDataMapOfStringHArray1OfInteger_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_HDataMapOfStringHArray1OfInteger_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_HDataMapOfStringHArray1OfInteger_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(TDataStd_HDataMapOfStringHArray1OfInteger self, Standard_Integer const NbBuckets=1) -> TDataStd_HDataMapOfStringHArray1OfInteger
        __init__(TDataStd_HDataMapOfStringHArray1OfInteger self, NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString theOther) -> TDataStd_HDataMapOfStringHArray1OfInteger

        :type theOther: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringHArray1OfInteger

        """
        this = _TDataStd.new_TDataStd_HDataMapOfStringHArray1OfInteger(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Map(self, *args):
        """
        :rtype: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringHArray1OfInteger

        """
        res = _TDataStd.TDataStd_HDataMapOfStringHArray1OfInteger_Map(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeMap(self, *args):
        """
        ChangeMap(TDataStd_HDataMapOfStringHArray1OfInteger self) -> NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString

        :rtype: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringHArray1OfInteger

        """
        return _TDataStd.TDataStd_HDataMapOfStringHArray1OfInteger_ChangeMap(self, *args)

    __swig_destroy__ = _TDataStd.delete_TDataStd_HDataMapOfStringHArray1OfInteger
TDataStd_HDataMapOfStringHArray1OfInteger_swigregister = _TDataStd.TDataStd_HDataMapOfStringHArray1OfInteger_swigregister
TDataStd_HDataMapOfStringHArray1OfInteger_swigregister(TDataStd_HDataMapOfStringHArray1OfInteger)

def TDataStd_HDataMapOfStringHArray1OfInteger_get_type_name(*args):
    """
    TDataStd_HDataMapOfStringHArray1OfInteger_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_HDataMapOfStringHArray1OfInteger_get_type_name(*args)

def TDataStd_HDataMapOfStringHArray1OfInteger_get_type_descriptor(*args):
    """
    TDataStd_HDataMapOfStringHArray1OfInteger_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_HDataMapOfStringHArray1OfInteger_get_type_descriptor(*args)

class TDataStd_HDataMapOfStringString(Standard.Standard_Transient):
    """
    Extension of TDataStd_DataMapOfStringString class
    to be manipulated by handle.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_HDataMapOfStringString
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_HDataMapOfStringString(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_HDataMapOfStringString_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_HDataMapOfStringString_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_HDataMapOfStringString_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(TDataStd_HDataMapOfStringString self, Standard_Integer const NbBuckets=1) -> TDataStd_HDataMapOfStringString
        __init__(TDataStd_HDataMapOfStringString self, NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString theOther) -> TDataStd_HDataMapOfStringString

        :type theOther: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringString

        """
        this = _TDataStd.new_TDataStd_HDataMapOfStringString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Map(self, *args):
        """
        :rtype: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringString

        """
        res = _TDataStd.TDataStd_HDataMapOfStringString_Map(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeMap(self, *args):
        """
        ChangeMap(TDataStd_HDataMapOfStringString self) -> NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString

        :rtype: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringString

        """
        return _TDataStd.TDataStd_HDataMapOfStringString_ChangeMap(self, *args)

    __swig_destroy__ = _TDataStd.delete_TDataStd_HDataMapOfStringString
TDataStd_HDataMapOfStringString_swigregister = _TDataStd.TDataStd_HDataMapOfStringString_swigregister
TDataStd_HDataMapOfStringString_swigregister(TDataStd_HDataMapOfStringString)

def TDataStd_HDataMapOfStringString_get_type_name(*args):
    """
    TDataStd_HDataMapOfStringString_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_HDataMapOfStringString_get_type_name(*args)

def TDataStd_HDataMapOfStringString_get_type_descriptor(*args):
    """
    TDataStd_HDataMapOfStringString_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_HDataMapOfStringString_get_type_descriptor(*args)

class TDataStd_ReferenceArray(TDF.TDF_Attribute):
    """Contains an array of references to the labels."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_ReferenceArray
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_ReferenceArray(self) 
            return h


    def GetID(*args):
        """
        GetID() -> Standard_GUID

        Static methods
        ==============
        Returns the ID of the array of references (labels) attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.TDataStd_ReferenceArray_GetID(*args)

    GetID = staticmethod(GetID)

    def Set(*args):
        """
        Set(TDF_Label label, Standard_Integer const lower, Standard_Integer const upper) -> Handle_TDataStd_ReferenceArray
        Set(TDF_Label label, Standard_GUID theGuid, Standard_Integer const lower, Standard_Integer const upper) -> Handle_TDataStd_ReferenceArray

        Finds or creates an array of reference values (labels) attribute with explicit user defined <guid>.

        :type label: OCC.wrapper.TDF.TDF_Label
        :type theGuid: OCC.wrapper.Standard.Standard_GUID
        :type lower: int
        :type upper: int
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_ReferenceArray

        """
        return _TDataStd.TDataStd_ReferenceArray_Set(*args)

    Set = staticmethod(Set)

    def Init(self, *args):
        """
        Init(TDataStd_ReferenceArray self, Standard_Integer const lower, Standard_Integer const upper)

        Initialize the inner array with bounds from <lower> to <upper>

        :type lower: int
        :type upper: int

        """
        return _TDataStd.TDataStd_ReferenceArray_Init(self, *args)


    def SetValue(self, *args):
        """
        SetValue(TDataStd_ReferenceArray self, Standard_Integer const index, TDF_Label value)

        Sets the <Index>th element of the array to <Value>
        OutOfRange exception is raised if <Index> doesn't respect Lower and Upper bounds of the internal  array.

        :type index: int
        :type value: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.TDataStd_ReferenceArray_SetValue(self, *args)


    def SetID(self, *args):
        """
        SetID(TDataStd_ReferenceArray self, Standard_GUID theGuid)
        SetID(TDataStd_ReferenceArray self)

        Sets default GUID for the attribute.


        """
        return _TDataStd.TDataStd_ReferenceArray_SetID(self, *args)


    def Value(self, *args):
        """
        Value(TDataStd_ReferenceArray self, Standard_Integer const Index) -> TDF_Label

        Returns the value of the <Index>th element of the array.

        :type Index: int
        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.TDataStd_ReferenceArray_Value(self, *args)


    def __call__(self, *args):
        """
        __call__(TDataStd_ReferenceArray self, Standard_Integer const Index) -> TDF_Label

        :type Index: int
        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.TDataStd_ReferenceArray___call__(self, *args)


    def Lower(self, *args):
        """
        Lower(TDataStd_ReferenceArray self) -> Standard_Integer

        Returns the lower boundary of the array.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.TDataStd_ReferenceArray_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(TDataStd_ReferenceArray self) -> Standard_Integer

        Returns the upper boundary of the array.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.TDataStd_ReferenceArray_Upper(self, *args)


    def Length(self, *args):
        """
        Length(TDataStd_ReferenceArray self) -> Standard_Integer

        Returns the number of elements in the array.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.TDataStd_ReferenceArray_Length(self, *args)


    def InternalArray(self, *args):
        """
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_HLabelArray1

        """
        res = _TDataStd.TDataStd_ReferenceArray_InternalArray(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetInternalArray(self, *args):
        """
        SetInternalArray(TDataStd_ReferenceArray self, Handle_TDataStd_HLabelArray1 values, Standard_Boolean const isCheckItems)

        :type values: OCC.wrapper.TDataStd.Handle_TDataStd_HLabelArray1
        :type isCheckItems: bool

        """
        return _TDataStd.TDataStd_ReferenceArray_SetInternalArray(self, *args)


    def __init__(self, *args):
        """
        __init__(TDataStd_ReferenceArray self) -> TDataStd_ReferenceArray

        Contains an array of references to the labels.
        """
        this = _TDataStd.new_TDataStd_ReferenceArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.TDataStd_ReferenceArray_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TDataStd_ReferenceArray self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_ReferenceArray_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TDataStd_ReferenceArray self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_ReferenceArray_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TDataStd_ReferenceArray self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.TDataStd_ReferenceArray_Paste(self, *args)


    def References(self, *args):
        """
        References(TDataStd_ReferenceArray self, Handle_TDF_DataSet DS)

        :type DS: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDataStd.TDataStd_ReferenceArray_References(self, *args)


    def Dump(self, *args):
        """
        Dump(TDataStd_ReferenceArray self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.TDataStd_ReferenceArray_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_ReferenceArray_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_ReferenceArray_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_ReferenceArray_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDataStd.delete_TDataStd_ReferenceArray
TDataStd_ReferenceArray_swigregister = _TDataStd.TDataStd_ReferenceArray_swigregister
TDataStd_ReferenceArray_swigregister(TDataStd_ReferenceArray)

def TDataStd_ReferenceArray_GetID(*args):
    """
    TDataStd_ReferenceArray_GetID() -> Standard_GUID

    Static methods
    ==============
    Returns the ID of the array of references (labels) attribute.

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TDataStd.TDataStd_ReferenceArray_GetID(*args)

def TDataStd_ReferenceArray_Set(*args):
    """
    Set(TDF_Label label, Standard_Integer const lower, Standard_Integer const upper) -> Handle_TDataStd_ReferenceArray
    TDataStd_ReferenceArray_Set(TDF_Label label, Standard_GUID theGuid, Standard_Integer const lower, Standard_Integer const upper) -> Handle_TDataStd_ReferenceArray

    Finds or creates an array of reference values (labels) attribute with explicit user defined <guid>.

    :type label: OCC.wrapper.TDF.TDF_Label
    :type theGuid: OCC.wrapper.Standard.Standard_GUID
    :type lower: int
    :type upper: int
    :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_ReferenceArray

    """
    return _TDataStd.TDataStd_ReferenceArray_Set(*args)

def TDataStd_ReferenceArray_get_type_name(*args):
    """
    TDataStd_ReferenceArray_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_ReferenceArray_get_type_name(*args)

def TDataStd_ReferenceArray_get_type_descriptor(*args):
    """
    TDataStd_ReferenceArray_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_ReferenceArray_get_type_descriptor(*args)

class Handle_TDataStd_ReferenceList(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_ReferenceList self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_ReferenceList_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_ReferenceList self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_ReferenceList self, TDataStd_ReferenceList thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_ReferenceList self, Handle_TDataStd_ReferenceList theHandle) -> Handle_TDataStd_ReferenceList
        assign(Handle_TDataStd_ReferenceList self, TDataStd_ReferenceList thePtr) -> Handle_TDataStd_ReferenceList
        assign(Handle_TDataStd_ReferenceList self, Handle_TDataStd_ReferenceList theHandle) -> Handle_TDataStd_ReferenceList

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_ReferenceList self) -> TDataStd_ReferenceList

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_ReferenceList self) -> TDataStd_ReferenceList

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_ReferenceList___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_ReferenceList self) -> TDataStd_ReferenceList

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_ReferenceList___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_ReferenceList___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_ReferenceList___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_ReferenceList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_ReferenceList_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_ReferenceList

    def GetID(self, *args):
        """
        Static methods
        ==============
        Returns the ID of the list of references (labels) attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_ReferenceList_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_TDataStd_ReferenceList self, TDF_Label label) -> Handle_TDataStd_ReferenceList
        Set(Handle_TDataStd_ReferenceList self, TDF_Label label, Standard_GUID theGuid) -> Handle_TDataStd_ReferenceList

        Finds or creates a list of reference values (labels) attribute with explicit user defined <guid>.

        :type label: OCC.wrapper.TDF.TDF_Label
        :type theGuid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_ReferenceList

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_Set(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_TDataStd_ReferenceList self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_IsEmpty(self, *args)


    def Extent(self, *args):
        """
        Extent(Handle_TDataStd_ReferenceList self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_Extent(self, *args)


    def Prepend(self, *args):
        """
        Prepend(Handle_TDataStd_ReferenceList self, TDF_Label value)

        :type value: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_Prepend(self, *args)


    def Append(self, *args):
        """
        Append(Handle_TDataStd_ReferenceList self, TDF_Label value)

        :type value: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_Append(self, *args)


    def SetID(self, *args):
        """
        SetID(Handle_TDataStd_ReferenceList self, Standard_GUID theGuid)
        SetID(Handle_TDataStd_ReferenceList self)

        Sets default GUID for the attribute.


        """
        return _TDataStd.Handle_TDataStd_ReferenceList_SetID(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(Handle_TDataStd_ReferenceList self, TDF_Label value, TDF_Label before_value) -> Standard_Boolean
        InsertBefore(Handle_TDataStd_ReferenceList self, Standard_Integer const index, TDF_Label before_value) -> Standard_Boolean

        Inserts the label before the <index> position.
        The indices start with 1 .. Extent().

        :type index: int
        :type before_value: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(Handle_TDataStd_ReferenceList self, TDF_Label value, TDF_Label after_value) -> Standard_Boolean
        InsertAfter(Handle_TDataStd_ReferenceList self, Standard_Integer const index, TDF_Label after_value) -> Standard_Boolean

        Inserts the label after the <index> position.
        The indices start with 1 .. Extent().

        :type index: int
        :type after_value: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_InsertAfter(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_TDataStd_ReferenceList self, TDF_Label value) -> Standard_Boolean
        Remove(Handle_TDataStd_ReferenceList self, Standard_Integer const index) -> Standard_Boolean

        Removes a label at "index" position.

        :type index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_Remove(self, *args)


    def Clear(self, *args):
        """Clear(Handle_TDataStd_ReferenceList self)"""
        return _TDataStd.Handle_TDataStd_ReferenceList_Clear(self, *args)


    def First(self, *args):
        """
        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        res = _TDataStd.Handle_TDataStd_ReferenceList_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        res = _TDataStd.Handle_TDataStd_ReferenceList_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def List(self, *args):
        """
        :rtype: OCC.wrapper.TDF.TDF_LabelList

        """
        res = _TDataStd.Handle_TDataStd_ReferenceList_List(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_ReferenceList_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TDataStd_ReferenceList self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TDataStd_ReferenceList self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TDataStd_ReferenceList self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_Paste(self, *args)


    def References(self, *args):
        """
        References(Handle_TDataStd_ReferenceList self, Handle_TDF_DataSet DS)

        :type DS: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_References(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDataStd_ReferenceList self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_ReferenceList self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_ReferenceList_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_ReferenceList_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Label(self, *args):
        """
        Label(Handle_TDataStd_ReferenceList self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDataStd_ReferenceList self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TDataStd_ReferenceList self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDataStd_ReferenceList self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TDataStd_ReferenceList self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TDataStd_ReferenceList self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TDataStd_ReferenceList self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TDataStd_ReferenceList self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDataStd_ReferenceList self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TDataStd_ReferenceList self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TDataStd_ReferenceList self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TDataStd_ReferenceList self)

        Something to do after adding an Attribute to a label.


        """
        return _TDataStd.Handle_TDataStd_ReferenceList_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TDataStd_ReferenceList self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_ReferenceList_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TDataStd_ReferenceList self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TDataStd.Handle_TDataStd_ReferenceList_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TDataStd_ReferenceList self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_ReferenceList_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TDataStd_ReferenceList self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TDataStd_ReferenceList self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TDataStd_ReferenceList self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TDataStd_ReferenceList self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDataStd.Handle_TDataStd_ReferenceList_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TDataStd_ReferenceList self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDataStd.Handle_TDataStd_ReferenceList_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TDataStd_ReferenceList self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TDataStd_ReferenceList self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TDataStd_ReferenceList self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TDataStd_ReferenceList self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TDataStd_ReferenceList self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TDataStd_ReferenceList self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_DeltaOnRemoval(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDataStd_ReferenceList self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_ReferenceList___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TDataStd_ReferenceList self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TDataStd_ReferenceList self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_ReferenceList self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_ReferenceList_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_ReferenceList self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_ReferenceList self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_ReferenceList self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_ReferenceList self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_ReferenceList self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_ReferenceList self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_ReferenceList self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_ReferenceList_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_ReferenceList self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_ReferenceList_DecrementRefCounter(self, *args)

Handle_TDataStd_ReferenceList_swigregister = _TDataStd.Handle_TDataStd_ReferenceList_swigregister
Handle_TDataStd_ReferenceList_swigregister(Handle_TDataStd_ReferenceList)

def Handle_TDataStd_ReferenceList_DownCast(thing):
    return _TDataStd.Handle_TDataStd_ReferenceList_DownCast(thing)
Handle_TDataStd_ReferenceList_DownCast = _TDataStd.Handle_TDataStd_ReferenceList_DownCast

class Handle_TDataStd_NoteBook(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_NoteBook self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_NoteBook_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_NoteBook self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_NoteBook_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_NoteBook self, TDataStd_NoteBook thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_NoteBook_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_NoteBook self, Handle_TDataStd_NoteBook theHandle) -> Handle_TDataStd_NoteBook
        assign(Handle_TDataStd_NoteBook self, TDataStd_NoteBook thePtr) -> Handle_TDataStd_NoteBook
        assign(Handle_TDataStd_NoteBook self, Handle_TDataStd_NoteBook theHandle) -> Handle_TDataStd_NoteBook

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_NoteBook_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_NoteBook self) -> TDataStd_NoteBook

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_NoteBook_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_NoteBook self) -> TDataStd_NoteBook

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_NoteBook___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_NoteBook self) -> TDataStd_NoteBook

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_NoteBook___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_NoteBook___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_NoteBook___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_NoteBook(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_NoteBook_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_NoteBook

    def Find(self, *args):
        """
        Find(Handle_TDataStd_NoteBook self, TDF_Label current, Handle_TDataStd_NoteBook N) -> Standard_Boolean

        class methods
        =============
        try to retrieve a NoteBook attribute at <current> label
        or in  fathers  label of  <current>. Returns True  if
        found and set <N>.

        :type current: OCC.wrapper.TDF.TDF_Label
        :type N: OCC.wrapper.TDataStd.Handle_TDataStd_NoteBook
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NoteBook_Find(self, *args)


    def New(self, *args):
        """
        New(Handle_TDataStd_NoteBook self, TDF_Label label) -> Handle_TDataStd_NoteBook

        Create  an  enpty   NoteBook attribute,  located  at
        <label>. Raises if <label> has attribute

        :type label: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_NoteBook

        """
        return _TDataStd.Handle_TDataStd_NoteBook_New(self, *args)


    def GetID(self, *args):
        """
        NoteBook methods
        ===============

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_NoteBook_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Handle_TDataStd_NoteBook self, Standard_Real const value, Standard_Boolean const isExported) -> Handle_TDataStd_Real
        Append(Handle_TDataStd_NoteBook self, Standard_Integer const value, Standard_Boolean const isExported) -> Handle_TDataStd_Integer

        Tool to Create  an Real attribute from <value>, Insert
        it  in a new son label  of <me>. The Integer attribute
        is returned.

        :type value: int
        :type isExported: bool
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_Integer

        """
        return _TDataStd.Handle_TDataStd_NoteBook_Append(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_NoteBook_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TDataStd_NoteBook self, Handle_TDF_Attribute arg2)

        :type with: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_NoteBook_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TDataStd_NoteBook self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_NoteBook_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TDataStd_NoteBook self, Handle_TDF_Attribute into, Handle_TDF_RelocationTable RT)

        :type into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.Handle_TDataStd_NoteBook_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDataStd_NoteBook self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_NoteBook_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_NoteBook self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_NoteBook_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_NoteBook_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_NoteBook_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetID(self, *args):
        """
        SetID(Handle_TDataStd_NoteBook self, Standard_GUID arg2)
        SetID(Handle_TDataStd_NoteBook self)

        Sets default ID defined in nested class (to be used for attributes having User ID feature).


        """
        return _TDataStd.Handle_TDataStd_NoteBook_SetID(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TDataStd_NoteBook self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_NoteBook_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDataStd_NoteBook self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_NoteBook_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TDataStd_NoteBook self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_NoteBook_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDataStd_NoteBook self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NoteBook_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TDataStd_NoteBook self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NoteBook_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TDataStd_NoteBook self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NoteBook_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TDataStd_NoteBook self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NoteBook_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TDataStd_NoteBook self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NoteBook_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDataStd_NoteBook self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_NoteBook_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TDataStd_NoteBook self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NoteBook_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TDataStd_NoteBook self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDataStd.Handle_TDataStd_NoteBook_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TDataStd_NoteBook self)

        Something to do after adding an Attribute to a label.


        """
        return _TDataStd.Handle_TDataStd_NoteBook_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TDataStd_NoteBook self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_NoteBook_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TDataStd_NoteBook self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TDataStd.Handle_TDataStd_NoteBook_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TDataStd_NoteBook self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_NoteBook_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TDataStd_NoteBook self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NoteBook_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TDataStd_NoteBook self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NoteBook_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TDataStd_NoteBook self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NoteBook_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TDataStd_NoteBook self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDataStd.Handle_TDataStd_NoteBook_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TDataStd_NoteBook self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDataStd.Handle_TDataStd_NoteBook_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TDataStd_NoteBook self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NoteBook_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TDataStd_NoteBook self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_NoteBook_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TDataStd_NoteBook self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDataStd.Handle_TDataStd_NoteBook_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TDataStd_NoteBook self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDataStd.Handle_TDataStd_NoteBook_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TDataStd_NoteBook self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDataStd.Handle_TDataStd_NoteBook_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TDataStd_NoteBook self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDataStd.Handle_TDataStd_NoteBook_DeltaOnRemoval(self, *args)


    def References(self, *args):
        """
        References(Handle_TDataStd_NoteBook self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDataStd.Handle_TDataStd_NoteBook_References(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDataStd_NoteBook self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_NoteBook___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TDataStd_NoteBook self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDataStd.Handle_TDataStd_NoteBook_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TDataStd_NoteBook self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDataStd.Handle_TDataStd_NoteBook_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_NoteBook self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_NoteBook_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_NoteBook self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_NoteBook self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NoteBook_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_NoteBook self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_NoteBook self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NoteBook_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_NoteBook self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_NoteBook_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_NoteBook self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_NoteBook_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_NoteBook self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_NoteBook_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_NoteBook self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_NoteBook_DecrementRefCounter(self, *args)

Handle_TDataStd_NoteBook_swigregister = _TDataStd.Handle_TDataStd_NoteBook_swigregister
Handle_TDataStd_NoteBook_swigregister(Handle_TDataStd_NoteBook)

def Handle_TDataStd_NoteBook_DownCast(thing):
    return _TDataStd.Handle_TDataStd_NoteBook_DownCast(thing)
Handle_TDataStd_NoteBook_DownCast = _TDataStd.Handle_TDataStd_NoteBook_DownCast

class Handle_TDataStd_HDataMapOfStringHArray1OfInteger(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_HDataMapOfStringHArray1OfInteger self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfInteger_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_HDataMapOfStringHArray1OfInteger self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfInteger_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_HDataMapOfStringHArray1OfInteger self, TDataStd_HDataMapOfStringHArray1OfInteger thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfInteger_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_HDataMapOfStringHArray1OfInteger self, Handle_TDataStd_HDataMapOfStringHArray1OfInteger theHandle) -> Handle_TDataStd_HDataMapOfStringHArray1OfInteger
        assign(Handle_TDataStd_HDataMapOfStringHArray1OfInteger self, TDataStd_HDataMapOfStringHArray1OfInteger thePtr) -> Handle_TDataStd_HDataMapOfStringHArray1OfInteger
        assign(Handle_TDataStd_HDataMapOfStringHArray1OfInteger self, Handle_TDataStd_HDataMapOfStringHArray1OfInteger theHandle) -> Handle_TDataStd_HDataMapOfStringHArray1OfInteger

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfInteger_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_HDataMapOfStringHArray1OfInteger self) -> TDataStd_HDataMapOfStringHArray1OfInteger

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfInteger_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_HDataMapOfStringHArray1OfInteger self) -> TDataStd_HDataMapOfStringHArray1OfInteger

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfInteger___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_HDataMapOfStringHArray1OfInteger self) -> TDataStd_HDataMapOfStringHArray1OfInteger

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfInteger___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfInteger___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfInteger___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_HDataMapOfStringHArray1OfInteger(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfInteger_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_HDataMapOfStringHArray1OfInteger

    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_HDataMapOfStringHArray1OfInteger self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfInteger_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfInteger_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfInteger_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Map(self, *args):
        """
        :rtype: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringHArray1OfInteger

        """
        res = _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfInteger_Map(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeMap(self, *args):
        """
        ChangeMap(Handle_TDataStd_HDataMapOfStringHArray1OfInteger self) -> NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString

        :rtype: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringHArray1OfInteger

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfInteger_ChangeMap(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_HDataMapOfStringHArray1OfInteger self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfInteger_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_HDataMapOfStringHArray1OfInteger self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_HDataMapOfStringHArray1OfInteger self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfInteger_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_HDataMapOfStringHArray1OfInteger self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_HDataMapOfStringHArray1OfInteger self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfInteger_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_HDataMapOfStringHArray1OfInteger self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfInteger_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_HDataMapOfStringHArray1OfInteger self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfInteger_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_HDataMapOfStringHArray1OfInteger self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfInteger_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_HDataMapOfStringHArray1OfInteger self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfInteger_DecrementRefCounter(self, *args)

Handle_TDataStd_HDataMapOfStringHArray1OfInteger_swigregister = _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfInteger_swigregister
Handle_TDataStd_HDataMapOfStringHArray1OfInteger_swigregister(Handle_TDataStd_HDataMapOfStringHArray1OfInteger)

def Handle_TDataStd_HDataMapOfStringHArray1OfInteger_DownCast(thing):
    return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfInteger_DownCast(thing)
Handle_TDataStd_HDataMapOfStringHArray1OfInteger_DownCast = _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfInteger_DownCast

class Handle_TDataStd_Current(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_Current self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_Current_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_Current self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_Current_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_Current self, TDataStd_Current thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_Current_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_Current self, Handle_TDataStd_Current theHandle) -> Handle_TDataStd_Current
        assign(Handle_TDataStd_Current self, TDataStd_Current thePtr) -> Handle_TDataStd_Current
        assign(Handle_TDataStd_Current self, Handle_TDataStd_Current theHandle) -> Handle_TDataStd_Current

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_Current_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_Current self) -> TDataStd_Current

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_Current_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_Current self) -> TDataStd_Current

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_Current___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_Current self) -> TDataStd_Current

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_Current___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_Current___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_Current___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_Current(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_Current_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_Current

    def GetID(self, *args):
        """
        class methods
        =============

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_Current_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_TDataStd_Current self, TDF_Label L)

        Set <L> as current of <L> Framework.

        :type L: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_Current_Set(self, *args)


    def Get(self, *args):
        """
        Get(Handle_TDataStd_Current self, TDF_Label acces) -> TDF_Label

        returns current of <acces> Framework. raise if (!Has)

        :type acces: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_Current_Get(self, *args)


    def Has(self, *args):
        """
        Has(Handle_TDataStd_Current self, TDF_Label acces) -> Standard_Boolean

        returns True if a  current label is managed in <acces>
        Framework.
        class methods
        =============

        :type acces: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Current_Has(self, *args)


    def SetLabel(self, *args):
        """
        SetLabel(Handle_TDataStd_Current self, TDF_Label current)

        :type current: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_Current_SetLabel(self, *args)


    def GetLabel(self, *args):
        """
        GetLabel(Handle_TDataStd_Current self) -> TDF_Label

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_Current_GetLabel(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_Current_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TDataStd_Current self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Current_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TDataStd_Current self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Current_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TDataStd_Current self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.Handle_TDataStd_Current_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDataStd_Current self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_Current_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_Current self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_Current_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_Current_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_Current_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetID(self, *args):
        """
        SetID(Handle_TDataStd_Current self, Standard_GUID arg2)
        SetID(Handle_TDataStd_Current self)

        Sets default ID defined in nested class (to be used for attributes having User ID feature).


        """
        return _TDataStd.Handle_TDataStd_Current_SetID(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TDataStd_Current self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_Current_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDataStd_Current self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Current_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TDataStd_Current self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Current_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDataStd_Current self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Current_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TDataStd_Current self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Current_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TDataStd_Current self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Current_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TDataStd_Current self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Current_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TDataStd_Current self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Current_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDataStd_Current self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Current_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TDataStd_Current self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Current_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TDataStd_Current self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDataStd.Handle_TDataStd_Current_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TDataStd_Current self)

        Something to do after adding an Attribute to a label.


        """
        return _TDataStd.Handle_TDataStd_Current_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TDataStd_Current self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_Current_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TDataStd_Current self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TDataStd.Handle_TDataStd_Current_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TDataStd_Current self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_Current_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TDataStd_Current self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Current_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TDataStd_Current self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Current_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TDataStd_Current self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Current_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TDataStd_Current self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDataStd.Handle_TDataStd_Current_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TDataStd_Current self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDataStd.Handle_TDataStd_Current_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TDataStd_Current self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Current_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TDataStd_Current self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Current_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TDataStd_Current self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDataStd.Handle_TDataStd_Current_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TDataStd_Current self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDataStd.Handle_TDataStd_Current_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TDataStd_Current self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDataStd.Handle_TDataStd_Current_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TDataStd_Current self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDataStd.Handle_TDataStd_Current_DeltaOnRemoval(self, *args)


    def References(self, *args):
        """
        References(Handle_TDataStd_Current self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDataStd.Handle_TDataStd_Current_References(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDataStd_Current self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_Current___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TDataStd_Current self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDataStd.Handle_TDataStd_Current_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TDataStd_Current self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDataStd.Handle_TDataStd_Current_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_Current self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_Current_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_Current self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_Current self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Current_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_Current self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_Current self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Current_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_Current self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_Current_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_Current self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Current_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_Current self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_Current_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_Current self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Current_DecrementRefCounter(self, *args)

Handle_TDataStd_Current_swigregister = _TDataStd.Handle_TDataStd_Current_swigregister
Handle_TDataStd_Current_swigregister(Handle_TDataStd_Current)

def Handle_TDataStd_Current_DownCast(thing):
    return _TDataStd.Handle_TDataStd_Current_DownCast(thing)
Handle_TDataStd_Current_DownCast = _TDataStd.Handle_TDataStd_Current_DownCast

class Handle_TDataStd_Directory(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_Directory self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_Directory_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_Directory self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_Directory_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_Directory self, TDataStd_Directory thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_Directory_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_Directory self, Handle_TDataStd_Directory theHandle) -> Handle_TDataStd_Directory
        assign(Handle_TDataStd_Directory self, TDataStd_Directory thePtr) -> Handle_TDataStd_Directory
        assign(Handle_TDataStd_Directory self, Handle_TDataStd_Directory theHandle) -> Handle_TDataStd_Directory

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_Directory_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_Directory self) -> TDataStd_Directory

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_Directory_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_Directory self) -> TDataStd_Directory

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_Directory___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_Directory self) -> TDataStd_Directory

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_Directory___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_Directory___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_Directory___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_Directory(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_Directory_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_Directory

    def Find(self, *args):
        """
        Find(Handle_TDataStd_Directory self, TDF_Label current, Handle_TDataStd_Directory D) -> Standard_Boolean

        class methods
        =============
        Searches for a directory attribute on the label
        current, or on one of the father labels of current.
        If a directory attribute is found, true is returned,
        and the attribute found is set as D.

        :type current: OCC.wrapper.TDF.TDF_Label
        :type D: OCC.wrapper.TDataStd.Handle_TDataStd_Directory
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Directory_Find(self, *args)


    def New(self, *args):
        """
        New(Handle_TDataStd_Directory self, TDF_Label label) -> Handle_TDataStd_Directory

        Creates  an  enpty   Directory attribute,  located  at
        <label>. Raises if <label> has attribute

        :type label: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_Directory

        """
        return _TDataStd.Handle_TDataStd_Directory_New(self, *args)


    def AddDirectory(self, *args):
        """
        AddDirectory(Handle_TDataStd_Directory self, Handle_TDataStd_Directory dir) -> Handle_TDataStd_Directory

        Creates a new sub-label and sets the
        sub-directory dir on that label.

        :type dir: OCC.wrapper.TDataStd.Handle_TDataStd_Directory
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_Directory

        """
        return _TDataStd.Handle_TDataStd_Directory_AddDirectory(self, *args)


    def MakeObjectLabel(self, *args):
        """
        MakeObjectLabel(Handle_TDataStd_Directory self, Handle_TDataStd_Directory dir) -> TDF_Label

        Makes new label and returns it to insert
        other object attributes (sketch,part...etc...)

        :type dir: OCC.wrapper.TDataStd.Handle_TDataStd_Directory
        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_Directory_MakeObjectLabel(self, *args)


    def GetID(self, *args):
        """
        Directory methods
        ===============

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_Directory_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_Directory_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TDataStd_Directory self, Handle_TDF_Attribute arg2)

        :type with: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Directory_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TDataStd_Directory self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Directory_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TDataStd_Directory self, Handle_TDF_Attribute into, Handle_TDF_RelocationTable RT)

        :type into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.Handle_TDataStd_Directory_Paste(self, *args)


    def References(self, *args):
        """
        References(Handle_TDataStd_Directory self, Handle_TDF_DataSet DS)

        :type DS: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDataStd.Handle_TDataStd_Directory_References(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDataStd_Directory self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_Directory_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_Directory self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_Directory_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_Directory_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_Directory_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetID(self, *args):
        """
        SetID(Handle_TDataStd_Directory self, Standard_GUID arg2)
        SetID(Handle_TDataStd_Directory self)

        Sets default ID defined in nested class (to be used for attributes having User ID feature).


        """
        return _TDataStd.Handle_TDataStd_Directory_SetID(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TDataStd_Directory self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_Directory_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDataStd_Directory self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Directory_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TDataStd_Directory self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Directory_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDataStd_Directory self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Directory_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TDataStd_Directory self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Directory_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TDataStd_Directory self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Directory_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TDataStd_Directory self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Directory_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TDataStd_Directory self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Directory_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDataStd_Directory self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Directory_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TDataStd_Directory self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Directory_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TDataStd_Directory self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDataStd.Handle_TDataStd_Directory_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TDataStd_Directory self)

        Something to do after adding an Attribute to a label.


        """
        return _TDataStd.Handle_TDataStd_Directory_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TDataStd_Directory self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_Directory_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TDataStd_Directory self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TDataStd.Handle_TDataStd_Directory_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TDataStd_Directory self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_Directory_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TDataStd_Directory self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Directory_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TDataStd_Directory self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Directory_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TDataStd_Directory self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Directory_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TDataStd_Directory self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDataStd.Handle_TDataStd_Directory_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TDataStd_Directory self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDataStd.Handle_TDataStd_Directory_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TDataStd_Directory self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Directory_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TDataStd_Directory self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Directory_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TDataStd_Directory self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDataStd.Handle_TDataStd_Directory_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TDataStd_Directory self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDataStd.Handle_TDataStd_Directory_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TDataStd_Directory self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDataStd.Handle_TDataStd_Directory_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TDataStd_Directory self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDataStd.Handle_TDataStd_Directory_DeltaOnRemoval(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDataStd_Directory self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_Directory___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TDataStd_Directory self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDataStd.Handle_TDataStd_Directory_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TDataStd_Directory self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDataStd.Handle_TDataStd_Directory_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_Directory self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_Directory_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_Directory self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_Directory self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Directory_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_Directory self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_Directory self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Directory_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_Directory self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_Directory_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_Directory self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Directory_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_Directory self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_Directory_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_Directory self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Directory_DecrementRefCounter(self, *args)

Handle_TDataStd_Directory_swigregister = _TDataStd.Handle_TDataStd_Directory_swigregister
Handle_TDataStd_Directory_swigregister(Handle_TDataStd_Directory)

def Handle_TDataStd_Directory_DownCast(thing):
    return _TDataStd.Handle_TDataStd_Directory_DownCast(thing)
Handle_TDataStd_Directory_DownCast = _TDataStd.Handle_TDataStd_Directory_DownCast

class Handle_TDataStd_NamedData(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_NamedData self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_NamedData_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_NamedData self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_NamedData_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_NamedData self, TDataStd_NamedData thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_NamedData_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_NamedData self, Handle_TDataStd_NamedData theHandle) -> Handle_TDataStd_NamedData
        assign(Handle_TDataStd_NamedData self, TDataStd_NamedData thePtr) -> Handle_TDataStd_NamedData
        assign(Handle_TDataStd_NamedData self, Handle_TDataStd_NamedData theHandle) -> Handle_TDataStd_NamedData

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_NamedData_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_NamedData self) -> TDataStd_NamedData

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_NamedData_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_NamedData self) -> TDataStd_NamedData

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_NamedData___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_NamedData self) -> TDataStd_NamedData

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_NamedData___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_NamedData___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_NamedData___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_NamedData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_NamedData_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_NamedData

    def GetID(self, *args):
        """
        Static methods
        ==============
        Returns the ID of the named data attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_NamedData_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_TDataStd_NamedData self, TDF_Label label) -> Handle_TDataStd_NamedData

        Finds or creates a named data attribute.

        :type label: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_NamedData

        """
        return _TDataStd.Handle_TDataStd_NamedData_Set(self, *args)


    def HasIntegers(self, *args):
        """
        HasIntegers(Handle_TDataStd_NamedData self) -> Standard_Boolean

        Returns true if at least one named integer value is
        kept in the attribute.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NamedData_HasIntegers(self, *args)


    def HasInteger(self, *args):
        """
        HasInteger(Handle_TDataStd_NamedData self, TCollection_ExtendedString theName) -> Standard_Boolean

        Returns true if the attribute contains specified by Name
        integer value.

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NamedData_HasInteger(self, *args)


    def GetInteger(self, *args):
        """
        GetInteger(Handle_TDataStd_NamedData self, TCollection_ExtendedString theName) -> Standard_Integer

        Returns the integer value specified by the Name.
        It returns 0 if internal map doesn't contain the specified
        integer (use HasInteger() to check before).

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_NamedData_GetInteger(self, *args)


    def SetInteger(self, *args):
        """
        SetInteger(Handle_TDataStd_NamedData self, TCollection_ExtendedString theName, Standard_Integer const theInteger)

        Defines a named integer.
        If the integer already exists, it changes its value to <theInteger>.

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type theInteger: int

        """
        return _TDataStd.Handle_TDataStd_NamedData_SetInteger(self, *args)


    def GetIntegersContainer(self, *args):
        """
        Returns the internal container of named integers.

        :rtype: OCC.wrapper.TColStd.TColStd_DataMapOfStringInteger

        """
        res = _TDataStd.Handle_TDataStd_NamedData_GetIntegersContainer(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeIntegers(self, *args):
        """
        ChangeIntegers(Handle_TDataStd_NamedData self, NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString theIntegers)

        Replace the container content by new content of the <theIntegers>.

        :type theIntegers: OCC.wrapper.TColStd.TColStd_DataMapOfStringInteger

        """
        return _TDataStd.Handle_TDataStd_NamedData_ChangeIntegers(self, *args)


    def HasReals(self, *args):
        """
        HasReals(Handle_TDataStd_NamedData self) -> Standard_Boolean

        Returns true if at least one named real value is
        kept in the attribute.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NamedData_HasReals(self, *args)


    def HasReal(self, *args):
        """
        HasReal(Handle_TDataStd_NamedData self, TCollection_ExtendedString theName) -> Standard_Boolean

        Returns true if the attribute contains a real specified by Name.

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NamedData_HasReal(self, *args)


    def GetReal(self, *args):
        """
        GetReal(Handle_TDataStd_NamedData self, TCollection_ExtendedString theName) -> Standard_Real

        Returns the named real.
        It returns 0.0 if there is no such a named real
        (use HasReal()).

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TDataStd.Handle_TDataStd_NamedData_GetReal(self, *args)


    def SetReal(self, *args):
        """
        SetReal(Handle_TDataStd_NamedData self, TCollection_ExtendedString theName, Standard_Real const theReal)

        Defines a named real.
        If the real already exists, it changes its value to <theReal>.

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type theReal: float

        """
        return _TDataStd.Handle_TDataStd_NamedData_SetReal(self, *args)


    def GetRealsContainer(self, *args):
        """
        Returns the internal container of named reals.

        :rtype: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringReal

        """
        res = _TDataStd.Handle_TDataStd_NamedData_GetRealsContainer(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeReals(self, *args):
        """
        ChangeReals(Handle_TDataStd_NamedData self, NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString theReals)

        Replace the container content by new content of the <theReals>.

        :type theReals: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringReal

        """
        return _TDataStd.Handle_TDataStd_NamedData_ChangeReals(self, *args)


    def HasStrings(self, *args):
        """
        HasStrings(Handle_TDataStd_NamedData self) -> Standard_Boolean

        Returns true if there are some named strings in the attribute.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NamedData_HasStrings(self, *args)


    def HasString(self, *args):
        """
        HasString(Handle_TDataStd_NamedData self, TCollection_ExtendedString theName) -> Standard_Boolean

        Returns true if the attribute contains this named string.

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NamedData_HasString(self, *args)


    def GetString(self, *args):
        """
        Returns the named string.
        It returns an empty string if there is no such a named string
        (use HasString()).

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _TDataStd.Handle_TDataStd_NamedData_GetString(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetString(self, *args):
        """
        SetString(Handle_TDataStd_NamedData self, TCollection_ExtendedString theName, TCollection_ExtendedString theString)

        Defines a named string.
        If the string already exists, it changes its value to <theString>.

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type theString: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDataStd.Handle_TDataStd_NamedData_SetString(self, *args)


    def GetStringsContainer(self, *args):
        """
        Returns the internal container of named strings.

        :rtype: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringString

        """
        res = _TDataStd.Handle_TDataStd_NamedData_GetStringsContainer(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeStrings(self, *args):
        """
        ChangeStrings(Handle_TDataStd_NamedData self, NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString theStrings)

        Replace the container content by new content of the <theStrings>.

        :type theStrings: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringString

        """
        return _TDataStd.Handle_TDataStd_NamedData_ChangeStrings(self, *args)


    def HasBytes(self, *args):
        """
        HasBytes(Handle_TDataStd_NamedData self) -> Standard_Boolean

        Returns true if there are some named bytes in the attribute.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NamedData_HasBytes(self, *args)


    def HasByte(self, *args):
        """
        HasByte(Handle_TDataStd_NamedData self, TCollection_ExtendedString theName) -> Standard_Boolean

        Returns true if the attribute contains this named byte.

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NamedData_HasByte(self, *args)


    def GetByte(self, *args):
        """
        GetByte(Handle_TDataStd_NamedData self, TCollection_ExtendedString theName) -> Standard_Byte

        Returns the named byte.
        It returns 0 if there is no such a named byte
        (use HasByte()).

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Byte

        """
        return _TDataStd.Handle_TDataStd_NamedData_GetByte(self, *args)


    def SetByte(self, *args):
        """
        SetByte(Handle_TDataStd_NamedData self, TCollection_ExtendedString theName, Standard_Byte const theByte)

        Defines a named byte.
        If the byte already exists, it changes its value to <theByte>.

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type theByte: int

        """
        return _TDataStd.Handle_TDataStd_NamedData_SetByte(self, *args)


    def GetBytesContainer(self, *args):
        """
        Returns the internal container of named bytes.

        :rtype: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringByte

        """
        res = _TDataStd.Handle_TDataStd_NamedData_GetBytesContainer(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeBytes(self, *args):
        """
        ChangeBytes(Handle_TDataStd_NamedData self, NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString theBytes)

        Replace the container content by new content of the <theBytes>.

        :type theBytes: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringByte

        """
        return _TDataStd.Handle_TDataStd_NamedData_ChangeBytes(self, *args)


    def HasArraysOfIntegers(self, *args):
        """
        HasArraysOfIntegers(Handle_TDataStd_NamedData self) -> Standard_Boolean

        Returns true if there are some named arrays of integer values in the attribute.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NamedData_HasArraysOfIntegers(self, *args)


    def HasArrayOfIntegers(self, *args):
        """
        HasArrayOfIntegers(Handle_TDataStd_NamedData self, TCollection_ExtendedString theName) -> Standard_Boolean

        Returns true if the attribute contains this named array of integer values.

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NamedData_HasArrayOfIntegers(self, *args)


    def GetArrayOfIntegers(self, *args):
        """
        Returns the named array of integer values.
        It returns a NULL Handle if there is no such a named array of integers
        (use HasArrayOfIntegers()).

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfInteger

        """
        res = _TDataStd.Handle_TDataStd_NamedData_GetArrayOfIntegers(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetArrayOfIntegers(self, *args):
        """
        SetArrayOfIntegers(Handle_TDataStd_NamedData self, TCollection_ExtendedString theName, Handle_TColStd_HArray1OfInteger theArrayOfIntegers)

        Defines a named array of integer values.
        If the array already exists, it changes its value to <theArrayOfIntegers>.

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type theArrayOfIntegers: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfInteger

        """
        return _TDataStd.Handle_TDataStd_NamedData_SetArrayOfIntegers(self, *args)


    def GetArraysOfIntegersContainer(self, *args):
        """
        Returns the internal container of named arrays of integer values.

        :rtype: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringHArray1OfInteger

        """
        res = _TDataStd.Handle_TDataStd_NamedData_GetArraysOfIntegersContainer(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArraysOfIntegers(self, *args):
        """
        ChangeArraysOfIntegers(Handle_TDataStd_NamedData self, NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString theArraysOfIntegers)

        Replace the container content by new content of the <theArraysOfIntegers>.

        :type theArraysOfIntegers: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringHArray1OfInteger

        """
        return _TDataStd.Handle_TDataStd_NamedData_ChangeArraysOfIntegers(self, *args)


    def HasArraysOfReals(self, *args):
        """
        HasArraysOfReals(Handle_TDataStd_NamedData self) -> Standard_Boolean

        Returns true if there are some named arrays of real values in the attribute.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NamedData_HasArraysOfReals(self, *args)


    def HasArrayOfReals(self, *args):
        """
        HasArrayOfReals(Handle_TDataStd_NamedData self, TCollection_ExtendedString theName) -> Standard_Boolean

        Returns true if the attribute contains this named array of real values.

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NamedData_HasArrayOfReals(self, *args)


    def GetArrayOfReals(self, *args):
        """
        Returns the named array of real values.
        It returns a NULL Handle if there is no such a named array of reals
        (use HasArrayOfReals()).

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        res = _TDataStd.Handle_TDataStd_NamedData_GetArrayOfReals(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetArrayOfReals(self, *args):
        """
        SetArrayOfReals(Handle_TDataStd_NamedData self, TCollection_ExtendedString theName, Handle_TColStd_HArray1OfReal theArrayOfReals)

        Defines a named array of real values.
        If the array already exists, it changes its value to <theArrayOfReals>.

        :type theName: OCC.wrapper.TCollection.TCollection_ExtendedString
        :type theArrayOfReals: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        return _TDataStd.Handle_TDataStd_NamedData_SetArrayOfReals(self, *args)


    def GetArraysOfRealsContainer(self, *args):
        """
        Returns the internal container of named arrays of real values.

        :rtype: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringHArray1OfReal

        """
        res = _TDataStd.Handle_TDataStd_NamedData_GetArraysOfRealsContainer(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArraysOfReals(self, *args):
        """
        ChangeArraysOfReals(Handle_TDataStd_NamedData self, NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString theArraysOfReals)

        Replace the container content by new content of the <theArraysOfReals>.

        :type theArraysOfReals: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringHArray1OfReal

        """
        return _TDataStd.Handle_TDataStd_NamedData_ChangeArraysOfReals(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_NamedData_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TDataStd_NamedData self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_NamedData_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TDataStd_NamedData self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_NamedData_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TDataStd_NamedData self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.Handle_TDataStd_NamedData_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDataStd_NamedData self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_NamedData_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_NamedData self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_NamedData_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_NamedData_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_NamedData_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetID(self, *args):
        """
        SetID(Handle_TDataStd_NamedData self, Standard_GUID arg2)
        SetID(Handle_TDataStd_NamedData self)

        Sets default ID defined in nested class (to be used for attributes having User ID feature).


        """
        return _TDataStd.Handle_TDataStd_NamedData_SetID(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TDataStd_NamedData self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_NamedData_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDataStd_NamedData self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_NamedData_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TDataStd_NamedData self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_NamedData_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDataStd_NamedData self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NamedData_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TDataStd_NamedData self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NamedData_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TDataStd_NamedData self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NamedData_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TDataStd_NamedData self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NamedData_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TDataStd_NamedData self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NamedData_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDataStd_NamedData self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_NamedData_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TDataStd_NamedData self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NamedData_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TDataStd_NamedData self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDataStd.Handle_TDataStd_NamedData_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TDataStd_NamedData self)

        Something to do after adding an Attribute to a label.


        """
        return _TDataStd.Handle_TDataStd_NamedData_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TDataStd_NamedData self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_NamedData_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TDataStd_NamedData self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TDataStd.Handle_TDataStd_NamedData_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TDataStd_NamedData self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_NamedData_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TDataStd_NamedData self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NamedData_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TDataStd_NamedData self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NamedData_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TDataStd_NamedData self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NamedData_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TDataStd_NamedData self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDataStd.Handle_TDataStd_NamedData_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TDataStd_NamedData self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDataStd.Handle_TDataStd_NamedData_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TDataStd_NamedData self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NamedData_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TDataStd_NamedData self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_NamedData_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TDataStd_NamedData self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDataStd.Handle_TDataStd_NamedData_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TDataStd_NamedData self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDataStd.Handle_TDataStd_NamedData_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TDataStd_NamedData self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDataStd.Handle_TDataStd_NamedData_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TDataStd_NamedData self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDataStd.Handle_TDataStd_NamedData_DeltaOnRemoval(self, *args)


    def References(self, *args):
        """
        References(Handle_TDataStd_NamedData self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDataStd.Handle_TDataStd_NamedData_References(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDataStd_NamedData self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_NamedData___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TDataStd_NamedData self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDataStd.Handle_TDataStd_NamedData_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TDataStd_NamedData self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDataStd.Handle_TDataStd_NamedData_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_NamedData self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_NamedData_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_NamedData self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_NamedData self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NamedData_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_NamedData self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_NamedData self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_NamedData_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_NamedData self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_NamedData_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_NamedData self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_NamedData_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_NamedData self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_NamedData_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_NamedData self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_NamedData_DecrementRefCounter(self, *args)

Handle_TDataStd_NamedData_swigregister = _TDataStd.Handle_TDataStd_NamedData_swigregister
Handle_TDataStd_NamedData_swigregister(Handle_TDataStd_NamedData)

def Handle_TDataStd_NamedData_DownCast(thing):
    return _TDataStd.Handle_TDataStd_NamedData_DownCast(thing)
Handle_TDataStd_NamedData_DownCast = _TDataStd.Handle_TDataStd_NamedData_DownCast

class Handle_TDataStd_Relation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_Relation self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_Relation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_Relation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_Relation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_Relation self, TDataStd_Relation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_Relation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_Relation self, Handle_TDataStd_Relation theHandle) -> Handle_TDataStd_Relation
        assign(Handle_TDataStd_Relation self, TDataStd_Relation thePtr) -> Handle_TDataStd_Relation
        assign(Handle_TDataStd_Relation self, Handle_TDataStd_Relation theHandle) -> Handle_TDataStd_Relation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_Relation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_Relation self) -> TDataStd_Relation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_Relation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_Relation self) -> TDataStd_Relation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_Relation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_Relation self) -> TDataStd_Relation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_Relation___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_Relation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_Relation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_Relation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_Relation_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_Relation

    def GetID(self, *args):
        """
        class methods
        =============

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_Relation_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_TDataStd_Relation self, TDF_Label label) -> Handle_TDataStd_Relation

        Find, or create, an Relation attribute.
        Real methods
        ============

        :type label: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_Relation

        """
        return _TDataStd.Handle_TDataStd_Relation_Set(self, *args)


    def Name(self, *args):
        """
        Name(Handle_TDataStd_Relation self) -> TCollection_ExtendedString

        build and return the relation name

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDataStd.Handle_TDataStd_Relation_Name(self, *args)


    def SetRelation(self, *args):
        """
        SetRelation(Handle_TDataStd_Relation self, TCollection_ExtendedString E)

        :type E: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDataStd.Handle_TDataStd_Relation_SetRelation(self, *args)


    def GetRelation(self, *args):
        """
        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _TDataStd.Handle_TDataStd_Relation_GetRelation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetVariables(self, *args):
        """
        GetVariables(Handle_TDataStd_Relation self) -> NCollection_List_Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.TDF_AttributeList

        """
        return _TDataStd.Handle_TDataStd_Relation_GetVariables(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_Relation_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TDataStd_Relation self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Relation_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TDataStd_Relation self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Relation_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TDataStd_Relation self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.Handle_TDataStd_Relation_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDataStd_Relation self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_Relation_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_Relation self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_Relation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_Relation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_Relation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetID(self, *args):
        """
        SetID(Handle_TDataStd_Relation self, Standard_GUID arg2)
        SetID(Handle_TDataStd_Relation self)

        Sets default ID defined in nested class (to be used for attributes having User ID feature).


        """
        return _TDataStd.Handle_TDataStd_Relation_SetID(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TDataStd_Relation self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_Relation_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDataStd_Relation self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Relation_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TDataStd_Relation self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Relation_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDataStd_Relation self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Relation_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TDataStd_Relation self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Relation_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TDataStd_Relation self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Relation_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TDataStd_Relation self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Relation_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TDataStd_Relation self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Relation_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDataStd_Relation self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Relation_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TDataStd_Relation self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Relation_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TDataStd_Relation self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDataStd.Handle_TDataStd_Relation_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TDataStd_Relation self)

        Something to do after adding an Attribute to a label.


        """
        return _TDataStd.Handle_TDataStd_Relation_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TDataStd_Relation self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_Relation_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TDataStd_Relation self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TDataStd.Handle_TDataStd_Relation_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TDataStd_Relation self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_Relation_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TDataStd_Relation self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Relation_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TDataStd_Relation self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Relation_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TDataStd_Relation self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Relation_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TDataStd_Relation self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDataStd.Handle_TDataStd_Relation_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TDataStd_Relation self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDataStd.Handle_TDataStd_Relation_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TDataStd_Relation self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Relation_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TDataStd_Relation self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Relation_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TDataStd_Relation self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDataStd.Handle_TDataStd_Relation_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TDataStd_Relation self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDataStd.Handle_TDataStd_Relation_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TDataStd_Relation self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDataStd.Handle_TDataStd_Relation_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TDataStd_Relation self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDataStd.Handle_TDataStd_Relation_DeltaOnRemoval(self, *args)


    def References(self, *args):
        """
        References(Handle_TDataStd_Relation self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDataStd.Handle_TDataStd_Relation_References(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDataStd_Relation self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_Relation___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TDataStd_Relation self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDataStd.Handle_TDataStd_Relation_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TDataStd_Relation self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDataStd.Handle_TDataStd_Relation_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_Relation self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_Relation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_Relation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_Relation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Relation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_Relation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_Relation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Relation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_Relation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_Relation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_Relation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Relation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_Relation self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_Relation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_Relation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Relation_DecrementRefCounter(self, *args)

Handle_TDataStd_Relation_swigregister = _TDataStd.Handle_TDataStd_Relation_swigregister
Handle_TDataStd_Relation_swigregister(Handle_TDataStd_Relation)

def Handle_TDataStd_Relation_DownCast(thing):
    return _TDataStd.Handle_TDataStd_Relation_DownCast(thing)
Handle_TDataStd_Relation_DownCast = _TDataStd.Handle_TDataStd_Relation_DownCast

class TDataStd_HDataMapOfStringByte(Standard.Standard_Transient):
    """
    Extension of TDataStd_DataMapOfStringByte class
    to be manipulated by handle.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_HDataMapOfStringByte
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_HDataMapOfStringByte(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_HDataMapOfStringByte_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_HDataMapOfStringByte_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_HDataMapOfStringByte_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(TDataStd_HDataMapOfStringByte self, Standard_Integer const NbBuckets=1) -> TDataStd_HDataMapOfStringByte
        __init__(TDataStd_HDataMapOfStringByte self, NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString theOther) -> TDataStd_HDataMapOfStringByte

        :type theOther: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringByte

        """
        this = _TDataStd.new_TDataStd_HDataMapOfStringByte(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Map(self, *args):
        """
        :rtype: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringByte

        """
        res = _TDataStd.TDataStd_HDataMapOfStringByte_Map(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeMap(self, *args):
        """
        ChangeMap(TDataStd_HDataMapOfStringByte self) -> NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString

        :rtype: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringByte

        """
        return _TDataStd.TDataStd_HDataMapOfStringByte_ChangeMap(self, *args)

    __swig_destroy__ = _TDataStd.delete_TDataStd_HDataMapOfStringByte
TDataStd_HDataMapOfStringByte_swigregister = _TDataStd.TDataStd_HDataMapOfStringByte_swigregister
TDataStd_HDataMapOfStringByte_swigregister(TDataStd_HDataMapOfStringByte)

def TDataStd_HDataMapOfStringByte_get_type_name(*args):
    """
    TDataStd_HDataMapOfStringByte_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_HDataMapOfStringByte_get_type_name(*args)

def TDataStd_HDataMapOfStringByte_get_type_descriptor(*args):
    """
    TDataStd_HDataMapOfStringByte_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_HDataMapOfStringByte_get_type_descriptor(*args)

class Handle_TDataStd_DeltaOnModificationOfByteArray(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_DeltaOnModificationOfByteArray self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfByteArray_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_DeltaOnModificationOfByteArray self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfByteArray_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_DeltaOnModificationOfByteArray self, TDataStd_DeltaOnModificationOfByteArray thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfByteArray_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_DeltaOnModificationOfByteArray self, Handle_TDataStd_DeltaOnModificationOfByteArray theHandle) -> Handle_TDataStd_DeltaOnModificationOfByteArray
        assign(Handle_TDataStd_DeltaOnModificationOfByteArray self, TDataStd_DeltaOnModificationOfByteArray thePtr) -> Handle_TDataStd_DeltaOnModificationOfByteArray
        assign(Handle_TDataStd_DeltaOnModificationOfByteArray self, Handle_TDataStd_DeltaOnModificationOfByteArray theHandle) -> Handle_TDataStd_DeltaOnModificationOfByteArray

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfByteArray_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_DeltaOnModificationOfByteArray self) -> TDataStd_DeltaOnModificationOfByteArray

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfByteArray_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_DeltaOnModificationOfByteArray self) -> TDataStd_DeltaOnModificationOfByteArray

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfByteArray___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_DeltaOnModificationOfByteArray self) -> TDataStd_DeltaOnModificationOfByteArray

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfByteArray___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfByteArray___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_DeltaOnModificationOfByteArray___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_DeltaOnModificationOfByteArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_DeltaOnModificationOfByteArray_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_DeltaOnModificationOfByteArray

    def Apply(self, *args):
        """
        Apply(Handle_TDataStd_DeltaOnModificationOfByteArray self)

        Applies the delta to the attribute.


        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfByteArray_Apply(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_DeltaOnModificationOfByteArray self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfByteArray_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_DeltaOnModificationOfByteArray_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_DeltaOnModificationOfByteArray_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Label(self, *args):
        """
        Label(Handle_TDataStd_DeltaOnModificationOfByteArray self) -> TDF_Label

        Returns the label concerned by <me>.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfByteArray_Label(self, *args)


    def Attribute(self, *args):
        """
        Attribute(Handle_TDataStd_DeltaOnModificationOfByteArray self) -> Handle_TDF_Attribute

        Returns the reference attribute.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfByteArray_Attribute(self, *args)


    def ID(self, *args):
        """
        ID(Handle_TDataStd_DeltaOnModificationOfByteArray self) -> Standard_GUID

        Returns the ID of the attribute concerned by <me>.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfByteArray_ID(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDataStd_DeltaOnModificationOfByteArray self, Standard_OStream & OS) -> Standard_OStream &

        Dumps the contents.

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfByteArray_Dump(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDataStd_DeltaOnModificationOfByteArray self, Standard_OStream & OS) -> Standard_OStream &

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfByteArray___lshift__(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_DeltaOnModificationOfByteArray self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfByteArray_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_DeltaOnModificationOfByteArray self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_DeltaOnModificationOfByteArray self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfByteArray_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_DeltaOnModificationOfByteArray self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_DeltaOnModificationOfByteArray self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfByteArray_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_DeltaOnModificationOfByteArray self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfByteArray_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_DeltaOnModificationOfByteArray self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfByteArray_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_DeltaOnModificationOfByteArray self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfByteArray_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_DeltaOnModificationOfByteArray self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfByteArray_DecrementRefCounter(self, *args)

Handle_TDataStd_DeltaOnModificationOfByteArray_swigregister = _TDataStd.Handle_TDataStd_DeltaOnModificationOfByteArray_swigregister
Handle_TDataStd_DeltaOnModificationOfByteArray_swigregister(Handle_TDataStd_DeltaOnModificationOfByteArray)

def Handle_TDataStd_DeltaOnModificationOfByteArray_DownCast(thing):
    return _TDataStd.Handle_TDataStd_DeltaOnModificationOfByteArray_DownCast(thing)
Handle_TDataStd_DeltaOnModificationOfByteArray_DownCast = _TDataStd.Handle_TDataStd_DeltaOnModificationOfByteArray_DownCast

class TDataStd_BooleanArray(TDF.TDF_Attribute):
    """An array of boolean values."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_BooleanArray
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_BooleanArray(self) 
            return h


    def GetID(*args):
        """
        GetID() -> Standard_GUID

        Static methods
        ==============
        Returns an ID for array.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.TDataStd_BooleanArray_GetID(*args)

    GetID = staticmethod(GetID)

    def Set(*args):
        """
        Set(TDF_Label label, Standard_Integer const lower, Standard_Integer const upper) -> Handle_TDataStd_BooleanArray
        Set(TDF_Label label, Standard_GUID theGuid, Standard_Integer const lower, Standard_Integer const upper) -> Handle_TDataStd_BooleanArray

        Finds or creates an attribute with the array using explicit user defined <guid>.

        :type label: OCC.wrapper.TDF.TDF_Label
        :type theGuid: OCC.wrapper.Standard.Standard_GUID
        :type lower: int
        :type upper: int
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_BooleanArray

        """
        return _TDataStd.TDataStd_BooleanArray_Set(*args)

    Set = staticmethod(Set)

    def Init(self, *args):
        """
        Init(TDataStd_BooleanArray self, Standard_Integer const lower, Standard_Integer const upper)

        Initialize the inner array with bounds from <lower> to <upper>

        :type lower: int
        :type upper: int

        """
        return _TDataStd.TDataStd_BooleanArray_Init(self, *args)


    def SetValue(self, *args):
        """
        SetValue(TDataStd_BooleanArray self, Standard_Integer const index, Standard_Boolean const value)

        Sets the <Index>th element of the array to <Value>
        OutOfRange exception is raised if <Index> doesn't respect Lower and Upper bounds of the internal  array.

        :type index: int
        :type value: bool

        """
        return _TDataStd.TDataStd_BooleanArray_SetValue(self, *args)


    def SetID(self, *args):
        """
        SetID(TDataStd_BooleanArray self, Standard_GUID theGuid)
        SetID(TDataStd_BooleanArray self)

        Sets default GUID for the attribute.


        """
        return _TDataStd.TDataStd_BooleanArray_SetID(self, *args)


    def Value(self, *args):
        """
        Value(TDataStd_BooleanArray self, Standard_Integer const Index) -> Standard_Boolean

        Return the value of the <Index>th element of the array.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_BooleanArray_Value(self, *args)


    def __call__(self, *args):
        """
        __call__(TDataStd_BooleanArray self, Standard_Integer const Index) -> Standard_Boolean

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_BooleanArray___call__(self, *args)


    def Lower(self, *args):
        """
        Lower(TDataStd_BooleanArray self) -> Standard_Integer

        Returns the lower boundary of the array.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.TDataStd_BooleanArray_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(TDataStd_BooleanArray self) -> Standard_Integer

        Returns the upper boundary of the array.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.TDataStd_BooleanArray_Upper(self, *args)


    def Length(self, *args):
        """
        Length(TDataStd_BooleanArray self) -> Standard_Integer

        Returns the number of elements in the array.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.TDataStd_BooleanArray_Length(self, *args)


    def InternalArray(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfByte

        """
        res = _TDataStd.TDataStd_BooleanArray_InternalArray(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetInternalArray(self, *args):
        """
        SetInternalArray(TDataStd_BooleanArray self, Handle_TColStd_HArray1OfByte values)

        :type values: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfByte

        """
        return _TDataStd.TDataStd_BooleanArray_SetInternalArray(self, *args)


    def __init__(self, *args):
        """
        __init__(TDataStd_BooleanArray self) -> TDataStd_BooleanArray

        An array of boolean values.
        """
        this = _TDataStd.new_TDataStd_BooleanArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.TDataStd_BooleanArray_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TDataStd_BooleanArray self, Handle_TDF_Attribute arg2)

        :type with: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_BooleanArray_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TDataStd_BooleanArray self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_BooleanArray_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TDataStd_BooleanArray self, Handle_TDF_Attribute into, Handle_TDF_RelocationTable RT)

        :type into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.TDataStd_BooleanArray_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(TDataStd_BooleanArray self, Standard_OStream & OS) -> Standard_OStream &

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.TDataStd_BooleanArray_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_BooleanArray_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_BooleanArray_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_BooleanArray_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDataStd.delete_TDataStd_BooleanArray
TDataStd_BooleanArray_swigregister = _TDataStd.TDataStd_BooleanArray_swigregister
TDataStd_BooleanArray_swigregister(TDataStd_BooleanArray)

def TDataStd_BooleanArray_GetID(*args):
    """
    TDataStd_BooleanArray_GetID() -> Standard_GUID

    Static methods
    ==============
    Returns an ID for array.

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TDataStd.TDataStd_BooleanArray_GetID(*args)

def TDataStd_BooleanArray_Set(*args):
    """
    Set(TDF_Label label, Standard_Integer const lower, Standard_Integer const upper) -> Handle_TDataStd_BooleanArray
    TDataStd_BooleanArray_Set(TDF_Label label, Standard_GUID theGuid, Standard_Integer const lower, Standard_Integer const upper) -> Handle_TDataStd_BooleanArray

    Finds or creates an attribute with the array using explicit user defined <guid>.

    :type label: OCC.wrapper.TDF.TDF_Label
    :type theGuid: OCC.wrapper.Standard.Standard_GUID
    :type lower: int
    :type upper: int
    :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_BooleanArray

    """
    return _TDataStd.TDataStd_BooleanArray_Set(*args)

def TDataStd_BooleanArray_get_type_name(*args):
    """
    TDataStd_BooleanArray_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_BooleanArray_get_type_name(*args)

def TDataStd_BooleanArray_get_type_descriptor(*args):
    """
    TDataStd_BooleanArray_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_BooleanArray_get_type_descriptor(*args)

class TDataStd_Name(TDF.TDF_Attribute):
    """Used to define a name attribute containing a string which specifies the name."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_Name
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_Name(self) 
            return h


    def GetID(*args):
        """
        GetID() -> Standard_GUID

        class methods working on the name itself
        ========================================
        Returns the GUID for name attributes.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.TDataStd_Name_GetID(*args)

    GetID = staticmethod(GetID)

    def __init__(self, *args):
        """
        __init__(TDataStd_Name self) -> TDataStd_Name

        Used to define a name attribute containing a string which specifies the name.
        """
        this = _TDataStd.new_TDataStd_Name(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Set(self, *args):
        """
        Set(TDataStd_Name self, TDF_Label label, TCollection_ExtendedString string) -> Handle_TDataStd_Name
        Set(TDataStd_Name self, TDF_Label label, Standard_GUID guid, TCollection_ExtendedString string) -> Handle_TDataStd_Name
        Set(TDataStd_Name self, TCollection_ExtendedString S)

        Sets <S> as name. Raises if <S> is not a valid name.

        :type S: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDataStd.TDataStd_Name_Set(self, *args)


    def SetID(self, *args):
        """
        SetID(TDataStd_Name self, Standard_GUID guid)
        SetID(TDataStd_Name self)

        Sets default GUID for the attribute.


        """
        return _TDataStd.TDataStd_Name_SetID(self, *args)


    def Get(self, *args):
        """
        Returns the name contained in this name attribute.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _TDataStd.TDataStd_Name_Get(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.TDataStd_Name_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TDataStd_Name self, Handle_TDF_Attribute arg2)

        :type with: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_Name_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TDataStd_Name self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_Name_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TDataStd_Name self, Handle_TDF_Attribute into, Handle_TDF_RelocationTable RT)

        :type into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.TDataStd_Name_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(TDataStd_Name self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.TDataStd_Name_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_Name_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_Name_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_Name_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDataStd.delete_TDataStd_Name
TDataStd_Name_swigregister = _TDataStd.TDataStd_Name_swigregister
TDataStd_Name_swigregister(TDataStd_Name)

def TDataStd_Name_GetID(*args):
    """
    TDataStd_Name_GetID() -> Standard_GUID

    class methods working on the name itself
    ========================================
    Returns the GUID for name attributes.

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TDataStd.TDataStd_Name_GetID(*args)

def TDataStd_Name_get_type_name(*args):
    """
    TDataStd_Name_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_Name_get_type_name(*args)

def TDataStd_Name_get_type_descriptor(*args):
    """
    TDataStd_Name_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_Name_get_type_descriptor(*args)

class TDataStd_Expression(TDF.TDF_Attribute):
    """
    Expression attribute.
    ====================

    * Data Structure  of the Expression   is stored in a
    string and references to variables used by the string

    Warning:  To be consistent,  each  Variable  referenced by  the
    expression must have its equivalent in the string
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_Expression
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_Expression(self) 
            return h


    def GetID(*args):
        """
        GetID() -> Standard_GUID

        class methods
        =============

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.TDataStd_Expression_GetID(*args)

    GetID = staticmethod(GetID)

    def Set(*args):
        """
        Set(TDF_Label label) -> Handle_TDataStd_Expression

        Find, or create, an Expression attribute.
        Expressionmethods
        ============

        :type label: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_Expression

        """
        return _TDataStd.TDataStd_Expression_Set(*args)

    Set = staticmethod(Set)

    def __init__(self, *args):
        """
        __init__(TDataStd_Expression self) -> TDataStd_Expression

        Expression attribute.
        ====================

        * Data Structure  of the Expression   is stored in a
        string and references to variables used by the string

        Warning:  To be consistent,  each  Variable  referenced by  the
        expression must have its equivalent in the string
        """
        this = _TDataStd.new_TDataStd_Expression(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Name(self, *args):
        """
        Name(TDataStd_Expression self) -> TCollection_ExtendedString

        build and return the expression name

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDataStd.TDataStd_Expression_Name(self, *args)


    def SetExpression(self, *args):
        """
        SetExpression(TDataStd_Expression self, TCollection_ExtendedString E)

        :type E: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDataStd.TDataStd_Expression_SetExpression(self, *args)


    def GetExpression(self, *args):
        """
        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _TDataStd.TDataStd_Expression_GetExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetVariables(self, *args):
        """
        GetVariables(TDataStd_Expression self) -> NCollection_List_Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.TDF_AttributeList

        """
        return _TDataStd.TDataStd_Expression_GetVariables(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.TDataStd_Expression_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TDataStd_Expression self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_Expression_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TDataStd_Expression self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_Expression_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TDataStd_Expression self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.TDataStd_Expression_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(TDataStd_Expression self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.TDataStd_Expression_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_Expression_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_Expression_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_Expression_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDataStd.delete_TDataStd_Expression
TDataStd_Expression_swigregister = _TDataStd.TDataStd_Expression_swigregister
TDataStd_Expression_swigregister(TDataStd_Expression)

def TDataStd_Expression_GetID(*args):
    """
    TDataStd_Expression_GetID() -> Standard_GUID

    class methods
    =============

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TDataStd.TDataStd_Expression_GetID(*args)

def TDataStd_Expression_Set(*args):
    """
    TDataStd_Expression_Set(TDF_Label label) -> Handle_TDataStd_Expression

    Find, or create, an Expression attribute.
    Expressionmethods
    ============

    :type label: OCC.wrapper.TDF.TDF_Label
    :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_Expression

    """
    return _TDataStd.TDataStd_Expression_Set(*args)

def TDataStd_Expression_get_type_name(*args):
    """
    TDataStd_Expression_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_Expression_get_type_name(*args)

def TDataStd_Expression_get_type_descriptor(*args):
    """
    TDataStd_Expression_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_Expression_get_type_descriptor(*args)

class Handle_TDataStd_Comment(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_Comment self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_Comment_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_Comment self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_Comment_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_Comment self, TDataStd_Comment thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_Comment_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_Comment self, Handle_TDataStd_Comment theHandle) -> Handle_TDataStd_Comment
        assign(Handle_TDataStd_Comment self, TDataStd_Comment thePtr) -> Handle_TDataStd_Comment
        assign(Handle_TDataStd_Comment self, Handle_TDataStd_Comment theHandle) -> Handle_TDataStd_Comment

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_Comment_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_Comment self) -> TDataStd_Comment

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_Comment_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_Comment self) -> TDataStd_Comment

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_Comment___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_Comment self) -> TDataStd_Comment

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_Comment___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_Comment___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_Comment___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_Comment(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_Comment_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_Comment

    def GetID(self, *args):
        """
        class methods
        =============
        Returns the GUID for comments.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_Comment_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_TDataStd_Comment self, TDF_Label label) -> Handle_TDataStd_Comment
        Set(Handle_TDataStd_Comment self, TDF_Label label, TCollection_ExtendedString string) -> Handle_TDataStd_Comment
        Set(Handle_TDataStd_Comment self, TCollection_ExtendedString S)

        :type S: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDataStd.Handle_TDataStd_Comment_Set(self, *args)


    def Get(self, *args):
        """
        Returns the comment attribute.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _TDataStd.Handle_TDataStd_Comment_Get(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_Comment_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TDataStd_Comment self, Handle_TDF_Attribute arg2)

        :type with: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Comment_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TDataStd_Comment self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Comment_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TDataStd_Comment self, Handle_TDF_Attribute into, Handle_TDF_RelocationTable RT)

        :type into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.Handle_TDataStd_Comment_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDataStd_Comment self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_Comment_Dump(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TDataStd_Comment self, Standard_Boolean const forceIt) -> Standard_Boolean

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Comment_AfterRetrieval(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_Comment self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_Comment_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_Comment_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_Comment_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetID(self, *args):
        """
        SetID(Handle_TDataStd_Comment self, Standard_GUID arg2)
        SetID(Handle_TDataStd_Comment self)

        Sets default ID defined in nested class (to be used for attributes having User ID feature).


        """
        return _TDataStd.Handle_TDataStd_Comment_SetID(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TDataStd_Comment self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_Comment_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDataStd_Comment self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Comment_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TDataStd_Comment self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Comment_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDataStd_Comment self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Comment_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TDataStd_Comment self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Comment_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TDataStd_Comment self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Comment_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TDataStd_Comment self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Comment_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TDataStd_Comment self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Comment_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDataStd_Comment self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Comment_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TDataStd_Comment self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Comment_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TDataStd_Comment self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDataStd.Handle_TDataStd_Comment_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TDataStd_Comment self)

        Something to do after adding an Attribute to a label.


        """
        return _TDataStd.Handle_TDataStd_Comment_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TDataStd_Comment self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_Comment_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TDataStd_Comment self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TDataStd.Handle_TDataStd_Comment_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TDataStd_Comment self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_Comment_AfterResume(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TDataStd_Comment self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Comment_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TDataStd_Comment self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Comment_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TDataStd_Comment self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDataStd.Handle_TDataStd_Comment_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TDataStd_Comment self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDataStd.Handle_TDataStd_Comment_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TDataStd_Comment self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Comment_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TDataStd_Comment self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Comment_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TDataStd_Comment self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDataStd.Handle_TDataStd_Comment_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TDataStd_Comment self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDataStd.Handle_TDataStd_Comment_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TDataStd_Comment self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDataStd.Handle_TDataStd_Comment_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TDataStd_Comment self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDataStd.Handle_TDataStd_Comment_DeltaOnRemoval(self, *args)


    def References(self, *args):
        """
        References(Handle_TDataStd_Comment self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDataStd.Handle_TDataStd_Comment_References(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDataStd_Comment self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_Comment___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TDataStd_Comment self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDataStd.Handle_TDataStd_Comment_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TDataStd_Comment self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDataStd.Handle_TDataStd_Comment_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_Comment self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_Comment_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_Comment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_Comment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Comment_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_Comment self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_Comment self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Comment_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_Comment self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_Comment_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_Comment self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Comment_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_Comment self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_Comment_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_Comment self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Comment_DecrementRefCounter(self, *args)

Handle_TDataStd_Comment_swigregister = _TDataStd.Handle_TDataStd_Comment_swigregister
Handle_TDataStd_Comment_swigregister(Handle_TDataStd_Comment)

def Handle_TDataStd_Comment_DownCast(thing):
    return _TDataStd.Handle_TDataStd_Comment_DownCast(thing)
Handle_TDataStd_Comment_DownCast = _TDataStd.Handle_TDataStd_Comment_DownCast

class TDataStd_UAttribute(TDF.TDF_Attribute):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_UAttribute
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_UAttribute(self) 
            return h


    def Set(*args):
        """
        Set(TDF_Label label, Standard_GUID LocalID) -> Handle_TDataStd_UAttribute

        api class methods
        =============
        Find, or create, a UAttribute attribute with <LocalID> as Local GUID.
        The UAttribute attribute is returned.
        UAttribute methods
        ============

        :type label: OCC.wrapper.TDF.TDF_Label
        :type LocalID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_UAttribute

        """
        return _TDataStd.TDataStd_UAttribute_Set(*args)

    Set = staticmethod(Set)

    def __init__(self, *args):
        """__init__(TDataStd_UAttribute self) -> TDataStd_UAttribute"""
        this = _TDataStd.new_TDataStd_UAttribute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetID(self, *args):
        """
        SetID(TDataStd_UAttribute self, Standard_GUID LocalID)

        :type LocalID: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.TDataStd_UAttribute_SetID(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.TDataStd_UAttribute_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TDataStd_UAttribute self, Handle_TDF_Attribute arg2)

        :type with: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_UAttribute_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TDataStd_UAttribute self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_UAttribute_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TDataStd_UAttribute self, Handle_TDF_Attribute into, Handle_TDF_RelocationTable RT)

        :type into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.TDataStd_UAttribute_Paste(self, *args)


    def References(self, *args):
        """
        References(TDataStd_UAttribute self, Handle_TDF_DataSet DS)

        :type DS: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDataStd.TDataStd_UAttribute_References(self, *args)


    def Dump(self, *args):
        """
        Dump(TDataStd_UAttribute self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.TDataStd_UAttribute_Dump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_UAttribute_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_UAttribute_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_UAttribute_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDataStd.delete_TDataStd_UAttribute
TDataStd_UAttribute_swigregister = _TDataStd.TDataStd_UAttribute_swigregister
TDataStd_UAttribute_swigregister(TDataStd_UAttribute)

def TDataStd_UAttribute_Set(*args):
    """
    TDataStd_UAttribute_Set(TDF_Label label, Standard_GUID LocalID) -> Handle_TDataStd_UAttribute

    api class methods
    =============
    Find, or create, a UAttribute attribute with <LocalID> as Local GUID.
    The UAttribute attribute is returned.
    UAttribute methods
    ============

    :type label: OCC.wrapper.TDF.TDF_Label
    :type LocalID: OCC.wrapper.Standard.Standard_GUID
    :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_UAttribute

    """
    return _TDataStd.TDataStd_UAttribute_Set(*args)

def TDataStd_UAttribute_get_type_name(*args):
    """
    TDataStd_UAttribute_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_UAttribute_get_type_name(*args)

def TDataStd_UAttribute_get_type_descriptor(*args):
    """
    TDataStd_UAttribute_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_UAttribute_get_type_descriptor(*args)

class Handle_TDataStd_Tick(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_Tick self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_Tick_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_Tick self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_Tick_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_Tick self, TDataStd_Tick thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_Tick_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_Tick self, Handle_TDataStd_Tick theHandle) -> Handle_TDataStd_Tick
        assign(Handle_TDataStd_Tick self, TDataStd_Tick thePtr) -> Handle_TDataStd_Tick
        assign(Handle_TDataStd_Tick self, Handle_TDataStd_Tick theHandle) -> Handle_TDataStd_Tick

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_Tick_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_Tick self) -> TDataStd_Tick

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_Tick_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_Tick self) -> TDataStd_Tick

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_Tick___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_Tick self) -> TDataStd_Tick

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_Tick___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_Tick___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_Tick___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_Tick(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_Tick_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_Tick

    def GetID(self, *args):
        """
        Static methods
        ==============

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_Tick_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_TDataStd_Tick self, TDF_Label label) -> Handle_TDataStd_Tick

        Find, or create, a Tick attribute.
        Tick methods
        ============

        :type label: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_Tick

        """
        return _TDataStd.Handle_TDataStd_Tick_Set(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_Tick_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TDataStd_Tick self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Tick_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TDataStd_Tick self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Tick_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TDataStd_Tick self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.Handle_TDataStd_Tick_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDataStd_Tick self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_Tick_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_Tick self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_Tick_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_Tick_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_Tick_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetID(self, *args):
        """
        SetID(Handle_TDataStd_Tick self, Standard_GUID arg2)
        SetID(Handle_TDataStd_Tick self)

        Sets default ID defined in nested class (to be used for attributes having User ID feature).


        """
        return _TDataStd.Handle_TDataStd_Tick_SetID(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TDataStd_Tick self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_Tick_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDataStd_Tick self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Tick_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TDataStd_Tick self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Tick_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDataStd_Tick self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Tick_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TDataStd_Tick self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Tick_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TDataStd_Tick self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Tick_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TDataStd_Tick self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Tick_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TDataStd_Tick self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Tick_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDataStd_Tick self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Tick_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TDataStd_Tick self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Tick_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TDataStd_Tick self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDataStd.Handle_TDataStd_Tick_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TDataStd_Tick self)

        Something to do after adding an Attribute to a label.


        """
        return _TDataStd.Handle_TDataStd_Tick_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TDataStd_Tick self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_Tick_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TDataStd_Tick self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TDataStd.Handle_TDataStd_Tick_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TDataStd_Tick self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_Tick_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TDataStd_Tick self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Tick_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TDataStd_Tick self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Tick_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TDataStd_Tick self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Tick_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TDataStd_Tick self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDataStd.Handle_TDataStd_Tick_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TDataStd_Tick self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDataStd.Handle_TDataStd_Tick_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TDataStd_Tick self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Tick_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TDataStd_Tick self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Tick_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TDataStd_Tick self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDataStd.Handle_TDataStd_Tick_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TDataStd_Tick self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDataStd.Handle_TDataStd_Tick_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TDataStd_Tick self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDataStd.Handle_TDataStd_Tick_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TDataStd_Tick self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDataStd.Handle_TDataStd_Tick_DeltaOnRemoval(self, *args)


    def References(self, *args):
        """
        References(Handle_TDataStd_Tick self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDataStd.Handle_TDataStd_Tick_References(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDataStd_Tick self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_Tick___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TDataStd_Tick self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDataStd.Handle_TDataStd_Tick_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TDataStd_Tick self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDataStd.Handle_TDataStd_Tick_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_Tick self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_Tick_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_Tick self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_Tick self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Tick_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_Tick self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_Tick self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Tick_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_Tick self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_Tick_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_Tick self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Tick_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_Tick self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_Tick_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_Tick self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Tick_DecrementRefCounter(self, *args)

Handle_TDataStd_Tick_swigregister = _TDataStd.Handle_TDataStd_Tick_swigregister
Handle_TDataStd_Tick_swigregister(Handle_TDataStd_Tick)

def Handle_TDataStd_Tick_DownCast(thing):
    return _TDataStd.Handle_TDataStd_Tick_DownCast(thing)
Handle_TDataStd_Tick_DownCast = _TDataStd.Handle_TDataStd_Tick_DownCast

class Handle_TDataStd_ExtStringList(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_ExtStringList self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_ExtStringList_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_ExtStringList self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_ExtStringList self, TDataStd_ExtStringList thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_ExtStringList self, Handle_TDataStd_ExtStringList theHandle) -> Handle_TDataStd_ExtStringList
        assign(Handle_TDataStd_ExtStringList self, TDataStd_ExtStringList thePtr) -> Handle_TDataStd_ExtStringList
        assign(Handle_TDataStd_ExtStringList self, Handle_TDataStd_ExtStringList theHandle) -> Handle_TDataStd_ExtStringList

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_ExtStringList self) -> TDataStd_ExtStringList

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_ExtStringList self) -> TDataStd_ExtStringList

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_ExtStringList___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_ExtStringList self) -> TDataStd_ExtStringList

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_ExtStringList___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_ExtStringList___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_ExtStringList___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_ExtStringList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_ExtStringList_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_ExtStringList

    def GetID(self, *args):
        """
        Static methods
        ==============
        Returns the ID of the list of strings attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_ExtStringList_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_TDataStd_ExtStringList self, TDF_Label label) -> Handle_TDataStd_ExtStringList
        Set(Handle_TDataStd_ExtStringList self, TDF_Label label, Standard_GUID theGuid) -> Handle_TDataStd_ExtStringList

        Finds or creates a list of string values attribute.

        :type label: OCC.wrapper.TDF.TDF_Label
        :type theGuid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_ExtStringList

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_Set(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_TDataStd_ExtStringList self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_IsEmpty(self, *args)


    def Extent(self, *args):
        """
        Extent(Handle_TDataStd_ExtStringList self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_Extent(self, *args)


    def Prepend(self, *args):
        """
        Prepend(Handle_TDataStd_ExtStringList self, TCollection_ExtendedString value)

        :type value: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_Prepend(self, *args)


    def Append(self, *args):
        """
        Append(Handle_TDataStd_ExtStringList self, TCollection_ExtendedString value)

        :type value: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_Append(self, *args)


    def SetID(self, *args):
        """
        SetID(Handle_TDataStd_ExtStringList self, Standard_GUID theGuid)
        SetID(Handle_TDataStd_ExtStringList self)

        Sets default GUID for the attribute.


        """
        return _TDataStd.Handle_TDataStd_ExtStringList_SetID(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(Handle_TDataStd_ExtStringList self, TCollection_ExtendedString value, TCollection_ExtendedString before_value) -> Standard_Boolean
        InsertBefore(Handle_TDataStd_ExtStringList self, Standard_Integer const index, TCollection_ExtendedString before_value) -> Standard_Boolean

        Inserts the <value> before the <index> position.
        The indices start with 1 .. Extent().

        :type index: int
        :type before_value: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(Handle_TDataStd_ExtStringList self, TCollection_ExtendedString value, TCollection_ExtendedString after_value) -> Standard_Boolean
        InsertAfter(Handle_TDataStd_ExtStringList self, Standard_Integer const index, TCollection_ExtendedString after_value) -> Standard_Boolean

        Inserts the <value> after the <index> position.
        The indices start with 1 .. Extent().

        :type index: int
        :type after_value: OCC.wrapper.TCollection.TCollection_ExtendedString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_InsertAfter(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_TDataStd_ExtStringList self, TCollection_ExtendedString value) -> Standard_Boolean
        Remove(Handle_TDataStd_ExtStringList self, Standard_Integer const index) -> Standard_Boolean

        Removes a value at <index> position.

        :type index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_Remove(self, *args)


    def Clear(self, *args):
        """Clear(Handle_TDataStd_ExtStringList self)"""
        return _TDataStd.Handle_TDataStd_ExtStringList_Clear(self, *args)


    def First(self, *args):
        """
        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _TDataStd.Handle_TDataStd_ExtStringList_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _TDataStd.Handle_TDataStd_ExtStringList_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def List(self, *args):
        """
        :rtype: OCC.wrapper.TDataStd.TDataStd_ListOfExtendedString

        """
        res = _TDataStd.Handle_TDataStd_ExtStringList_List(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_ExtStringList_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TDataStd_ExtStringList self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TDataStd_ExtStringList self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TDataStd_ExtStringList self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDataStd_ExtStringList self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_ExtStringList self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_ExtStringList_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_ExtStringList_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Label(self, *args):
        """
        Label(Handle_TDataStd_ExtStringList self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDataStd_ExtStringList self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TDataStd_ExtStringList self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDataStd_ExtStringList self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TDataStd_ExtStringList self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TDataStd_ExtStringList self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TDataStd_ExtStringList self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TDataStd_ExtStringList self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDataStd_ExtStringList self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TDataStd_ExtStringList self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TDataStd_ExtStringList self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TDataStd_ExtStringList self)

        Something to do after adding an Attribute to a label.


        """
        return _TDataStd.Handle_TDataStd_ExtStringList_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TDataStd_ExtStringList self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_ExtStringList_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TDataStd_ExtStringList self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TDataStd.Handle_TDataStd_ExtStringList_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TDataStd_ExtStringList self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_ExtStringList_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TDataStd_ExtStringList self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TDataStd_ExtStringList self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TDataStd_ExtStringList self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TDataStd_ExtStringList self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDataStd.Handle_TDataStd_ExtStringList_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TDataStd_ExtStringList self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDataStd.Handle_TDataStd_ExtStringList_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TDataStd_ExtStringList self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TDataStd_ExtStringList self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TDataStd_ExtStringList self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TDataStd_ExtStringList self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TDataStd_ExtStringList self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TDataStd_ExtStringList self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_DeltaOnRemoval(self, *args)


    def References(self, *args):
        """
        References(Handle_TDataStd_ExtStringList self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_References(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDataStd_ExtStringList self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_ExtStringList___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TDataStd_ExtStringList self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TDataStd_ExtStringList self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_ExtStringList self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_ExtStringList_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_ExtStringList self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_ExtStringList self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_ExtStringList self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_ExtStringList self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_ExtStringList self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_ExtStringList self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_ExtStringList self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_ExtStringList_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_ExtStringList self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_ExtStringList_DecrementRefCounter(self, *args)

Handle_TDataStd_ExtStringList_swigregister = _TDataStd.Handle_TDataStd_ExtStringList_swigregister
Handle_TDataStd_ExtStringList_swigregister(Handle_TDataStd_ExtStringList)

def Handle_TDataStd_ExtStringList_DownCast(thing):
    return _TDataStd.Handle_TDataStd_ExtStringList_DownCast(thing)
Handle_TDataStd_ExtStringList_DownCast = _TDataStd.Handle_TDataStd_ExtStringList_DownCast

class Handle_TDataStd_ExtStringArray(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_ExtStringArray self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_ExtStringArray self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_ExtStringArray self, TDataStd_ExtStringArray thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_ExtStringArray self, Handle_TDataStd_ExtStringArray theHandle) -> Handle_TDataStd_ExtStringArray
        assign(Handle_TDataStd_ExtStringArray self, TDataStd_ExtStringArray thePtr) -> Handle_TDataStd_ExtStringArray
        assign(Handle_TDataStd_ExtStringArray self, Handle_TDataStd_ExtStringArray theHandle) -> Handle_TDataStd_ExtStringArray

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_ExtStringArray self) -> TDataStd_ExtStringArray

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_ExtStringArray self) -> TDataStd_ExtStringArray

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_ExtStringArray self) -> TDataStd_ExtStringArray

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_ExtStringArray___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_ExtStringArray___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_ExtStringArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_ExtStringArray_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_ExtStringArray

    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_ExtStringArray self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_ExtStringArray_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_ExtStringArray_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetID(self, *args):
        """
        class methods
        =============
        Returns the GUID for the attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_ExtStringArray_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_TDataStd_ExtStringArray self, TDF_Label label, Standard_Integer const lower, Standard_Integer const upper, Standard_Boolean const isDelta) -> Handle_TDataStd_ExtStringArray
        Set(Handle_TDataStd_ExtStringArray self, TDF_Label label, Standard_GUID theGuid, Standard_Integer const lower, Standard_Integer const upper, Standard_Boolean const isDelta) -> Handle_TDataStd_ExtStringArray

        Finds, or creates, an ExtStringArray attribute with explicit user defined <guid>.
        The ExtStringArray attribute  is  returned.

        :type label: OCC.wrapper.TDF.TDF_Label
        :type theGuid: OCC.wrapper.Standard.Standard_GUID
        :type lower: int
        :type upper: int
        :type isDelta: bool
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_ExtStringArray

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_Set(self, *args)


    def Init(self, *args):
        """
        Init(Handle_TDataStd_ExtStringArray self, Standard_Integer const lower, Standard_Integer const upper)

        Initializes the inner array with bounds from <lower> to <upper>

        :type lower: int
        :type upper: int

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_Init(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_TDataStd_ExtStringArray self, Standard_Integer const Index, TCollection_ExtendedString Value)

        Sets  the   <Index>th  element  of   the  array to <Value>
        OutOfRange exception is raised if <Index> doesn't respect Lower and Upper bounds of the internal  array.

        :type Index: int
        :type Value: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_SetValue(self, *args)


    def SetID(self, *args):
        """
        SetID(Handle_TDataStd_ExtStringArray self, Standard_GUID theGuid)
        SetID(Handle_TDataStd_ExtStringArray self)

        Sets default GUID for the attribute.


        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_SetID(self, *args)


    def Value(self, *args):
        """
        Returns the value of  the  <Index>th element of the array

        :type Index: int
        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _TDataStd.Handle_TDataStd_ExtStringArray_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __call__(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _TDataStd.Handle_TDataStd_ExtStringArray___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Lower(self, *args):
        """
        Lower(Handle_TDataStd_ExtStringArray self) -> Standard_Integer

        Return the lower bound.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(Handle_TDataStd_ExtStringArray self) -> Standard_Integer

        Return the upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_Upper(self, *args)


    def Length(self, *args):
        """
        Length(Handle_TDataStd_ExtStringArray self) -> Standard_Integer

        Return the number of elements of <me>.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_Length(self, *args)


    def ChangeArray(self, *args):
        """
        ChangeArray(Handle_TDataStd_ExtStringArray self, Handle_TColStd_HArray1OfExtendedString newArray, Standard_Boolean const isCheckItems)

        Sets the inner array <myValue> of the ExtStringArray attribute to <newArray>.
        If value of <newArray> differs from <myValue>, Backup performed and myValue
        refers to new instance of HArray1OfExtendedString that holds <newArray> values
        If <isCheckItems> equal True each item of <newArray> will be checked with each
        item of <myValue> for coincidence (to avoid backup).

        :type newArray: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfExtendedString
        :type isCheckItems: bool

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_ChangeArray(self, *args)


    def Array(self, *args):
        """
        Return the inner array of the ExtStringArray attribute

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfExtendedString

        """
        res = _TDataStd.Handle_TDataStd_ExtStringArray_Array(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetDelta(self, *args):
        """
        GetDelta(Handle_TDataStd_ExtStringArray self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_GetDelta(self, *args)


    def SetDelta(self, *args):
        """
        SetDelta(Handle_TDataStd_ExtStringArray self, Standard_Boolean const isDelta)

        for  internal  use  only!

        :type isDelta: bool

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_SetDelta(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_ExtStringArray_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TDataStd_ExtStringArray self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TDataStd_ExtStringArray self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TDataStd_ExtStringArray self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDataStd_ExtStringArray self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_Dump(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TDataStd_ExtStringArray self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDataStd_ExtStringArray self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TDataStd_ExtStringArray self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDataStd_ExtStringArray self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TDataStd_ExtStringArray self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TDataStd_ExtStringArray self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TDataStd_ExtStringArray self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TDataStd_ExtStringArray self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDataStd_ExtStringArray self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TDataStd_ExtStringArray self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TDataStd_ExtStringArray self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TDataStd_ExtStringArray self)

        Something to do after adding an Attribute to a label.


        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TDataStd_ExtStringArray self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TDataStd_ExtStringArray self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TDataStd_ExtStringArray self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TDataStd_ExtStringArray self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TDataStd_ExtStringArray self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TDataStd_ExtStringArray self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TDataStd_ExtStringArray self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TDataStd_ExtStringArray self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TDataStd_ExtStringArray self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TDataStd_ExtStringArray self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TDataStd_ExtStringArray self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TDataStd_ExtStringArray self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TDataStd_ExtStringArray self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TDataStd_ExtStringArray self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_DeltaOnRemoval(self, *args)


    def References(self, *args):
        """
        References(Handle_TDataStd_ExtStringArray self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_References(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDataStd_ExtStringArray self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TDataStd_ExtStringArray self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TDataStd_ExtStringArray self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_ExtStringArray self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_ExtStringArray self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_ExtStringArray self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_ExtStringArray self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_ExtStringArray self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_ExtStringArray self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_ExtStringArray self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_ExtStringArray self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_ExtStringArray self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_ExtStringArray_DecrementRefCounter(self, *args)

Handle_TDataStd_ExtStringArray_swigregister = _TDataStd.Handle_TDataStd_ExtStringArray_swigregister
Handle_TDataStd_ExtStringArray_swigregister(Handle_TDataStd_ExtStringArray)

def Handle_TDataStd_ExtStringArray_DownCast(thing):
    return _TDataStd.Handle_TDataStd_ExtStringArray_DownCast(thing)
Handle_TDataStd_ExtStringArray_DownCast = _TDataStd.Handle_TDataStd_ExtStringArray_DownCast

class NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString self) -> NCollection_DataMap< TCollection_ExtendedString,opencascade::handle< TColStd_HArray1OfReal >,TCollection_ExtendedString >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString self) -> NCollection_DataMap< TCollection_ExtendedString,opencascade::handle< TColStd_HArray1OfReal >,TCollection_ExtendedString >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString self) -> NCollection_DataMap< TCollection_ExtendedString,opencascade::handle< TColStd_HArray1OfReal >,TCollection_ExtendedString >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString self) -> NCollection_DataMap< TCollection_ExtendedString,opencascade::handle< TColStd_HArray1OfReal >,TCollection_ExtendedString >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TDataStd.new_NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString self, NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString self, NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString theOther) -> NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString self, NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString theOther) -> NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString self, TCollection_ExtendedString theKey, Handle_TColStd_HArray1OfReal theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString self, TCollection_ExtendedString theKey, Handle_TColStd_HArray1OfReal theItem) -> Handle_TColStd_HArray1OfReal

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> Handle_TColStd_HArray1OfReal

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> Handle_TColStd_HArray1OfReal

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> Handle_TColStd_HArray1OfReal

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString_Size(self, *args)


    def __iter__(self):
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString___iter__(self)
    __swig_destroy__ = _TDataStd.delete_NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString
NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString_swigregister = _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString_swigregister
NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString_swigregister(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString)

class NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TDataStd.new_NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDataStd.delete_NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString_IteratorHelper

    def __next__(self):
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString_IteratorHelper___next__(self)
NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString_IteratorHelper_swigregister = _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString_IteratorHelper_swigregister
NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString_IteratorHelper_swigregister(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString_IteratorHelper)


try:
	TDataStd_DataMapOfStringHArray1OfReal = NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString
except NameError:
	pass # does not exist, probably ignored

class Handle_TDataStd_BooleanList(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_BooleanList self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_BooleanList_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_BooleanList self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_BooleanList_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_BooleanList self, TDataStd_BooleanList thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_BooleanList_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_BooleanList self, Handle_TDataStd_BooleanList theHandle) -> Handle_TDataStd_BooleanList
        assign(Handle_TDataStd_BooleanList self, TDataStd_BooleanList thePtr) -> Handle_TDataStd_BooleanList
        assign(Handle_TDataStd_BooleanList self, Handle_TDataStd_BooleanList theHandle) -> Handle_TDataStd_BooleanList

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_BooleanList_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_BooleanList self) -> TDataStd_BooleanList

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_BooleanList_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_BooleanList self) -> TDataStd_BooleanList

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_BooleanList___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_BooleanList self) -> TDataStd_BooleanList

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_BooleanList___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_BooleanList___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_BooleanList___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_BooleanList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_BooleanList_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_BooleanList

    def GetID(self, *args):
        """
        Static methods
        ==============
        Returns the ID of the list of booleans attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_BooleanList_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_TDataStd_BooleanList self, TDF_Label label) -> Handle_TDataStd_BooleanList
        Set(Handle_TDataStd_BooleanList self, TDF_Label label, Standard_GUID theGuid) -> Handle_TDataStd_BooleanList

        Finds or creates a list of boolean values attribute with explicit user defined <guid>.

        :type label: OCC.wrapper.TDF.TDF_Label
        :type theGuid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_BooleanList

        """
        return _TDataStd.Handle_TDataStd_BooleanList_Set(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_TDataStd_BooleanList self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_BooleanList_IsEmpty(self, *args)


    def Extent(self, *args):
        """
        Extent(Handle_TDataStd_BooleanList self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_BooleanList_Extent(self, *args)


    def Prepend(self, *args):
        """
        Prepend(Handle_TDataStd_BooleanList self, Standard_Boolean const value)

        :type value: bool

        """
        return _TDataStd.Handle_TDataStd_BooleanList_Prepend(self, *args)


    def Append(self, *args):
        """
        Append(Handle_TDataStd_BooleanList self, Standard_Boolean const value)

        :type value: bool

        """
        return _TDataStd.Handle_TDataStd_BooleanList_Append(self, *args)


    def Clear(self, *args):
        """Clear(Handle_TDataStd_BooleanList self)"""
        return _TDataStd.Handle_TDataStd_BooleanList_Clear(self, *args)


    def First(self, *args):
        """
        First(Handle_TDataStd_BooleanList self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_BooleanList_First(self, *args)


    def Last(self, *args):
        """
        Last(Handle_TDataStd_BooleanList self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_BooleanList_Last(self, *args)


    def List(self, *args):
        """
        1 - means TRUE,
        0 - means FALSE.

        :rtype: OCC.wrapper.TDataStd.TDataStd_ListOfByte

        """
        res = _TDataStd.Handle_TDataStd_BooleanList_List(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def InsertBefore(self, *args):
        """
        InsertBefore(Handle_TDataStd_BooleanList self, Standard_Integer const index, Standard_Boolean const before_value) -> Standard_Boolean

        Inserts the <value> before the <index> position.
        The indices start with 1 .. Extent().

        :type index: int
        :type before_value: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_BooleanList_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(Handle_TDataStd_BooleanList self, Standard_Integer const index, Standard_Boolean const after_value) -> Standard_Boolean

        Inserts the <value> after the <index> position.
        The indices start with 1 .. Extent().

        :type index: int
        :type after_value: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_BooleanList_InsertAfter(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_TDataStd_BooleanList self, Standard_Integer const index) -> Standard_Boolean

        Removes a value at <index> position.

        :type index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_BooleanList_Remove(self, *args)


    def SetID(self, *args):
        """
        SetID(Handle_TDataStd_BooleanList self, Standard_GUID theGuid)
        SetID(Handle_TDataStd_BooleanList self)

        Sets default GUID for the attribute.


        """
        return _TDataStd.Handle_TDataStd_BooleanList_SetID(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_BooleanList_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TDataStd_BooleanList self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_BooleanList_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TDataStd_BooleanList self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_BooleanList_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TDataStd_BooleanList self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.Handle_TDataStd_BooleanList_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDataStd_BooleanList self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_BooleanList_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_BooleanList self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_BooleanList_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_BooleanList_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_BooleanList_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Label(self, *args):
        """
        Label(Handle_TDataStd_BooleanList self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_BooleanList_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDataStd_BooleanList self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_BooleanList_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TDataStd_BooleanList self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_BooleanList_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDataStd_BooleanList self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_BooleanList_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TDataStd_BooleanList self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_BooleanList_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TDataStd_BooleanList self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_BooleanList_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TDataStd_BooleanList self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_BooleanList_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TDataStd_BooleanList self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_BooleanList_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDataStd_BooleanList self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_BooleanList_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TDataStd_BooleanList self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_BooleanList_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TDataStd_BooleanList self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDataStd.Handle_TDataStd_BooleanList_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TDataStd_BooleanList self)

        Something to do after adding an Attribute to a label.


        """
        return _TDataStd.Handle_TDataStd_BooleanList_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TDataStd_BooleanList self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_BooleanList_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TDataStd_BooleanList self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TDataStd.Handle_TDataStd_BooleanList_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TDataStd_BooleanList self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_BooleanList_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TDataStd_BooleanList self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_BooleanList_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TDataStd_BooleanList self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_BooleanList_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TDataStd_BooleanList self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_BooleanList_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TDataStd_BooleanList self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDataStd.Handle_TDataStd_BooleanList_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TDataStd_BooleanList self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDataStd.Handle_TDataStd_BooleanList_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TDataStd_BooleanList self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_BooleanList_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TDataStd_BooleanList self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_BooleanList_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TDataStd_BooleanList self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDataStd.Handle_TDataStd_BooleanList_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TDataStd_BooleanList self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDataStd.Handle_TDataStd_BooleanList_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TDataStd_BooleanList self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDataStd.Handle_TDataStd_BooleanList_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TDataStd_BooleanList self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDataStd.Handle_TDataStd_BooleanList_DeltaOnRemoval(self, *args)


    def References(self, *args):
        """
        References(Handle_TDataStd_BooleanList self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDataStd.Handle_TDataStd_BooleanList_References(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDataStd_BooleanList self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_BooleanList___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TDataStd_BooleanList self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDataStd.Handle_TDataStd_BooleanList_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TDataStd_BooleanList self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDataStd.Handle_TDataStd_BooleanList_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_BooleanList self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_BooleanList_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_BooleanList self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_BooleanList self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_BooleanList_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_BooleanList self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_BooleanList self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_BooleanList_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_BooleanList self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_BooleanList_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_BooleanList self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_BooleanList_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_BooleanList self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_BooleanList_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_BooleanList self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_BooleanList_DecrementRefCounter(self, *args)

Handle_TDataStd_BooleanList_swigregister = _TDataStd.Handle_TDataStd_BooleanList_swigregister
Handle_TDataStd_BooleanList_swigregister(Handle_TDataStd_BooleanList)

def Handle_TDataStd_BooleanList_DownCast(thing):
    return _TDataStd.Handle_TDataStd_BooleanList_DownCast(thing)
Handle_TDataStd_BooleanList_DownCast = _TDataStd.Handle_TDataStd_BooleanList_DownCast

class Handle_TDataStd_HLabelArray1(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_HLabelArray1 self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_HLabelArray1_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_HLabelArray1 self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_HLabelArray1_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_HLabelArray1 self, TDataStd_HLabelArray1 thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_HLabelArray1_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_HLabelArray1 self, Handle_TDataStd_HLabelArray1 theHandle) -> Handle_TDataStd_HLabelArray1
        assign(Handle_TDataStd_HLabelArray1 self, TDataStd_HLabelArray1 thePtr) -> Handle_TDataStd_HLabelArray1
        assign(Handle_TDataStd_HLabelArray1 self, Handle_TDataStd_HLabelArray1 theHandle) -> Handle_TDataStd_HLabelArray1

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_HLabelArray1_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_HLabelArray1 self) -> TDataStd_HLabelArray1

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_HLabelArray1_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_HLabelArray1 self) -> TDataStd_HLabelArray1

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_HLabelArray1___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_HLabelArray1 self) -> TDataStd_HLabelArray1

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_HLabelArray1___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_HLabelArray1___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_HLabelArray1___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_HLabelArray1(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_HLabelArray1_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_HLabelArray1

    def Array1(self, *args):
        """
        :rtype: OCC.wrapper.TDataStd.TDataStd_LabelArray1

        """
        res = _TDataStd.Handle_TDataStd_HLabelArray1_Array1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray1(self, *args):
        """
        ChangeArray1(Handle_TDataStd_HLabelArray1 self) -> NCollection_Array1_TDF_Label

        :rtype: OCC.wrapper.TDataStd.TDataStd_LabelArray1

        """
        return _TDataStd.Handle_TDataStd_HLabelArray1_ChangeArray1(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_HLabelArray1 self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_HLabelArray1_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_HLabelArray1_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_HLabelArray1_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_HLabelArray1 self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_HLabelArray1_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_HLabelArray1 self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_HLabelArray1 self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_HLabelArray1_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_HLabelArray1 self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_HLabelArray1 self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_HLabelArray1_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_HLabelArray1 self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_HLabelArray1_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_HLabelArray1 self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_HLabelArray1_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_HLabelArray1 self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_HLabelArray1_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_HLabelArray1 self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_HLabelArray1_DecrementRefCounter(self, *args)

Handle_TDataStd_HLabelArray1_swigregister = _TDataStd.Handle_TDataStd_HLabelArray1_swigregister
Handle_TDataStd_HLabelArray1_swigregister(Handle_TDataStd_HLabelArray1)

def Handle_TDataStd_HLabelArray1_DownCast(thing):
    return _TDataStd.Handle_TDataStd_HLabelArray1_DownCast(thing)
Handle_TDataStd_HLabelArray1_DownCast = _TDataStd.Handle_TDataStd_HLabelArray1_DownCast

class TDataStd_HDataMapOfStringInteger(Standard.Standard_Transient):
    """
    Extension of TColStd_DataMapOfStringInteger class
    to be manipulated by handle.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_HDataMapOfStringInteger
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_HDataMapOfStringInteger(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_HDataMapOfStringInteger_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_HDataMapOfStringInteger_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_HDataMapOfStringInteger_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(TDataStd_HDataMapOfStringInteger self, Standard_Integer const NbBuckets=1) -> TDataStd_HDataMapOfStringInteger
        __init__(TDataStd_HDataMapOfStringInteger self, NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString theOther) -> TDataStd_HDataMapOfStringInteger

        :type theOther: OCC.wrapper.TColStd.TColStd_DataMapOfStringInteger

        """
        this = _TDataStd.new_TDataStd_HDataMapOfStringInteger(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Map(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_DataMapOfStringInteger

        """
        res = _TDataStd.TDataStd_HDataMapOfStringInteger_Map(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeMap(self, *args):
        """
        ChangeMap(TDataStd_HDataMapOfStringInteger self) -> NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString

        :rtype: OCC.wrapper.TColStd.TColStd_DataMapOfStringInteger

        """
        return _TDataStd.TDataStd_HDataMapOfStringInteger_ChangeMap(self, *args)

    __swig_destroy__ = _TDataStd.delete_TDataStd_HDataMapOfStringInteger
TDataStd_HDataMapOfStringInteger_swigregister = _TDataStd.TDataStd_HDataMapOfStringInteger_swigregister
TDataStd_HDataMapOfStringInteger_swigregister(TDataStd_HDataMapOfStringInteger)

def TDataStd_HDataMapOfStringInteger_get_type_name(*args):
    """
    TDataStd_HDataMapOfStringInteger_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_HDataMapOfStringInteger_get_type_name(*args)

def TDataStd_HDataMapOfStringInteger_get_type_descriptor(*args):
    """
    TDataStd_HDataMapOfStringInteger_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_HDataMapOfStringInteger_get_type_descriptor(*args)

class Handle_TDataStd_HDataMapOfStringHArray1OfReal(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_HDataMapOfStringHArray1OfReal self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfReal_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_HDataMapOfStringHArray1OfReal self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfReal_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_HDataMapOfStringHArray1OfReal self, TDataStd_HDataMapOfStringHArray1OfReal thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfReal_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_HDataMapOfStringHArray1OfReal self, Handle_TDataStd_HDataMapOfStringHArray1OfReal theHandle) -> Handle_TDataStd_HDataMapOfStringHArray1OfReal
        assign(Handle_TDataStd_HDataMapOfStringHArray1OfReal self, TDataStd_HDataMapOfStringHArray1OfReal thePtr) -> Handle_TDataStd_HDataMapOfStringHArray1OfReal
        assign(Handle_TDataStd_HDataMapOfStringHArray1OfReal self, Handle_TDataStd_HDataMapOfStringHArray1OfReal theHandle) -> Handle_TDataStd_HDataMapOfStringHArray1OfReal

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfReal_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_HDataMapOfStringHArray1OfReal self) -> TDataStd_HDataMapOfStringHArray1OfReal

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfReal_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_HDataMapOfStringHArray1OfReal self) -> TDataStd_HDataMapOfStringHArray1OfReal

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfReal___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_HDataMapOfStringHArray1OfReal self) -> TDataStd_HDataMapOfStringHArray1OfReal

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfReal___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfReal___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfReal___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_HDataMapOfStringHArray1OfReal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfReal_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_HDataMapOfStringHArray1OfReal

    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_HDataMapOfStringHArray1OfReal self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfReal_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfReal_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfReal_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Map(self, *args):
        """
        :rtype: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringHArray1OfReal

        """
        res = _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfReal_Map(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeMap(self, *args):
        """
        ChangeMap(Handle_TDataStd_HDataMapOfStringHArray1OfReal self) -> NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfReal_TCollection_ExtendedString

        :rtype: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringHArray1OfReal

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfReal_ChangeMap(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_HDataMapOfStringHArray1OfReal self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfReal_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_HDataMapOfStringHArray1OfReal self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_HDataMapOfStringHArray1OfReal self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfReal_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_HDataMapOfStringHArray1OfReal self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_HDataMapOfStringHArray1OfReal self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfReal_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_HDataMapOfStringHArray1OfReal self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfReal_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_HDataMapOfStringHArray1OfReal self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfReal_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_HDataMapOfStringHArray1OfReal self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfReal_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_HDataMapOfStringHArray1OfReal self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfReal_DecrementRefCounter(self, *args)

Handle_TDataStd_HDataMapOfStringHArray1OfReal_swigregister = _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfReal_swigregister
Handle_TDataStd_HDataMapOfStringHArray1OfReal_swigregister(Handle_TDataStd_HDataMapOfStringHArray1OfReal)

def Handle_TDataStd_HDataMapOfStringHArray1OfReal_DownCast(thing):
    return _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfReal_DownCast(thing)
Handle_TDataStd_HDataMapOfStringHArray1OfReal_DownCast = _TDataStd.Handle_TDataStd_HDataMapOfStringHArray1OfReal_DownCast

class Handle_TDataStd_UAttribute(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_UAttribute self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_UAttribute_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_UAttribute self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_UAttribute_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_UAttribute self, TDataStd_UAttribute thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_UAttribute_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_UAttribute self, Handle_TDataStd_UAttribute theHandle) -> Handle_TDataStd_UAttribute
        assign(Handle_TDataStd_UAttribute self, TDataStd_UAttribute thePtr) -> Handle_TDataStd_UAttribute
        assign(Handle_TDataStd_UAttribute self, Handle_TDataStd_UAttribute theHandle) -> Handle_TDataStd_UAttribute

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_UAttribute_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_UAttribute self) -> TDataStd_UAttribute

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_UAttribute_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_UAttribute self) -> TDataStd_UAttribute

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_UAttribute___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_UAttribute self) -> TDataStd_UAttribute

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_UAttribute___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_UAttribute___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_UAttribute___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_UAttribute(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_UAttribute_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_UAttribute

    def Set(self, *args):
        """
        Set(Handle_TDataStd_UAttribute self, TDF_Label label, Standard_GUID LocalID) -> Handle_TDataStd_UAttribute

        api class methods
        =============
        Find, or create, a UAttribute attribute with <LocalID> as Local GUID.
        The UAttribute attribute is returned.
        UAttribute methods
        ============

        :type label: OCC.wrapper.TDF.TDF_Label
        :type LocalID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_UAttribute

        """
        return _TDataStd.Handle_TDataStd_UAttribute_Set(self, *args)


    def SetID(self, *args):
        """
        SetID(Handle_TDataStd_UAttribute self, Standard_GUID LocalID)

        :type LocalID: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.Handle_TDataStd_UAttribute_SetID(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_UAttribute_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TDataStd_UAttribute self, Handle_TDF_Attribute arg2)

        :type with: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_UAttribute_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TDataStd_UAttribute self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_UAttribute_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TDataStd_UAttribute self, Handle_TDF_Attribute into, Handle_TDF_RelocationTable RT)

        :type into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.Handle_TDataStd_UAttribute_Paste(self, *args)


    def References(self, *args):
        """
        References(Handle_TDataStd_UAttribute self, Handle_TDF_DataSet DS)

        :type DS: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDataStd.Handle_TDataStd_UAttribute_References(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDataStd_UAttribute self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_UAttribute_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_UAttribute self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_UAttribute_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_UAttribute_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_UAttribute_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Label(self, *args):
        """
        Label(Handle_TDataStd_UAttribute self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_UAttribute_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDataStd_UAttribute self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_UAttribute_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TDataStd_UAttribute self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_UAttribute_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDataStd_UAttribute self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_UAttribute_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TDataStd_UAttribute self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_UAttribute_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TDataStd_UAttribute self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_UAttribute_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TDataStd_UAttribute self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_UAttribute_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TDataStd_UAttribute self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_UAttribute_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDataStd_UAttribute self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_UAttribute_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TDataStd_UAttribute self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_UAttribute_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TDataStd_UAttribute self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDataStd.Handle_TDataStd_UAttribute_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TDataStd_UAttribute self)

        Something to do after adding an Attribute to a label.


        """
        return _TDataStd.Handle_TDataStd_UAttribute_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TDataStd_UAttribute self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_UAttribute_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TDataStd_UAttribute self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TDataStd.Handle_TDataStd_UAttribute_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TDataStd_UAttribute self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_UAttribute_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TDataStd_UAttribute self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_UAttribute_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TDataStd_UAttribute self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_UAttribute_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TDataStd_UAttribute self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_UAttribute_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TDataStd_UAttribute self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDataStd.Handle_TDataStd_UAttribute_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TDataStd_UAttribute self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDataStd.Handle_TDataStd_UAttribute_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TDataStd_UAttribute self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_UAttribute_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TDataStd_UAttribute self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_UAttribute_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TDataStd_UAttribute self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDataStd.Handle_TDataStd_UAttribute_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TDataStd_UAttribute self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDataStd.Handle_TDataStd_UAttribute_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TDataStd_UAttribute self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDataStd.Handle_TDataStd_UAttribute_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TDataStd_UAttribute self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDataStd.Handle_TDataStd_UAttribute_DeltaOnRemoval(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDataStd_UAttribute self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_UAttribute___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TDataStd_UAttribute self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDataStd.Handle_TDataStd_UAttribute_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TDataStd_UAttribute self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDataStd.Handle_TDataStd_UAttribute_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_UAttribute self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_UAttribute_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_UAttribute self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_UAttribute self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_UAttribute_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_UAttribute self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_UAttribute self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_UAttribute_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_UAttribute self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_UAttribute_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_UAttribute self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_UAttribute_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_UAttribute self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_UAttribute_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_UAttribute self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_UAttribute_DecrementRefCounter(self, *args)

Handle_TDataStd_UAttribute_swigregister = _TDataStd.Handle_TDataStd_UAttribute_swigregister
Handle_TDataStd_UAttribute_swigregister(Handle_TDataStd_UAttribute)

def Handle_TDataStd_UAttribute_DownCast(thing):
    return _TDataStd.Handle_TDataStd_UAttribute_DownCast(thing)
Handle_TDataStd_UAttribute_DownCast = _TDataStd.Handle_TDataStd_UAttribute_DownCast

class TDataStd_(object):
    """
    This  package  defines   standard attributes for
    modelling.
    These allow you to create and modify labels
    and attributes for many basic data types.
    Standard topological and visualization
    attributes have also been created.
    To find an attribute attached to a specific label,
    you use the GUID of the type of attribute you
    are looking for. To do this, first find this
    information using the method GetID as follows: Standard_GUID anID =
    MyAttributeClass::GetID();
    Then, use the method Find for the label as follows:
    Standard_Boolean HasAttribute
    =
    aLabel.Find(anID,anAttribute);
    Note
    For information on the relations between this
    component of OCAF and the others, refer to the OCAF User's Guide.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def IDList(*args):
        """
        IDList(NCollection_List_Standard_GUID anIDList)

        Appends to <anIDList> the list of the attributes
        IDs of this package. CAUTION: <anIDList> is NOT
        cleared before use.

        :type anIDList: OCC.wrapper.TDF.TDF_IDList

        """
        return _TDataStd.TDataStd__IDList(*args)

    IDList = staticmethod(IDList)

    def Print(*args):
        """
        Print(TDataStd_RealEnum const DIM, Standard_OStream & S) -> Standard_OStream &

        Prints the name of the real dimension <DIM> as a String on
        the Stream <S> and returns <S>.

        :type DIM: OCC.wrapper.TDataStd.TDataStd_RealEnum
        :type S: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.TDataStd__Print(*args)

    Print = staticmethod(Print)

    def __init__(self):
        """
        This  package  defines   standard attributes for
        modelling.
        These allow you to create and modify labels
        and attributes for many basic data types.
        Standard topological and visualization
        attributes have also been created.
        To find an attribute attached to a specific label,
        you use the GUID of the type of attribute you
        are looking for. To do this, first find this
        information using the method GetID as follows: Standard_GUID anID =
        MyAttributeClass::GetID();
        Then, use the method Find for the label as follows:
        Standard_Boolean HasAttribute
        =
        aLabel.Find(anID,anAttribute);
        Note
        For information on the relations between this
        component of OCAF and the others, refer to the OCAF User's Guide.
        """
        this = _TDataStd.new_TDataStd_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDataStd.delete_TDataStd_
TDataStd__swigregister = _TDataStd.TDataStd__swigregister
TDataStd__swigregister(TDataStd_)

def TDataStd__IDList(*args):
    """
    TDataStd__IDList(NCollection_List_Standard_GUID anIDList)

    Appends to <anIDList> the list of the attributes
    IDs of this package. CAUTION: <anIDList> is NOT
    cleared before use.

    :type anIDList: OCC.wrapper.TDF.TDF_IDList

    """
    return _TDataStd.TDataStd__IDList(*args)

def TDataStd__Print(*args):
    """
    TDataStd__Print(TDataStd_RealEnum const DIM, Standard_OStream & S) -> Standard_OStream &

    Prints the name of the real dimension <DIM> as a String on
    the Stream <S> and returns <S>.

    :type DIM: OCC.wrapper.TDataStd.TDataStd_RealEnum
    :type S: OCC.wrapper.Standard.Standard_OStream
    :rtype: OCC.wrapper.Standard.Standard_OStream

    """
    return _TDataStd.TDataStd__Print(*args)

class TDataStd_ChildNodeIterator(object):
    """
    Iterates on the  ChildStepren step of  a step, at the
    first level  only.   It  is possible  to ask  the
    iterator to explore all the sub step levels of the
    given one, with the option "allLevels".
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TDataStd_ChildNodeIterator self) -> TDataStd_ChildNodeIterator
        __init__(TDataStd_ChildNodeIterator self, Handle_TDataStd_TreeNode aTreeNode, Standard_Boolean const allLevels) -> TDataStd_ChildNodeIterator

        Iterates on the ChildStepren of the given Step. If
        <allLevels> option is set to true, it explores not
        only the first, but all the sub Step levels.

        :type aTreeNode: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode
        :type allLevels: bool

        """
        this = _TDataStd.new_TDataStd_ChildNodeIterator(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Initialize(self, *args):
        """
        Initialize(TDataStd_ChildNodeIterator self, Handle_TDataStd_TreeNode aTreeNode, Standard_Boolean const allLevels)

        Initializes the iteration on  the Children Step of
        the  given Step. If <allLevels>  option is  set to
        true, it explores not  only the first, but all the
        sub Step levels.

        :type aTreeNode: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode
        :type allLevels: bool

        """
        return _TDataStd.TDataStd_ChildNodeIterator_Initialize(self, *args)


    def More(self, *args):
        """
        More(TDataStd_ChildNodeIterator self) -> Standard_Boolean

        Returns True if there is a current Item in the
        iteration.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_ChildNodeIterator_More(self, *args)


    def Next(self, *args):
        """
        Next(TDataStd_ChildNodeIterator self)

        Move to the next Item


        """
        return _TDataStd.TDataStd_ChildNodeIterator_Next(self, *args)


    def NextBrother(self, *args):
        """
        NextBrother(TDataStd_ChildNodeIterator self)

        Move to the next Brother. If there is none, go up
        etc. This method is interesting only with
        "allLevels" behavior, because it avoids to explore
        the current Step ChildStepren.


        """
        return _TDataStd.TDataStd_ChildNodeIterator_NextBrother(self, *args)


    def Value(self, *args):
        """
        Returns the current item; a null Step if there is
        no one.

        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode

        """
        res = _TDataStd.TDataStd_ChildNodeIterator_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDataStd.delete_TDataStd_ChildNodeIterator
TDataStd_ChildNodeIterator_swigregister = _TDataStd.TDataStd_ChildNodeIterator_swigregister
TDataStd_ChildNodeIterator_swigregister(TDataStd_ChildNodeIterator)

class Handle_TDataStd_DeltaOnModificationOfRealArray(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_DeltaOnModificationOfRealArray self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfRealArray_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_DeltaOnModificationOfRealArray self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfRealArray_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_DeltaOnModificationOfRealArray self, TDataStd_DeltaOnModificationOfRealArray thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfRealArray_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_DeltaOnModificationOfRealArray self, Handle_TDataStd_DeltaOnModificationOfRealArray theHandle) -> Handle_TDataStd_DeltaOnModificationOfRealArray
        assign(Handle_TDataStd_DeltaOnModificationOfRealArray self, TDataStd_DeltaOnModificationOfRealArray thePtr) -> Handle_TDataStd_DeltaOnModificationOfRealArray
        assign(Handle_TDataStd_DeltaOnModificationOfRealArray self, Handle_TDataStd_DeltaOnModificationOfRealArray theHandle) -> Handle_TDataStd_DeltaOnModificationOfRealArray

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfRealArray_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_DeltaOnModificationOfRealArray self) -> TDataStd_DeltaOnModificationOfRealArray

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfRealArray_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_DeltaOnModificationOfRealArray self) -> TDataStd_DeltaOnModificationOfRealArray

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfRealArray___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_DeltaOnModificationOfRealArray self) -> TDataStd_DeltaOnModificationOfRealArray

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfRealArray___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfRealArray___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_DeltaOnModificationOfRealArray___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_DeltaOnModificationOfRealArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_DeltaOnModificationOfRealArray_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_DeltaOnModificationOfRealArray

    def Apply(self, *args):
        """
        Apply(Handle_TDataStd_DeltaOnModificationOfRealArray self)

        Applies the delta to the attribute.


        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfRealArray_Apply(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_DeltaOnModificationOfRealArray self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfRealArray_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_DeltaOnModificationOfRealArray_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_DeltaOnModificationOfRealArray_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Label(self, *args):
        """
        Label(Handle_TDataStd_DeltaOnModificationOfRealArray self) -> TDF_Label

        Returns the label concerned by <me>.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfRealArray_Label(self, *args)


    def Attribute(self, *args):
        """
        Attribute(Handle_TDataStd_DeltaOnModificationOfRealArray self) -> Handle_TDF_Attribute

        Returns the reference attribute.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfRealArray_Attribute(self, *args)


    def ID(self, *args):
        """
        ID(Handle_TDataStd_DeltaOnModificationOfRealArray self) -> Standard_GUID

        Returns the ID of the attribute concerned by <me>.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfRealArray_ID(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDataStd_DeltaOnModificationOfRealArray self, Standard_OStream & OS) -> Standard_OStream &

        Dumps the contents.

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfRealArray_Dump(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDataStd_DeltaOnModificationOfRealArray self, Standard_OStream & OS) -> Standard_OStream &

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfRealArray___lshift__(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_DeltaOnModificationOfRealArray self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfRealArray_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_DeltaOnModificationOfRealArray self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_DeltaOnModificationOfRealArray self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfRealArray_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_DeltaOnModificationOfRealArray self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_DeltaOnModificationOfRealArray self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfRealArray_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_DeltaOnModificationOfRealArray self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfRealArray_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_DeltaOnModificationOfRealArray self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfRealArray_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_DeltaOnModificationOfRealArray self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfRealArray_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_DeltaOnModificationOfRealArray self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfRealArray_DecrementRefCounter(self, *args)

Handle_TDataStd_DeltaOnModificationOfRealArray_swigregister = _TDataStd.Handle_TDataStd_DeltaOnModificationOfRealArray_swigregister
Handle_TDataStd_DeltaOnModificationOfRealArray_swigregister(Handle_TDataStd_DeltaOnModificationOfRealArray)

def Handle_TDataStd_DeltaOnModificationOfRealArray_DownCast(thing):
    return _TDataStd.Handle_TDataStd_DeltaOnModificationOfRealArray_DownCast(thing)
Handle_TDataStd_DeltaOnModificationOfRealArray_DownCast = _TDataStd.Handle_TDataStd_DeltaOnModificationOfRealArray_DownCast

class Handle_TDataStd_DeltaOnModificationOfIntPackedMap(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_DeltaOnModificationOfIntPackedMap self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntPackedMap_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_DeltaOnModificationOfIntPackedMap self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntPackedMap_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_DeltaOnModificationOfIntPackedMap self, TDataStd_DeltaOnModificationOfIntPackedMap thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntPackedMap_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_DeltaOnModificationOfIntPackedMap self, Handle_TDataStd_DeltaOnModificationOfIntPackedMap theHandle) -> Handle_TDataStd_DeltaOnModificationOfIntPackedMap
        assign(Handle_TDataStd_DeltaOnModificationOfIntPackedMap self, TDataStd_DeltaOnModificationOfIntPackedMap thePtr) -> Handle_TDataStd_DeltaOnModificationOfIntPackedMap
        assign(Handle_TDataStd_DeltaOnModificationOfIntPackedMap self, Handle_TDataStd_DeltaOnModificationOfIntPackedMap theHandle) -> Handle_TDataStd_DeltaOnModificationOfIntPackedMap

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntPackedMap_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_DeltaOnModificationOfIntPackedMap self) -> TDataStd_DeltaOnModificationOfIntPackedMap

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntPackedMap_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_DeltaOnModificationOfIntPackedMap self) -> TDataStd_DeltaOnModificationOfIntPackedMap

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntPackedMap___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_DeltaOnModificationOfIntPackedMap self) -> TDataStd_DeltaOnModificationOfIntPackedMap

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntPackedMap___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntPackedMap___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntPackedMap___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_DeltaOnModificationOfIntPackedMap(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_DeltaOnModificationOfIntPackedMap_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_DeltaOnModificationOfIntPackedMap

    def Apply(self, *args):
        """
        Apply(Handle_TDataStd_DeltaOnModificationOfIntPackedMap self)

        Applies the delta to the attribute.


        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntPackedMap_Apply(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_DeltaOnModificationOfIntPackedMap self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntPackedMap_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntPackedMap_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntPackedMap_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Label(self, *args):
        """
        Label(Handle_TDataStd_DeltaOnModificationOfIntPackedMap self) -> TDF_Label

        Returns the label concerned by <me>.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntPackedMap_Label(self, *args)


    def Attribute(self, *args):
        """
        Attribute(Handle_TDataStd_DeltaOnModificationOfIntPackedMap self) -> Handle_TDF_Attribute

        Returns the reference attribute.

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntPackedMap_Attribute(self, *args)


    def ID(self, *args):
        """
        ID(Handle_TDataStd_DeltaOnModificationOfIntPackedMap self) -> Standard_GUID

        Returns the ID of the attribute concerned by <me>.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntPackedMap_ID(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDataStd_DeltaOnModificationOfIntPackedMap self, Standard_OStream & OS) -> Standard_OStream &

        Dumps the contents.

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntPackedMap_Dump(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDataStd_DeltaOnModificationOfIntPackedMap self, Standard_OStream & OS) -> Standard_OStream &

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntPackedMap___lshift__(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_DeltaOnModificationOfIntPackedMap self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntPackedMap_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_DeltaOnModificationOfIntPackedMap self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_DeltaOnModificationOfIntPackedMap self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntPackedMap_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_DeltaOnModificationOfIntPackedMap self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_DeltaOnModificationOfIntPackedMap self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntPackedMap_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_DeltaOnModificationOfIntPackedMap self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntPackedMap_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_DeltaOnModificationOfIntPackedMap self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntPackedMap_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_DeltaOnModificationOfIntPackedMap self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntPackedMap_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_DeltaOnModificationOfIntPackedMap self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntPackedMap_DecrementRefCounter(self, *args)

Handle_TDataStd_DeltaOnModificationOfIntPackedMap_swigregister = _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntPackedMap_swigregister
Handle_TDataStd_DeltaOnModificationOfIntPackedMap_swigregister(Handle_TDataStd_DeltaOnModificationOfIntPackedMap)

def Handle_TDataStd_DeltaOnModificationOfIntPackedMap_DownCast(thing):
    return _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntPackedMap_DownCast(thing)
Handle_TDataStd_DeltaOnModificationOfIntPackedMap_DownCast = _TDataStd.Handle_TDataStd_DeltaOnModificationOfIntPackedMap_DownCast

class TDataStd_Integer(TDF.TDF_Attribute):
    """The basis to define an integer attribute."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_Integer
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_Integer(self) 
            return h


    def GetID(*args):
        """
        GetID() -> Standard_GUID

        class methods
        =============
        Returns the GUID for integers.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.TDataStd_Integer_GetID(*args)

    GetID = staticmethod(GetID)

    def Set(self, *args):
        """
        Set(TDataStd_Integer self, TDF_Label label, Standard_Integer const value) -> Handle_TDataStd_Integer
        Set(TDataStd_Integer self, TDF_Label label, Standard_GUID guid, Standard_Integer const value) -> Handle_TDataStd_Integer
        Set(TDataStd_Integer self, Standard_Integer const V)

        Integer methods
        ===============

        :type V: int

        """
        return _TDataStd.TDataStd_Integer_Set(self, *args)


    def SetID(self, *args):
        """
        SetID(TDataStd_Integer self, Standard_GUID guid)
        SetID(TDataStd_Integer self)

        Sets default GUID for the attribute.


        """
        return _TDataStd.TDataStd_Integer_SetID(self, *args)


    def Get(self, *args):
        """
        Get(TDataStd_Integer self) -> Standard_Integer

        Returns the integer value contained in the attribute.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.TDataStd_Integer_Get(self, *args)


    def IsCaptured(self, *args):
        """
        IsCaptured(TDataStd_Integer self) -> Standard_Boolean

        Returns True if there is a reference on the same label

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_Integer_IsCaptured(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.TDataStd_Integer_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TDataStd_Integer self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_Integer_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TDataStd_Integer self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_Integer_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TDataStd_Integer self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.TDataStd_Integer_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(TDataStd_Integer self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.TDataStd_Integer_Dump(self, *args)


    def __init__(self, *args):
        """
        __init__(TDataStd_Integer self) -> TDataStd_Integer

        The basis to define an integer attribute.
        """
        this = _TDataStd.new_TDataStd_Integer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_Integer_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_Integer_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_Integer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TDataStd.delete_TDataStd_Integer
TDataStd_Integer_swigregister = _TDataStd.TDataStd_Integer_swigregister
TDataStd_Integer_swigregister(TDataStd_Integer)

def TDataStd_Integer_GetID(*args):
    """
    TDataStd_Integer_GetID() -> Standard_GUID

    class methods
    =============
    Returns the GUID for integers.

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TDataStd.TDataStd_Integer_GetID(*args)

def TDataStd_Integer_get_type_name(*args):
    """
    TDataStd_Integer_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_Integer_get_type_name(*args)

def TDataStd_Integer_get_type_descriptor(*args):
    """
    TDataStd_Integer_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_Integer_get_type_descriptor(*args)

class NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString self) -> NCollection_DataMap< TCollection_ExtendedString,opencascade::handle< TColStd_HArray1OfInteger >,TCollection_ExtendedString >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString self) -> NCollection_DataMap< TCollection_ExtendedString,opencascade::handle< TColStd_HArray1OfInteger >,TCollection_ExtendedString >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString self) -> NCollection_DataMap< TCollection_ExtendedString,opencascade::handle< TColStd_HArray1OfInteger >,TCollection_ExtendedString >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString self) -> NCollection_DataMap< TCollection_ExtendedString,opencascade::handle< TColStd_HArray1OfInteger >,TCollection_ExtendedString >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TDataStd.new_NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString self, NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString self, NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString theOther) -> NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString self, NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString theOther) -> NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString self, TCollection_ExtendedString theKey, Handle_TColStd_HArray1OfInteger theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString self, TCollection_ExtendedString theKey, Handle_TColStd_HArray1OfInteger theItem) -> Handle_TColStd_HArray1OfInteger

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> Handle_TColStd_HArray1OfInteger

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> Handle_TColStd_HArray1OfInteger

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> Handle_TColStd_HArray1OfInteger

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString_Size(self, *args)


    def __iter__(self):
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString___iter__(self)
    __swig_destroy__ = _TDataStd.delete_NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString
NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString_swigregister = _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString_swigregister
NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString_swigregister(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString)

class NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TDataStd.new_NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDataStd.delete_NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString_IteratorHelper

    def __next__(self):
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString_IteratorHelper___next__(self)
NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString_IteratorHelper_swigregister = _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString_IteratorHelper_swigregister
NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString_IteratorHelper_swigregister(NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString_IteratorHelper)


try:
	TDataStd_DataMapOfStringHArray1OfInteger = NCollection_DataMap_TCollection_ExtendedString_Handle_TColStd_HArray1OfInteger_TCollection_ExtendedString
except NameError:
	pass # does not exist, probably ignored

class NCollection_Array1_TDF_Label(object):
    """
    Purpose:     The class Array1 represents unidimensional arrays 
    of fixed size known at run time. 
    The range of the index is user defined.
    An array1 can be constructed with a "C array".
    This functionality is useful to call methods expecting
    an Array1. It allows to carry the bounds inside the arrays.

    Examples:    Item tab[100]; //  An example with a C array
    Array1OfItem ttab (tab[0],1,100);

    Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

    If you want to reindex an array from 1 to Length do :

    Array1 tab1(tab(tab.Lower()),1,tab.Length());

    Warning:     Programs client of such a class must be independant
    of the range of the first element. Then, a C++ for
    loop must be written like this

    for (i = A.Lower(); i <= A.Upper(); i++)

    Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
    renamed into myDeletable (alike in  the Array2).  For naming
    compatibility the method IsAllocated remained in class along
    with IsDeletable.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Array1_TDF_Label self) -> NCollection_Array1< TDF_Label >::iterator

        Returns an iterator pointing to the first element in the array.

        :rtype: iterator

        """
        return _TDataStd.NCollection_Array1_TDF_Label_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Array1_TDF_Label self) -> NCollection_Array1< TDF_Label >::iterator

        Returns an iterator referring to the past-the-end element in the array.

        :rtype: iterator

        """
        return _TDataStd.NCollection_Array1_TDF_Label_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Array1_TDF_Label self) -> NCollection_Array1< TDF_Label >::const_iterator

        Returns a const iterator pointing to the first element in the array.

        :rtype: const_iterator

        """
        return _TDataStd.NCollection_Array1_TDF_Label_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Array1_TDF_Label self) -> NCollection_Array1< TDF_Label >::const_iterator

        Returns a const iterator referring to the past-the-end element in the array.

        :rtype: const_iterator

        """
        return _TDataStd.NCollection_Array1_TDF_Label_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The class Array1 represents unidimensional arrays 
        of fixed size known at run time. 
        The range of the index is user defined.
        An array1 can be constructed with a "C array".
        This functionality is useful to call methods expecting
        an Array1. It allows to carry the bounds inside the arrays.

        Examples:    Item tab[100]; //  An example with a C array
        Array1OfItem ttab (tab[0],1,100);

        Array1OfItem tttab (ttab(10),10,20); // a slice of ttab

        If you want to reindex an array from 1 to Length do :

        Array1 tab1(tab(tab.Lower()),1,tab.Length());

        Warning:     Programs client of such a class must be independant
        of the range of the first element. Then, a C++ for
        loop must be written like this

        for (i = A.Lower(); i <= A.Upper(); i++)

        Changes:     In  comparison  to  TCollection  the  flag  isAllocated  was
        renamed into myDeletable (alike in  the Array2).  For naming
        compatibility the method IsAllocated remained in class along
        with IsDeletable.
        """
        this = _TDataStd.new_NCollection_Array1_TDF_Label(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(NCollection_Array1_TDF_Label self, TDF_Label theValue)

        Initialise the items with theValue

        :type theValue: const TheItemType &

        """
        return _TDataStd.NCollection_Array1_TDF_Label_Init(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Array1_TDF_Label self) -> Standard_Integer

        Size query

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.NCollection_Array1_TDF_Label_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Array1_TDF_Label self) -> Standard_Integer

        Length query (the same)

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.NCollection_Array1_TDF_Label_Length(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Array1_TDF_Label self) -> Standard_Boolean

        Return TRUE if array has zero length.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.NCollection_Array1_TDF_Label_IsEmpty(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Array1_TDF_Label self) -> Standard_Integer

        Lower bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.NCollection_Array1_TDF_Label_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Array1_TDF_Label self) -> Standard_Integer

        Upper bound

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.NCollection_Array1_TDF_Label_Upper(self, *args)


    def IsDeletable(self, *args):
        """
        IsDeletable(NCollection_Array1_TDF_Label self) -> Standard_Boolean

        myDeletable flag

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.NCollection_Array1_TDF_Label_IsDeletable(self, *args)


    def IsAllocated(self, *args):
        """
        IsAllocated(NCollection_Array1_TDF_Label self) -> Standard_Boolean

        IsAllocated flag - for naming compatibility

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.NCollection_Array1_TDF_Label_IsAllocated(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Array1_TDF_Label self, NCollection_Array1_TDF_Label theOther) -> NCollection_Array1_TDF_Label

        Copies data of theOther array to this.
        This array should be pre-allocated and have the same length as theOther;
        otherwise exception Standard_DimensionMismatch is thrown.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TDataStd.NCollection_Array1_TDF_Label_Assign(self, *args)


    def Move(self, *args):
        """
        Move(NCollection_Array1_TDF_Label self, NCollection_Array1_TDF_Label theOther) -> NCollection_Array1_TDF_Label

        Move assignment.
        This array will borrow all the data from theOther.
        The moved object will keep pointer to the memory buffer and
        range, but it will not free the buffer on destruction.

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TDataStd.NCollection_Array1_TDF_Label_Move(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Array1_TDF_Label self, NCollection_Array1_TDF_Label theOther) -> NCollection_Array1_TDF_Label
        assign(NCollection_Array1_TDF_Label self, NCollection_Array1_TDF_Label theOther) -> NCollection_Array1_TDF_Label

        Move assignment operator; @sa Move()

        :type theOther: OCC.wrapper.NCollection.NCollection_Array1<TheItemType> &&
        :rtype: OCC.wrapper.NCollection.NCollection_Array1

        """
        return _TDataStd.NCollection_Array1_TDF_Label_assign(self, *args)


    def First(self, *args):
        """
        @return first element

        :rtype: const TheItemType &

        """
        res = _TDataStd.NCollection_Array1_TDF_Label_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Array1_TDF_Label self) -> TDF_Label

        @return first element

        :rtype: TheItemType &

        """
        return _TDataStd.NCollection_Array1_TDF_Label_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        @return last element

        :rtype: const TheItemType &

        """
        res = _TDataStd.NCollection_Array1_TDF_Label_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Array1_TDF_Label self) -> TDF_Label

        @return last element

        :rtype: TheItemType &

        """
        return _TDataStd.NCollection_Array1_TDF_Label_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant value access

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TDataStd.NCollection_Array1_TDF_Label_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Array1_TDF_Label self, Standard_Integer const theIndex) -> TDF_Label

        Variable value access

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _TDataStd.NCollection_Array1_TDF_Label_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        operator() - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TDataStd.NCollection_Array1_TDF_Label___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __getitem__(self, *args):
        """
        operator[] - alias to Value

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _TDataStd.NCollection_Array1_TDF_Label_at(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Array1_TDF_Label self, Standard_Integer const theIndex, TDF_Label theItem)

        Set value 

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _TDataStd.NCollection_Array1_TDF_Label_SetValue(self, *args)


    def Resize(self, *args):
        """
        Resize(NCollection_Array1_TDF_Label self, Standard_Integer const theLower, Standard_Integer const theUpper, Standard_Boolean const theToCopyData)

        Resizes the array to specified bounds.
        No re-allocation will be done if length of array does not change,
        but existing values will not be discarded if theToCopyData set to FALSE.
        @param theLower new lower bound of array
        @param theUpper new upper bound of array
        @param theToCopyData flag to copy existing data into new array

        :type theLower: int
        :type theUpper: int
        :type theToCopyData: bool

        """
        return _TDataStd.NCollection_Array1_TDF_Label_Resize(self, *args)

    __swig_destroy__ = _TDataStd.delete_NCollection_Array1_TDF_Label
NCollection_Array1_TDF_Label_swigregister = _TDataStd.NCollection_Array1_TDF_Label_swigregister
NCollection_Array1_TDF_Label_swigregister(NCollection_Array1_TDF_Label)


try:
	TDataStd_LabelArray1 = NCollection_Array1_TDF_Label
except NameError:
	pass # does not exist, probably ignored

class Handle_TDataStd_IntegerArray(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_IntegerArray self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_IntegerArray_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_IntegerArray self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_IntegerArray self, TDataStd_IntegerArray thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_IntegerArray self, Handle_TDataStd_IntegerArray theHandle) -> Handle_TDataStd_IntegerArray
        assign(Handle_TDataStd_IntegerArray self, TDataStd_IntegerArray thePtr) -> Handle_TDataStd_IntegerArray
        assign(Handle_TDataStd_IntegerArray self, Handle_TDataStd_IntegerArray theHandle) -> Handle_TDataStd_IntegerArray

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_IntegerArray self) -> TDataStd_IntegerArray

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_IntegerArray self) -> TDataStd_IntegerArray

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_IntegerArray___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_IntegerArray self) -> TDataStd_IntegerArray

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_IntegerArray___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_IntegerArray___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_IntegerArray___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_IntegerArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_IntegerArray_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_IntegerArray

    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_IntegerArray self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_IntegerArray_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_IntegerArray_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetID(self, *args):
        """
        class methods
        =============
        Returns the GUID for arrays of integers.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_IntegerArray_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_TDataStd_IntegerArray self, TDF_Label label, Standard_Integer const lower, Standard_Integer const upper, Standard_Boolean const isDelta) -> Handle_TDataStd_IntegerArray
        Set(Handle_TDataStd_IntegerArray self, TDF_Label label, Standard_GUID theGuid, Standard_Integer const lower, Standard_Integer const upper, Standard_Boolean const isDelta) -> Handle_TDataStd_IntegerArray

        Finds, or creates, an IntegerArray attribute with explicit user defined <guid>.
        The IntegerArray attribute  is  returned.

        :type label: OCC.wrapper.TDF.TDF_Label
        :type theGuid: OCC.wrapper.Standard.Standard_GUID
        :type lower: int
        :type upper: int
        :type isDelta: bool
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_IntegerArray

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_Set(self, *args)


    def Init(self, *args):
        """
        Init(Handle_TDataStd_IntegerArray self, Standard_Integer const lower, Standard_Integer const upper)

        Initialize the inner array with bounds from <lower> to <upper>

        :type lower: int
        :type upper: int

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_Init(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_TDataStd_IntegerArray self, Standard_Integer const Index, Standard_Integer const Value)

        Sets  the   <Index>th  element  of   the  array to <Value>
        OutOfRange exception is raised if <Index> doesn't respect Lower and Upper bounds of the internal  array.

        :type Index: int
        :type Value: int

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_SetValue(self, *args)


    def SetID(self, *args):
        """
        SetID(Handle_TDataStd_IntegerArray self, Standard_GUID theGuid)
        SetID(Handle_TDataStd_IntegerArray self)

        Sets default GUID for the attribute.


        """
        return _TDataStd.Handle_TDataStd_IntegerArray_SetID(self, *args)


    def Value(self, *args):
        """
        Value(Handle_TDataStd_IntegerArray self, Standard_Integer const Index) -> Standard_Integer

        Return the value of  the  <Index>th element of the array

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_Value(self, *args)


    def __call__(self, *args):
        """
        __call__(Handle_TDataStd_IntegerArray self, Standard_Integer const Index) -> Standard_Integer

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_IntegerArray___call__(self, *args)


    def Lower(self, *args):
        """
        Lower(Handle_TDataStd_IntegerArray self) -> Standard_Integer

        Returns the lower boundary of this array of integers.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(Handle_TDataStd_IntegerArray self) -> Standard_Integer

        Return the upper boundary of this array of integers.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_Upper(self, *args)


    def Length(self, *args):
        """
        Length(Handle_TDataStd_IntegerArray self) -> Standard_Integer

        Returns the length of this array of integers in
        terms of the number of elements it contains.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_Length(self, *args)


    def ChangeArray(self, *args):
        """
        ChangeArray(Handle_TDataStd_IntegerArray self, Handle_TColStd_HArray1OfInteger newArray, Standard_Boolean const isCheckItems)

        Sets the inner array <myValue>  of the IntegerArray attribute to
        <newArray>. If value of <newArray> differs from <myValue>, Backup performed
        and myValue refers to new instance of HArray1OfInteger that holds <newArray>
        values
        If <isCheckItems> equal True each item of <newArray> will be checked with each
        item of <myValue> for coincidence (to avoid backup).

        :type newArray: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfInteger
        :type isCheckItems: bool

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_ChangeArray(self, *args)


    def Array(self, *args):
        """
        Return the inner array of the IntegerArray attribute

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfInteger

        """
        res = _TDataStd.Handle_TDataStd_IntegerArray_Array(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetDelta(self, *args):
        """
        GetDelta(Handle_TDataStd_IntegerArray self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_GetDelta(self, *args)


    def SetDelta(self, *args):
        """
        SetDelta(Handle_TDataStd_IntegerArray self, Standard_Boolean const isDelta)

        for  internal  use  only!

        :type isDelta: bool

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_SetDelta(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_IntegerArray_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TDataStd_IntegerArray self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TDataStd_IntegerArray self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TDataStd_IntegerArray self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        Note. Uses inside ChangeArray() method

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDataStd_IntegerArray self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_Dump(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TDataStd_IntegerArray self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDataStd_IntegerArray self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TDataStd_IntegerArray self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDataStd_IntegerArray self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TDataStd_IntegerArray self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TDataStd_IntegerArray self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TDataStd_IntegerArray self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TDataStd_IntegerArray self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDataStd_IntegerArray self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TDataStd_IntegerArray self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TDataStd_IntegerArray self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TDataStd_IntegerArray self)

        Something to do after adding an Attribute to a label.


        """
        return _TDataStd.Handle_TDataStd_IntegerArray_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TDataStd_IntegerArray self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_IntegerArray_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TDataStd_IntegerArray self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TDataStd.Handle_TDataStd_IntegerArray_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TDataStd_IntegerArray self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_IntegerArray_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TDataStd_IntegerArray self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TDataStd_IntegerArray self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TDataStd_IntegerArray self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TDataStd_IntegerArray self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDataStd.Handle_TDataStd_IntegerArray_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TDataStd_IntegerArray self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDataStd.Handle_TDataStd_IntegerArray_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TDataStd_IntegerArray self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TDataStd_IntegerArray self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TDataStd_IntegerArray self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TDataStd_IntegerArray self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TDataStd_IntegerArray self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TDataStd_IntegerArray self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_DeltaOnRemoval(self, *args)


    def References(self, *args):
        """
        References(Handle_TDataStd_IntegerArray self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_References(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDataStd_IntegerArray self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_IntegerArray___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TDataStd_IntegerArray self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TDataStd_IntegerArray self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_IntegerArray self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_IntegerArray_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_IntegerArray self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_IntegerArray self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_IntegerArray self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_IntegerArray self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_IntegerArray self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_IntegerArray self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_IntegerArray self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_IntegerArray_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_IntegerArray self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_IntegerArray_DecrementRefCounter(self, *args)

Handle_TDataStd_IntegerArray_swigregister = _TDataStd.Handle_TDataStd_IntegerArray_swigregister
Handle_TDataStd_IntegerArray_swigregister(Handle_TDataStd_IntegerArray)

def Handle_TDataStd_IntegerArray_DownCast(thing):
    return _TDataStd.Handle_TDataStd_IntegerArray_DownCast(thing)
Handle_TDataStd_IntegerArray_DownCast = _TDataStd.Handle_TDataStd_IntegerArray_DownCast

class Handle_TDataStd_Real(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_Real self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_Real_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_Real self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_Real_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_Real self, TDataStd_Real thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_Real_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_Real self, Handle_TDataStd_Real theHandle) -> Handle_TDataStd_Real
        assign(Handle_TDataStd_Real self, TDataStd_Real thePtr) -> Handle_TDataStd_Real
        assign(Handle_TDataStd_Real self, Handle_TDataStd_Real theHandle) -> Handle_TDataStd_Real

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_Real_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_Real self) -> TDataStd_Real

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_Real_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_Real self) -> TDataStd_Real

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_Real___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_Real self) -> TDataStd_Real

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_Real___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_Real___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_Real___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_Real(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_Real_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_Real

    def GetID(self, *args):
        """
        class methods
        =============
        Returns the default GUID for real numbers.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_Real_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_TDataStd_Real self, TDF_Label label, Standard_Real const value) -> Handle_TDataStd_Real
        Set(Handle_TDataStd_Real self, TDF_Label label, Standard_GUID guid, Standard_Real const value) -> Handle_TDataStd_Real
        Set(Handle_TDataStd_Real self, Standard_Real const V)

        Sets the real number V.

        :type V: float

        """
        return _TDataStd.Handle_TDataStd_Real_Set(self, *args)


    def SetDimension(self, *args):
        """
        SetDimension(Handle_TDataStd_Real self, TDataStd_RealEnum const DIM)

        Obsolete method that will be removed in next versions.
        This field is not supported in the persistence mechanism.

        :type DIM: OCC.wrapper.TDataStd.TDataStd_RealEnum

        """
        return _TDataStd.Handle_TDataStd_Real_SetDimension(self, *args)


    def GetDimension(self, *args):
        """
        GetDimension(Handle_TDataStd_Real self) -> TDataStd_RealEnum

        Obsolete method that will be removed in next versions.
        This field is not supported in the persistence mechanism.

        :rtype: OCC.wrapper.TDataStd.TDataStd_RealEnum

        """
        return _TDataStd.Handle_TDataStd_Real_GetDimension(self, *args)


    def SetID(self, *args):
        """
        SetID(Handle_TDataStd_Real self, Standard_GUID guid)
        SetID(Handle_TDataStd_Real self)

        Sets default GUID for the attribute.


        """
        return _TDataStd.Handle_TDataStd_Real_SetID(self, *args)


    def Get(self, *args):
        """
        Get(Handle_TDataStd_Real self) -> Standard_Real

        Returns the real number value contained in the attribute.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _TDataStd.Handle_TDataStd_Real_Get(self, *args)


    def IsCaptured(self, *args):
        """
        IsCaptured(Handle_TDataStd_Real self) -> Standard_Boolean

        Returns True if there is a reference on the same label

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Real_IsCaptured(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_Real_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TDataStd_Real self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Real_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TDataStd_Real self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Real_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TDataStd_Real self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.Handle_TDataStd_Real_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDataStd_Real self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_Real_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_Real self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_Real_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_Real_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_Real_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Label(self, *args):
        """
        Label(Handle_TDataStd_Real self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_Real_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDataStd_Real self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Real_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TDataStd_Real self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Real_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDataStd_Real self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Real_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TDataStd_Real self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Real_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TDataStd_Real self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Real_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TDataStd_Real self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Real_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TDataStd_Real self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Real_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDataStd_Real self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Real_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TDataStd_Real self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Real_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TDataStd_Real self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDataStd.Handle_TDataStd_Real_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TDataStd_Real self)

        Something to do after adding an Attribute to a label.


        """
        return _TDataStd.Handle_TDataStd_Real_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TDataStd_Real self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_Real_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TDataStd_Real self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TDataStd.Handle_TDataStd_Real_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TDataStd_Real self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_Real_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TDataStd_Real self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Real_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TDataStd_Real self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Real_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TDataStd_Real self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Real_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TDataStd_Real self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDataStd.Handle_TDataStd_Real_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TDataStd_Real self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDataStd.Handle_TDataStd_Real_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TDataStd_Real self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Real_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TDataStd_Real self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Real_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TDataStd_Real self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDataStd.Handle_TDataStd_Real_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TDataStd_Real self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDataStd.Handle_TDataStd_Real_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TDataStd_Real self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDataStd.Handle_TDataStd_Real_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TDataStd_Real self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDataStd.Handle_TDataStd_Real_DeltaOnRemoval(self, *args)


    def References(self, *args):
        """
        References(Handle_TDataStd_Real self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDataStd.Handle_TDataStd_Real_References(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDataStd_Real self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_Real___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TDataStd_Real self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDataStd.Handle_TDataStd_Real_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TDataStd_Real self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDataStd.Handle_TDataStd_Real_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_Real self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_Real_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_Real self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_Real self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Real_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_Real self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_Real self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Real_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_Real self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_Real_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_Real self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Real_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_Real self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_Real_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_Real self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Real_DecrementRefCounter(self, *args)

Handle_TDataStd_Real_swigregister = _TDataStd.Handle_TDataStd_Real_swigregister
Handle_TDataStd_Real_swigregister(Handle_TDataStd_Real)

def Handle_TDataStd_Real_DownCast(thing):
    return _TDataStd.Handle_TDataStd_Real_DownCast(thing)
Handle_TDataStd_Real_DownCast = _TDataStd.Handle_TDataStd_Real_DownCast

class Handle_TDataStd_ReferenceArray(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_ReferenceArray self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_ReferenceArray self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_ReferenceArray self, TDataStd_ReferenceArray thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_ReferenceArray self, Handle_TDataStd_ReferenceArray theHandle) -> Handle_TDataStd_ReferenceArray
        assign(Handle_TDataStd_ReferenceArray self, TDataStd_ReferenceArray thePtr) -> Handle_TDataStd_ReferenceArray
        assign(Handle_TDataStd_ReferenceArray self, Handle_TDataStd_ReferenceArray theHandle) -> Handle_TDataStd_ReferenceArray

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_ReferenceArray self) -> TDataStd_ReferenceArray

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_ReferenceArray self) -> TDataStd_ReferenceArray

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_ReferenceArray self) -> TDataStd_ReferenceArray

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_ReferenceArray___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_ReferenceArray___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_ReferenceArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_ReferenceArray_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_ReferenceArray

    def GetID(self, *args):
        """
        Static methods
        ==============
        Returns the ID of the array of references (labels) attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_ReferenceArray_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_TDataStd_ReferenceArray self, TDF_Label label, Standard_Integer const lower, Standard_Integer const upper) -> Handle_TDataStd_ReferenceArray
        Set(Handle_TDataStd_ReferenceArray self, TDF_Label label, Standard_GUID theGuid, Standard_Integer const lower, Standard_Integer const upper) -> Handle_TDataStd_ReferenceArray

        Finds or creates an array of reference values (labels) attribute with explicit user defined <guid>.

        :type label: OCC.wrapper.TDF.TDF_Label
        :type theGuid: OCC.wrapper.Standard.Standard_GUID
        :type lower: int
        :type upper: int
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_ReferenceArray

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_Set(self, *args)


    def Init(self, *args):
        """
        Init(Handle_TDataStd_ReferenceArray self, Standard_Integer const lower, Standard_Integer const upper)

        Initialize the inner array with bounds from <lower> to <upper>

        :type lower: int
        :type upper: int

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_Init(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_TDataStd_ReferenceArray self, Standard_Integer const index, TDF_Label value)

        Sets the <Index>th element of the array to <Value>
        OutOfRange exception is raised if <Index> doesn't respect Lower and Upper bounds of the internal  array.

        :type index: int
        :type value: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_SetValue(self, *args)


    def SetID(self, *args):
        """
        SetID(Handle_TDataStd_ReferenceArray self, Standard_GUID theGuid)
        SetID(Handle_TDataStd_ReferenceArray self)

        Sets default GUID for the attribute.


        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_SetID(self, *args)


    def Value(self, *args):
        """
        Value(Handle_TDataStd_ReferenceArray self, Standard_Integer const Index) -> TDF_Label

        Returns the value of the <Index>th element of the array.

        :type Index: int
        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_Value(self, *args)


    def __call__(self, *args):
        """
        __call__(Handle_TDataStd_ReferenceArray self, Standard_Integer const Index) -> TDF_Label

        :type Index: int
        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray___call__(self, *args)


    def Lower(self, *args):
        """
        Lower(Handle_TDataStd_ReferenceArray self) -> Standard_Integer

        Returns the lower boundary of the array.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(Handle_TDataStd_ReferenceArray self) -> Standard_Integer

        Returns the upper boundary of the array.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_Upper(self, *args)


    def Length(self, *args):
        """
        Length(Handle_TDataStd_ReferenceArray self) -> Standard_Integer

        Returns the number of elements in the array.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_Length(self, *args)


    def InternalArray(self, *args):
        """
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_HLabelArray1

        """
        res = _TDataStd.Handle_TDataStd_ReferenceArray_InternalArray(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetInternalArray(self, *args):
        """
        SetInternalArray(Handle_TDataStd_ReferenceArray self, Handle_TDataStd_HLabelArray1 values, Standard_Boolean const isCheckItems)

        :type values: OCC.wrapper.TDataStd.Handle_TDataStd_HLabelArray1
        :type isCheckItems: bool

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_SetInternalArray(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_ReferenceArray_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TDataStd_ReferenceArray self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TDataStd_ReferenceArray self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TDataStd_ReferenceArray self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_Paste(self, *args)


    def References(self, *args):
        """
        References(Handle_TDataStd_ReferenceArray self, Handle_TDF_DataSet DS)

        :type DS: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_References(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDataStd_ReferenceArray self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_ReferenceArray self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_ReferenceArray_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_ReferenceArray_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Label(self, *args):
        """
        Label(Handle_TDataStd_ReferenceArray self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDataStd_ReferenceArray self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TDataStd_ReferenceArray self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDataStd_ReferenceArray self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TDataStd_ReferenceArray self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TDataStd_ReferenceArray self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TDataStd_ReferenceArray self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TDataStd_ReferenceArray self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDataStd_ReferenceArray self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TDataStd_ReferenceArray self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TDataStd_ReferenceArray self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TDataStd_ReferenceArray self)

        Something to do after adding an Attribute to a label.


        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TDataStd_ReferenceArray self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TDataStd_ReferenceArray self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TDataStd_ReferenceArray self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TDataStd_ReferenceArray self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TDataStd_ReferenceArray self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TDataStd_ReferenceArray self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TDataStd_ReferenceArray self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TDataStd_ReferenceArray self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TDataStd_ReferenceArray self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TDataStd_ReferenceArray self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TDataStd_ReferenceArray self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TDataStd_ReferenceArray self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TDataStd_ReferenceArray self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TDataStd_ReferenceArray self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_DeltaOnRemoval(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDataStd_ReferenceArray self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TDataStd_ReferenceArray self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TDataStd_ReferenceArray self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_ReferenceArray self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_ReferenceArray self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_ReferenceArray self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_ReferenceArray self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_ReferenceArray self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_ReferenceArray self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_ReferenceArray self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_ReferenceArray self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_ReferenceArray self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_ReferenceArray_DecrementRefCounter(self, *args)

Handle_TDataStd_ReferenceArray_swigregister = _TDataStd.Handle_TDataStd_ReferenceArray_swigregister
Handle_TDataStd_ReferenceArray_swigregister(Handle_TDataStd_ReferenceArray)

def Handle_TDataStd_ReferenceArray_DownCast(thing):
    return _TDataStd.Handle_TDataStd_ReferenceArray_DownCast(thing)
Handle_TDataStd_ReferenceArray_DownCast = _TDataStd.Handle_TDataStd_ReferenceArray_DownCast

class Handle_TDataStd_Integer(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_Integer self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_Integer_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_Integer self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_Integer_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_Integer self, TDataStd_Integer thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_Integer_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_Integer self, Handle_TDataStd_Integer theHandle) -> Handle_TDataStd_Integer
        assign(Handle_TDataStd_Integer self, TDataStd_Integer thePtr) -> Handle_TDataStd_Integer
        assign(Handle_TDataStd_Integer self, Handle_TDataStd_Integer theHandle) -> Handle_TDataStd_Integer

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_Integer_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_Integer self) -> TDataStd_Integer

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_Integer_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_Integer self) -> TDataStd_Integer

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_Integer___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_Integer self) -> TDataStd_Integer

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_Integer___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_Integer___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_Integer___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_Integer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_Integer_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_Integer

    def GetID(self, *args):
        """
        class methods
        =============
        Returns the GUID for integers.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_Integer_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_TDataStd_Integer self, TDF_Label label, Standard_Integer const value) -> Handle_TDataStd_Integer
        Set(Handle_TDataStd_Integer self, TDF_Label label, Standard_GUID guid, Standard_Integer const value) -> Handle_TDataStd_Integer
        Set(Handle_TDataStd_Integer self, Standard_Integer const V)

        Integer methods
        ===============

        :type V: int

        """
        return _TDataStd.Handle_TDataStd_Integer_Set(self, *args)


    def SetID(self, *args):
        """
        SetID(Handle_TDataStd_Integer self, Standard_GUID guid)
        SetID(Handle_TDataStd_Integer self)

        Sets default GUID for the attribute.


        """
        return _TDataStd.Handle_TDataStd_Integer_SetID(self, *args)


    def Get(self, *args):
        """
        Get(Handle_TDataStd_Integer self) -> Standard_Integer

        Returns the integer value contained in the attribute.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Integer_Get(self, *args)


    def IsCaptured(self, *args):
        """
        IsCaptured(Handle_TDataStd_Integer self) -> Standard_Boolean

        Returns True if there is a reference on the same label

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Integer_IsCaptured(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_Integer_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TDataStd_Integer self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Integer_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TDataStd_Integer self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Integer_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TDataStd_Integer self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.Handle_TDataStd_Integer_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDataStd_Integer self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_Integer_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_Integer self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_Integer_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_Integer_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_Integer_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Label(self, *args):
        """
        Label(Handle_TDataStd_Integer self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_Integer_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDataStd_Integer self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Integer_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TDataStd_Integer self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Integer_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDataStd_Integer self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Integer_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TDataStd_Integer self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Integer_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TDataStd_Integer self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Integer_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TDataStd_Integer self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Integer_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TDataStd_Integer self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Integer_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDataStd_Integer self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Integer_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TDataStd_Integer self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Integer_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TDataStd_Integer self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDataStd.Handle_TDataStd_Integer_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TDataStd_Integer self)

        Something to do after adding an Attribute to a label.


        """
        return _TDataStd.Handle_TDataStd_Integer_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TDataStd_Integer self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_Integer_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TDataStd_Integer self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TDataStd.Handle_TDataStd_Integer_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TDataStd_Integer self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_Integer_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TDataStd_Integer self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Integer_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TDataStd_Integer self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Integer_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TDataStd_Integer self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Integer_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TDataStd_Integer self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDataStd.Handle_TDataStd_Integer_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TDataStd_Integer self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDataStd.Handle_TDataStd_Integer_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TDataStd_Integer self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Integer_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TDataStd_Integer self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Integer_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TDataStd_Integer self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDataStd.Handle_TDataStd_Integer_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TDataStd_Integer self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDataStd.Handle_TDataStd_Integer_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TDataStd_Integer self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDataStd.Handle_TDataStd_Integer_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TDataStd_Integer self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDataStd.Handle_TDataStd_Integer_DeltaOnRemoval(self, *args)


    def References(self, *args):
        """
        References(Handle_TDataStd_Integer self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDataStd.Handle_TDataStd_Integer_References(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDataStd_Integer self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_Integer___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TDataStd_Integer self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDataStd.Handle_TDataStd_Integer_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TDataStd_Integer self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDataStd.Handle_TDataStd_Integer_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_Integer self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_Integer_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_Integer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_Integer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Integer_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_Integer self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_Integer self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Integer_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_Integer self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_Integer_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_Integer self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Integer_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_Integer self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_Integer_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_Integer self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Integer_DecrementRefCounter(self, *args)

Handle_TDataStd_Integer_swigregister = _TDataStd.Handle_TDataStd_Integer_swigregister
Handle_TDataStd_Integer_swigregister(Handle_TDataStd_Integer)

def Handle_TDataStd_Integer_DownCast(thing):
    return _TDataStd.Handle_TDataStd_Integer_DownCast(thing)
Handle_TDataStd_Integer_DownCast = _TDataStd.Handle_TDataStd_Integer_DownCast

class TDataStd_IntPackedMap(TDF.TDF_Attribute):
    """Attribute for storing TColStd_PackedMapOfInteger"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_IntPackedMap
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_IntPackedMap(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_IntPackedMap_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_IntPackedMap_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_IntPackedMap_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetID(*args):
        """
        GetID() -> Standard_GUID

        class methods
        =============
        Returns the GUID of the attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.TDataStd_IntPackedMap_GetID(*args)

    GetID = staticmethod(GetID)

    def Set(*args):
        """
        Set(TDF_Label label, Standard_Boolean const isDelta) -> Handle_TDataStd_IntPackedMap

        Finds or creates an integer map attribute on the given label.
        If <isDelta> == False, DefaultDeltaOnModification is used.
        If <isDelta> == True, DeltaOnModification of the current attribute is used.
        If attribute is already set, input parameter <isDelta> is refused and the found
        attribute returned.
        Attribute methods
        ===================

        :type label: OCC.wrapper.TDF.TDF_Label
        :type isDelta: bool
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_IntPackedMap

        """
        return _TDataStd.TDataStd_IntPackedMap_Set(*args)

    Set = staticmethod(Set)

    def __init__(self, *args):
        """
        __init__(TDataStd_IntPackedMap self) -> TDataStd_IntPackedMap

        Attribute for storing TColStd_PackedMapOfInteger
        """
        this = _TDataStd.new_TDataStd_IntPackedMap(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def ChangeMap(self, *args):
        """
        ChangeMap(TDataStd_IntPackedMap self, Handle_TColStd_HPackedMapOfInteger theMap) -> Standard_Boolean
        ChangeMap(TDataStd_IntPackedMap self, TColStd_PackedMapOfInteger theMap) -> Standard_Boolean

        :type theMap: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_IntPackedMap_ChangeMap(self, *args)


    def GetMap(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        res = _TDataStd.TDataStd_IntPackedMap_GetMap(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetHMap(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger

        """
        res = _TDataStd.TDataStd_IntPackedMap_GetHMap(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(TDataStd_IntPackedMap self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_IntPackedMap_Clear(self, *args)


    def Add(self, *args):
        """
        Add(TDataStd_IntPackedMap self, Standard_Integer const theKey) -> Standard_Boolean

        :type theKey: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_IntPackedMap_Add(self, *args)


    def Remove(self, *args):
        """
        Remove(TDataStd_IntPackedMap self, Standard_Integer const theKey) -> Standard_Boolean

        :type theKey: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_IntPackedMap_Remove(self, *args)


    def Contains(self, *args):
        """
        Contains(TDataStd_IntPackedMap self, Standard_Integer const theKey) -> Standard_Boolean

        :type theKey: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_IntPackedMap_Contains(self, *args)


    def Extent(self, *args):
        """
        Extent(TDataStd_IntPackedMap self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.TDataStd_IntPackedMap_Extent(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(TDataStd_IntPackedMap self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_IntPackedMap_IsEmpty(self, *args)


    def GetDelta(self, *args):
        """
        GetDelta(TDataStd_IntPackedMap self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.TDataStd_IntPackedMap_GetDelta(self, *args)


    def SetDelta(self, *args):
        """
        SetDelta(TDataStd_IntPackedMap self, Standard_Boolean const isDelta)

        for  internal  use  only!

        :type isDelta: bool

        """
        return _TDataStd.TDataStd_IntPackedMap_SetDelta(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.TDataStd_IntPackedMap_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(TDataStd_IntPackedMap self, Handle_TDF_Attribute arg2)

        :type with: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_IntPackedMap_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(TDataStd_IntPackedMap self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.TDataStd_IntPackedMap_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(TDataStd_IntPackedMap self, Handle_TDF_Attribute into, Handle_TDF_RelocationTable RT)

        :type into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.TDataStd_IntPackedMap_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(TDataStd_IntPackedMap self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.TDataStd_IntPackedMap_Dump(self, *args)

    __swig_destroy__ = _TDataStd.delete_TDataStd_IntPackedMap
TDataStd_IntPackedMap_swigregister = _TDataStd.TDataStd_IntPackedMap_swigregister
TDataStd_IntPackedMap_swigregister(TDataStd_IntPackedMap)

def TDataStd_IntPackedMap_get_type_name(*args):
    """
    TDataStd_IntPackedMap_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_IntPackedMap_get_type_name(*args)

def TDataStd_IntPackedMap_get_type_descriptor(*args):
    """
    TDataStd_IntPackedMap_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_IntPackedMap_get_type_descriptor(*args)

def TDataStd_IntPackedMap_GetID(*args):
    """
    TDataStd_IntPackedMap_GetID() -> Standard_GUID

    class methods
    =============
    Returns the GUID of the attribute.

    :rtype: OCC.wrapper.Standard.Standard_GUID

    """
    return _TDataStd.TDataStd_IntPackedMap_GetID(*args)

def TDataStd_IntPackedMap_Set(*args):
    """
    TDataStd_IntPackedMap_Set(TDF_Label label, Standard_Boolean const isDelta) -> Handle_TDataStd_IntPackedMap

    Finds or creates an integer map attribute on the given label.
    If <isDelta> == False, DefaultDeltaOnModification is used.
    If <isDelta> == True, DeltaOnModification of the current attribute is used.
    If attribute is already set, input parameter <isDelta> is refused and the found
    attribute returned.
    Attribute methods
    ===================

    :type label: OCC.wrapper.TDF.TDF_Label
    :type isDelta: bool
    :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_IntPackedMap

    """
    return _TDataStd.TDataStd_IntPackedMap_Set(*args)

class Handle_TDataStd_Name(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_Name self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_Name_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_Name self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_Name_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_Name self, TDataStd_Name thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_Name_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_Name self, Handle_TDataStd_Name theHandle) -> Handle_TDataStd_Name
        assign(Handle_TDataStd_Name self, TDataStd_Name thePtr) -> Handle_TDataStd_Name
        assign(Handle_TDataStd_Name self, Handle_TDataStd_Name theHandle) -> Handle_TDataStd_Name

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_Name_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_Name self) -> TDataStd_Name

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_Name_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_Name self) -> TDataStd_Name

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_Name___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_Name self) -> TDataStd_Name

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_Name___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_Name___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_Name___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_Name(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_Name_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_Name

    def GetID(self, *args):
        """
        class methods working on the name itself
        ========================================
        Returns the GUID for name attributes.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_Name_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_TDataStd_Name self, TDF_Label label, TCollection_ExtendedString string) -> Handle_TDataStd_Name
        Set(Handle_TDataStd_Name self, TDF_Label label, Standard_GUID guid, TCollection_ExtendedString string) -> Handle_TDataStd_Name
        Set(Handle_TDataStd_Name self, TCollection_ExtendedString S)

        Sets <S> as name. Raises if <S> is not a valid name.

        :type S: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDataStd.Handle_TDataStd_Name_Set(self, *args)


    def SetID(self, *args):
        """
        SetID(Handle_TDataStd_Name self, Standard_GUID guid)
        SetID(Handle_TDataStd_Name self)

        Sets default GUID for the attribute.


        """
        return _TDataStd.Handle_TDataStd_Name_SetID(self, *args)


    def Get(self, *args):
        """
        Returns the name contained in this name attribute.

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _TDataStd.Handle_TDataStd_Name_Get(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_Name_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TDataStd_Name self, Handle_TDF_Attribute arg2)

        :type with: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Name_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TDataStd_Name self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Name_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TDataStd_Name self, Handle_TDF_Attribute into, Handle_TDF_RelocationTable RT)

        :type into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.Handle_TDataStd_Name_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDataStd_Name self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_Name_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_Name self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_Name_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_Name_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_Name_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Label(self, *args):
        """
        Label(Handle_TDataStd_Name self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_Name_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDataStd_Name self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Name_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TDataStd_Name self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Name_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDataStd_Name self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Name_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TDataStd_Name self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Name_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TDataStd_Name self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Name_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TDataStd_Name self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Name_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TDataStd_Name self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Name_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDataStd_Name self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Name_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TDataStd_Name self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Name_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TDataStd_Name self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDataStd.Handle_TDataStd_Name_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TDataStd_Name self)

        Something to do after adding an Attribute to a label.


        """
        return _TDataStd.Handle_TDataStd_Name_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TDataStd_Name self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_Name_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TDataStd_Name self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TDataStd.Handle_TDataStd_Name_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TDataStd_Name self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_Name_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TDataStd_Name self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Name_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TDataStd_Name self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Name_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TDataStd_Name self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Name_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TDataStd_Name self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDataStd.Handle_TDataStd_Name_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TDataStd_Name self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDataStd.Handle_TDataStd_Name_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TDataStd_Name self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Name_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TDataStd_Name self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Name_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TDataStd_Name self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDataStd.Handle_TDataStd_Name_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TDataStd_Name self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDataStd.Handle_TDataStd_Name_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TDataStd_Name self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDataStd.Handle_TDataStd_Name_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TDataStd_Name self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDataStd.Handle_TDataStd_Name_DeltaOnRemoval(self, *args)


    def References(self, *args):
        """
        References(Handle_TDataStd_Name self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDataStd.Handle_TDataStd_Name_References(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDataStd_Name self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_Name___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TDataStd_Name self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDataStd.Handle_TDataStd_Name_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TDataStd_Name self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDataStd.Handle_TDataStd_Name_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_Name self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_Name_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_Name self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_Name self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Name_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_Name self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_Name self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Name_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_Name self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_Name_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_Name self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Name_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_Name self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_Name_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_Name self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Name_DecrementRefCounter(self, *args)

Handle_TDataStd_Name_swigregister = _TDataStd.Handle_TDataStd_Name_swigregister
Handle_TDataStd_Name_swigregister(Handle_TDataStd_Name)

def Handle_TDataStd_Name_DownCast(thing):
    return _TDataStd.Handle_TDataStd_Name_DownCast(thing)
Handle_TDataStd_Name_DownCast = _TDataStd.Handle_TDataStd_Name_DownCast

class TDataStd_HDataMapOfStringReal(Standard.Standard_Transient):
    """
    Extension of TDataStd_DataMapOfStringReal class
    to be manipulated by handle.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TDataStd_HDataMapOfStringReal
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TDataStd_HDataMapOfStringReal(self) 
            return h


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TDataStd.TDataStd_HDataMapOfStringReal_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TDataStd.TDataStd_HDataMapOfStringReal_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.TDataStd_HDataMapOfStringReal_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __init__(self, *args):
        """
        __init__(TDataStd_HDataMapOfStringReal self, Standard_Integer const NbBuckets=1) -> TDataStd_HDataMapOfStringReal
        __init__(TDataStd_HDataMapOfStringReal self, NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString theOther) -> TDataStd_HDataMapOfStringReal

        :type theOther: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringReal

        """
        this = _TDataStd.new_TDataStd_HDataMapOfStringReal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Map(self, *args):
        """
        :rtype: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringReal

        """
        res = _TDataStd.TDataStd_HDataMapOfStringReal_Map(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeMap(self, *args):
        """
        ChangeMap(TDataStd_HDataMapOfStringReal self) -> NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString

        :rtype: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringReal

        """
        return _TDataStd.TDataStd_HDataMapOfStringReal_ChangeMap(self, *args)

    __swig_destroy__ = _TDataStd.delete_TDataStd_HDataMapOfStringReal
TDataStd_HDataMapOfStringReal_swigregister = _TDataStd.TDataStd_HDataMapOfStringReal_swigregister
TDataStd_HDataMapOfStringReal_swigregister(TDataStd_HDataMapOfStringReal)

def TDataStd_HDataMapOfStringReal_get_type_name(*args):
    """
    TDataStd_HDataMapOfStringReal_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TDataStd.TDataStd_HDataMapOfStringReal_get_type_name(*args)

def TDataStd_HDataMapOfStringReal_get_type_descriptor(*args):
    """
    TDataStd_HDataMapOfStringReal_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TDataStd.TDataStd_HDataMapOfStringReal_get_type_descriptor(*args)

class NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString self) -> NCollection_DataMap< TCollection_ExtendedString,Standard_Real,TCollection_ExtendedString >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString self) -> NCollection_DataMap< TCollection_ExtendedString,Standard_Real,TCollection_ExtendedString >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString self) -> NCollection_DataMap< TCollection_ExtendedString,Standard_Real,TCollection_ExtendedString >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString self) -> NCollection_DataMap< TCollection_ExtendedString,Standard_Real,TCollection_ExtendedString >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _TDataStd.new_NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString self, NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString self, NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString theOther) -> NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString self, NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString theOther) -> NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString self, TCollection_ExtendedString theKey, double const & theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString self, TCollection_ExtendedString theKey, double const & theItem) -> double *

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> double const *

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> double *

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString self, TCollection_ExtendedString theKey) -> double &

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString_Size(self, *args)


    def __iter__(self):
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString___iter__(self)
    __swig_destroy__ = _TDataStd.delete_NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString
NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString_swigregister = _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString_swigregister
NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString_swigregister(NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString)

class NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TDataStd.new_NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDataStd.delete_NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString_IteratorHelper

    def __next__(self):
        return _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString_IteratorHelper___next__(self)
NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString_IteratorHelper_swigregister = _TDataStd.NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString_IteratorHelper_swigregister
NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString_IteratorHelper_swigregister(NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString_IteratorHelper)


try:
	TDataStd_DataMapOfStringReal = NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString
except NameError:
	pass # does not exist, probably ignored

class Handle_TDataStd_IntegerList(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_IntegerList self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_IntegerList_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_IntegerList self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_IntegerList_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_IntegerList self, TDataStd_IntegerList thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_IntegerList_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_IntegerList self, Handle_TDataStd_IntegerList theHandle) -> Handle_TDataStd_IntegerList
        assign(Handle_TDataStd_IntegerList self, TDataStd_IntegerList thePtr) -> Handle_TDataStd_IntegerList
        assign(Handle_TDataStd_IntegerList self, Handle_TDataStd_IntegerList theHandle) -> Handle_TDataStd_IntegerList

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_IntegerList_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_IntegerList self) -> TDataStd_IntegerList

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_IntegerList_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_IntegerList self) -> TDataStd_IntegerList

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_IntegerList___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_IntegerList self) -> TDataStd_IntegerList

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_IntegerList___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_IntegerList___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_IntegerList___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_IntegerList(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_IntegerList_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_IntegerList

    def GetID(self, *args):
        """
        Static methods
        ==============
        Returns the ID of the list of integer attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_IntegerList_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_TDataStd_IntegerList self, TDF_Label label) -> Handle_TDataStd_IntegerList
        Set(Handle_TDataStd_IntegerList self, TDF_Label label, Standard_GUID theGuid) -> Handle_TDataStd_IntegerList

        Finds or creates a list of integer values attribute with explicit user defined <guid>.

        :type label: OCC.wrapper.TDF.TDF_Label
        :type theGuid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_IntegerList

        """
        return _TDataStd.Handle_TDataStd_IntegerList_Set(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_TDataStd_IntegerList self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntegerList_IsEmpty(self, *args)


    def Extent(self, *args):
        """
        Extent(Handle_TDataStd_IntegerList self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_IntegerList_Extent(self, *args)


    def Prepend(self, *args):
        """
        Prepend(Handle_TDataStd_IntegerList self, Standard_Integer const value)

        :type value: int

        """
        return _TDataStd.Handle_TDataStd_IntegerList_Prepend(self, *args)


    def Append(self, *args):
        """
        Append(Handle_TDataStd_IntegerList self, Standard_Integer const value)

        :type value: int

        """
        return _TDataStd.Handle_TDataStd_IntegerList_Append(self, *args)


    def SetID(self, *args):
        """
        SetID(Handle_TDataStd_IntegerList self, Standard_GUID theGuid)
        SetID(Handle_TDataStd_IntegerList self)

        Sets default GUID for the attribute.


        """
        return _TDataStd.Handle_TDataStd_IntegerList_SetID(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(Handle_TDataStd_IntegerList self, Standard_Integer const value, Standard_Integer const before_value) -> Standard_Boolean

        Inserts the <value> before the first meet of <before_value>.

        :type value: int
        :type before_value: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntegerList_InsertBefore(self, *args)


    def InsertBeforeByIndex(self, *args):
        """
        InsertBeforeByIndex(Handle_TDataStd_IntegerList self, Standard_Integer const index, Standard_Integer const before_value) -> Standard_Boolean

        Inserts the <value> before the <index> position.
        The indices start with 1 .. Extent().

        :type index: int
        :type before_value: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntegerList_InsertBeforeByIndex(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(Handle_TDataStd_IntegerList self, Standard_Integer const value, Standard_Integer const after_value) -> Standard_Boolean

        Inserts the <value> after the first meet of <after_value>.

        :type value: int
        :type after_value: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntegerList_InsertAfter(self, *args)


    def InsertAfterByIndex(self, *args):
        """
        InsertAfterByIndex(Handle_TDataStd_IntegerList self, Standard_Integer const index, Standard_Integer const after_value) -> Standard_Boolean

        Inserts the <value> after the <index> position.
        The indices start with 1 .. Extent().

        :type index: int
        :type after_value: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntegerList_InsertAfterByIndex(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_TDataStd_IntegerList self, Standard_Integer const value) -> Standard_Boolean

        Removes the first meet of the <value>.

        :type value: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntegerList_Remove(self, *args)


    def RemoveByIndex(self, *args):
        """
        RemoveByIndex(Handle_TDataStd_IntegerList self, Standard_Integer const index) -> Standard_Boolean

        Removes a value at <index> position.

        :type index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntegerList_RemoveByIndex(self, *args)


    def Clear(self, *args):
        """Clear(Handle_TDataStd_IntegerList self)"""
        return _TDataStd.Handle_TDataStd_IntegerList_Clear(self, *args)


    def First(self, *args):
        """
        First(Handle_TDataStd_IntegerList self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_IntegerList_First(self, *args)


    def Last(self, *args):
        """
        Last(Handle_TDataStd_IntegerList self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_IntegerList_Last(self, *args)


    def List(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_ListOfInteger

        """
        res = _TDataStd.Handle_TDataStd_IntegerList_List(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_IntegerList_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TDataStd_IntegerList self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_IntegerList_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TDataStd_IntegerList self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_IntegerList_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TDataStd_IntegerList self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.Handle_TDataStd_IntegerList_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDataStd_IntegerList self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_IntegerList_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_IntegerList self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_IntegerList_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_IntegerList_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_IntegerList_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Label(self, *args):
        """
        Label(Handle_TDataStd_IntegerList self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_IntegerList_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDataStd_IntegerList self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_IntegerList_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TDataStd_IntegerList self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_IntegerList_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDataStd_IntegerList self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntegerList_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TDataStd_IntegerList self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntegerList_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TDataStd_IntegerList self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntegerList_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TDataStd_IntegerList self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntegerList_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TDataStd_IntegerList self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntegerList_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDataStd_IntegerList self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_IntegerList_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TDataStd_IntegerList self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntegerList_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TDataStd_IntegerList self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDataStd.Handle_TDataStd_IntegerList_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TDataStd_IntegerList self)

        Something to do after adding an Attribute to a label.


        """
        return _TDataStd.Handle_TDataStd_IntegerList_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TDataStd_IntegerList self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_IntegerList_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TDataStd_IntegerList self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TDataStd.Handle_TDataStd_IntegerList_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TDataStd_IntegerList self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_IntegerList_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TDataStd_IntegerList self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntegerList_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TDataStd_IntegerList self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntegerList_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TDataStd_IntegerList self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntegerList_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TDataStd_IntegerList self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDataStd.Handle_TDataStd_IntegerList_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TDataStd_IntegerList self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDataStd.Handle_TDataStd_IntegerList_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TDataStd_IntegerList self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntegerList_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TDataStd_IntegerList self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_IntegerList_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TDataStd_IntegerList self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDataStd.Handle_TDataStd_IntegerList_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TDataStd_IntegerList self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDataStd.Handle_TDataStd_IntegerList_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TDataStd_IntegerList self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDataStd.Handle_TDataStd_IntegerList_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TDataStd_IntegerList self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDataStd.Handle_TDataStd_IntegerList_DeltaOnRemoval(self, *args)


    def References(self, *args):
        """
        References(Handle_TDataStd_IntegerList self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDataStd.Handle_TDataStd_IntegerList_References(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDataStd_IntegerList self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_IntegerList___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TDataStd_IntegerList self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDataStd.Handle_TDataStd_IntegerList_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TDataStd_IntegerList self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDataStd.Handle_TDataStd_IntegerList_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_IntegerList self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_IntegerList_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_IntegerList self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_IntegerList self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntegerList_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_IntegerList self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_IntegerList self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntegerList_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_IntegerList self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_IntegerList_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_IntegerList self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_IntegerList_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_IntegerList self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_IntegerList_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_IntegerList self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_IntegerList_DecrementRefCounter(self, *args)

Handle_TDataStd_IntegerList_swigregister = _TDataStd.Handle_TDataStd_IntegerList_swigregister
Handle_TDataStd_IntegerList_swigregister(Handle_TDataStd_IntegerList)

def Handle_TDataStd_IntegerList_DownCast(thing):
    return _TDataStd.Handle_TDataStd_IntegerList_DownCast(thing)
Handle_TDataStd_IntegerList_DownCast = _TDataStd.Handle_TDataStd_IntegerList_DownCast

class NCollection_List_Standard_Byte(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_Standard_Byte self) -> NCollection_List< Standard_Byte >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _TDataStd.NCollection_List_Standard_Byte_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_Standard_Byte self) -> NCollection_List< Standard_Byte >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _TDataStd.NCollection_List_Standard_Byte_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_Standard_Byte self) -> NCollection_List< Standard_Byte >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _TDataStd.NCollection_List_Standard_Byte_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_Standard_Byte self) -> NCollection_List< Standard_Byte >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _TDataStd.NCollection_List_Standard_Byte_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _TDataStd.new_NCollection_List_Standard_Byte(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_Standard_Byte self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.NCollection_List_Standard_Byte_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_Standard_Byte self, NCollection_List_Standard_Byte theOther) -> NCollection_List_Standard_Byte

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _TDataStd.NCollection_List_Standard_Byte_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_Standard_Byte self, NCollection_List_Standard_Byte theOther) -> NCollection_List_Standard_Byte

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _TDataStd.NCollection_List_Standard_Byte_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_Standard_Byte self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TDataStd.NCollection_List_Standard_Byte_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _TDataStd.NCollection_List_Standard_Byte_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _TDataStd.NCollection_List_Standard_Byte_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_Standard_Byte self, unsigned char const & theItem) -> unsigned char
        Append(NCollection_List_Standard_Byte self, unsigned char const & theItem, NCollection_List< Standard_Byte >::Iterator & theIter)
        Append(NCollection_List_Standard_Byte self, NCollection_List_Standard_Byte theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _TDataStd.NCollection_List_Standard_Byte_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_Standard_Byte self, unsigned char const & theItem) -> unsigned char
        Prepend(NCollection_List_Standard_Byte self, NCollection_List_Standard_Byte theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _TDataStd.NCollection_List_Standard_Byte_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_Standard_Byte self)

        RemoveFirst item


        """
        return _TDataStd.NCollection_List_Standard_Byte_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_Standard_Byte self, NCollection_List< Standard_Byte >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _TDataStd.NCollection_List_Standard_Byte_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_Standard_Byte self, unsigned char const & theItem, NCollection_List< Standard_Byte >::Iterator & theIter) -> unsigned char
        InsertBefore(NCollection_List_Standard_Byte self, NCollection_List_Standard_Byte theOther, NCollection_List< Standard_Byte >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _TDataStd.NCollection_List_Standard_Byte_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_Standard_Byte self, unsigned char const & theItem, NCollection_List< Standard_Byte >::Iterator & theIter) -> unsigned char
        InsertAfter(NCollection_List_Standard_Byte self, NCollection_List_Standard_Byte theOther, NCollection_List< Standard_Byte >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _TDataStd.NCollection_List_Standard_Byte_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_Standard_Byte self)

        Reverse the list


        """
        return _TDataStd.NCollection_List_Standard_Byte_Reverse(self, *args)


    def __iter__(self):
        return _TDataStd.NCollection_List_Standard_Byte___iter__(self)
    __swig_destroy__ = _TDataStd.delete_NCollection_List_Standard_Byte
NCollection_List_Standard_Byte_swigregister = _TDataStd.NCollection_List_Standard_Byte_swigregister
NCollection_List_Standard_Byte_swigregister(NCollection_List_Standard_Byte)

class NCollection_List_Standard_Byte_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TDataStd.new_NCollection_List_Standard_Byte_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDataStd.delete_NCollection_List_Standard_Byte_IteratorHelper

    def __next__(self):
        return _TDataStd.NCollection_List_Standard_Byte_IteratorHelper___next__(self)
NCollection_List_Standard_Byte_IteratorHelper_swigregister = _TDataStd.NCollection_List_Standard_Byte_IteratorHelper_swigregister
NCollection_List_Standard_Byte_IteratorHelper_swigregister(NCollection_List_Standard_Byte_IteratorHelper)


try:
	TDataStd_ListOfByte = NCollection_List_Standard_Byte
except NameError:
	pass # does not exist, probably ignored

class Handle_TDataStd_TreeNode(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_TreeNode self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_TreeNode_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_TreeNode self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_TreeNode_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_TreeNode self, TDataStd_TreeNode thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_TreeNode_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_TreeNode self, Handle_TDataStd_TreeNode theHandle) -> Handle_TDataStd_TreeNode
        assign(Handle_TDataStd_TreeNode self, TDataStd_TreeNode thePtr) -> Handle_TDataStd_TreeNode
        assign(Handle_TDataStd_TreeNode self, Handle_TDataStd_TreeNode theHandle) -> Handle_TDataStd_TreeNode

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_TreeNode_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_TreeNode self) -> TDataStd_TreeNode

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_TreeNode_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_TreeNode self) -> TDataStd_TreeNode

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_TreeNode___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_TreeNode self) -> TDataStd_TreeNode

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_TreeNode___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_TreeNode___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_TreeNode___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_TreeNode(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_TreeNode_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_TreeNode

    def Find(self, *args):
        """
        Find(Handle_TDataStd_TreeNode self, TDF_Label L, Handle_TDataStd_TreeNode T) -> Standard_Boolean

        class  methods working on the node
        ===================================
        Returns true if the tree node T is found on the label L.
        Otherwise, false is returned.

        :type L: OCC.wrapper.TDF.TDF_Label
        :type T: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_TreeNode_Find(self, *args)


    def Set(self, *args):
        """
        Set(Handle_TDataStd_TreeNode self, TDF_Label L) -> Handle_TDataStd_TreeNode
        Set(Handle_TDataStd_TreeNode self, TDF_Label L, Standard_GUID ExplicitTreeID) -> Handle_TDataStd_TreeNode

        Finds  or Creates a   TreeNode attribute on  the label
        <L>, with an   explicit tree ID.  <ExplicitTreeID>  is
        the  ID   returned by    <TDF_Attribute::ID>   method.
        Returns the found/created TreeNode attribute.

        :type L: OCC.wrapper.TDF.TDF_Label
        :type ExplicitTreeID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode

        """
        return _TDataStd.Handle_TDataStd_TreeNode_Set(self, *args)


    def GetDefaultTreeID(self, *args):
        """
        returns a default  tree ID.  this  ID is  used by the
        <Set> method without explicit tree ID.
        Instance methods:
        ================

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_TreeNode_GetDefaultTreeID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(Handle_TDataStd_TreeNode self, Handle_TDataStd_TreeNode Child) -> Standard_Boolean

        Insert the TreeNode <Child> as last  child of <me>. If
        the insertion is successful <me> becomes the Father of <Child>.

        :type Child: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_TreeNode_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(Handle_TDataStd_TreeNode self, Handle_TDataStd_TreeNode Child) -> Standard_Boolean

        Insert the   the TreeNode <Child>  as  first child of
        <me>. If the insertion is successful <me> becomes the Father of <Child>

        :type Child: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_TreeNode_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(Handle_TDataStd_TreeNode self, Handle_TDataStd_TreeNode Node) -> Standard_Boolean

        Inserts the TreeNode  <Node> before <me>. If insertion is successful <me>
        and <Node> belongs to the same Father.

        :type Node: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_TreeNode_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(Handle_TDataStd_TreeNode self, Handle_TDataStd_TreeNode Node) -> Standard_Boolean

        Inserts the TreeNode <Node>  after <me>. If insertion is successful  <me>
        and <Node> belongs to the same Father.

        :type Node: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_TreeNode_InsertAfter(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_TDataStd_TreeNode self) -> Standard_Boolean

        Removes this tree node attribute from its father
        node. The result is that this attribute becomes a root node.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_TreeNode_Remove(self, *args)


    def Depth(self, *args):
        """
        Depth(Handle_TDataStd_TreeNode self) -> Standard_Integer

        Returns the depth of this tree node in the overall tree node structure.
        In other words, the number of father tree nodes of this one is returned.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_TreeNode_Depth(self, *args)


    def NbChildren(self, *args):
        """
        NbChildren(Handle_TDataStd_TreeNode self, Standard_Boolean const allLevels) -> Standard_Integer

        Returns the number of child nodes.
        If <allLevels> is true, the method counts children of all levels
        (children of children ...)

        :type allLevels: bool
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_TreeNode_NbChildren(self, *args)


    def IsAscendant(self, *args):
        """
        IsAscendant(Handle_TDataStd_TreeNode self, Handle_TDataStd_TreeNode of) -> Standard_Boolean

        Returns true if this tree node attribute is an
        ascendant of of. In other words, if it is a father or
        the father of a father of of.

        :type of: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_TreeNode_IsAscendant(self, *args)


    def IsDescendant(self, *args):
        """
        IsDescendant(Handle_TDataStd_TreeNode self, Handle_TDataStd_TreeNode of) -> Standard_Boolean

        Returns true if this tree node attribute is a
        descendant of of. In other words, if it is a child or
        the child of a child of of.

        :type of: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_TreeNode_IsDescendant(self, *args)


    def IsRoot(self, *args):
        """
        IsRoot(Handle_TDataStd_TreeNode self) -> Standard_Boolean

        Returns true if this tree node attribute is the
        ultimate father in the tree.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_TreeNode_IsRoot(self, *args)


    def Root(self, *args):
        """
        Root(Handle_TDataStd_TreeNode self) -> Handle_TDataStd_TreeNode

        Returns the ultimate father of this tree node attribute.

        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode

        """
        return _TDataStd.Handle_TDataStd_TreeNode_Root(self, *args)


    def IsFather(self, *args):
        """
        IsFather(Handle_TDataStd_TreeNode self, Handle_TDataStd_TreeNode of) -> Standard_Boolean

        Returns true if this tree node attribute is a father of of.

        :type of: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_TreeNode_IsFather(self, *args)


    def IsChild(self, *args):
        """
        IsChild(Handle_TDataStd_TreeNode self, Handle_TDataStd_TreeNode of) -> Standard_Boolean

        Returns true if this tree node attribute is a child of of.

        :type of: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_TreeNode_IsChild(self, *args)


    def HasFather(self, *args):
        """
        HasFather(Handle_TDataStd_TreeNode self) -> Standard_Boolean

        Returns true if this tree node attribute has a father tree node.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_TreeNode_HasFather(self, *args)


    def Father(self, *args):
        """
        Father(Handle_TDataStd_TreeNode self) -> Handle_TDataStd_TreeNode

        Returns the father TreeNode of <me>. Null if root.

        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode

        """
        return _TDataStd.Handle_TDataStd_TreeNode_Father(self, *args)


    def HasNext(self, *args):
        """
        HasNext(Handle_TDataStd_TreeNode self) -> Standard_Boolean

        Returns true if this tree node attribute has a next tree node.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_TreeNode_HasNext(self, *args)


    def Next(self, *args):
        """
        Next(Handle_TDataStd_TreeNode self) -> Handle_TDataStd_TreeNode

        Returns the next tree node in this tree node attribute.
        Warning
        This tree node is null if it is the last one in this
        tree node attribute.Returns the next TreeNode of <me>. Null if last.

        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode

        """
        return _TDataStd.Handle_TDataStd_TreeNode_Next(self, *args)


    def HasPrevious(self, *args):
        """
        HasPrevious(Handle_TDataStd_TreeNode self) -> Standard_Boolean

        Returns true if this tree node attribute has a previous tree node.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_TreeNode_HasPrevious(self, *args)


    def Previous(self, *args):
        """
        Previous(Handle_TDataStd_TreeNode self) -> Handle_TDataStd_TreeNode

        Returns the previous tree node of this tree node attribute.
        Warning
        This tree node is null if it is the first one in this tree node attribute.

        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode

        """
        return _TDataStd.Handle_TDataStd_TreeNode_Previous(self, *args)


    def HasFirst(self, *args):
        """
        HasFirst(Handle_TDataStd_TreeNode self) -> Standard_Boolean

        Returns true if this tree node attribute has a first child tree node.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_TreeNode_HasFirst(self, *args)


    def First(self, *args):
        """
        First(Handle_TDataStd_TreeNode self) -> Handle_TDataStd_TreeNode

        Returns the first child tree node in this tree node object.

        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode

        """
        return _TDataStd.Handle_TDataStd_TreeNode_First(self, *args)


    def HasLast(self, *args):
        """
        HasLast(Handle_TDataStd_TreeNode self) -> Standard_Boolean

        Returns true if this tree node attribute has a last child tree node.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_TreeNode_HasLast(self, *args)


    def Last(self, *args):
        """
        Last(Handle_TDataStd_TreeNode self) -> Handle_TDataStd_TreeNode

        Returns the last child tree node in this tree node object.

        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode

        """
        return _TDataStd.Handle_TDataStd_TreeNode_Last(self, *args)


    def FindLast(self, *args):
        """
        FindLast(Handle_TDataStd_TreeNode self) -> Handle_TDataStd_TreeNode

        Returns the last child tree node in this tree node object.
        to set fields
        =============

        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode

        """
        return _TDataStd.Handle_TDataStd_TreeNode_FindLast(self, *args)


    def SetTreeID(self, *args):
        """
        SetTreeID(Handle_TDataStd_TreeNode self, Standard_GUID explicitID)

        :type explicitID: OCC.wrapper.Standard.Standard_GUID

        """
        return _TDataStd.Handle_TDataStd_TreeNode_SetTreeID(self, *args)


    def SetFather(self, *args):
        """
        SetFather(Handle_TDataStd_TreeNode self, Handle_TDataStd_TreeNode F)

        :type F: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode

        """
        return _TDataStd.Handle_TDataStd_TreeNode_SetFather(self, *args)


    def SetNext(self, *args):
        """
        SetNext(Handle_TDataStd_TreeNode self, Handle_TDataStd_TreeNode F)

        :type F: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode

        """
        return _TDataStd.Handle_TDataStd_TreeNode_SetNext(self, *args)


    def SetPrevious(self, *args):
        """
        SetPrevious(Handle_TDataStd_TreeNode self, Handle_TDataStd_TreeNode F)

        :type F: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode

        """
        return _TDataStd.Handle_TDataStd_TreeNode_SetPrevious(self, *args)


    def SetFirst(self, *args):
        """
        SetFirst(Handle_TDataStd_TreeNode self, Handle_TDataStd_TreeNode F)

        :type F: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode

        """
        return _TDataStd.Handle_TDataStd_TreeNode_SetFirst(self, *args)


    def SetLast(self, *args):
        """
        SetLast(Handle_TDataStd_TreeNode self, Handle_TDataStd_TreeNode F)

        TreeNode callback:
        ==================

        :type F: OCC.wrapper.TDataStd.Handle_TDataStd_TreeNode

        """
        return _TDataStd.Handle_TDataStd_TreeNode_SetLast(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TDataStd_TreeNode self)

        Connect the TreeNode to its father child list


        """
        return _TDataStd.Handle_TDataStd_TreeNode_AfterAddition(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TDataStd_TreeNode self)

        Disconnect the TreeNode from its Father child list


        """
        return _TDataStd.Handle_TDataStd_TreeNode_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TDataStd_TreeNode self)

        Reconnect the TreeNode to its father child list.


        """
        return _TDataStd.Handle_TDataStd_TreeNode_AfterResume(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TDataStd_TreeNode self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Disconnect the TreeNode, if necessary.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_TreeNode_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TDataStd_TreeNode self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Reconnect the TreeNode, if necessary.
        Implementation of Attribute methods:
        ===================================

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_TreeNode_AfterUndo(self, *args)


    def ID(self, *args):
        """
        Returns the tree ID (default or explicit one depending
        onthe Set method used).

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_TreeNode_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TDataStd_TreeNode self, Handle_TDF_Attribute arg2)

        :type with: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_TreeNode_Restore(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TDataStd_TreeNode self, Handle_TDF_Attribute into, Handle_TDF_RelocationTable RT)

        :type into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.Handle_TDataStd_TreeNode_Paste(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TDataStd_TreeNode self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_TreeNode_NewEmpty(self, *args)


    def References(self, *args):
        """
        References(Handle_TDataStd_TreeNode self, Handle_TDF_DataSet aDataSet)

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDataStd.Handle_TDataStd_TreeNode_References(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDataStd_TreeNode self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_TreeNode_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_TreeNode self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_TreeNode_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_TreeNode_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_TreeNode_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetID(self, *args):
        """
        SetID(Handle_TDataStd_TreeNode self, Standard_GUID arg2)
        SetID(Handle_TDataStd_TreeNode self)

        Sets default ID defined in nested class (to be used for attributes having User ID feature).


        """
        return _TDataStd.Handle_TDataStd_TreeNode_SetID(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TDataStd_TreeNode self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_TreeNode_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDataStd_TreeNode self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_TreeNode_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TDataStd_TreeNode self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_TreeNode_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDataStd_TreeNode self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_TreeNode_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TDataStd_TreeNode self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_TreeNode_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TDataStd_TreeNode self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_TreeNode_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TDataStd_TreeNode self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_TreeNode_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TDataStd_TreeNode self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_TreeNode_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDataStd_TreeNode self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_TreeNode_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TDataStd_TreeNode self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_TreeNode_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TDataStd_TreeNode self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDataStd.Handle_TDataStd_TreeNode_ForgetAllAttributes(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TDataStd_TreeNode self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_TreeNode_BeforeRemoval(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TDataStd_TreeNode self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_TreeNode_AfterRetrieval(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TDataStd_TreeNode self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDataStd.Handle_TDataStd_TreeNode_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TDataStd_TreeNode self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDataStd.Handle_TDataStd_TreeNode_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TDataStd_TreeNode self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_TreeNode_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TDataStd_TreeNode self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_TreeNode_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TDataStd_TreeNode self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDataStd.Handle_TDataStd_TreeNode_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TDataStd_TreeNode self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDataStd.Handle_TDataStd_TreeNode_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TDataStd_TreeNode self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDataStd.Handle_TDataStd_TreeNode_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TDataStd_TreeNode self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDataStd.Handle_TDataStd_TreeNode_DeltaOnRemoval(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDataStd_TreeNode self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_TreeNode___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TDataStd_TreeNode self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDataStd.Handle_TDataStd_TreeNode_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TDataStd_TreeNode self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDataStd.Handle_TDataStd_TreeNode_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_TreeNode self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_TreeNode_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_TreeNode self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_TreeNode self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_TreeNode_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_TreeNode self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_TreeNode self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_TreeNode_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_TreeNode self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_TreeNode_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_TreeNode self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_TreeNode_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_TreeNode self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_TreeNode_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_TreeNode self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_TreeNode_DecrementRefCounter(self, *args)

Handle_TDataStd_TreeNode_swigregister = _TDataStd.Handle_TDataStd_TreeNode_swigregister
Handle_TDataStd_TreeNode_swigregister(Handle_TDataStd_TreeNode)

def Handle_TDataStd_TreeNode_DownCast(thing):
    return _TDataStd.Handle_TDataStd_TreeNode_DownCast(thing)
Handle_TDataStd_TreeNode_DownCast = _TDataStd.Handle_TDataStd_TreeNode_DownCast

class Handle_TDataStd_HDataMapOfStringReal(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_HDataMapOfStringReal self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringReal_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_HDataMapOfStringReal self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringReal_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_HDataMapOfStringReal self, TDataStd_HDataMapOfStringReal thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringReal_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_HDataMapOfStringReal self, Handle_TDataStd_HDataMapOfStringReal theHandle) -> Handle_TDataStd_HDataMapOfStringReal
        assign(Handle_TDataStd_HDataMapOfStringReal self, TDataStd_HDataMapOfStringReal thePtr) -> Handle_TDataStd_HDataMapOfStringReal
        assign(Handle_TDataStd_HDataMapOfStringReal self, Handle_TDataStd_HDataMapOfStringReal theHandle) -> Handle_TDataStd_HDataMapOfStringReal

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringReal_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_HDataMapOfStringReal self) -> TDataStd_HDataMapOfStringReal

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringReal_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_HDataMapOfStringReal self) -> TDataStd_HDataMapOfStringReal

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringReal___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_HDataMapOfStringReal self) -> TDataStd_HDataMapOfStringReal

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringReal___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_HDataMapOfStringReal___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_HDataMapOfStringReal___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_HDataMapOfStringReal(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_HDataMapOfStringReal_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_HDataMapOfStringReal

    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_HDataMapOfStringReal self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringReal_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_HDataMapOfStringReal_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_HDataMapOfStringReal_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Map(self, *args):
        """
        :rtype: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringReal

        """
        res = _TDataStd.Handle_TDataStd_HDataMapOfStringReal_Map(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeMap(self, *args):
        """
        ChangeMap(Handle_TDataStd_HDataMapOfStringReal self) -> NCollection_DataMap_TCollection_ExtendedString_Standard_Real_TCollection_ExtendedString

        :rtype: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringReal

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringReal_ChangeMap(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_HDataMapOfStringReal self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringReal_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_HDataMapOfStringReal self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_HDataMapOfStringReal self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringReal_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_HDataMapOfStringReal self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_HDataMapOfStringReal self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringReal_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_HDataMapOfStringReal self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringReal_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_HDataMapOfStringReal self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringReal_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_HDataMapOfStringReal self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringReal_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_HDataMapOfStringReal self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringReal_DecrementRefCounter(self, *args)

Handle_TDataStd_HDataMapOfStringReal_swigregister = _TDataStd.Handle_TDataStd_HDataMapOfStringReal_swigregister
Handle_TDataStd_HDataMapOfStringReal_swigregister(Handle_TDataStd_HDataMapOfStringReal)

def Handle_TDataStd_HDataMapOfStringReal_DownCast(thing):
    return _TDataStd.Handle_TDataStd_HDataMapOfStringReal_DownCast(thing)
Handle_TDataStd_HDataMapOfStringReal_DownCast = _TDataStd.Handle_TDataStd_HDataMapOfStringReal_DownCast

class Handle_TDataStd_ByteArray(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_ByteArray self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_ByteArray_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_ByteArray self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_ByteArray_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_ByteArray self, TDataStd_ByteArray thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_ByteArray_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_ByteArray self, Handle_TDataStd_ByteArray theHandle) -> Handle_TDataStd_ByteArray
        assign(Handle_TDataStd_ByteArray self, TDataStd_ByteArray thePtr) -> Handle_TDataStd_ByteArray
        assign(Handle_TDataStd_ByteArray self, Handle_TDataStd_ByteArray theHandle) -> Handle_TDataStd_ByteArray

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_ByteArray_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_ByteArray self) -> TDataStd_ByteArray

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_ByteArray_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_ByteArray self) -> TDataStd_ByteArray

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_ByteArray___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_ByteArray self) -> TDataStd_ByteArray

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_ByteArray___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_ByteArray___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_ByteArray___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_ByteArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_ByteArray_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_ByteArray

    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_ByteArray self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_ByteArray_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_ByteArray_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_ByteArray_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetID(self, *args):
        """
        Static methods
        ==============
        Returns an ID for array.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_ByteArray_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_TDataStd_ByteArray self, TDF_Label label, Standard_Integer const lower, Standard_Integer const upper, Standard_Boolean const isDelta) -> Handle_TDataStd_ByteArray
        Set(Handle_TDataStd_ByteArray self, TDF_Label label, Standard_GUID theGuid, Standard_Integer const lower, Standard_Integer const upper, Standard_Boolean const isDelta) -> Handle_TDataStd_ByteArray

        Finds or creates an attribute with byte array and explicit user defined <guid> on the specified label.

        :type label: OCC.wrapper.TDF.TDF_Label
        :type theGuid: OCC.wrapper.Standard.Standard_GUID
        :type lower: int
        :type upper: int
        :type isDelta: bool
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_ByteArray

        """
        return _TDataStd.Handle_TDataStd_ByteArray_Set(self, *args)


    def Init(self, *args):
        """
        Init(Handle_TDataStd_ByteArray self, Standard_Integer const lower, Standard_Integer const upper)

        Initialize the inner array with bounds from <lower> to <upper>

        :type lower: int
        :type upper: int

        """
        return _TDataStd.Handle_TDataStd_ByteArray_Init(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_TDataStd_ByteArray self, Standard_Integer const index, Standard_Byte const value)

        Sets the <Index>th element of the array to <Value>
        OutOfRange exception is raised if <Index> doesn't respect Lower and Upper bounds of the internal  array.

        :type index: int
        :type value: int

        """
        return _TDataStd.Handle_TDataStd_ByteArray_SetValue(self, *args)


    def SetID(self, *args):
        """
        SetID(Handle_TDataStd_ByteArray self, Standard_GUID theGuid)
        SetID(Handle_TDataStd_ByteArray self)

        Sets default GUID for the attribute.


        """
        return _TDataStd.Handle_TDataStd_ByteArray_SetID(self, *args)


    def Value(self, *args):
        """
        Value(Handle_TDataStd_ByteArray self, Standard_Integer const Index) -> Standard_Byte

        Return the value of the <Index>th element of the array.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Byte

        """
        return _TDataStd.Handle_TDataStd_ByteArray_Value(self, *args)


    def __call__(self, *args):
        """
        __call__(Handle_TDataStd_ByteArray self, Standard_Integer const Index) -> Standard_Byte

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Byte

        """
        return _TDataStd.Handle_TDataStd_ByteArray___call__(self, *args)


    def Lower(self, *args):
        """
        Lower(Handle_TDataStd_ByteArray self) -> Standard_Integer

        Returns the lower boundary of the array.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_ByteArray_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(Handle_TDataStd_ByteArray self) -> Standard_Integer

        Returns the upper boundary of the array.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_ByteArray_Upper(self, *args)


    def Length(self, *args):
        """
        Length(Handle_TDataStd_ByteArray self) -> Standard_Integer

        Returns the number of elements in the array.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_ByteArray_Length(self, *args)


    def InternalArray(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfByte

        """
        res = _TDataStd.Handle_TDataStd_ByteArray_InternalArray(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeArray(self, *args):
        """
        ChangeArray(Handle_TDataStd_ByteArray self, Handle_TColStd_HArray1OfByte newArray, Standard_Boolean const isCheckItems)

        Sets the inner array <myValue>  of the attribute to
        <newArray>. If value of <newArray> differs from <myValue>, Backup performed
        and myValue refers to new instance of HArray1OfInteger that holds <newArray>
        values.
        If <isCheckItems> equal True each item of <newArray> will be checked with each
        item of <myValue> for coincidence (to avoid backup).

        :type newArray: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfByte
        :type isCheckItems: bool

        """
        return _TDataStd.Handle_TDataStd_ByteArray_ChangeArray(self, *args)


    def GetDelta(self, *args):
        """
        GetDelta(Handle_TDataStd_ByteArray self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ByteArray_GetDelta(self, *args)


    def SetDelta(self, *args):
        """
        SetDelta(Handle_TDataStd_ByteArray self, Standard_Boolean const isDelta)

        for internal  use  only!

        :type isDelta: bool

        """
        return _TDataStd.Handle_TDataStd_ByteArray_SetDelta(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_ByteArray_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TDataStd_ByteArray self, Handle_TDF_Attribute arg2)

        :type with: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_ByteArray_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TDataStd_ByteArray self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_ByteArray_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TDataStd_ByteArray self, Handle_TDF_Attribute into, Handle_TDF_RelocationTable RT)

        :type into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.Handle_TDataStd_ByteArray_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDataStd_ByteArray self, Standard_OStream & OS) -> Standard_OStream &

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_ByteArray_Dump(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TDataStd_ByteArray self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_ByteArray_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDataStd_ByteArray self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_ByteArray_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TDataStd_ByteArray self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_ByteArray_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDataStd_ByteArray self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ByteArray_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TDataStd_ByteArray self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ByteArray_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TDataStd_ByteArray self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ByteArray_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TDataStd_ByteArray self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ByteArray_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TDataStd_ByteArray self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ByteArray_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDataStd_ByteArray self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_ByteArray_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TDataStd_ByteArray self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ByteArray_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TDataStd_ByteArray self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDataStd.Handle_TDataStd_ByteArray_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TDataStd_ByteArray self)

        Something to do after adding an Attribute to a label.


        """
        return _TDataStd.Handle_TDataStd_ByteArray_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TDataStd_ByteArray self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_ByteArray_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TDataStd_ByteArray self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TDataStd.Handle_TDataStd_ByteArray_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TDataStd_ByteArray self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_ByteArray_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TDataStd_ByteArray self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ByteArray_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TDataStd_ByteArray self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ByteArray_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TDataStd_ByteArray self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ByteArray_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TDataStd_ByteArray self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDataStd.Handle_TDataStd_ByteArray_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TDataStd_ByteArray self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDataStd.Handle_TDataStd_ByteArray_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TDataStd_ByteArray self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ByteArray_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TDataStd_ByteArray self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_ByteArray_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TDataStd_ByteArray self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDataStd.Handle_TDataStd_ByteArray_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TDataStd_ByteArray self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDataStd.Handle_TDataStd_ByteArray_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TDataStd_ByteArray self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDataStd.Handle_TDataStd_ByteArray_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TDataStd_ByteArray self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDataStd.Handle_TDataStd_ByteArray_DeltaOnRemoval(self, *args)


    def References(self, *args):
        """
        References(Handle_TDataStd_ByteArray self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDataStd.Handle_TDataStd_ByteArray_References(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDataStd_ByteArray self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_ByteArray___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TDataStd_ByteArray self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDataStd.Handle_TDataStd_ByteArray_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TDataStd_ByteArray self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDataStd.Handle_TDataStd_ByteArray_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_ByteArray self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_ByteArray_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_ByteArray self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_ByteArray self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ByteArray_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_ByteArray self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_ByteArray self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_ByteArray_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_ByteArray self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_ByteArray_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_ByteArray self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_ByteArray_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_ByteArray self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_ByteArray_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_ByteArray self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_ByteArray_DecrementRefCounter(self, *args)

Handle_TDataStd_ByteArray_swigregister = _TDataStd.Handle_TDataStd_ByteArray_swigregister
Handle_TDataStd_ByteArray_swigregister(Handle_TDataStd_ByteArray)

def Handle_TDataStd_ByteArray_DownCast(thing):
    return _TDataStd.Handle_TDataStd_ByteArray_DownCast(thing)
Handle_TDataStd_ByteArray_DownCast = _TDataStd.Handle_TDataStd_ByteArray_DownCast

class Handle_TDataStd_HDataMapOfStringString(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_HDataMapOfStringString self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringString_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_HDataMapOfStringString self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringString_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_HDataMapOfStringString self, TDataStd_HDataMapOfStringString thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringString_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_HDataMapOfStringString self, Handle_TDataStd_HDataMapOfStringString theHandle) -> Handle_TDataStd_HDataMapOfStringString
        assign(Handle_TDataStd_HDataMapOfStringString self, TDataStd_HDataMapOfStringString thePtr) -> Handle_TDataStd_HDataMapOfStringString
        assign(Handle_TDataStd_HDataMapOfStringString self, Handle_TDataStd_HDataMapOfStringString theHandle) -> Handle_TDataStd_HDataMapOfStringString

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringString_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_HDataMapOfStringString self) -> TDataStd_HDataMapOfStringString

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringString_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_HDataMapOfStringString self) -> TDataStd_HDataMapOfStringString

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringString___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_HDataMapOfStringString self) -> TDataStd_HDataMapOfStringString

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringString___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_HDataMapOfStringString___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_HDataMapOfStringString___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_HDataMapOfStringString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_HDataMapOfStringString_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_HDataMapOfStringString

    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_HDataMapOfStringString self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringString_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_HDataMapOfStringString_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_HDataMapOfStringString_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Map(self, *args):
        """
        :rtype: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringString

        """
        res = _TDataStd.Handle_TDataStd_HDataMapOfStringString_Map(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeMap(self, *args):
        """
        ChangeMap(Handle_TDataStd_HDataMapOfStringString self) -> NCollection_DataMap_TCollection_ExtendedString_TCollection_ExtendedString_TCollection_ExtendedString

        :rtype: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringString

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringString_ChangeMap(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_HDataMapOfStringString self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringString_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_HDataMapOfStringString self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_HDataMapOfStringString self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringString_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_HDataMapOfStringString self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_HDataMapOfStringString self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringString_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_HDataMapOfStringString self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringString_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_HDataMapOfStringString self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringString_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_HDataMapOfStringString self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringString_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_HDataMapOfStringString self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringString_DecrementRefCounter(self, *args)

Handle_TDataStd_HDataMapOfStringString_swigregister = _TDataStd.Handle_TDataStd_HDataMapOfStringString_swigregister
Handle_TDataStd_HDataMapOfStringString_swigregister(Handle_TDataStd_HDataMapOfStringString)

def Handle_TDataStd_HDataMapOfStringString_DownCast(thing):
    return _TDataStd.Handle_TDataStd_HDataMapOfStringString_DownCast(thing)
Handle_TDataStd_HDataMapOfStringString_DownCast = _TDataStd.Handle_TDataStd_HDataMapOfStringString_DownCast

class Handle_TDataStd_BooleanArray(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_BooleanArray self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_BooleanArray_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_BooleanArray self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_BooleanArray self, TDataStd_BooleanArray thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_BooleanArray self, Handle_TDataStd_BooleanArray theHandle) -> Handle_TDataStd_BooleanArray
        assign(Handle_TDataStd_BooleanArray self, TDataStd_BooleanArray thePtr) -> Handle_TDataStd_BooleanArray
        assign(Handle_TDataStd_BooleanArray self, Handle_TDataStd_BooleanArray theHandle) -> Handle_TDataStd_BooleanArray

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_BooleanArray self) -> TDataStd_BooleanArray

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_BooleanArray self) -> TDataStd_BooleanArray

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_BooleanArray___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_BooleanArray self) -> TDataStd_BooleanArray

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_BooleanArray___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_BooleanArray___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_BooleanArray___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_BooleanArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_BooleanArray_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_BooleanArray

    def GetID(self, *args):
        """
        Static methods
        ==============
        Returns an ID for array.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_BooleanArray_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_TDataStd_BooleanArray self, TDF_Label label, Standard_Integer const lower, Standard_Integer const upper) -> Handle_TDataStd_BooleanArray
        Set(Handle_TDataStd_BooleanArray self, TDF_Label label, Standard_GUID theGuid, Standard_Integer const lower, Standard_Integer const upper) -> Handle_TDataStd_BooleanArray

        Finds or creates an attribute with the array using explicit user defined <guid>.

        :type label: OCC.wrapper.TDF.TDF_Label
        :type theGuid: OCC.wrapper.Standard.Standard_GUID
        :type lower: int
        :type upper: int
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_BooleanArray

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_Set(self, *args)


    def Init(self, *args):
        """
        Init(Handle_TDataStd_BooleanArray self, Standard_Integer const lower, Standard_Integer const upper)

        Initialize the inner array with bounds from <lower> to <upper>

        :type lower: int
        :type upper: int

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_Init(self, *args)


    def SetValue(self, *args):
        """
        SetValue(Handle_TDataStd_BooleanArray self, Standard_Integer const index, Standard_Boolean const value)

        Sets the <Index>th element of the array to <Value>
        OutOfRange exception is raised if <Index> doesn't respect Lower and Upper bounds of the internal  array.

        :type index: int
        :type value: bool

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_SetValue(self, *args)


    def SetID(self, *args):
        """
        SetID(Handle_TDataStd_BooleanArray self, Standard_GUID theGuid)
        SetID(Handle_TDataStd_BooleanArray self)

        Sets default GUID for the attribute.


        """
        return _TDataStd.Handle_TDataStd_BooleanArray_SetID(self, *args)


    def Value(self, *args):
        """
        Value(Handle_TDataStd_BooleanArray self, Standard_Integer const Index) -> Standard_Boolean

        Return the value of the <Index>th element of the array.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_Value(self, *args)


    def __call__(self, *args):
        """
        __call__(Handle_TDataStd_BooleanArray self, Standard_Integer const Index) -> Standard_Boolean

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_BooleanArray___call__(self, *args)


    def Lower(self, *args):
        """
        Lower(Handle_TDataStd_BooleanArray self) -> Standard_Integer

        Returns the lower boundary of the array.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(Handle_TDataStd_BooleanArray self) -> Standard_Integer

        Returns the upper boundary of the array.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_Upper(self, *args)


    def Length(self, *args):
        """
        Length(Handle_TDataStd_BooleanArray self) -> Standard_Integer

        Returns the number of elements in the array.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_Length(self, *args)


    def InternalArray(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfByte

        """
        res = _TDataStd.Handle_TDataStd_BooleanArray_InternalArray(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetInternalArray(self, *args):
        """
        SetInternalArray(Handle_TDataStd_BooleanArray self, Handle_TColStd_HArray1OfByte values)

        :type values: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfByte

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_SetInternalArray(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_BooleanArray_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TDataStd_BooleanArray self, Handle_TDF_Attribute arg2)

        :type with: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TDataStd_BooleanArray self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TDataStd_BooleanArray self, Handle_TDF_Attribute into, Handle_TDF_RelocationTable RT)

        :type into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDataStd_BooleanArray self, Standard_OStream & OS) -> Standard_OStream &

        :type OS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_BooleanArray self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_BooleanArray_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_BooleanArray_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Label(self, *args):
        """
        Label(Handle_TDataStd_BooleanArray self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDataStd_BooleanArray self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TDataStd_BooleanArray self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDataStd_BooleanArray self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TDataStd_BooleanArray self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TDataStd_BooleanArray self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TDataStd_BooleanArray self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TDataStd_BooleanArray self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDataStd_BooleanArray self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TDataStd_BooleanArray self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TDataStd_BooleanArray self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TDataStd_BooleanArray self)

        Something to do after adding an Attribute to a label.


        """
        return _TDataStd.Handle_TDataStd_BooleanArray_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TDataStd_BooleanArray self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_BooleanArray_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TDataStd_BooleanArray self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TDataStd.Handle_TDataStd_BooleanArray_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TDataStd_BooleanArray self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_BooleanArray_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TDataStd_BooleanArray self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TDataStd_BooleanArray self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TDataStd_BooleanArray self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TDataStd_BooleanArray self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDataStd.Handle_TDataStd_BooleanArray_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TDataStd_BooleanArray self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDataStd.Handle_TDataStd_BooleanArray_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TDataStd_BooleanArray self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TDataStd_BooleanArray self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TDataStd_BooleanArray self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TDataStd_BooleanArray self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TDataStd_BooleanArray self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TDataStd_BooleanArray self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_DeltaOnRemoval(self, *args)


    def References(self, *args):
        """
        References(Handle_TDataStd_BooleanArray self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_References(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDataStd_BooleanArray self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_BooleanArray___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TDataStd_BooleanArray self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TDataStd_BooleanArray self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_BooleanArray self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_BooleanArray_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_BooleanArray self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_BooleanArray self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_BooleanArray self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_BooleanArray self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_BooleanArray self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_BooleanArray self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_BooleanArray self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_BooleanArray_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_BooleanArray self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_BooleanArray_DecrementRefCounter(self, *args)

Handle_TDataStd_BooleanArray_swigregister = _TDataStd.Handle_TDataStd_BooleanArray_swigregister
Handle_TDataStd_BooleanArray_swigregister(Handle_TDataStd_BooleanArray)

def Handle_TDataStd_BooleanArray_DownCast(thing):
    return _TDataStd.Handle_TDataStd_BooleanArray_DownCast(thing)
Handle_TDataStd_BooleanArray_DownCast = _TDataStd.Handle_TDataStd_BooleanArray_DownCast

class NCollection_List_TCollection_ExtendedString(NCollection.NCollection_BaseList):
    """
    Purpose:      Simple list to link  items together keeping the first 
    and the last one.
    Inherits BaseList, adding the data item to each node.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_List_TCollection_ExtendedString self) -> NCollection_List< TCollection_ExtendedString >::iterator

        Returns an iterator pointing to the first element in the list.

        :rtype: iterator

        """
        return _TDataStd.NCollection_List_TCollection_ExtendedString_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_List_TCollection_ExtendedString self) -> NCollection_List< TCollection_ExtendedString >::iterator

        Returns an iterator referring to the past-the-end element in the list.

        :rtype: iterator

        """
        return _TDataStd.NCollection_List_TCollection_ExtendedString_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_List_TCollection_ExtendedString self) -> NCollection_List< TCollection_ExtendedString >::const_iterator

        Returns a const iterator pointing to the first element in the list.

        :rtype: const_iterator

        """
        return _TDataStd.NCollection_List_TCollection_ExtendedString_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_List_TCollection_ExtendedString self) -> NCollection_List< TCollection_ExtendedString >::const_iterator

        Returns a const iterator referring to the past-the-end element in the list.

        :rtype: const_iterator

        """
        return _TDataStd.NCollection_List_TCollection_ExtendedString_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:      Simple list to link  items together keeping the first 
        and the last one.
        Inherits BaseList, adding the data item to each node.
        """
        this = _TDataStd.new_NCollection_List_TCollection_ExtendedString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_List_TCollection_ExtendedString self) -> Standard_Integer

        Size - Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.NCollection_List_TCollection_ExtendedString_Size(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_List_TCollection_ExtendedString self, NCollection_List_TCollection_ExtendedString theOther) -> NCollection_List_TCollection_ExtendedString

        Replace this list by the items of another list (theOther parameter).
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _TDataStd.NCollection_List_TCollection_ExtendedString_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_List_TCollection_ExtendedString self, NCollection_List_TCollection_ExtendedString theOther) -> NCollection_List_TCollection_ExtendedString

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :rtype: OCC.wrapper.NCollection.NCollection_List

        """
        return _TDataStd.NCollection_List_TCollection_ExtendedString_assign(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_List_TCollection_ExtendedString self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear this list

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TDataStd.NCollection_List_TCollection_ExtendedString_Clear(self, *args)


    def First(self, *args):
        """
        First item

        :rtype: const TheItemType &

        """
        res = _TDataStd.NCollection_List_TCollection_ExtendedString_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Last(self, *args):
        """
        Last item

        :rtype: const TheItemType &

        """
        res = _TDataStd.NCollection_List_TCollection_ExtendedString_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Append(self, *args):
        """
        Append(NCollection_List_TCollection_ExtendedString self, TCollection_ExtendedString theItem) -> TCollection_ExtendedString
        Append(NCollection_List_TCollection_ExtendedString self, TCollection_ExtendedString theItem, NCollection_List< TCollection_ExtendedString >::Iterator & theIter)
        Append(NCollection_List_TCollection_ExtendedString self, NCollection_List_TCollection_ExtendedString theOther)

        Append another list at the end

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _TDataStd.NCollection_List_TCollection_ExtendedString_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_List_TCollection_ExtendedString self, TCollection_ExtendedString theItem) -> TCollection_ExtendedString
        Prepend(NCollection_List_TCollection_ExtendedString self, NCollection_List_TCollection_ExtendedString theOther)

        Prepend another list at the beginning

        :type theOther: OCC.wrapper.NCollection.NCollection_List

        """
        return _TDataStd.NCollection_List_TCollection_ExtendedString_Prepend(self, *args)


    def RemoveFirst(self, *args):
        """
        RemoveFirst(NCollection_List_TCollection_ExtendedString self)

        RemoveFirst item


        """
        return _TDataStd.NCollection_List_TCollection_ExtendedString_RemoveFirst(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_List_TCollection_ExtendedString self, NCollection_List< TCollection_ExtendedString >::Iterator & theIter)

        Remove item pointed by iterator theIter; 
        theIter is then set to the next item

        :type theIter: Iterator

        """
        return _TDataStd.NCollection_List_TCollection_ExtendedString_Remove(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_List_TCollection_ExtendedString self, TCollection_ExtendedString theItem, NCollection_List< TCollection_ExtendedString >::Iterator & theIter) -> TCollection_ExtendedString
        InsertBefore(NCollection_List_TCollection_ExtendedString self, NCollection_List_TCollection_ExtendedString theOther, NCollection_List< TCollection_ExtendedString >::Iterator & theIter)

        InsertBefore

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _TDataStd.NCollection_List_TCollection_ExtendedString_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_List_TCollection_ExtendedString self, TCollection_ExtendedString theItem, NCollection_List< TCollection_ExtendedString >::Iterator & theIter) -> TCollection_ExtendedString
        InsertAfter(NCollection_List_TCollection_ExtendedString self, NCollection_List_TCollection_ExtendedString theOther, NCollection_List< TCollection_ExtendedString >::Iterator & theIter)

        InsertAfter

        :type theOther: OCC.wrapper.NCollection.NCollection_List
        :type theIter: Iterator

        """
        return _TDataStd.NCollection_List_TCollection_ExtendedString_InsertAfter(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_List_TCollection_ExtendedString self)

        Reverse the list


        """
        return _TDataStd.NCollection_List_TCollection_ExtendedString_Reverse(self, *args)


    def __iter__(self):
        return _TDataStd.NCollection_List_TCollection_ExtendedString___iter__(self)
    __swig_destroy__ = _TDataStd.delete_NCollection_List_TCollection_ExtendedString
NCollection_List_TCollection_ExtendedString_swigregister = _TDataStd.NCollection_List_TCollection_ExtendedString_swigregister
NCollection_List_TCollection_ExtendedString_swigregister(NCollection_List_TCollection_ExtendedString)

class NCollection_List_TCollection_ExtendedString_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TDataStd.new_NCollection_List_TCollection_ExtendedString_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TDataStd.delete_NCollection_List_TCollection_ExtendedString_IteratorHelper

    def __next__(self):
        return _TDataStd.NCollection_List_TCollection_ExtendedString_IteratorHelper___next__(self)
NCollection_List_TCollection_ExtendedString_IteratorHelper_swigregister = _TDataStd.NCollection_List_TCollection_ExtendedString_IteratorHelper_swigregister
NCollection_List_TCollection_ExtendedString_IteratorHelper_swigregister(NCollection_List_TCollection_ExtendedString_IteratorHelper)


try:
	TDataStd_ListOfExtendedString = NCollection_List_TCollection_ExtendedString
except NameError:
	pass # does not exist, probably ignored

class Handle_TDataStd_Expression(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_Expression self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_Expression_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_Expression self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_Expression_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_Expression self, TDataStd_Expression thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_Expression_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_Expression self, Handle_TDataStd_Expression theHandle) -> Handle_TDataStd_Expression
        assign(Handle_TDataStd_Expression self, TDataStd_Expression thePtr) -> Handle_TDataStd_Expression
        assign(Handle_TDataStd_Expression self, Handle_TDataStd_Expression theHandle) -> Handle_TDataStd_Expression

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_Expression_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_Expression self) -> TDataStd_Expression

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_Expression_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_Expression self) -> TDataStd_Expression

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_Expression___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_Expression self) -> TDataStd_Expression

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_Expression___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_Expression___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_Expression___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_Expression(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_Expression_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_Expression

    def GetID(self, *args):
        """
        class methods
        =============

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_Expression_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_TDataStd_Expression self, TDF_Label label) -> Handle_TDataStd_Expression

        Find, or create, an Expression attribute.
        Expressionmethods
        ============

        :type label: OCC.wrapper.TDF.TDF_Label
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_Expression

        """
        return _TDataStd.Handle_TDataStd_Expression_Set(self, *args)


    def Name(self, *args):
        """
        Name(Handle_TDataStd_Expression self) -> TCollection_ExtendedString

        build and return the expression name

        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDataStd.Handle_TDataStd_Expression_Name(self, *args)


    def SetExpression(self, *args):
        """
        SetExpression(Handle_TDataStd_Expression self, TCollection_ExtendedString E)

        :type E: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        return _TDataStd.Handle_TDataStd_Expression_SetExpression(self, *args)


    def GetExpression(self, *args):
        """
        :rtype: OCC.wrapper.TCollection.TCollection_ExtendedString

        """
        res = _TDataStd.Handle_TDataStd_Expression_GetExpression(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetVariables(self, *args):
        """
        GetVariables(Handle_TDataStd_Expression self) -> NCollection_List_Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.TDF_AttributeList

        """
        return _TDataStd.Handle_TDataStd_Expression_GetVariables(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_Expression_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TDataStd_Expression self, Handle_TDF_Attribute With)

        :type With: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Expression_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TDataStd_Expression self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Expression_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TDataStd_Expression self, Handle_TDF_Attribute Into, Handle_TDF_RelocationTable RT)

        :type Into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.Handle_TDataStd_Expression_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDataStd_Expression self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_Expression_Dump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_Expression self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_Expression_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_Expression_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_Expression_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetID(self, *args):
        """
        SetID(Handle_TDataStd_Expression self, Standard_GUID arg2)
        SetID(Handle_TDataStd_Expression self)

        Sets default ID defined in nested class (to be used for attributes having User ID feature).


        """
        return _TDataStd.Handle_TDataStd_Expression_SetID(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TDataStd_Expression self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_Expression_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDataStd_Expression self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Expression_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TDataStd_Expression self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Expression_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDataStd_Expression self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Expression_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TDataStd_Expression self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Expression_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TDataStd_Expression self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Expression_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TDataStd_Expression self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Expression_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TDataStd_Expression self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Expression_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDataStd_Expression self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Expression_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TDataStd_Expression self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Expression_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TDataStd_Expression self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDataStd.Handle_TDataStd_Expression_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TDataStd_Expression self)

        Something to do after adding an Attribute to a label.


        """
        return _TDataStd.Handle_TDataStd_Expression_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TDataStd_Expression self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_Expression_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TDataStd_Expression self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TDataStd.Handle_TDataStd_Expression_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TDataStd_Expression self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_Expression_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TDataStd_Expression self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Expression_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TDataStd_Expression self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Expression_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TDataStd_Expression self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Expression_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TDataStd_Expression self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDataStd.Handle_TDataStd_Expression_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TDataStd_Expression self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDataStd.Handle_TDataStd_Expression_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TDataStd_Expression self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Expression_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TDataStd_Expression self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_Expression_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TDataStd_Expression self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDataStd.Handle_TDataStd_Expression_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TDataStd_Expression self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDataStd.Handle_TDataStd_Expression_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TDataStd_Expression self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDataStd.Handle_TDataStd_Expression_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TDataStd_Expression self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDataStd.Handle_TDataStd_Expression_DeltaOnRemoval(self, *args)


    def References(self, *args):
        """
        References(Handle_TDataStd_Expression self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDataStd.Handle_TDataStd_Expression_References(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDataStd_Expression self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_Expression___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TDataStd_Expression self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDataStd.Handle_TDataStd_Expression_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TDataStd_Expression self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDataStd.Handle_TDataStd_Expression_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_Expression self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_Expression_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_Expression self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_Expression self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Expression_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_Expression self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_Expression self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_Expression_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_Expression self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_Expression_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_Expression self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Expression_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_Expression self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_Expression_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_Expression self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_Expression_DecrementRefCounter(self, *args)

Handle_TDataStd_Expression_swigregister = _TDataStd.Handle_TDataStd_Expression_swigregister
Handle_TDataStd_Expression_swigregister(Handle_TDataStd_Expression)

def Handle_TDataStd_Expression_DownCast(thing):
    return _TDataStd.Handle_TDataStd_Expression_DownCast(thing)
Handle_TDataStd_Expression_DownCast = _TDataStd.Handle_TDataStd_Expression_DownCast

class Handle_TDataStd_HDataMapOfStringInteger(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_HDataMapOfStringInteger self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringInteger_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_HDataMapOfStringInteger self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringInteger_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_HDataMapOfStringInteger self, TDataStd_HDataMapOfStringInteger thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringInteger_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_HDataMapOfStringInteger self, Handle_TDataStd_HDataMapOfStringInteger theHandle) -> Handle_TDataStd_HDataMapOfStringInteger
        assign(Handle_TDataStd_HDataMapOfStringInteger self, TDataStd_HDataMapOfStringInteger thePtr) -> Handle_TDataStd_HDataMapOfStringInteger
        assign(Handle_TDataStd_HDataMapOfStringInteger self, Handle_TDataStd_HDataMapOfStringInteger theHandle) -> Handle_TDataStd_HDataMapOfStringInteger

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringInteger_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_HDataMapOfStringInteger self) -> TDataStd_HDataMapOfStringInteger

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringInteger_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_HDataMapOfStringInteger self) -> TDataStd_HDataMapOfStringInteger

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringInteger___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_HDataMapOfStringInteger self) -> TDataStd_HDataMapOfStringInteger

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringInteger___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_HDataMapOfStringInteger___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_HDataMapOfStringInteger___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_HDataMapOfStringInteger(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_HDataMapOfStringInteger_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_HDataMapOfStringInteger

    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_HDataMapOfStringInteger self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringInteger_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_HDataMapOfStringInteger_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_HDataMapOfStringInteger_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Map(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_DataMapOfStringInteger

        """
        res = _TDataStd.Handle_TDataStd_HDataMapOfStringInteger_Map(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeMap(self, *args):
        """
        ChangeMap(Handle_TDataStd_HDataMapOfStringInteger self) -> NCollection_DataMap_TCollection_ExtendedString_Standard_Integer_TCollection_ExtendedString

        :rtype: OCC.wrapper.TColStd.TColStd_DataMapOfStringInteger

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringInteger_ChangeMap(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_HDataMapOfStringInteger self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringInteger_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_HDataMapOfStringInteger self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_HDataMapOfStringInteger self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringInteger_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_HDataMapOfStringInteger self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_HDataMapOfStringInteger self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringInteger_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_HDataMapOfStringInteger self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringInteger_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_HDataMapOfStringInteger self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringInteger_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_HDataMapOfStringInteger self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringInteger_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_HDataMapOfStringInteger self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringInteger_DecrementRefCounter(self, *args)

Handle_TDataStd_HDataMapOfStringInteger_swigregister = _TDataStd.Handle_TDataStd_HDataMapOfStringInteger_swigregister
Handle_TDataStd_HDataMapOfStringInteger_swigregister(Handle_TDataStd_HDataMapOfStringInteger)

def Handle_TDataStd_HDataMapOfStringInteger_DownCast(thing):
    return _TDataStd.Handle_TDataStd_HDataMapOfStringInteger_DownCast(thing)
Handle_TDataStd_HDataMapOfStringInteger_DownCast = _TDataStd.Handle_TDataStd_HDataMapOfStringInteger_DownCast

class Handle_TDataStd_HDataMapOfStringByte(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_HDataMapOfStringByte self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringByte_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_HDataMapOfStringByte self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringByte_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_HDataMapOfStringByte self, TDataStd_HDataMapOfStringByte thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringByte_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_HDataMapOfStringByte self, Handle_TDataStd_HDataMapOfStringByte theHandle) -> Handle_TDataStd_HDataMapOfStringByte
        assign(Handle_TDataStd_HDataMapOfStringByte self, TDataStd_HDataMapOfStringByte thePtr) -> Handle_TDataStd_HDataMapOfStringByte
        assign(Handle_TDataStd_HDataMapOfStringByte self, Handle_TDataStd_HDataMapOfStringByte theHandle) -> Handle_TDataStd_HDataMapOfStringByte

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringByte_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_HDataMapOfStringByte self) -> TDataStd_HDataMapOfStringByte

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringByte_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_HDataMapOfStringByte self) -> TDataStd_HDataMapOfStringByte

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringByte___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_HDataMapOfStringByte self) -> TDataStd_HDataMapOfStringByte

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringByte___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_HDataMapOfStringByte___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_HDataMapOfStringByte___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_HDataMapOfStringByte(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_HDataMapOfStringByte_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_HDataMapOfStringByte

    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_HDataMapOfStringByte self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringByte_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_HDataMapOfStringByte_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_HDataMapOfStringByte_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Map(self, *args):
        """
        :rtype: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringByte

        """
        res = _TDataStd.Handle_TDataStd_HDataMapOfStringByte_Map(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeMap(self, *args):
        """
        ChangeMap(Handle_TDataStd_HDataMapOfStringByte self) -> NCollection_DataMap_TCollection_ExtendedString_Standard_Byte_TCollection_ExtendedString

        :rtype: OCC.wrapper.TDataStd.TDataStd_DataMapOfStringByte

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringByte_ChangeMap(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_HDataMapOfStringByte self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringByte_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_HDataMapOfStringByte self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_HDataMapOfStringByte self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringByte_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_HDataMapOfStringByte self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_HDataMapOfStringByte self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringByte_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_HDataMapOfStringByte self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringByte_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_HDataMapOfStringByte self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringByte_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_HDataMapOfStringByte self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringByte_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_HDataMapOfStringByte self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_HDataMapOfStringByte_DecrementRefCounter(self, *args)

Handle_TDataStd_HDataMapOfStringByte_swigregister = _TDataStd.Handle_TDataStd_HDataMapOfStringByte_swigregister
Handle_TDataStd_HDataMapOfStringByte_swigregister(Handle_TDataStd_HDataMapOfStringByte)

def Handle_TDataStd_HDataMapOfStringByte_DownCast(thing):
    return _TDataStd.Handle_TDataStd_HDataMapOfStringByte_DownCast(thing)
Handle_TDataStd_HDataMapOfStringByte_DownCast = _TDataStd.Handle_TDataStd_HDataMapOfStringByte_DownCast

class Handle_TDataStd_IntPackedMap(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TDataStd_IntPackedMap self)

        Nullify the handle


        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TDataStd_IntPackedMap self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TDataStd_IntPackedMap self, TDataStd_IntPackedMap thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TDataStd_IntPackedMap self, Handle_TDataStd_IntPackedMap theHandle) -> Handle_TDataStd_IntPackedMap
        assign(Handle_TDataStd_IntPackedMap self, TDataStd_IntPackedMap thePtr) -> Handle_TDataStd_IntPackedMap
        assign(Handle_TDataStd_IntPackedMap self, Handle_TDataStd_IntPackedMap theHandle) -> Handle_TDataStd_IntPackedMap

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TDataStd_IntPackedMap self) -> TDataStd_IntPackedMap

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TDataStd_IntPackedMap self) -> TDataStd_IntPackedMap

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TDataStd_IntPackedMap self) -> TDataStd_IntPackedMap

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap___ref__(self, *args)


    def __hash__(self):
        return _TDataStd.Handle_TDataStd_IntPackedMap___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TDataStd.Handle_TDataStd_IntPackedMap___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TDataStd.new_Handle_TDataStd_IntPackedMap(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TDataStd.Handle_TDataStd_IntPackedMap_DownCast)
    __swig_destroy__ = _TDataStd.delete_Handle_TDataStd_IntPackedMap

    def get_type_name(self, *args):
        """
        get_type_name(Handle_TDataStd_IntPackedMap self) -> char const *

        :rtype: const char *

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_IntPackedMap_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TDataStd.Handle_TDataStd_IntPackedMap_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetID(self, *args):
        """
        class methods
        =============
        Returns the GUID of the attribute.

        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_IntPackedMap_GetID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Set(self, *args):
        """
        Set(Handle_TDataStd_IntPackedMap self, TDF_Label label, Standard_Boolean const isDelta) -> Handle_TDataStd_IntPackedMap

        Finds or creates an integer map attribute on the given label.
        If <isDelta> == False, DefaultDeltaOnModification is used.
        If <isDelta> == True, DeltaOnModification of the current attribute is used.
        If attribute is already set, input parameter <isDelta> is refused and the found
        attribute returned.
        Attribute methods
        ===================

        :type label: OCC.wrapper.TDF.TDF_Label
        :type isDelta: bool
        :rtype: OCC.wrapper.TDataStd.Handle_TDataStd_IntPackedMap

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_Set(self, *args)


    def ChangeMap(self, *args):
        """
        ChangeMap(Handle_TDataStd_IntPackedMap self, Handle_TColStd_HPackedMapOfInteger theMap) -> Standard_Boolean
        ChangeMap(Handle_TDataStd_IntPackedMap self, TColStd_PackedMapOfInteger theMap) -> Standard_Boolean

        :type theMap: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_ChangeMap(self, *args)


    def GetMap(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.TColStd_PackedMapOfInteger

        """
        res = _TDataStd.Handle_TDataStd_IntPackedMap_GetMap(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetHMap(self, *args):
        """
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HPackedMapOfInteger

        """
        res = _TDataStd.Handle_TDataStd_IntPackedMap_GetHMap(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(Handle_TDataStd_IntPackedMap self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_Clear(self, *args)


    def Add(self, *args):
        """
        Add(Handle_TDataStd_IntPackedMap self, Standard_Integer const theKey) -> Standard_Boolean

        :type theKey: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_Add(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_TDataStd_IntPackedMap self, Standard_Integer const theKey) -> Standard_Boolean

        :type theKey: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_Remove(self, *args)


    def Contains(self, *args):
        """
        Contains(Handle_TDataStd_IntPackedMap self, Standard_Integer const theKey) -> Standard_Boolean

        :type theKey: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_Contains(self, *args)


    def Extent(self, *args):
        """
        Extent(Handle_TDataStd_IntPackedMap self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_Extent(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(Handle_TDataStd_IntPackedMap self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_IsEmpty(self, *args)


    def GetDelta(self, *args):
        """
        GetDelta(Handle_TDataStd_IntPackedMap self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_GetDelta(self, *args)


    def SetDelta(self, *args):
        """
        SetDelta(Handle_TDataStd_IntPackedMap self, Standard_Boolean const isDelta)

        for  internal  use  only!

        :type isDelta: bool

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_SetDelta(self, *args)


    def ID(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Standard_GUID

        """
        res = _TDataStd.Handle_TDataStd_IntPackedMap_ID(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Restore(self, *args):
        """
        Restore(Handle_TDataStd_IntPackedMap self, Handle_TDF_Attribute arg2)

        :type with: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_Restore(self, *args)


    def NewEmpty(self, *args):
        """
        NewEmpty(Handle_TDataStd_IntPackedMap self) -> Handle_TDF_Attribute

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_NewEmpty(self, *args)


    def Paste(self, *args):
        """
        Paste(Handle_TDataStd_IntPackedMap self, Handle_TDF_Attribute into, Handle_TDF_RelocationTable RT)

        :type into: OCC.wrapper.TDF.Handle_TDF_Attribute
        :type RT: OCC.wrapper.TDF.Handle_TDF_RelocationTable

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_Paste(self, *args)


    def Dump(self, *args):
        """
        Dump(Handle_TDataStd_IntPackedMap self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_Dump(self, *args)


    def SetID(self, *args):
        """
        SetID(Handle_TDataStd_IntPackedMap self, Standard_GUID arg2)
        SetID(Handle_TDataStd_IntPackedMap self)

        Sets default ID defined in nested class (to be used for attributes having User ID feature).


        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_SetID(self, *args)


    def Label(self, *args):
        """
        Label(Handle_TDataStd_IntPackedMap self) -> TDF_Label

        Returns   the   label to which  the   attribute is
        attached. If the  label is not  included in a  DF,
        the label is null. See Label.
        Warning
        If the label is not included in a data
        framework, it is null.
        This function should not be redefined inline.

        :rtype: OCC.wrapper.TDF.TDF_Label

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_Label(self, *args)


    def Transaction(self, *args):
        """
        Transaction(Handle_TDataStd_IntPackedMap self) -> Standard_Integer

        Returns the transaction index in which the
        attribute has been created or modified.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_Transaction(self, *args)


    def UntilTransaction(self, *args):
        """
        UntilTransaction(Handle_TDataStd_IntPackedMap self) -> Standard_Integer

        Returns the upper transaction index until which
        the attribute is/was valid. This number may
        vary. A removed attribute validity range is
        reduced to its transaction index.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_UntilTransaction(self, *args)


    def IsValid(self, *args):
        """
        IsValid(Handle_TDataStd_IntPackedMap self) -> Standard_Boolean

        Returns true if the attribute is valid; i.e. not a
        backuped or removed one.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_IsValid(self, *args)


    def IsNew(self, *args):
        """
        IsNew(Handle_TDataStd_IntPackedMap self) -> Standard_Boolean

        Returns true if the attribute has no backup

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_IsNew(self, *args)


    def IsForgotten(self, *args):
        """
        IsForgotten(Handle_TDataStd_IntPackedMap self) -> Standard_Boolean

        Returns true if the attribute forgotten status is
        set.

        ShortCut Methods concerning associated attributes
        =================================================

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_IsForgotten(self, *args)


    def IsAttribute(self, *args):
        """
        IsAttribute(Handle_TDataStd_IntPackedMap self, Standard_GUID anID) -> Standard_Boolean

        Returns true if it  exists an associated attribute
        of <me> with <anID> as ID.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_IsAttribute(self, *args)


    def FindAttribute(self, *args):
        """
        FindAttribute(Handle_TDataStd_IntPackedMap self, Standard_GUID anID, Handle_TDF_Attribute anAttribute) -> Standard_Boolean

        Finds an associated  attribute of  <me>, according
        to <anID>.  the returned <anAttribute> is a  valid
        one. The  method  returns  True if   found,  False
        otherwise.   A removed attribute  cannot be found using
        this  method.

        :type anID: OCC.wrapper.Standard.Standard_GUID
        :type anAttribute: OCC.wrapper.TDF.Handle_TDF_Attribute
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_FindAttribute(self, *args)


    def AddAttribute(self, *args):
        """
        AddAttribute(Handle_TDataStd_IntPackedMap self, Handle_TDF_Attribute other)

        Adds   an   Attribute <other>  to  the   label  of
        <me>.Raises if there is  already  one of the same
        GUID fhan <other>.

        :type other: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_AddAttribute(self, *args)


    def ForgetAttribute(self, *args):
        """
        ForgetAttribute(Handle_TDataStd_IntPackedMap self, Standard_GUID aguid) -> Standard_Boolean

        Forgets  the Attribute of  GUID <aguid> associated
        to the label of <me>. Be  carefull that if <me> is
        the attribute of <guid>, <me> will have a null label
        after this call.  If  the attribute doesn't  exist
        returns False. Otherwise returns True.

        :type aguid: OCC.wrapper.Standard.Standard_GUID
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_ForgetAttribute(self, *args)


    def ForgetAllAttributes(self, *args):
        """
        ForgetAllAttributes(Handle_TDataStd_IntPackedMap self, Standard_Boolean const clearChildren)

        Forgets all the  attributes attached to  the label
        of <me>.    Does   it   on  the  sub-labels   if
        <clearChildren> is set  to true.  Of  course, this
        method  is  compatible with Transaction  &  Delta
        mecanisms. Be carefull  that  if <me> will have a
        null label after this call

        :type clearChildren: bool

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_ForgetAllAttributes(self, *args)


    def AfterAddition(self, *args):
        """
        AfterAddition(Handle_TDataStd_IntPackedMap self)

        Something to do after adding an Attribute to a label.


        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_AfterAddition(self, *args)


    def BeforeRemoval(self, *args):
        """
        BeforeRemoval(Handle_TDataStd_IntPackedMap self)

        Something to do before removing an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_BeforeRemoval(self, *args)


    def BeforeForget(self, *args):
        """
        BeforeForget(Handle_TDataStd_IntPackedMap self)

        Something to do before forgetting an Attribute to a
        label.


        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_BeforeForget(self, *args)


    def AfterResume(self, *args):
        """
        AfterResume(Handle_TDataStd_IntPackedMap self)

        Something to do after resuming an Attribute from
        a label.


        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_AfterResume(self, *args)


    def AfterRetrieval(self, *args):
        """
        AfterRetrieval(Handle_TDataStd_IntPackedMap self, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do AFTER creation of an attribute by
        persistent-transient translation. The returned
        status says if AfterUndo has been performed (true)
        or if this callback must be called once again
        further (false). If <forceIt> is set to true, the
        method MUST perform and return true. Does nothing
        by default and returns true.

        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_AfterRetrieval(self, *args)


    def BeforeUndo(self, *args):
        """
        BeforeUndo(Handle_TDataStd_IntPackedMap self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do before applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_BeforeUndo(self, *args)


    def AfterUndo(self, *args):
        """
        AfterUndo(Handle_TDataStd_IntPackedMap self, Handle_TDF_AttributeDelta anAttDelta, Standard_Boolean const forceIt) -> Standard_Boolean

        Something to do after applying <anAttDelta>. The
        returned status says if AfterUndo has been
        performed (true) or if this callback must be
        called once again further (false). If <forceIt> is
        set to true, the method MUST perform and return
        true. Does nothing by default and returns true.

        :type anAttDelta: OCC.wrapper.TDF.Handle_TDF_AttributeDelta
        :type forceIt: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_AfterUndo(self, *args)


    def BeforeCommitTransaction(self, *args):
        """
        BeforeCommitTransaction(Handle_TDataStd_IntPackedMap self)

        A callback.
        By default does nothing.
        It is called by TDF_Data::CommitTransaction() method.


        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_BeforeCommitTransaction(self, *args)


    def Backup(self, *args):
        """
        Backup(Handle_TDataStd_IntPackedMap self)

        Backups the attribute. The backuped attribute is
        flagged "Backuped" and not "Valid".

        The method does nothing:

        1) If the attribute transaction number is equal to
        the current transaction number (the attribute has
        already been backuped).

        2) If the attribute is not attached to a label.


        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_Backup(self, *args)


    def IsBackuped(self, *args):
        """
        IsBackuped(Handle_TDataStd_IntPackedMap self) -> Standard_Boolean

        Returns true if the attribute backup status is
        set. This status is set/unset by the
        Backup() method.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_IsBackuped(self, *args)


    def BackupCopy(self, *args):
        """
        BackupCopy(Handle_TDataStd_IntPackedMap self) -> Handle_TDF_Attribute

        Copies  the attribute  contents into  a  new other
        attribute. It is used by Backup().

        :rtype: OCC.wrapper.TDF.Handle_TDF_Attribute

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_BackupCopy(self, *args)


    def DeltaOnAddition(self, *args):
        """
        DeltaOnAddition(Handle_TDataStd_IntPackedMap self) -> Handle_TDF_DeltaOnAddition

        Makes an AttributeDelta because <me>
        appeared. The only known use of a redefinition of
        this method is to return a null handle (no delta).

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnAddition

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_DeltaOnAddition(self, *args)


    def DeltaOnForget(self, *args):
        """
        DeltaOnForget(Handle_TDataStd_IntPackedMap self) -> Handle_TDF_DeltaOnForget

        Makes an AttributeDelta because <me> has been
        forgotten.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnForget

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_DeltaOnForget(self, *args)


    def DeltaOnResume(self, *args):
        """
        DeltaOnResume(Handle_TDataStd_IntPackedMap self) -> Handle_TDF_DeltaOnResume

        Makes an AttributeDelta because <me> has been
        resumed.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnResume

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_DeltaOnResume(self, *args)


    def DeltaOnRemoval(self, *args):
        """
        DeltaOnRemoval(Handle_TDataStd_IntPackedMap self) -> Handle_TDF_DeltaOnRemoval

        Makes a DeltaOnRemoval on <me> because <me> has
        disappeared from the DS.

        :rtype: OCC.wrapper.TDF.Handle_TDF_DeltaOnRemoval

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_DeltaOnRemoval(self, *args)


    def References(self, *args):
        """
        References(Handle_TDataStd_IntPackedMap self, Handle_TDF_DataSet aDataSet)

        Adds the first level referenced attributes and labels
        to <aDataSet>.

        For this, use the AddLabel or AddAttribute of
        DataSet.

        If there is none, do not implement the method.

        :type aDataSet: OCC.wrapper.TDF.Handle_TDF_DataSet

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_References(self, *args)


    def __lshift__(self, *args):
        """
        __lshift__(Handle_TDataStd_IntPackedMap self, Standard_OStream & anOS) -> Standard_OStream &

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap___lshift__(self, *args)


    def ExtendedDump(self, *args):
        """
        ExtendedDump(Handle_TDataStd_IntPackedMap self, Standard_OStream & anOS, TDF_IDFilter aFilter, NCollection_IndexedMap_Handle_TDF_Attribute_TColStd_MapTransientHasher aMap)

        Dumps the attribute content on <aStream>, using
        <aMap> like this: if an attribute is not in the
        map, first put add it to the map and then dump it.
        Use the map rank instead of dumping each attribute
        field.

        :type anOS: OCC.wrapper.Standard.Standard_OStream
        :type aFilter: OCC.wrapper.TDF.TDF_IDFilter
        :type aMap: OCC.wrapper.TDF.TDF_AttributeIndexedMap

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_ExtendedDump(self, *args)


    def Forget(self, *args):
        """
        Forget(Handle_TDataStd_IntPackedMap self, Standard_Integer const aTransaction)

        Forgets the attribute. <aTransaction> is the
        current transaction in which the forget is done. A
        forgotten attribute is also flagged not "Valid".

        A forgotten attribute is invisible. Set also the
        "Valid" status to False. Obvioulsy, DF cannot
        empty an attribute (this has a semantic
        signification), but can remove it from the
        structure. So, a forgotten attribute is NOT an empty
        one, but a soon DEAD one.

        Should be private.

        :type aTransaction: int

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_Forget(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_TDataStd_IntPackedMap self)

        Memory deallocator for transient classes


        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TDataStd_IntPackedMap self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TDataStd_IntPackedMap self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TDataStd_IntPackedMap self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TDataStd_IntPackedMap self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TDataStd_IntPackedMap self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TDataStd_IntPackedMap self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TDataStd_IntPackedMap self)

        Increments the reference counter of this object


        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TDataStd_IntPackedMap self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TDataStd.Handle_TDataStd_IntPackedMap_DecrementRefCounter(self, *args)

Handle_TDataStd_IntPackedMap_swigregister = _TDataStd.Handle_TDataStd_IntPackedMap_swigregister
Handle_TDataStd_IntPackedMap_swigregister(Handle_TDataStd_IntPackedMap)

def Handle_TDataStd_IntPackedMap_DownCast(thing):
    return _TDataStd.Handle_TDataStd_IntPackedMap_DownCast(thing)
Handle_TDataStd_IntPackedMap_DownCast = _TDataStd.Handle_TDataStd_IntPackedMap_DownCast




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Geom2dConvert')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Geom2dConvert')
    _Geom2dConvert = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Geom2dConvert', [dirname(__file__)])
        except ImportError:
            import _Geom2dConvert
            return _Geom2dConvert
        try:
            _mod = imp.load_module('_Geom2dConvert', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Geom2dConvert = swig_import_helper()
    del swig_import_helper
else:
    import _Geom2dConvert
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Geom2dConvert.delete_SwigPyIterator

    def value(self):
        return _Geom2dConvert.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Geom2dConvert.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Geom2dConvert.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Geom2dConvert.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Geom2dConvert.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Geom2dConvert.SwigPyIterator_copy(self)

    def next(self):
        return _Geom2dConvert.SwigPyIterator_next(self)

    def __next__(self):
        return _Geom2dConvert.SwigPyIterator___next__(self)

    def previous(self):
        return _Geom2dConvert.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Geom2dConvert.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Geom2dConvert.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Geom2dConvert.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Geom2dConvert.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Geom2dConvert.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Geom2dConvert.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Geom2dConvert.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _Geom2dConvert.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Geom2dConvert.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_Geom2dConvert.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _Geom2dConvert.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Geom2dConvert.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Geom2dConvert.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _Geom2dConvert.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _Geom2dConvert.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _Geom2dConvert.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Geom2dConvert.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_Geom2dConvert.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _Geom2dConvert.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Geom2dConvert.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Geom2dConvert.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _Geom2dConvert.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _Geom2dConvert.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _Geom2dConvert.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _Geom2dConvert.ptr_to_number(item)
ptr_to_number = _Geom2dConvert.ptr_to_number

def HashCode(*args):
    return _Geom2dConvert.HashCode(*args)
HashCode = _Geom2dConvert.HashCode

def ptr_equal(a, b):
    return _Geom2dConvert.ptr_equal(a, b)
ptr_equal = _Geom2dConvert.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColGeom2d
else:
    import TColGeom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Convert
else:
    import Convert
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
class Geom2dConvert_BSplineCurveToBezierCurve(object):
    """
    An algorithm to convert a BSpline curve into a series
    of adjacent Bezier curves.
    A BSplineCurveToBezierCurve object provides a framework for:
    -   defining the BSpline curve to be converted
    -   implementing the construction algorithm, and
    -   consulting the results.
    References :
    Generating the Bezier points of B-spline curves and surfaces
    (Wolfgang Bohm) CAD volume 13 number 6 november 1981
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dConvert_BSplineCurveToBezierCurve self, Handle_Geom2d_BSplineCurve BasisCurve) -> Geom2dConvert_BSplineCurveToBezierCurve
        __init__(Geom2dConvert_BSplineCurveToBezierCurve self, Handle_Geom2d_BSplineCurve BasisCurve, Standard_Real const U1, Standard_Real const U2, Standard_Real const ParametricTolerance) -> Geom2dConvert_BSplineCurveToBezierCurve

        Computes all the data needed to convert
        the portion of the BSpline curve BasisCurve
        limited by the two parameter values U1 and U2
        for Example if there is a Knot Uk and
        Uk < U < Uk + ParametricTolerance/2 the last curve
        corresponds to the span [Uk-1, Uk] and not to  [Uk, Uk+1]
        The result consists of a series of BasisCurve arcs
        limited by points corresponding to knot values of the curve.
        Use the available interrogation functions to ascertain
        the number of computed Bezier arcs, and then to
        construct each individual Bezier curve (or all Bezier curves).
        Note: ParametricTolerance is not used.
        Raises DomainError if U1 or U2 are out of the parametric bounds of the basis
        curve [FirstParameter, LastParameter]. The Tolerance criterion
        is ParametricTolerance.
        Raised if Abs (U2 - U1) <= ParametricTolerance.

        :type BasisCurve: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve
        :type U1: float
        :type U2: float
        :type ParametricTolerance: float

        """
        this = _Geom2dConvert.new_Geom2dConvert_BSplineCurveToBezierCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Arc(self, *args):
        """
        Arc(Geom2dConvert_BSplineCurveToBezierCurve self, Standard_Integer const Index) -> Handle_Geom2d_BezierCurve

        Constructs and returns the Bezier curve of index
        Index to the table of adjacent Bezier arcs
        computed by this algorithm.
        This Bezier curve has the same orientation as the
        BSpline curve analyzed in this framework.
        Exceptions
        Standard_OutOfRange if Index is less than 1 or
        greater than the number of adjacent Bezier arcs
        computed by this algorithm.

        :type Index: int
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BezierCurve

        """
        return _Geom2dConvert.Geom2dConvert_BSplineCurveToBezierCurve_Arc(self, *args)


    def Arcs(self, *args):
        """
        Arcs(Geom2dConvert_BSplineCurveToBezierCurve self, NCollection_Array1_Handle_Geom2d_BezierCurve Curves)

        Constructs all the Bezier curves whose data is
        computed by this algorithm and loads these curves
        into the Curves table.
        The Bezier curves have the same orientation as the
        BSpline curve analyzed in this framework.
        Exceptions
        Standard_DimensionError if the Curves array was
        not created with the following bounds:
        -   1 , and
        -   the number of adjacent Bezier arcs computed by
        this algorithm (as given by the function NbArcs).

        :type Curves: OCC.wrapper.TColGeom2d.TColGeom2d_Array1OfBezierCurve

        """
        return _Geom2dConvert.Geom2dConvert_BSplineCurveToBezierCurve_Arcs(self, *args)


    def Knots(self, *args):
        """
        Knots(Geom2dConvert_BSplineCurveToBezierCurve self, NCollection_Array1_Standard_Real TKnots)

        This methode returns the bspline's knots associated to
        the converted arcs
        Raises DimensionError if the length  of Curves is not equal to
        NbArcs +  1

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _Geom2dConvert.Geom2dConvert_BSplineCurveToBezierCurve_Knots(self, *args)


    def NbArcs(self, *args):
        """
        NbArcs(Geom2dConvert_BSplineCurveToBezierCurve self) -> Standard_Integer

        Returns the number of BezierCurve arcs.
        If at the creation time you have decomposed the basis curve
        between the parametric values UFirst, ULast the number of
        BezierCurve arcs depends on the number of knots included inside
        the interval [UFirst, ULast].
        If you have decomposed the whole basis B-spline curve the number
        of BezierCurve arcs NbArcs is equal to the number of knots less
        one.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dConvert.Geom2dConvert_BSplineCurveToBezierCurve_NbArcs(self, *args)

    __swig_destroy__ = _Geom2dConvert.delete_Geom2dConvert_BSplineCurveToBezierCurve
Geom2dConvert_BSplineCurveToBezierCurve_swigregister = _Geom2dConvert.Geom2dConvert_BSplineCurveToBezierCurve_swigregister
Geom2dConvert_BSplineCurveToBezierCurve_swigregister(Geom2dConvert_BSplineCurveToBezierCurve)

class Geom2dConvert_BSplineCurveKnotSplitting(object):
    """
    An algorithm to determine points at which a BSpline
    curve should be split in order to obtain arcs of the same continuity.
    If you require curves with a minimum continuity for
    your computation, it is useful to know the points
    between which an arc has a continuity of a given
    order. The continuity order is given at the construction time.
    For a BSpline curve, the discontinuities are
    localized at the knot values. Between two knot values
    the BSpline is infinitely and continuously
    differentiable. At a given knot, the continuity is equal
    to: Degree - Mult, where Degree is the
    degree of the BSpline curve and Mult is the multiplicity of the knot.
    It is possible to compute the arcs which correspond to
    this splitting using the global function
    SplitBSplineCurve provided by the package Geom2dConvert.
    A BSplineCurveKnotSplitting object provides a framework for:
    -   defining the curve to be analysed and the required degree of continuity,
    -   implementing the computation algorithm, and
    -   consulting the results.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dConvert_BSplineCurveKnotSplitting self, Handle_Geom2d_BSplineCurve BasisCurve, Standard_Integer const ContinuityRange) -> Geom2dConvert_BSplineCurveKnotSplitting

        Determines points at which the BSpline curve
        BasisCurve should be split in order to obtain arcs
        with a degree of continuity equal to ContinuityRange.
        These points are knot values of BasisCurve. They
        are identified by indices in the knots table of BasisCurve.
        Use the available interrogation functions to access
        computed values, followed by the global function
        SplitBSplineCurve (provided by the package
        Geom2dConvert) to split the curve.
        Exceptions
        Standard_RangeError if ContinuityRange is less than zero.

        :type BasisCurve: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve
        :type ContinuityRange: int

        """
        this = _Geom2dConvert.new_Geom2dConvert_BSplineCurveKnotSplitting(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbSplits(self, *args):
        """
        NbSplits(Geom2dConvert_BSplineCurveKnotSplitting self) -> Standard_Integer

        Returns the number of points at which the analysed
        BSpline curve should be split, in order to obtain arcs
        with the continuity required by this framework.
        All these points correspond to knot values. Note that
        the first and last points of the curve, which bound the
        first and last arcs, are counted among these splitting points.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dConvert.Geom2dConvert_BSplineCurveKnotSplitting_NbSplits(self, *args)


    def Splitting(self, *args):
        """
        Splitting(Geom2dConvert_BSplineCurveKnotSplitting self, NCollection_Array1_Standard_Integer SplitValues)

        Loads the SplitValues table with the split knots
        values computed in this framework. Each value in the
        table is an index in the knots table of the BSpline
        curve analysed by this algorithm.
        The values in SplitValues are given in ascending
        order and comprise the indices of the knots which
        give the first and last points of the curve. Use two
        consecutive values from the table as arguments of the
        global function SplitBSplineCurve (provided by the
        package Geom2dConvert) to split the curve.
        Exceptions
        Standard_DimensionError if the array SplitValues
        was not created with the following bounds:
        -   1, and
        -   the number of split points computed in this
        framework (as given by the function NbSplits).

        :type SplitValues: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _Geom2dConvert.Geom2dConvert_BSplineCurveKnotSplitting_Splitting(self, *args)


    def SplitValue(self, *args):
        """
        SplitValue(Geom2dConvert_BSplineCurveKnotSplitting self, Standard_Integer const Index) -> Standard_Integer

        Returns the split knot of index Index to the split knots
        table computed in this framework. The returned value
        is an index in the knots table of the BSpline curve
        analysed by this algorithm.
        Notes:
        -   If Index is equal to 1, the corresponding knot
        gives the first point of the curve.
        -   If Index is equal to the number of split knots
        computed in this framework, the corresponding
        point is the last point of the curve.
        Exceptions
        Standard_RangeError if Index is less than 1 or
        greater than the number of split knots computed in this framework.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _Geom2dConvert.Geom2dConvert_BSplineCurveKnotSplitting_SplitValue(self, *args)

    __swig_destroy__ = _Geom2dConvert.delete_Geom2dConvert_BSplineCurveKnotSplitting
Geom2dConvert_BSplineCurveKnotSplitting_swigregister = _Geom2dConvert.Geom2dConvert_BSplineCurveKnotSplitting_swigregister
Geom2dConvert_BSplineCurveKnotSplitting_swigregister(Geom2dConvert_BSplineCurveKnotSplitting)

class Geom2dConvert_CompCurveToBSplineCurve(object):
    """This algorithm converts and concat several curve in an BSplineCurve"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dConvert_CompCurveToBSplineCurve self, Convert_ParameterisationType const Parameterisation=Convert_TgtThetaOver2) -> Geom2dConvert_CompCurveToBSplineCurve
        __init__(Geom2dConvert_CompCurveToBSplineCurve self, Handle_Geom2d_BoundedCurve BasisCurve, Convert_ParameterisationType const Parameterisation=Convert_TgtThetaOver2) -> Geom2dConvert_CompCurveToBSplineCurve

        Initialize the algorithme with one curve
        - Parameterisation is used to convert

        :type BasisCurve: OCC.wrapper.Geom2d.Handle_Geom2d_BoundedCurve
        :type Parameterisation: OCC.wrapper.Convert.Convert_ParameterisationType

        """
        this = _Geom2dConvert.new_Geom2dConvert_CompCurveToBSplineCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args):
        """
        Add(Geom2dConvert_CompCurveToBSplineCurve self, Handle_Geom2d_BoundedCurve NewCurve, Standard_Real const Tolerance, Standard_Boolean const After) -> Standard_Boolean

        Append a curve in the BSpline
        Return False if the curve is not G0 with the BSplineCurve.
        Tolerance is used to check continuity and decrease
        Multiplicty at the common Knot
        After is usefull if BasisCurve is a closed curve .

        :type NewCurve: OCC.wrapper.Geom2d.Handle_Geom2d_BoundedCurve
        :type Tolerance: float
        :type After: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dConvert.Geom2dConvert_CompCurveToBSplineCurve_Add(self, *args)


    def BSplineCurve(self, *args):
        """
        BSplineCurve(Geom2dConvert_CompCurveToBSplineCurve self) -> Handle_Geom2d_BSplineCurve

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

        """
        return _Geom2dConvert.Geom2dConvert_CompCurveToBSplineCurve_BSplineCurve(self, *args)


    def Clear(self, *args):
        """
        Clear(Geom2dConvert_CompCurveToBSplineCurve self)

        Clear result curve


        """
        return _Geom2dConvert.Geom2dConvert_CompCurveToBSplineCurve_Clear(self, *args)

    __swig_destroy__ = _Geom2dConvert.delete_Geom2dConvert_CompCurveToBSplineCurve
Geom2dConvert_CompCurveToBSplineCurve_swigregister = _Geom2dConvert.Geom2dConvert_CompCurveToBSplineCurve_swigregister
Geom2dConvert_CompCurveToBSplineCurve_swigregister(Geom2dConvert_CompCurveToBSplineCurve)

class Geom2dConvert_(object):
    """
    This package provides an implementation of algorithmes to do
    the conversion between equivalent geometric entities from
    package Geom2d.
    It gives the possibility :
    . to obtain the B-spline representation of bounded curves.
    . to split a B-spline curve into several B-spline curves
    with some constraints of continuity,
    . to convert a B-spline curve into several Bezier curves
    or surfaces.
    All the geometric entities used in this package are bounded.
    References :
    . Generating the Bezier Points of B-spline curves and surfaces
    (Wolfgang Bohm) CAGD volume 13 number 6 november 1981
    . On NURBS: A Survey  (Leslie Piegl) IEEE Computer Graphics and
    Application January 1991
    . Curve and surface construction using rational B-splines
    (Leslie Piegl and Wayne Tiller) CAD Volume 19 number 9 november
    1987
    . A survey of curve and surface methods in CAGD (Wolfgang BOHM)
    CAGD 1 1984
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def SplitBSplineCurve(*args):
        """
        SplitBSplineCurve(Handle_Geom2d_BSplineCurve C, Standard_Integer const FromK1, Standard_Integer const ToK2, Standard_Boolean const SameOrientation) -> Handle_Geom2d_BSplineCurve
        SplitBSplineCurve(Handle_Geom2d_BSplineCurve C, Standard_Real const FromU1, Standard_Real const ToU2, Standard_Real const ParametricTolerance, Standard_Boolean const SameOrientation) -> Handle_Geom2d_BSplineCurve

        This function computes the segment of B-spline curve between the
        parametric values FromU1, ToU2.
        If C is periodic the arc has the same orientation as C if
        SameOrientation = True.
        If C is not periodic SameOrientation is not used for the
        computation and C is oriented fromU1 toU2.
        If U1 and U2 and two parametric values we consider that
        U1 = U2 if Abs (U1 - U2) <= ParametricTolerance and
        ParametricTolerance must  be greater or equal to Resolution
        from package gp.

        Raised if FromU1 or ToU2 are out of the parametric bounds of the
        curve (The tolerance criterion is ParametricTolerance).
        Raised if Abs (FromU1 - ToU2) <= ParametricTolerance
        Raised if ParametricTolerance < Resolution from gp.

        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve
        :type FromU1: float
        :type ToU2: float
        :type ParametricTolerance: float
        :type SameOrientation: bool
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

        """
        return _Geom2dConvert.Geom2dConvert__SplitBSplineCurve(*args)

    SplitBSplineCurve = staticmethod(SplitBSplineCurve)

    def CurveToBSplineCurve(*args):
        """
        CurveToBSplineCurve(Handle_Geom2d_Curve C, Convert_ParameterisationType const Parameterisation=Convert_TgtThetaOver2) -> Handle_Geom2d_BSplineCurve

        This function converts a non infinite curve from
        Geom into a  B-spline curve.  C must  be  an ellipse or a
        circle or a trimmed conic  or a trimmed  line or a Bezier
        curve or a trimmed  Bezier curve or a  BSpline curve or  a
        trimmed BSpline   curve  or an  Offset  curve or a  trimmed
        Offset curve.
        The returned B-spline is not periodic except if C is a
        Circle or an Ellipse.
        ParameterisationType applies only if the curve is a Circle
        or an ellipse :
        TgtThetaOver2,
        TgtThetaOver2_1,
        TgtThetaOver2_2,
        TgtThetaOver2_3,
        TgtThetaOver2_4,
        Purpose: this is the classical rational parameterisation
        2
        1 - t
        cos(theta) = ------
        2
        1 + t

        2t
        sin(theta) = ------
        2
        1 + t

        t = tan (theta/2)

        with TgtThetaOver2  the routine will compute the number of spans
        using the rule num_spans = [ (ULast - UFirst) / 1.2 ] + 1
        with TgtThetaOver2_N, N  spans will be forced: an error will
        be raized if (ULast - UFirst) >= PI and N = 1,
        ULast - UFirst >= 2 PI and N = 2

        QuasiAngular,
        here t is a rational function that approximates
        theta ----> tan(theta/2).
        Neverthless the composing with above function yields exact
        functions whose square sum up to 1
        RationalC1 ;
        t is replaced by a polynomial function of u so as to grant
        C1 contiuity across knots.
        Exceptions
        Standard_DomainError if the curve C is infinite.
        Standard_ConstructionError:
        -   if C is a complete circle or ellipse, and if
        Parameterisation is not equal to
        Convert_TgtThetaOver2 or to Convert_RationalC1, or
        -   if C is a trimmed circle or ellipse and if
        Parameterisation is equal to
        Convert_TgtThetaOver2_1 and if U2 - U1 >
        0.9999 * Pi where U1 and U2 are
        respectively the first and the last parameters of the
        trimmed curve (this method of parameterization
        cannot be used to convert a half-circle or a
        half-ellipse, for example), or
        -   if C is a trimmed circle or ellipse and
        Parameterisation is equal to
        Convert_TgtThetaOver2_2 and U2 - U1 >
        1.9999 * Pi where U1 and U2 are
        respectively the first and the last parameters of the
        trimmed curve (this method of parameterization
        cannot be used to convert a quasi-complete circle or ellipse).

        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Parameterisation: OCC.wrapper.Convert.Convert_ParameterisationType
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

        """
        return _Geom2dConvert.Geom2dConvert__CurveToBSplineCurve(*args)

    CurveToBSplineCurve = staticmethod(CurveToBSplineCurve)

    def ConcatG1(*args):
        """
        ConcatG1(NCollection_Array1_Handle_Geom2d_BSplineCurve ArrayOfCurves, NCollection_Array1_Standard_Real ArrayOfToler, Handle_TColGeom2d_HArray1OfBSplineCurve ArrayOfConcatenated, Standard_Boolean const ClosedFlag, Standard_Real const ClosedTolerance)

        This Method concatenates G1 the ArrayOfCurves as far
        as it is possible.
        ArrayOfCurves[0..N-1]
        ArrayOfToler contains the  biggest tolerance of the two
        points shared by two consecutives curves.
        Its dimension: [0..N-2]
        ClosedTolerance     indicates if the ArrayOfCurves is closed.
        In this case ClosedTolerance contains the biggest tolerance
        of the two points which are at the closure.
        Otherwise its value is 0.0

        :type ArrayOfCurves: OCC.wrapper.TColGeom2d.TColGeom2d_Array1OfBSplineCurve
        :type ArrayOfToler: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type ArrayOfConcatenated: OCC.wrapper.TColGeom2d.Handle_TColGeom2d_HArray1OfBSplineCurve
        :type ClosedFlag: bool
        :type ClosedTolerance: float

        """
        return _Geom2dConvert.Geom2dConvert__ConcatG1(*args)

    ConcatG1 = staticmethod(ConcatG1)

    def ConcatC1(*args):
        """
        ConcatC1(NCollection_Array1_Handle_Geom2d_BSplineCurve ArrayOfCurves, NCollection_Array1_Standard_Real ArrayOfToler, Handle_TColStd_HArray1OfInteger ArrayOfIndices, Handle_TColGeom2d_HArray1OfBSplineCurve ArrayOfConcatenated, Standard_Boolean const ClosedFlag, Standard_Real const ClosedTolerance)
        ConcatC1(NCollection_Array1_Handle_Geom2d_BSplineCurve ArrayOfCurves, NCollection_Array1_Standard_Real ArrayOfToler, Handle_TColStd_HArray1OfInteger ArrayOfIndices, Handle_TColGeom2d_HArray1OfBSplineCurve ArrayOfConcatenated, Standard_Boolean const ClosedFlag, Standard_Real const ClosedTolerance, Standard_Real const AngularTolerance)

        This Method concatenates C1 the ArrayOfCurves as far
        as it is possible.
        ArrayOfCurves[0..N-1]
        ArrayOfToler contains the  biggest tolerance of the two
        points shared by two consecutives curves.
        Its dimension: [0..N-2]
        ClosedTolerance     indicates if the ArrayOfCurves is closed.
        In this case ClosedTolerance contains the biggest tolerance
        of the two points which are at the closure.
        Otherwise its value is 0.0

        :type ArrayOfCurves: OCC.wrapper.TColGeom2d.TColGeom2d_Array1OfBSplineCurve
        :type ArrayOfToler: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type ArrayOfIndices: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfInteger
        :type ArrayOfConcatenated: OCC.wrapper.TColGeom2d.Handle_TColGeom2d_HArray1OfBSplineCurve
        :type ClosedFlag: bool
        :type ClosedTolerance: float
        :type AngularTolerance: float

        """
        return _Geom2dConvert.Geom2dConvert__ConcatC1(*args)

    ConcatC1 = staticmethod(ConcatC1)

    def C0BSplineToC1BSplineCurve(*args):
        """
        C0BSplineToC1BSplineCurve(Handle_Geom2d_BSplineCurve BS, Standard_Real const Tolerance)

        This Method reduces as   far as it  is possible the
        multiplicities of  the  knots of  the BSpline BS.(keeping  the geometry).
        It returns a new BSpline which could still be C0.
        tolerance is a geometrical tolerance

        :type BS: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve
        :type Tolerance: float

        """
        return _Geom2dConvert.Geom2dConvert__C0BSplineToC1BSplineCurve(*args)

    C0BSplineToC1BSplineCurve = staticmethod(C0BSplineToC1BSplineCurve)

    def C0BSplineToArrayOfC1BSplineCurve(*args):
        """
        C0BSplineToArrayOfC1BSplineCurve(Handle_Geom2d_BSplineCurve BS, Handle_TColGeom2d_HArray1OfBSplineCurve tabBS, Standard_Real const Tolerance)
        C0BSplineToArrayOfC1BSplineCurve(Handle_Geom2d_BSplineCurve BS, Handle_TColGeom2d_HArray1OfBSplineCurve tabBS, Standard_Real const AngularTolerance, Standard_Real const Tolerance)

        This Method   reduces as far  as  it is possible  the
        multiplicities  of  the knots  of the BSpline  BS.(keeping the geometry).
        It returns an array of BSpline C1.
        tolerance is a geometrical tolerance

        :type BS: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve
        :type tabBS: OCC.wrapper.TColGeom2d.Handle_TColGeom2d_HArray1OfBSplineCurve
        :type AngularTolerance: float
        :type Tolerance: float

        """
        return _Geom2dConvert.Geom2dConvert__C0BSplineToArrayOfC1BSplineCurve(*args)

    C0BSplineToArrayOfC1BSplineCurve = staticmethod(C0BSplineToArrayOfC1BSplineCurve)

    def __init__(self):
        """
        This package provides an implementation of algorithmes to do
        the conversion between equivalent geometric entities from
        package Geom2d.
        It gives the possibility :
        . to obtain the B-spline representation of bounded curves.
        . to split a B-spline curve into several B-spline curves
        with some constraints of continuity,
        . to convert a B-spline curve into several Bezier curves
        or surfaces.
        All the geometric entities used in this package are bounded.
        References :
        . Generating the Bezier Points of B-spline curves and surfaces
        (Wolfgang Bohm) CAGD volume 13 number 6 november 1981
        . On NURBS: A Survey  (Leslie Piegl) IEEE Computer Graphics and
        Application January 1991
        . Curve and surface construction using rational B-splines
        (Leslie Piegl and Wayne Tiller) CAD Volume 19 number 9 november
        1987
        . A survey of curve and surface methods in CAGD (Wolfgang BOHM)
        CAGD 1 1984
        """
        this = _Geom2dConvert.new_Geom2dConvert_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Geom2dConvert.delete_Geom2dConvert_
Geom2dConvert__swigregister = _Geom2dConvert.Geom2dConvert__swigregister
Geom2dConvert__swigregister(Geom2dConvert_)

def Geom2dConvert__SplitBSplineCurve(*args):
    """
    SplitBSplineCurve(Handle_Geom2d_BSplineCurve C, Standard_Integer const FromK1, Standard_Integer const ToK2, Standard_Boolean const SameOrientation) -> Handle_Geom2d_BSplineCurve
    Geom2dConvert__SplitBSplineCurve(Handle_Geom2d_BSplineCurve C, Standard_Real const FromU1, Standard_Real const ToU2, Standard_Real const ParametricTolerance, Standard_Boolean const SameOrientation) -> Handle_Geom2d_BSplineCurve

    This function computes the segment of B-spline curve between the
    parametric values FromU1, ToU2.
    If C is periodic the arc has the same orientation as C if
    SameOrientation = True.
    If C is not periodic SameOrientation is not used for the
    computation and C is oriented fromU1 toU2.
    If U1 and U2 and two parametric values we consider that
    U1 = U2 if Abs (U1 - U2) <= ParametricTolerance and
    ParametricTolerance must  be greater or equal to Resolution
    from package gp.

    Raised if FromU1 or ToU2 are out of the parametric bounds of the
    curve (The tolerance criterion is ParametricTolerance).
    Raised if Abs (FromU1 - ToU2) <= ParametricTolerance
    Raised if ParametricTolerance < Resolution from gp.

    :type C: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve
    :type FromU1: float
    :type ToU2: float
    :type ParametricTolerance: float
    :type SameOrientation: bool
    :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

    """
    return _Geom2dConvert.Geom2dConvert__SplitBSplineCurve(*args)

def Geom2dConvert__CurveToBSplineCurve(*args):
    """
    Geom2dConvert__CurveToBSplineCurve(Handle_Geom2d_Curve C, Convert_ParameterisationType const Parameterisation=Convert_TgtThetaOver2) -> Handle_Geom2d_BSplineCurve

    This function converts a non infinite curve from
    Geom into a  B-spline curve.  C must  be  an ellipse or a
    circle or a trimmed conic  or a trimmed  line or a Bezier
    curve or a trimmed  Bezier curve or a  BSpline curve or  a
    trimmed BSpline   curve  or an  Offset  curve or a  trimmed
    Offset curve.
    The returned B-spline is not periodic except if C is a
    Circle or an Ellipse.
    ParameterisationType applies only if the curve is a Circle
    or an ellipse :
    TgtThetaOver2,
    TgtThetaOver2_1,
    TgtThetaOver2_2,
    TgtThetaOver2_3,
    TgtThetaOver2_4,
    Purpose: this is the classical rational parameterisation
    2
    1 - t
    cos(theta) = ------
    2
    1 + t

    2t
    sin(theta) = ------
    2
    1 + t

    t = tan (theta/2)

    with TgtThetaOver2  the routine will compute the number of spans
    using the rule num_spans = [ (ULast - UFirst) / 1.2 ] + 1
    with TgtThetaOver2_N, N  spans will be forced: an error will
    be raized if (ULast - UFirst) >= PI and N = 1,
    ULast - UFirst >= 2 PI and N = 2

    QuasiAngular,
    here t is a rational function that approximates
    theta ----> tan(theta/2).
    Neverthless the composing with above function yields exact
    functions whose square sum up to 1
    RationalC1 ;
    t is replaced by a polynomial function of u so as to grant
    C1 contiuity across knots.
    Exceptions
    Standard_DomainError if the curve C is infinite.
    Standard_ConstructionError:
    -   if C is a complete circle or ellipse, and if
    Parameterisation is not equal to
    Convert_TgtThetaOver2 or to Convert_RationalC1, or
    -   if C is a trimmed circle or ellipse and if
    Parameterisation is equal to
    Convert_TgtThetaOver2_1 and if U2 - U1 >
    0.9999 * Pi where U1 and U2 are
    respectively the first and the last parameters of the
    trimmed curve (this method of parameterization
    cannot be used to convert a half-circle or a
    half-ellipse, for example), or
    -   if C is a trimmed circle or ellipse and
    Parameterisation is equal to
    Convert_TgtThetaOver2_2 and U2 - U1 >
    1.9999 * Pi where U1 and U2 are
    respectively the first and the last parameters of the
    trimmed curve (this method of parameterization
    cannot be used to convert a quasi-complete circle or ellipse).

    :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
    :type Parameterisation: OCC.wrapper.Convert.Convert_ParameterisationType
    :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

    """
    return _Geom2dConvert.Geom2dConvert__CurveToBSplineCurve(*args)

def Geom2dConvert__ConcatG1(*args):
    """
    Geom2dConvert__ConcatG1(NCollection_Array1_Handle_Geom2d_BSplineCurve ArrayOfCurves, NCollection_Array1_Standard_Real ArrayOfToler, Handle_TColGeom2d_HArray1OfBSplineCurve ArrayOfConcatenated, Standard_Boolean const ClosedFlag, Standard_Real const ClosedTolerance)

    This Method concatenates G1 the ArrayOfCurves as far
    as it is possible.
    ArrayOfCurves[0..N-1]
    ArrayOfToler contains the  biggest tolerance of the two
    points shared by two consecutives curves.
    Its dimension: [0..N-2]
    ClosedTolerance     indicates if the ArrayOfCurves is closed.
    In this case ClosedTolerance contains the biggest tolerance
    of the two points which are at the closure.
    Otherwise its value is 0.0

    :type ArrayOfCurves: OCC.wrapper.TColGeom2d.TColGeom2d_Array1OfBSplineCurve
    :type ArrayOfToler: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type ArrayOfConcatenated: OCC.wrapper.TColGeom2d.Handle_TColGeom2d_HArray1OfBSplineCurve
    :type ClosedFlag: bool
    :type ClosedTolerance: float

    """
    return _Geom2dConvert.Geom2dConvert__ConcatG1(*args)

def Geom2dConvert__ConcatC1(*args):
    """
    ConcatC1(NCollection_Array1_Handle_Geom2d_BSplineCurve ArrayOfCurves, NCollection_Array1_Standard_Real ArrayOfToler, Handle_TColStd_HArray1OfInteger ArrayOfIndices, Handle_TColGeom2d_HArray1OfBSplineCurve ArrayOfConcatenated, Standard_Boolean const ClosedFlag, Standard_Real const ClosedTolerance)
    Geom2dConvert__ConcatC1(NCollection_Array1_Handle_Geom2d_BSplineCurve ArrayOfCurves, NCollection_Array1_Standard_Real ArrayOfToler, Handle_TColStd_HArray1OfInteger ArrayOfIndices, Handle_TColGeom2d_HArray1OfBSplineCurve ArrayOfConcatenated, Standard_Boolean const ClosedFlag, Standard_Real const ClosedTolerance, Standard_Real const AngularTolerance)

    This Method concatenates C1 the ArrayOfCurves as far
    as it is possible.
    ArrayOfCurves[0..N-1]
    ArrayOfToler contains the  biggest tolerance of the two
    points shared by two consecutives curves.
    Its dimension: [0..N-2]
    ClosedTolerance     indicates if the ArrayOfCurves is closed.
    In this case ClosedTolerance contains the biggest tolerance
    of the two points which are at the closure.
    Otherwise its value is 0.0

    :type ArrayOfCurves: OCC.wrapper.TColGeom2d.TColGeom2d_Array1OfBSplineCurve
    :type ArrayOfToler: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type ArrayOfIndices: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfInteger
    :type ArrayOfConcatenated: OCC.wrapper.TColGeom2d.Handle_TColGeom2d_HArray1OfBSplineCurve
    :type ClosedFlag: bool
    :type ClosedTolerance: float
    :type AngularTolerance: float

    """
    return _Geom2dConvert.Geom2dConvert__ConcatC1(*args)

def Geom2dConvert__C0BSplineToC1BSplineCurve(*args):
    """
    Geom2dConvert__C0BSplineToC1BSplineCurve(Handle_Geom2d_BSplineCurve BS, Standard_Real const Tolerance)

    This Method reduces as   far as it  is possible the
    multiplicities of  the  knots of  the BSpline BS.(keeping  the geometry).
    It returns a new BSpline which could still be C0.
    tolerance is a geometrical tolerance

    :type BS: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve
    :type Tolerance: float

    """
    return _Geom2dConvert.Geom2dConvert__C0BSplineToC1BSplineCurve(*args)

def Geom2dConvert__C0BSplineToArrayOfC1BSplineCurve(*args):
    """
    C0BSplineToArrayOfC1BSplineCurve(Handle_Geom2d_BSplineCurve BS, Handle_TColGeom2d_HArray1OfBSplineCurve tabBS, Standard_Real const Tolerance)
    Geom2dConvert__C0BSplineToArrayOfC1BSplineCurve(Handle_Geom2d_BSplineCurve BS, Handle_TColGeom2d_HArray1OfBSplineCurve tabBS, Standard_Real const AngularTolerance, Standard_Real const Tolerance)

    This Method   reduces as far  as  it is possible  the
    multiplicities  of  the knots  of the BSpline  BS.(keeping the geometry).
    It returns an array of BSpline C1.
    tolerance is a geometrical tolerance

    :type BS: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve
    :type tabBS: OCC.wrapper.TColGeom2d.Handle_TColGeom2d_HArray1OfBSplineCurve
    :type AngularTolerance: float
    :type Tolerance: float

    """
    return _Geom2dConvert.Geom2dConvert__C0BSplineToArrayOfC1BSplineCurve(*args)

class Geom2dConvert_ApproxCurve(object):
    """
    A framework to convert a 2D curve to a BSpline.
    This is done by approximation within a given tolerance.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(Geom2dConvert_ApproxCurve self, Handle_Geom2d_Curve Curve, Standard_Real const Tol2d, GeomAbs_Shape const Order, Standard_Integer const MaxSegments, Standard_Integer const MaxDegree) -> Geom2dConvert_ApproxCurve
        __init__(Geom2dConvert_ApproxCurve self, Handle_Adaptor2d_HCurve2d Curve, Standard_Real const Tol2d, GeomAbs_Shape const Order, Standard_Integer const MaxSegments, Standard_Integer const MaxDegree) -> Geom2dConvert_ApproxCurve

        Constructs an approximation framework defined by
        -   the 2D conic Curve
        -   the tolerance value Tol2d
        -   the degree of continuity Order
        -   the maximum number of segments allowed MaxSegments
        -   the highest degree MaxDegree which the
        polynomial defining the BSpline is allowed to have.

        :type Curve: OCC.wrapper.Adaptor2d.Handle_Adaptor2d_HCurve2d
        :type Tol2d: float
        :type Order: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type MaxSegments: int
        :type MaxDegree: int

        """
        this = _Geom2dConvert.new_Geom2dConvert_ApproxCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Curve(self, *args):
        """
        Curve(Geom2dConvert_ApproxCurve self) -> Handle_Geom2d_BSplineCurve

        Returns the 2D BSpline curve resulting from the
        approximation algorithm.

        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve

        """
        return _Geom2dConvert.Geom2dConvert_ApproxCurve_Curve(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Geom2dConvert_ApproxCurve self) -> Standard_Boolean

        returns  Standard_True  if  the  approximation  has
        been  done  with  within  requiered tolerance

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dConvert.Geom2dConvert_ApproxCurve_IsDone(self, *args)


    def HasResult(self, *args):
        """
        HasResult(Geom2dConvert_ApproxCurve self) -> Standard_Boolean

        returns  Standard_True if the approximation did come out
        with a result that  is not NECESSARELY within the required tolerance

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Geom2dConvert.Geom2dConvert_ApproxCurve_HasResult(self, *args)


    def MaxError(self, *args):
        """
        MaxError(Geom2dConvert_ApproxCurve self) -> Standard_Real

        Returns the greatest distance between a point on the
        source conic and the BSpline curve resulting from the
        approximation. (>0 when an approximation
        has  been  done, 0  if  no  approximation)

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Geom2dConvert.Geom2dConvert_ApproxCurve_MaxError(self, *args)


    def Dump(self, *args):
        """
        Dump(Geom2dConvert_ApproxCurve self, Standard_OStream & o)

        Print on the stream  o  information about the object

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _Geom2dConvert.Geom2dConvert_ApproxCurve_Dump(self, *args)

    __swig_destroy__ = _Geom2dConvert.delete_Geom2dConvert_ApproxCurve
Geom2dConvert_ApproxCurve_swigregister = _Geom2dConvert.Geom2dConvert_ApproxCurve_swigregister
Geom2dConvert_ApproxCurve_swigregister(Geom2dConvert_ApproxCurve)




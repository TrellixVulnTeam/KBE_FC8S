# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_gce')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_gce')
    _gce = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_gce', [dirname(__file__)])
        except ImportError:
            import _gce
            return _gce
        try:
            _mod = imp.load_module('_gce', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _gce = swig_import_helper()
    del swig_import_helper
else:
    import _gce
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gce.delete_SwigPyIterator

    def value(self):
        return _gce.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _gce.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _gce.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _gce.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _gce.SwigPyIterator_equal(self, x)

    def copy(self):
        return _gce.SwigPyIterator_copy(self)

    def next(self):
        return _gce.SwigPyIterator_next(self)

    def __next__(self):
        return _gce.SwigPyIterator___next__(self)

    def previous(self):
        return _gce.SwigPyIterator_previous(self)

    def advance(self, n):
        return _gce.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _gce.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _gce.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _gce.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _gce.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _gce.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _gce.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _gce.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _gce.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_gce.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _gce.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _gce.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gce.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _gce.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _gce.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _gce.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _gce.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_gce.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _gce.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _gce.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gce.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _gce.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _gce.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _gce.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _gce.ptr_to_number(item)
ptr_to_number = _gce.ptr_to_number

def HashCode(*args):
    return _gce.HashCode(*args)
HashCode = _gce.HashCode

def ptr_equal(a, b):
    return _gce.ptr_equal(a, b)
ptr_equal = _gce.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
gce_Done = _gce.gce_Done
gce_ConfusedPoints = _gce.gce_ConfusedPoints
gce_NegativeRadius = _gce.gce_NegativeRadius
gce_ColinearPoints = _gce.gce_ColinearPoints
gce_IntersectionError = _gce.gce_IntersectionError
gce_NullAxis = _gce.gce_NullAxis
gce_NullAngle = _gce.gce_NullAngle
gce_NullRadius = _gce.gce_NullRadius
gce_InvertAxis = _gce.gce_InvertAxis
gce_BadAngle = _gce.gce_BadAngle
gce_InvertRadius = _gce.gce_InvertRadius
gce_NullFocusLength = _gce.gce_NullFocusLength
gce_NullVector = _gce.gce_NullVector
gce_BadEquation = _gce.gce_BadEquation
class gce_Root(object):
    """
    This class implements the common services for
    all classes of gce which report error.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def IsDone(self, *args):
        """
        IsDone(gce_Root self) -> Standard_Boolean

        Returns true if the construction is successful.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _gce.gce_Root_IsDone(self, *args)


    def Status(self, *args):
        """
        Status(gce_Root self) -> gce_ErrorType

        Returns the status of the construction:
        -   gce_Done, if the construction is successful, or
        -   another value of the gce_ErrorType enumeration
        indicating why the construction failed.

        :rtype: OCC.wrapper.gce.gce_ErrorType

        """
        return _gce.gce_Root_Status(self, *args)


    def __init__(self):
        """
        This class implements the common services for
        all classes of gce which report error.
        """
        this = _gce.new_gce_Root()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gce.delete_gce_Root
gce_Root_swigregister = _gce.gce_Root_swigregister
gce_Root_swigregister(gce_Root)

class gce_MakeMirror2d(object):
    """
    This class implements elementary construction algorithms for a
    symmetrical transformation in 2D space about a point
    or axis. The result is a gp_Trsf2d transformation.
    A MakeMirror2d object provides a framework for:
    -   defining the construction of the transformation,
    -   implementing the construction algorithm, and consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gce_MakeMirror2d self, gp_Pnt2d Point) -> gce_MakeMirror2d
        __init__(gce_MakeMirror2d self, gp_Ax2d Axis) -> gce_MakeMirror2d
        __init__(gce_MakeMirror2d self, gp_Lin2d Line) -> gce_MakeMirror2d
        __init__(gce_MakeMirror2d self, gp_Pnt2d Point, gp_Dir2d Direc) -> gce_MakeMirror2d

        Makes a symmetry transformation af axis defined by
        <Point> and <Direc>.

        :type Point: OCC.wrapper.gp.gp_Pnt2d
        :type Direc: OCC.wrapper.gp.gp_Dir2d

        """
        this = _gce.new_gce_MakeMirror2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed transformation.

        :rtype: OCC.wrapper.gp.gp_Trsf2d

        """
        res = _gce.gce_MakeMirror2d_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operator(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Trsf2d

        """
        res = _gce.gce_MakeMirror2d_Operator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _gce.delete_gce_MakeMirror2d
gce_MakeMirror2d_swigregister = _gce.gce_MakeMirror2d_swigregister
gce_MakeMirror2d_swigregister(gce_MakeMirror2d)

class gce_MakeScale2d(object):
    """
    This class implements an elementary construction algorithm for
    a scaling transformation in 2D space. The result is a gp_Trsf2d transformation.
    A MakeScale2d object provides a framework for:
    -   defining the construction of the transformation,
    -   implementing the construction algorithm, and
    -   consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gce_MakeScale2d self, gp_Pnt2d Point, Standard_Real const Scale) -> gce_MakeScale2d

        Constructs a scaling transformation with:
        -   Point as the center of the transformation, and
        -   Scale as the scale factor.

        :type Point: OCC.wrapper.gp.gp_Pnt2d
        :type Scale: float

        """
        this = _gce.new_gce_MakeScale2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed transformation.

        :rtype: OCC.wrapper.gp.gp_Trsf2d

        """
        res = _gce.gce_MakeScale2d_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operator(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Trsf2d

        """
        res = _gce.gce_MakeScale2d_Operator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _gce.delete_gce_MakeScale2d
gce_MakeScale2d_swigregister = _gce.gce_MakeScale2d_swigregister
gce_MakeScale2d_swigregister(gce_MakeScale2d)

class gce_MakeHypr2d(gce_Root):
    """
    This class implements the following algorithms used to
    create a 2d Hyperbola from gp.
    * Create a 2d Hyperbola from its center and two points:
    one on its axis of symmetry giving the major radius, the
    other giving the value of the small radius.
    * Create a 2d Hyperbola from its major axis and its major
    radius and its minor radius.

    ^YAxis
    |
    FirstConjugateBranch
    |
    Other            |                Main
    --------------------- C ------------------------------>XAxis
    Branch           |                Branch
    |
    |
    SecondConjugateBranch
    |

    An axis placement (one axis) is associated with the hyperbola.
    This axis is the "XAxis" or major axis of the hyperbola. It is
    the symmetry axis of the main branch of hyperbola.
    The "YAxis" is normal to this axis and pass throught its location
    point. It is the minor axis.

    The major radius is the distance between the Location point
    of the hyperbola C and the vertex of the Main Branch (or the
    Other branch). The minor radius is the distance between the
    Location point of the hyperbola C and the vertex of the First
    (or Second) Conjugate branch.
    The major radius can be lower than the minor radius.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gce_MakeHypr2d self, gp_Pnt2d S1, gp_Pnt2d S2, gp_Pnt2d Center) -> gce_MakeHypr2d
        __init__(gce_MakeHypr2d self, gp_Ax2d MajorAxis, Standard_Real const MajorRadius, Standard_Real const MinorRadius, Standard_Boolean const Sense) -> gce_MakeHypr2d
        __init__(gce_MakeHypr2d self, gp_Ax22d A, Standard_Real const MajorRadius, Standard_Real const MinorRadius) -> gce_MakeHypr2d

        Creates a Hypr2d centered on the origin of the coordinate system
        A, with major and minor radii MajorRadius and
        MinorRadius, where its major axis is the "X Axis"
        of A (A is the local coordinate system of the hyperbola).

        :type A: OCC.wrapper.gp.gp_Ax22d
        :type MajorRadius: float
        :type MinorRadius: float

        """
        this = _gce.new_gce_MakeHypr2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed hyperbola.
        Exceptions StdFail_NotDone if no hyperbola is constructed.

        :rtype: OCC.wrapper.gp.gp_Hypr2d

        """
        res = _gce.gce_MakeHypr2d_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operator(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Hypr2d

        """
        res = _gce.gce_MakeHypr2d_Operator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _gce.delete_gce_MakeHypr2d
gce_MakeHypr2d_swigregister = _gce.gce_MakeHypr2d_swigregister
gce_MakeHypr2d_swigregister(gce_MakeHypr2d)

class gce_MakeParab2d(gce_Root):
    """
    This class implements the following algorithms used to
    create Parab2d from gp.
    Defines an infinite parabola.
    An axis placement one axis defines the local cartesian
    coordinate system ("XAxis") of the parabola.
    The vertex of the parabola is the "Location" point of the
    local coordinate system of the parabola.
    The "XAxis" of the parabola is its axis of symmetry.
    The "XAxis" is oriented from the vertex of the parabola to the
    Focus of the parabola.
    The "YAxis" is parallel to the directrix of the parabola and
    its "Location" point is the vertex of the parabola.
    The equation of the parabola in the local coordinate system is
    Y**2 = (2*P) * X
    P is the distance between the focus and the directrix of the
    parabola called Parameter).
    The focal length F = P/2 is the distance between the vertex
    and the focus of the parabola.

    * Create a Parab2d from one apex  and the center.
    * Create a Parab2d with the directrix and the focus point.
    * Create a Parab2d with its vertex point and its axis
    of symetry and its focus length.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gce_MakeParab2d self, gp_Ax2d MirrorAxis, Standard_Real const Focal, Standard_Boolean const Sense) -> gce_MakeParab2d
        __init__(gce_MakeParab2d self, gp_Ax22d A, Standard_Real const Focal) -> gce_MakeParab2d
        __init__(gce_MakeParab2d self, gp_Ax2d D, gp_Pnt2d F, Standard_Boolean const Sense) -> gce_MakeParab2d
        __init__(gce_MakeParab2d self, gp_Pnt2d S1, gp_Pnt2d Center, Standard_Boolean const Sense) -> gce_MakeParab2d

        Make an Parab2d with S1 as the Focal point and Center
        as the apex of the parabola
        Warning
        The MakeParab2d class does not prevent the
        construction of a parabola with a null focal distance.
        If an error occurs (that is, when IsDone returns
        false), the Status function returns:
        -   gce_NullFocusLength if Focal is less than 0.0, or
        -   gce_NullAxis if S1 and Center are coincident.

        :type S1: OCC.wrapper.gp.gp_Pnt2d
        :type Center: OCC.wrapper.gp.gp_Pnt2d
        :type Sense: bool

        """
        this = _gce.new_gce_MakeParab2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed parabola.
        Exceptions StdFail_NotDone if no parabola is constructed.

        :rtype: OCC.wrapper.gp.gp_Parab2d

        """
        res = _gce.gce_MakeParab2d_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operator(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Parab2d

        """
        res = _gce.gce_MakeParab2d_Operator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _gce.delete_gce_MakeParab2d
gce_MakeParab2d_swigregister = _gce.gce_MakeParab2d_swigregister
gce_MakeParab2d_swigregister(gce_MakeParab2d)

class gce_MakeCone(gce_Root):
    """
    This class implements the following algorithms used
    to create a Cone from gp.
    * Create a Cone coaxial to another and passing
    through a point.
    * Create a Cone coaxial to another at a distance
    <Dist>.
    * Create a Cone by 4 points.
    * Create a Cone by its axis and 2 points.
    * Create a Cone by 2 points and 2 radius.
    * Create a Cone by an Ax2 an angle and the radius of
    its reference section.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gce_MakeCone self, gp_Ax2 A2, Standard_Real const Ang, Standard_Real const Radius) -> gce_MakeCone
        __init__(gce_MakeCone self, gp_Cone Cone, gp_Pnt Point) -> gce_MakeCone
        __init__(gce_MakeCone self, gp_Cone Cone, Standard_Real const Dist) -> gce_MakeCone
        __init__(gce_MakeCone self, gp_Pnt P1, gp_Pnt P2, gp_Pnt P3, gp_Pnt P4) -> gce_MakeCone
        __init__(gce_MakeCone self, gp_Ax1 Axis, gp_Pnt P1, gp_Pnt P2) -> gce_MakeCone
        __init__(gce_MakeCone self, gp_Lin Axis, gp_Pnt P1, gp_Pnt P2) -> gce_MakeCone
        __init__(gce_MakeCone self, gp_Pnt P1, gp_Pnt P2, Standard_Real const R1, Standard_Real const R2) -> gce_MakeCone

        Makes a Cone with two points and two radius.
        The axis of the solution is the line passing through
        <P1> and <P2>.
        <R1> is the radius of the section passing through <P1>
        and <R2> the radius of the section passing through <P2>.
        If <P1> and <P2> are confused we have the status "NullAxis".
        Warning
        If an error occurs (that is, when IsDone returns
        false), the Status function returns:
        -   gce_NegativeRadius if Radius, R1 or R2 is less than 0.0;
        -   gce_BadAngle if Ang is less than
        gp::Resolution() or greater than Pi/2.- gp::Resolution();
        -   gce_ConfusedPoints if P1 and P2 or P3 and P4 are coincident;
        -   gce_NullAxis if the points P1 and P2, are coincident (5th syntax only);
        -   gce_NullAngle if:
        -   the vector joining P1 to P2 is parallel to either
        Axis or the line joining P3 to P4, or
        -   R1 and R2 are equal, (that is, their difference is
        less than gp::Resolution()); or
        -   gce_NullRadius if:
        -   the vector joining P1 to P2 is perpendicular to the line joining P3 to P4,
        -   the vector joining P1 to P2 is perpendicular to Axis, or
        -   P1, P2, P3, and P4 are collinear.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :type R1: float
        :type R2: float

        """
        this = _gce.new_gce_MakeCone(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed cone.
        Exceptions StdFail_NotDone if no cone is constructed.

        :rtype: OCC.wrapper.gp.gp_Cone

        """
        res = _gce.gce_MakeCone_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operator(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Cone

        """
        res = _gce.gce_MakeCone_Operator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _gce.delete_gce_MakeCone
gce_MakeCone_swigregister = _gce.gce_MakeCone_swigregister
gce_MakeCone_swigregister(gce_MakeCone)

class gce_MakeDir(gce_Root):
    """
    This class implements the following algorithms used
    to create a Dir from gp.
    * Create a Dir parallel to another and passing
    through a point.
    * Create a Dir passing through 2 points.
    * Create a Dir from its axis (Ax1 from gp).
    * Create a Dir from a point and a direction.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gce_MakeDir self, gp_Vec V) -> gce_MakeDir
        __init__(gce_MakeDir self, gp_XYZ Coord) -> gce_MakeDir
        __init__(gce_MakeDir self, Standard_Real const Xv, Standard_Real const Yv, Standard_Real const Zv) -> gce_MakeDir
        __init__(gce_MakeDir self, gp_Pnt P1, gp_Pnt P2) -> gce_MakeDir

        Make a Dir from gp <TheDir> passing through 2
        Pnt <P1>,<P2>.
        Status is "ConfusedPoints" if <p1> and <P2> are confused.
        Warning
        If an error occurs (that is, when IsDone returns
        false), the Status function returns:
        -   gce_ConfusedPoints if points P1 and P2 are coincident, or
        -   gce_NullVector if one of the following is less
        than or equal to gp::Resolution():
        -   the magnitude of vector V,
        -   the modulus of Coord,
        -   Sqrt(Xv*Xv + Yv*Yv + Zv*Zv).

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        this = _gce.new_gce_MakeDir(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed unit vector.
        Exceptions StdFail_NotDone if no unit vector is constructed.

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        res = _gce.gce_MakeDir_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operator(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Dir

        """
        res = _gce.gce_MakeDir_Operator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _gce.delete_gce_MakeDir
gce_MakeDir_swigregister = _gce.gce_MakeDir_swigregister
gce_MakeDir_swigregister(gce_MakeDir)

class gce_MakeTranslation(object):
    """
    This class implements elementary construction algorithms for a
    translation in 3D space. The result is a gp_Trsf transformation.
    A MakeTranslation object provides a framework for:
    -   defining the construction of the transformation,
    -   implementing the construction algorithm, and
    -   consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gce_MakeTranslation self, gp_Vec Vect) -> gce_MakeTranslation
        __init__(gce_MakeTranslation self, gp_Pnt Point1, gp_Pnt Point2) -> gce_MakeTranslation

        Constructs a translation along the vector
        (Point1,Point2) defined from the point Point1 to the point Point2.

        :type Point1: OCC.wrapper.gp.gp_Pnt
        :type Point2: OCC.wrapper.gp.gp_Pnt

        """
        this = _gce.new_gce_MakeTranslation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed transformation.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _gce.gce_MakeTranslation_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operator(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _gce.gce_MakeTranslation_Operator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _gce.delete_gce_MakeTranslation
gce_MakeTranslation_swigregister = _gce.gce_MakeTranslation_swigregister
gce_MakeTranslation_swigregister(gce_MakeTranslation)

class gce_MakeDir2d(gce_Root):
    """
    This class implements the following algorithms used
    to create a Dir2d from gp.
    * Create a Dir2d with 2 points.
    * Create a Dir2d with a Vec2d.
    * Create a Dir2d with a XY from gp.
    * Create a Dir2d with a 2 Reals (Coordinates).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gce_MakeDir2d self, gp_Vec2d V) -> gce_MakeDir2d
        __init__(gce_MakeDir2d self, gp_XY Coord) -> gce_MakeDir2d
        __init__(gce_MakeDir2d self, Standard_Real const Xv, Standard_Real const Yv) -> gce_MakeDir2d
        __init__(gce_MakeDir2d self, gp_Pnt2d P1, gp_Pnt2d P2) -> gce_MakeDir2d

        Make a Dir2d from gp <TheDir> passing through 2
        Pnt <P1>,<P2>.
        Status is "ConfusedPoints" if <P1> and <P2> are confused.
        Warning
        If an error occurs (that is, when IsDone returns
        false), the Status function returns:
        -   gce_ConfusedPoints if points P1 and P2 are coincident, or
        -   gce_NullVector if one of the following is less
        than or equal to gp::Resolution():
        -   the magnitude of vector V,
        -   the modulus of Coord,
        -   Sqrt(Xv*Xv + Yv*Yv).

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        this = _gce.new_gce_MakeDir2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed unit vector.
        Exceptions StdFail_NotDone if no unit vector is constructed.

        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        res = _gce.gce_MakeDir2d_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operator(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        res = _gce.gce_MakeDir2d_Operator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _gce.delete_gce_MakeDir2d
gce_MakeDir2d_swigregister = _gce.gce_MakeDir2d_swigregister
gce_MakeDir2d_swigregister(gce_MakeDir2d)

class gce_MakeCirc2d(gce_Root):
    """
    This class implements the following algorithms used
    to create Circ2d from gp.

    * Create a Circ2d concentric with another and passing
    though a point.
    * Create a Circ2d concentric with another at the distance
    Dist.
    * Create a Circ2d passing through 3 points.
    * Create a Circ2d with its center and radius.
    * Create a Circ2d with its center and a point given
    the radius.
    * Create a Circ2d with its axis and its radius.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gce_MakeCirc2d self, gp_Ax2d XAxis, Standard_Real const Radius, Standard_Boolean const Sense) -> gce_MakeCirc2d
        __init__(gce_MakeCirc2d self, gp_Ax22d Axis, Standard_Real const Radius) -> gce_MakeCirc2d
        __init__(gce_MakeCirc2d self, gp_Circ2d Circ, Standard_Real const Dist) -> gce_MakeCirc2d
        __init__(gce_MakeCirc2d self, gp_Circ2d Circ, gp_Pnt2d Point) -> gce_MakeCirc2d
        __init__(gce_MakeCirc2d self, gp_Pnt2d P1, gp_Pnt2d P2, gp_Pnt2d P3) -> gce_MakeCirc2d
        __init__(gce_MakeCirc2d self, gp_Pnt2d Center, Standard_Real const Radius, Standard_Boolean const Sense) -> gce_MakeCirc2d
        __init__(gce_MakeCirc2d self, gp_Pnt2d Center, gp_Pnt2d Point, Standard_Boolean const Sense) -> gce_MakeCirc2d

        Makes a Circ2d from gp <TheCirc> with its center
        <Center> and a point giving the radius.
        If Sense is true the local coordinate system of
        the solution is direct and non direct in the other case.

        :type Center: OCC.wrapper.gp.gp_Pnt2d
        :type Point: OCC.wrapper.gp.gp_Pnt2d
        :type Sense: bool

        """
        this = _gce.new_gce_MakeCirc2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed circle.
        Exceptions StdFail_NotDone if no circle is constructed.

        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        res = _gce.gce_MakeCirc2d_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operator(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Circ2d

        """
        res = _gce.gce_MakeCirc2d_Operator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _gce.delete_gce_MakeCirc2d
gce_MakeCirc2d_swigregister = _gce.gce_MakeCirc2d_swigregister
gce_MakeCirc2d_swigregister(gce_MakeCirc2d)

class gce_MakeCylinder(gce_Root):
    """
    This class implements the following algorithms used
    to create a Cylinder from gp.
    * Create a Cylinder coaxial to another and passing
    through a point.
    * Create a Cylinder coaxial to another at a distance
    <Dist>.
    * Create a Cylinder with 3 points.
    * Create a Cylinder by its axis and radius.
    * Create a cylinder by its circular base.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gce_MakeCylinder self, gp_Ax2 A2, Standard_Real const Radius) -> gce_MakeCylinder
        __init__(gce_MakeCylinder self, gp_Cylinder Cyl, gp_Pnt Point) -> gce_MakeCylinder
        __init__(gce_MakeCylinder self, gp_Cylinder Cyl, Standard_Real const Dist) -> gce_MakeCylinder
        __init__(gce_MakeCylinder self, gp_Pnt P1, gp_Pnt P2, gp_Pnt P3) -> gce_MakeCylinder
        __init__(gce_MakeCylinder self, gp_Ax1 Axis, Standard_Real const Radius) -> gce_MakeCylinder
        __init__(gce_MakeCylinder self, gp_Circ Circ) -> gce_MakeCylinder

        Makes a Cylinder by its circular base.
        Warning
        If an error occurs (that is, when IsDone returns
        false), the Status function returns:
        -   gce_NegativeRadius if:
        -   Radius is less than 0.0, or
        -   Dist is negative and has an absolute value
        which is greater than the radius of Cyl; or
        -   gce_ConfusedPoints if points P1 and P2 are coincident.

        :type Circ: OCC.wrapper.gp.gp_Circ

        """
        this = _gce.new_gce_MakeCylinder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed cylinder.
        Exceptions StdFail_NotDone if no cylinder is constructed.

        :rtype: OCC.wrapper.gp.gp_Cylinder

        """
        res = _gce.gce_MakeCylinder_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operator(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Cylinder

        """
        res = _gce.gce_MakeCylinder_Operator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _gce.delete_gce_MakeCylinder
gce_MakeCylinder_swigregister = _gce.gce_MakeCylinder_swigregister
gce_MakeCylinder_swigregister(gce_MakeCylinder)

class gce_MakeRotation(object):
    """
    This class implements elementary construction algorithms for a
    rotation in 3D space. The result is a gp_Trsf transformation.
    A MakeRotation object provides a framework for:
    -   defining the construction of the transformation,
    -   implementing the construction algorithm, and
    -   consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gce_MakeRotation self, gp_Lin Line, Standard_Real const Angle) -> gce_MakeRotation
        __init__(gce_MakeRotation self, gp_Ax1 Axis, Standard_Real const Angle) -> gce_MakeRotation
        __init__(gce_MakeRotation self, gp_Pnt Point, gp_Dir Direc, Standard_Real const Angle) -> gce_MakeRotation

        Constructs a rotation through angle Angle about the axis defined by:
        the point Point and the unit vector Direc.

        :type Point: OCC.wrapper.gp.gp_Pnt
        :type Direc: OCC.wrapper.gp.gp_Dir
        :type Angle: float

        """
        this = _gce.new_gce_MakeRotation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed transformation.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _gce.gce_MakeRotation_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operator(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _gce.gce_MakeRotation_Operator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _gce.delete_gce_MakeRotation
gce_MakeRotation_swigregister = _gce.gce_MakeRotation_swigregister
gce_MakeRotation_swigregister(gce_MakeRotation)

class gce_MakePln(gce_Root):
    """
    This class implements the following algorithms used
    to create a Plane from gp.
    * Create a Pln parallel to another and passing
    through a point.
    * Create a Pln passing through 3 points.
    * Create a Pln by its normal.
    Defines a non-persistent plane.
    The plane is located in 3D space with an axis placement
    two axis. It is the local coordinate system of the plane.

    The "Location" point and the main direction of this axis
    placement define the "Axis" of the plane. It is the axis
    normal to the plane which gives the orientation of the
    plane.

    The "XDirection" and the "YDirection" of the axis
    placement define the plane ("XAxis" and "YAxis") .
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gce_MakePln self, gp_Ax2 A2) -> gce_MakePln
        __init__(gce_MakePln self, gp_Pnt P, gp_Dir V) -> gce_MakePln
        __init__(gce_MakePln self, Standard_Real const A, Standard_Real const B, Standard_Real const C, Standard_Real const D) -> gce_MakePln
        __init__(gce_MakePln self, gp_Pln Pln, gp_Pnt Point) -> gce_MakePln
        __init__(gce_MakePln self, gp_Pln Pln, Standard_Real const Dist) -> gce_MakePln
        __init__(gce_MakePln self, gp_Pnt P1, gp_Pnt P2, gp_Pnt P3) -> gce_MakePln
        __init__(gce_MakePln self, gp_Pnt P1, gp_Pnt P2) -> gce_MakePln
        __init__(gce_MakePln self, gp_Ax1 Axis) -> gce_MakePln

        Make a pln  passing through the location of <Axis>and
        normal to the Direction of <Axis>.
        Warning -  If an error occurs (that is, when IsDone returns
        false), the Status function returns:
        -   gce_BadEquation if Sqrt(A*A + B*B +
        C*C) is less than or equal to gp::Resolution(),
        -   gce_ConfusedPoints if P1 and P2 are coincident, or
        -   gce_ColinearPoints if P1, P2 and P3 are collinear.

        :type Axis: OCC.wrapper.gp.gp_Ax1

        """
        this = _gce.new_gce_MakePln(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed plane.
        Exceptions StdFail_NotDone if no plane is constructed.

        :rtype: OCC.wrapper.gp.gp_Pln

        """
        res = _gce.gce_MakePln_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operator(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Pln

        """
        res = _gce.gce_MakePln_Operator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _gce.delete_gce_MakePln
gce_MakePln_swigregister = _gce.gce_MakePln_swigregister
gce_MakePln_swigregister(gce_MakePln)

class gce_MakeElips2d(gce_Root):
    """
    This class implements the following algorithms used to
    create Elips2d from gp.

    * Create an ellipse from its center, and two points:
    one on the ciconference giving the major radius, the
    other giving the value of the small radius.
    * Create an ellipse from its major axis and its major
    radius and its minor radius.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gce_MakeElips2d self, gp_Ax2d MajorAxis, Standard_Real const MajorRadius, Standard_Real const MinorRadius, Standard_Boolean const Sense) -> gce_MakeElips2d
        __init__(gce_MakeElips2d self, gp_Ax22d A, Standard_Real const MajorRadius, Standard_Real const MinorRadius) -> gce_MakeElips2d
        __init__(gce_MakeElips2d self, gp_Pnt2d S1, gp_Pnt2d S2, gp_Pnt2d Center) -> gce_MakeElips2d

        Makes an Elips2d with its center and two points.
        The sense of parametrization is given by S1, S2,
        and Center.
        Depending on the constructor, the  implicit orientation of the ellipse is:
        -   the sense defined by A,
        -   the sense defined by points Center, S1 and S2,
        -   the trigonometric sense if Sense is not given or is true, or
        -   the opposite if Sense is false.
        It is possible to construct an ellipse where the major
        and minor radii are equal.
        Warning
        If an error occurs (that is, when IsDone returns
        false), the Status function returns:
        -   gce_InvertRadius if MajorRadius is less than MinorRadius,
        -   gce_NegativeRadius if MajorRadius or
        MinorRadius is less than 0.0,
        -   gce_NullAxis if points S1, S2 and Center are collinear, or
        -   gce_InvertAxis if the major radius computed with
        Center and S1 is less than the minor radius
        computed with Center, S1 and S2.

        :type S1: OCC.wrapper.gp.gp_Pnt2d
        :type S2: OCC.wrapper.gp.gp_Pnt2d
        :type Center: OCC.wrapper.gp.gp_Pnt2d

        """
        this = _gce.new_gce_MakeElips2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed ellipse.
        Exceptions StdFail_NotDone if no ellipse is constructed.

        :rtype: OCC.wrapper.gp.gp_Elips2d

        """
        res = _gce.gce_MakeElips2d_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operator(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Elips2d

        """
        res = _gce.gce_MakeElips2d_Operator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _gce.delete_gce_MakeElips2d
gce_MakeElips2d_swigregister = _gce.gce_MakeElips2d_swigregister
gce_MakeElips2d_swigregister(gce_MakeElips2d)

class gce_MakeRotation2d(object):
    """
    Implements an elementary construction algorithm for
    a rotation in 2D space. The result is a gp_Trsf2d transformation.
    A MakeRotation2d object provides a framework for:
    -   defining the construction of the transformation,
    -   implementing the construction algorithm, and
    -   consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gce_MakeRotation2d self, gp_Pnt2d Point, Standard_Real const Angle) -> gce_MakeRotation2d

        Constructs a rotation through angle Angle about the center Point.

        :type Point: OCC.wrapper.gp.gp_Pnt2d
        :type Angle: float

        """
        this = _gce.new_gce_MakeRotation2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed transformation.

        :rtype: OCC.wrapper.gp.gp_Trsf2d

        """
        res = _gce.gce_MakeRotation2d_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operator(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Trsf2d

        """
        res = _gce.gce_MakeRotation2d_Operator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _gce.delete_gce_MakeRotation2d
gce_MakeRotation2d_swigregister = _gce.gce_MakeRotation2d_swigregister
gce_MakeRotation2d_swigregister(gce_MakeRotation2d)

class gce_MakeLin(gce_Root):
    """
    This class implements the following algorithms used
    to create a Lin from gp.
    * Create a Lin parallel to another and passing
    through a point.
    * Create a Lin passing through 2 points.
    * Create a lin from its axis (Ax1 from gp).
    * Create a lin from a point and a direction.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gce_MakeLin self, gp_Ax1 A1) -> gce_MakeLin
        __init__(gce_MakeLin self, gp_Pnt P, gp_Dir V) -> gce_MakeLin
        __init__(gce_MakeLin self, gp_Lin Lin, gp_Pnt Point) -> gce_MakeLin
        __init__(gce_MakeLin self, gp_Pnt P1, gp_Pnt P2) -> gce_MakeLin

        Make a Lin from gp <TheLin> passing through 2
        Pnt <P1>,<P2>.
        It returns false if <p1> and <P2> are confused.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        this = _gce.new_gce_MakeLin(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed line.
        Exceptions StdFail_NotDone is raised if no line is constructed.

        :rtype: OCC.wrapper.gp.gp_Lin

        """
        res = _gce.gce_MakeLin_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operator(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Lin

        """
        res = _gce.gce_MakeLin_Operator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _gce.delete_gce_MakeLin
gce_MakeLin_swigregister = _gce.gce_MakeLin_swigregister
gce_MakeLin_swigregister(gce_MakeLin)

class gce_MakeElips(gce_Root):
    """
    This class implements the following algorithms used to
    create an ellipse from gp.

    * Create an ellipse from its center, and two points:
    one on the ciconference giving the major radius, the
    other giving the value of the small radius.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gce_MakeElips self, gp_Ax2 A2, Standard_Real const MajorRadius, Standard_Real const MinorRadius) -> gce_MakeElips
        __init__(gce_MakeElips self, gp_Pnt S1, gp_Pnt S2, gp_Pnt Center) -> gce_MakeElips

        Make an ellipse with its center and two points.
        Warning
        The MakeElips class does not prevent the
        construction of an ellipse where the MajorRadius is
        equal to the MinorRadius.
        If an error occurs (that is, when IsDone returns
        false), the Status function returns:
        -   gce_InvertRadius if MajorRadius is less than MinorRadius;
        -   gce_NegativeRadius if MinorRadius is less than 0.0;
        -   gce_NullAxis if the points S1 and Center are coincident; or
        -   gce_InvertAxis if:
        -   the major radius computed with Center and S1
        is less than the minor radius computed with Center, S1 and S2, or
        -   Center, S1 and S2 are collinear.

        :type S1: OCC.wrapper.gp.gp_Pnt
        :type S2: OCC.wrapper.gp.gp_Pnt
        :type Center: OCC.wrapper.gp.gp_Pnt

        """
        this = _gce.new_gce_MakeElips(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed ellipse.
        Exceptions StdFail_NotDone if no ellipse is constructed.

        :rtype: OCC.wrapper.gp.gp_Elips

        """
        res = _gce.gce_MakeElips_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operator(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Elips

        """
        res = _gce.gce_MakeElips_Operator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _gce.delete_gce_MakeElips
gce_MakeElips_swigregister = _gce.gce_MakeElips_swigregister
gce_MakeElips_swigregister(gce_MakeElips)

class gce_MakeLin2d(gce_Root):
    """
    This class implements the following algorithms used
    to create Lin2d from gp.

    * Create a Lin2d parallel to another and passing
    through a point.
    * Create a Lin2d parallel to another at the distance
    Dist.
    * Create a Lin2d passing through 2 points.
    * Create a Lin2d from its axis (Ax1 from gp).
    * Create a Lin2d from a point and a direction.
    * Create a Lin2d from its equation.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gce_MakeLin2d self, gp_Ax2d A) -> gce_MakeLin2d
        __init__(gce_MakeLin2d self, gp_Pnt2d P, gp_Dir2d V) -> gce_MakeLin2d
        __init__(gce_MakeLin2d self, Standard_Real const A, Standard_Real const B, Standard_Real const C) -> gce_MakeLin2d
        __init__(gce_MakeLin2d self, gp_Lin2d Lin, Standard_Real const Dist) -> gce_MakeLin2d
        __init__(gce_MakeLin2d self, gp_Lin2d Lin, gp_Pnt2d Point) -> gce_MakeLin2d
        __init__(gce_MakeLin2d self, gp_Pnt2d P1, gp_Pnt2d P2) -> gce_MakeLin2d

        Make a Lin2d from gp <TheLin> passing through 2
        Pnt2d <P1>,<P2>.
        It returns false if <P1> and <P2> are confused.
        Warning
        If an error occurs (that is, when IsDone returns
        false), the Status function returns:
        -   gce_NullAxis if Sqrt(A*A + B*B) is less
        than or equal to gp::Resolution(), or
        -   gce_ConfusedPoints if points P1 and P2 are coincident.

        :type P1: OCC.wrapper.gp.gp_Pnt2d
        :type P2: OCC.wrapper.gp.gp_Pnt2d

        """
        this = _gce.new_gce_MakeLin2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Value(gce_MakeLin2d self) -> gp_Lin2d

        Returns the constructed line.
        Exceptions StdFail_NotDone if no line is constructed.

        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _gce.gce_MakeLin2d_Value(self, *args)


    def Operator(self, *args):
        """
        Operator(gce_MakeLin2d self) -> gp_Lin2d

        :rtype: OCC.wrapper.gp.gp_Lin2d

        """
        return _gce.gce_MakeLin2d_Operator(self, *args)

    __swig_destroy__ = _gce.delete_gce_MakeLin2d
gce_MakeLin2d_swigregister = _gce.gce_MakeLin2d_swigregister
gce_MakeLin2d_swigregister(gce_MakeLin2d)

class gce_MakeTranslation2d(object):
    """
    This class implements elementary construction algorithms for a
    translation in 2D space. The result is a gp_Trsf2d transformation.
    A MakeTranslation2d object provides a framework for:
    -   defining the construction of the transformation,
    -   implementing the construction algorithm, and
    -   consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gce_MakeTranslation2d self, gp_Vec2d Vect) -> gce_MakeTranslation2d
        __init__(gce_MakeTranslation2d self, gp_Pnt2d Point1, gp_Pnt2d Point2) -> gce_MakeTranslation2d

        Constructs a translation along the vector
        (Point1,Point2) defined from the point Point1 to the point Point2.

        :type Point1: OCC.wrapper.gp.gp_Pnt2d
        :type Point2: OCC.wrapper.gp.gp_Pnt2d

        """
        this = _gce.new_gce_MakeTranslation2d(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed transformation.

        :rtype: OCC.wrapper.gp.gp_Trsf2d

        """
        res = _gce.gce_MakeTranslation2d_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operator(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Trsf2d

        """
        res = _gce.gce_MakeTranslation2d_Operator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _gce.delete_gce_MakeTranslation2d
gce_MakeTranslation2d_swigregister = _gce.gce_MakeTranslation2d_swigregister
gce_MakeTranslation2d_swigregister(gce_MakeTranslation2d)

class gce_MakeParab(gce_Root):
    """
    This class implements the following algorithms used to
    create Parab from gp.
    Defines the parabola in the parameterization range  :
    ]-infinite, +infinite[
    The vertex of the parabola is the "Location" point of the
    local coordinate system (axis placement) of the parabola.

    The "XDirection" and the "YDirection" of this system define
    the plane of the parabola.

    The "XAxis" of the parabola ("Location", "XDirection") is
    the axis of symmetry of the parabola. The Xaxis is oriented
    from the vertex of the parabola to the Focus of the parabola.

    The "YAxis" of the parabola ("Location", "YDirection") is
    parallel to the directrix of the parabola.

    The equation of the parabola in the local coordinates system is
    Y**2 = (2*P) * X
    P is the distance between the focus and the directrix of the
    parabola (called Parameter).
    The focal length F = P/2 is the distance between the vertex
    and the focus of the parabola.

    * Creates a parabola with its local coordinate system "A2"
    and it's focal length "Focal".
    * Create a parabola with its directrix and its focus point.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gce_MakeParab self, gp_Ax2 A2, Standard_Real const Focal) -> gce_MakeParab
        __init__(gce_MakeParab self, gp_Ax1 D, gp_Pnt F) -> gce_MakeParab

        D is the directrix of the parabola and F the focus point.
        The symmetry axis (XAxis) of the parabola is normal to the
        directrix and pass through the focus point F, but its
        location point is the vertex of the parabola.
        The YAxis of the parabola is parallel to D and its location
        point is the vertex of the parabola. The normal to the plane
        of the parabola is the cross product between the XAxis and the
        YAxis.

        :type D: OCC.wrapper.gp.gp_Ax1
        :type F: OCC.wrapper.gp.gp_Pnt

        """
        this = _gce.new_gce_MakeParab(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed parabola.
        Exceptions StdFail_NotDone if no parabola is constructed.

        :rtype: OCC.wrapper.gp.gp_Parab

        """
        res = _gce.gce_MakeParab_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operator(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Parab

        """
        res = _gce.gce_MakeParab_Operator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _gce.delete_gce_MakeParab
gce_MakeParab_swigregister = _gce.gce_MakeParab_swigregister
gce_MakeParab_swigregister(gce_MakeParab)

class gce_MakeMirror(object):
    """
    This class mplements elementary construction algorithms for a
    symmetrical transformation in 3D space about a point,
    axis or plane. The result is a gp_Trsf transformation.
    A MakeMirror object provides a framework for:
    -   defining the construction of the transformation,
    -   implementing the construction algorithm, and
    -   consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gce_MakeMirror self, gp_Pnt Point) -> gce_MakeMirror
        __init__(gce_MakeMirror self, gp_Ax1 Axis) -> gce_MakeMirror
        __init__(gce_MakeMirror self, gp_Lin Line) -> gce_MakeMirror
        __init__(gce_MakeMirror self, gp_Pnt Point, gp_Dir Direc) -> gce_MakeMirror
        __init__(gce_MakeMirror self, gp_Pln Plane) -> gce_MakeMirror
        __init__(gce_MakeMirror self, gp_Ax2 Plane) -> gce_MakeMirror

        Makes a symmetry transformation of plane <Plane>.

        :type Plane: OCC.wrapper.gp.gp_Ax2

        """
        this = _gce.new_gce_MakeMirror(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed transformation.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _gce.gce_MakeMirror_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operator(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _gce.gce_MakeMirror_Operator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _gce.delete_gce_MakeMirror
gce_MakeMirror_swigregister = _gce.gce_MakeMirror_swigregister
gce_MakeMirror_swigregister(gce_MakeMirror)

class gce_MakeCirc(gce_Root):
    """
    This class implements the following algorithms used
    to create Circ from gp.

    * Create a Circ coaxial to another and passing
    though a point.
    * Create a Circ coaxial to another at the distance
    Dist.
    * Create a Circ passing through 3 points.
    * Create a Circ with its center and the normal of its
    plane and its radius.
    * Create a Circ with its center and its plane and its
    radius.
    * Create a Circ with its axis and radius.
    * Create a Circ with two points giving its axis and
    its radius.
    * Create a Circ with is Ax2 and its Radius.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gce_MakeCirc self, gp_Ax2 A2, Standard_Real const Radius) -> gce_MakeCirc
        __init__(gce_MakeCirc self, gp_Circ Circ, Standard_Real const Dist) -> gce_MakeCirc
        __init__(gce_MakeCirc self, gp_Circ Circ, gp_Pnt Point) -> gce_MakeCirc
        __init__(gce_MakeCirc self, gp_Pnt P1, gp_Pnt P2, gp_Pnt P3) -> gce_MakeCirc
        __init__(gce_MakeCirc self, gp_Pnt Center, gp_Dir Norm, Standard_Real const Radius) -> gce_MakeCirc
        __init__(gce_MakeCirc self, gp_Pnt Center, gp_Pln Plane, Standard_Real const Radius) -> gce_MakeCirc
        __init__(gce_MakeCirc self, gp_Pnt Center, gp_Pnt Ptaxis, Standard_Real const Radius) -> gce_MakeCirc
        __init__(gce_MakeCirc self, gp_Ax1 Axis, Standard_Real const Radius) -> gce_MakeCirc

        Makes a Circ from gp <TheCirc> with its center
        <Center> and its radius <Radius>.
        Warning
        The MakeCirc class does not prevent the
        construction of a circle with a null radius.
        If an error occurs (that is, when IsDone returns
        false), the Status function returns:
        -   gce_Negative Radius if:
        -   Radius is less than 0.0, or
        -   Dist is less than 0.0 and the absolute value of
        Dist is greater than the radius of Circ;
        -   gce_IntersectionError if the points P1, P2 and
        P3 are collinear, and the three are not coincident;
        -   gce_ConfusedPoints if two of the three points
        P1, P2 and P3 are coincident; or
        -   gce_NullAxis if Center and Ptaxis are coincident.

        :type Axis: OCC.wrapper.gp.gp_Ax1
        :type Radius: float

        """
        this = _gce.new_gce_MakeCirc(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed circle.
        Exceptions StdFail_NotDone if no circle is constructed.

        :rtype: OCC.wrapper.gp.gp_Circ

        """
        res = _gce.gce_MakeCirc_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operator(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Circ

        """
        res = _gce.gce_MakeCirc_Operator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _gce.delete_gce_MakeCirc
gce_MakeCirc_swigregister = _gce.gce_MakeCirc_swigregister
gce_MakeCirc_swigregister(gce_MakeCirc)

class gce_MakeScale(object):
    """
    Implements an elementary construction algorithm for
    a scaling transformation in 3D space. The result is a gp_Trsf transformation.
    A MakeScale object provides a framework for:
    -   defining the construction of the transformation,
    -   implementing the construction algorithm, and
    -   consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gce_MakeScale self, gp_Pnt Point, Standard_Real const Scale) -> gce_MakeScale

        Constructs a scaling transformation with
        -   Point as the center of the transformation, and
        -   Scale as the scale factor.

        :type Point: OCC.wrapper.gp.gp_Pnt
        :type Scale: float

        """
        this = _gce.new_gce_MakeScale(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed transformation.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _gce.gce_MakeScale_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operator(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _gce.gce_MakeScale_Operator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _gce.delete_gce_MakeScale
gce_MakeScale_swigregister = _gce.gce_MakeScale_swigregister
gce_MakeScale_swigregister(gce_MakeScale)

class gce_MakeHypr(gce_Root):
    """
    This class implements the following algorithms used to
    create Hyperbola from gp.
    * Create an Hyperbola from its center, and two points:
    one on its axis of symmetry giving the major radius, the
    other giving the value of the small radius.
    The three points give the plane of the hyperbola.
    * Create an hyperbola from its axisplacement and its
    MajorRadius and its MinorRadius.

    ^YAxis
    |
    FirstConjugateBranch
    |
    Other            |                Main
    --------------------- C ------------------------------>XAxis
    Branch           |                Branch
    |
    |
    SecondConjugateBranch
    |

    The local cartesian coordinate system of the ellipse is an
    axis placement (two axis).

    The "XDirection" and the "YDirection" of the axis placement
    define the plane of the hyperbola.

    The "Direction" of the axis placement defines the normal axis
    to the hyperbola's plane.

    The "XAxis" of the hyperbola ("Location", "XDirection") is the
    major axis  and the  "YAxis" of the hyperbola ("Location",
    "YDirection") is the minor axis.

    Warnings :
    The major radius (on the major axis) can be lower than the
    minor radius (on the minor axis).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(gce_MakeHypr self, gp_Ax2 A2, Standard_Real const MajorRadius, Standard_Real const MinorRadius) -> gce_MakeHypr
        __init__(gce_MakeHypr self, gp_Pnt S1, gp_Pnt S2, gp_Pnt Center) -> gce_MakeHypr

        Constructs a hyperbola
        -   centered on the point Center, where:
        -   the plane of the hyperbola is defined by Center, S1 and S2,
        -   its major axis is defined by Center and S1,
        -   its major radius is the distance between Center and S1, and
        -   its minor radius is the distance between S2 and the major axis.
        Warning
        If an error occurs (that is, when IsDone returns
        false), the Status function returns:
        -   gce_NegativeRadius if MajorRadius is less than 0.0;
        -   gce_InvertRadius if:
        -   the major radius (computed with Center, S1) is
        less than the minor radius (computed with Center, S1 and S2), or
        -   MajorRadius is less than MinorRadius; or
        -   gce_ColinearPoints if S1, S2 and Center are collinear.

        :type S1: OCC.wrapper.gp.gp_Pnt
        :type S2: OCC.wrapper.gp.gp_Pnt
        :type Center: OCC.wrapper.gp.gp_Pnt

        """
        this = _gce.new_gce_MakeHypr(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Value(self, *args):
        """
        Returns the constructed hyperbola.
        Exceptions StdFail_NotDone if no hyperbola is constructed.

        :rtype: OCC.wrapper.gp.gp_Hypr

        """
        res = _gce.gce_MakeHypr_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Operator(self, *args):
        """
        :rtype: OCC.wrapper.gp.gp_Hypr

        """
        res = _gce.gce_MakeHypr_Operator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _gce.delete_gce_MakeHypr
gce_MakeHypr_swigregister = _gce.gce_MakeHypr_swigregister
gce_MakeHypr_swigregister(gce_MakeHypr)




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_STEPConstruct')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_STEPConstruct')
    _STEPConstruct = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_STEPConstruct', [dirname(__file__)])
        except ImportError:
            import _STEPConstruct
            return _STEPConstruct
        try:
            _mod = imp.load_module('_STEPConstruct', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _STEPConstruct = swig_import_helper()
    del swig_import_helper
else:
    import _STEPConstruct
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _STEPConstruct.delete_SwigPyIterator

    def value(self):
        return _STEPConstruct.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _STEPConstruct.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _STEPConstruct.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _STEPConstruct.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _STEPConstruct.SwigPyIterator_equal(self, x)

    def copy(self):
        return _STEPConstruct.SwigPyIterator_copy(self)

    def next(self):
        return _STEPConstruct.SwigPyIterator_next(self)

    def __next__(self):
        return _STEPConstruct.SwigPyIterator___next__(self)

    def previous(self):
        return _STEPConstruct.SwigPyIterator_previous(self)

    def advance(self, n):
        return _STEPConstruct.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _STEPConstruct.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _STEPConstruct.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _STEPConstruct.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _STEPConstruct.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _STEPConstruct.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _STEPConstruct.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _STEPConstruct.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _STEPConstruct.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_STEPConstruct.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _STEPConstruct.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _STEPConstruct.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _STEPConstruct.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _STEPConstruct.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _STEPConstruct.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _STEPConstruct.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _STEPConstruct.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_STEPConstruct.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _STEPConstruct.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _STEPConstruct.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _STEPConstruct.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _STEPConstruct.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _STEPConstruct.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _STEPConstruct.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _STEPConstruct.ptr_to_number(item)
ptr_to_number = _STEPConstruct.ptr_to_number

def HashCode(*args):
    return _STEPConstruct.HashCode(*args)
HashCode = _STEPConstruct.HashCode

def ptr_equal(a, b):
    return _STEPConstruct.ptr_equal(a, b)
ptr_equal = _STEPConstruct.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepBasic
else:
    import StepBasic
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepData
else:
    import StepData
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Interface
else:
    import Interface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import MoniTool
else:
    import MoniTool
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import OSD
else:
    import OSD
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Transfer
else:
    import Transfer
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepAP203
else:
    import StepAP203
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepRepr
else:
    import StepRepr
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepShape
else:
    import StepShape
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepGeom
else:
    import StepGeom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepVisual
else:
    import StepVisual
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import StepAP214
else:
    import StepAP214
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import XSControl
else:
    import XSControl
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IFSelect
else:
    import IFSelect
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IFGraph
else:
    import IFGraph
del _swig_python_version_info
class STEPConstruct_Tool(object):
    """
    Provides basic functionalities for tools which are intended
    for encoding/decoding specific STEP constructs

    It is initialized by WorkSession and allows easy access to
    its fields and internal data such as Model, TP and FP

    NOTE: Call to method Graph() with True (or for a first time,
    if you have updated the model since last computation of model)
    can take a time, so it is recommended to avoid creation of
    this (and derived) tool multiple times
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(STEPConstruct_Tool self) -> STEPConstruct_Tool
        __init__(STEPConstruct_Tool self, Handle_XSControl_WorkSession WS) -> STEPConstruct_Tool

        Creates a tool and loads it with worksession

        :type WS: OCC.wrapper.XSControl.Handle_XSControl_WorkSession

        """
        this = _STEPConstruct.new_STEPConstruct_Tool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def WS(self, *args):
        """
        Returns currently loaded WorkSession

        :rtype: OCC.wrapper.XSControl.Handle_XSControl_WorkSession

        """
        res = _STEPConstruct.STEPConstruct_Tool_WS(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Model(self, *args):
        """
        Model(STEPConstruct_Tool self) -> Handle_Interface_InterfaceModel

        Returns current model (Null if not loaded)

        :rtype: OCC.wrapper.Interface.Handle_Interface_InterfaceModel

        """
        return _STEPConstruct.STEPConstruct_Tool_Model(self, *args)


    def Graph(self, *args):
        """
        Returns current graph (recomputing if necessary)

        :type recompute: bool
        :rtype: OCC.wrapper.Interface.Interface_Graph

        """
        res = _STEPConstruct.STEPConstruct_Tool_Graph(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TransientProcess(self, *args):
        """
        Returns TransientProcess (reading; Null if not loaded)

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess

        """
        res = _STEPConstruct.STEPConstruct_Tool_TransientProcess(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FinderProcess(self, *args):
        """
        Returns FinderProcess (writing; Null if not loaded)

        :rtype: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess

        """
        res = _STEPConstruct.STEPConstruct_Tool_FinderProcess(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _STEPConstruct.delete_STEPConstruct_Tool
STEPConstruct_Tool_swigregister = _STEPConstruct.STEPConstruct_Tool_swigregister
STEPConstruct_Tool_swigregister(STEPConstruct_Tool)

class STEPConstruct_PointHasher(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def HashCode(*args):
        """
        HashCode(gp_Pnt Point, Standard_Integer const Upper) -> Standard_Integer

        Returns a HasCode value  for  the  Key <K>  in the
        range 0..Upper.

        :type Point: OCC.wrapper.gp.gp_Pnt
        :type Upper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPConstruct.STEPConstruct_PointHasher_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args):
        """
        IsEqual(gp_Pnt Point1, gp_Pnt Point2) -> Standard_Boolean

        Returns True  when the two  keys are the same. Two
        same  keys  must   have  the  same  hashcode,  the
        contrary is not necessary.

        :type Point1: OCC.wrapper.gp.gp_Pnt
        :type Point2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.STEPConstruct_PointHasher_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    def __init__(self):
        this = _STEPConstruct.new_STEPConstruct_PointHasher()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _STEPConstruct.delete_STEPConstruct_PointHasher
STEPConstruct_PointHasher_swigregister = _STEPConstruct.STEPConstruct_PointHasher_swigregister
STEPConstruct_PointHasher_swigregister(STEPConstruct_PointHasher)

def STEPConstruct_PointHasher_HashCode(*args):
    """
    STEPConstruct_PointHasher_HashCode(gp_Pnt Point, Standard_Integer const Upper) -> Standard_Integer

    Returns a HasCode value  for  the  Key <K>  in the
    range 0..Upper.

    :type Point: OCC.wrapper.gp.gp_Pnt
    :type Upper: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _STEPConstruct.STEPConstruct_PointHasher_HashCode(*args)

def STEPConstruct_PointHasher_IsEqual(*args):
    """
    STEPConstruct_PointHasher_IsEqual(gp_Pnt Point1, gp_Pnt Point2) -> Standard_Boolean

    Returns True  when the two  keys are the same. Two
    same  keys  must   have  the  same  hashcode,  the
    contrary is not necessary.

    :type Point1: OCC.wrapper.gp.gp_Pnt
    :type Point2: OCC.wrapper.gp.gp_Pnt
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _STEPConstruct.STEPConstruct_PointHasher_IsEqual(*args)

class STEPConstruct_(object):
    """
    Defines tools for creation and investigation STEP constructs
    used for representing various kinds of data, such as product and
    assembly structure, unit contexts, associated information
    The creation of these structures is made according to currently
    active schema (AP203 or AP214 CD2 or DIS)
    This is taken from parameter write.step.schema
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def FindEntity(*args):
        """
        FindEntity(Handle_Transfer_FinderProcess FinderProcess, TopoDS_Shape Shape) -> Handle_StepRepr_RepresentationItem
        FindEntity(Handle_Transfer_FinderProcess FinderProcess, TopoDS_Shape Shape, TopLoc_Location Loc) -> Handle_StepRepr_RepresentationItem

        The same as above, but in the case if item not found, repeats
        search on the same shape without location. The Loc corresponds to the
        location with which result is found (either location of the Shape,
        or Null)

        :type FinderProcess: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
        :type Shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Loc: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

        """
        return _STEPConstruct.STEPConstruct__FindEntity(*args)

    FindEntity = staticmethod(FindEntity)

    def FindShape(*args):
        """
        FindShape(Handle_Transfer_TransientProcess TransientProcess, Handle_StepRepr_RepresentationItem item) -> TopoDS_Shape

        Returns Shape resulting from given STEP entity (Null if not mapped)

        :type TransientProcess: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
        :type item: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _STEPConstruct.STEPConstruct__FindShape(*args)

    FindShape = staticmethod(FindShape)

    def FindCDSR(*args):
        """
        FindCDSR( ComponentBinder, Handle_StepShape_ShapeDefinitionRepresentation AssemblySDR, Handle_StepShape_ContextDependentShapeRepresentation ComponentCDSR) -> Standard_Boolean

        Find CDSR correcponding to the component in the specified assembly

        :type ComponentBinder: OCC.wrapper.Transfer.Handle_Transfer_Binder
        :type AssemblySDR: OCC.wrapper.StepShape.Handle_StepShape_ShapeDefinitionRepresentation
        :type ComponentCDSR: OCC.wrapper.StepShape.Handle_StepShape_ContextDependentShapeRepresentation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.STEPConstruct__FindCDSR(*args)

    FindCDSR = staticmethod(FindCDSR)

    def __init__(self):
        """
        Defines tools for creation and investigation STEP constructs
        used for representing various kinds of data, such as product and
        assembly structure, unit contexts, associated information
        The creation of these structures is made according to currently
        active schema (AP203 or AP214 CD2 or DIS)
        This is taken from parameter write.step.schema
        """
        this = _STEPConstruct.new_STEPConstruct_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _STEPConstruct.delete_STEPConstruct_
STEPConstruct__swigregister = _STEPConstruct.STEPConstruct__swigregister
STEPConstruct__swigregister(STEPConstruct_)

def STEPConstruct__FindEntity(*args):
    """
    FindEntity(Handle_Transfer_FinderProcess FinderProcess, TopoDS_Shape Shape) -> Handle_StepRepr_RepresentationItem
    STEPConstruct__FindEntity(Handle_Transfer_FinderProcess FinderProcess, TopoDS_Shape Shape, TopLoc_Location Loc) -> Handle_StepRepr_RepresentationItem

    The same as above, but in the case if item not found, repeats
    search on the same shape without location. The Loc corresponds to the
    location with which result is found (either location of the Shape,
    or Null)

    :type FinderProcess: OCC.wrapper.Transfer.Handle_Transfer_FinderProcess
    :type Shape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type Loc: OCC.wrapper.TopLoc.TopLoc_Location
    :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem

    """
    return _STEPConstruct.STEPConstruct__FindEntity(*args)

def STEPConstruct__FindShape(*args):
    """
    STEPConstruct__FindShape(Handle_Transfer_TransientProcess TransientProcess, Handle_StepRepr_RepresentationItem item) -> TopoDS_Shape

    Returns Shape resulting from given STEP entity (Null if not mapped)

    :type TransientProcess: OCC.wrapper.Transfer.Handle_Transfer_TransientProcess
    :type item: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem
    :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _STEPConstruct.STEPConstruct__FindShape(*args)

def STEPConstruct__FindCDSR(*args):
    """
    STEPConstruct__FindCDSR( ComponentBinder, Handle_StepShape_ShapeDefinitionRepresentation AssemblySDR, Handle_StepShape_ContextDependentShapeRepresentation ComponentCDSR) -> Standard_Boolean

    Find CDSR correcponding to the component in the specified assembly

    :type ComponentBinder: OCC.wrapper.Transfer.Handle_Transfer_Binder
    :type AssemblySDR: OCC.wrapper.StepShape.Handle_StepShape_ShapeDefinitionRepresentation
    :type ComponentCDSR: OCC.wrapper.StepShape.Handle_StepShape_ContextDependentShapeRepresentation
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _STEPConstruct.STEPConstruct__FindCDSR(*args)

class STEPConstruct_AP203Context(object):
    """
    Maintains context specific for AP203 (required data and
    management information such as persons, dates, approvals etc.)
    It contains static entities (which can be shared), default
    values for person and organisation, and also provides
    tool for creating management entities around specific part (SDR).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(STEPConstruct_AP203Context self) -> STEPConstruct_AP203Context

        Creates tool and fills constant fields


        """
        this = _STEPConstruct.new_STEPConstruct_AP203Context(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def DefaultApproval(self, *args):
        """
        DefaultApproval(STEPConstruct_AP203Context self) -> Handle_StepBasic_Approval

        Returns default approval entity which
        is used when no other data are available

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Approval

        """
        return _STEPConstruct.STEPConstruct_AP203Context_DefaultApproval(self, *args)


    def SetDefaultApproval(self, *args):
        """
        SetDefaultApproval(STEPConstruct_AP203Context self, Handle_StepBasic_Approval app)

        Sets default approval

        :type app: OCC.wrapper.StepBasic.Handle_StepBasic_Approval

        """
        return _STEPConstruct.STEPConstruct_AP203Context_SetDefaultApproval(self, *args)


    def DefaultDateAndTime(self, *args):
        """
        DefaultDateAndTime(STEPConstruct_AP203Context self) -> Handle_StepBasic_DateAndTime

        Returns default date_and_time entity which
        is used when no other data are available

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DateAndTime

        """
        return _STEPConstruct.STEPConstruct_AP203Context_DefaultDateAndTime(self, *args)


    def SetDefaultDateAndTime(self, *args):
        """
        SetDefaultDateAndTime(STEPConstruct_AP203Context self, Handle_StepBasic_DateAndTime dt)

        Sets default date_and_time entity

        :type dt: OCC.wrapper.StepBasic.Handle_StepBasic_DateAndTime

        """
        return _STEPConstruct.STEPConstruct_AP203Context_SetDefaultDateAndTime(self, *args)


    def DefaultPersonAndOrganization(self, *args):
        """
        DefaultPersonAndOrganization(STEPConstruct_AP203Context self) -> Handle_StepBasic_PersonAndOrganization

        Returns default person_and_organization entity which
        is used when no other data are available

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_PersonAndOrganization

        """
        return _STEPConstruct.STEPConstruct_AP203Context_DefaultPersonAndOrganization(self, *args)


    def SetDefaultPersonAndOrganization(self, *args):
        """
        SetDefaultPersonAndOrganization(STEPConstruct_AP203Context self, Handle_StepBasic_PersonAndOrganization po)

        Sets default person_and_organization entity

        :type po: OCC.wrapper.StepBasic.Handle_StepBasic_PersonAndOrganization

        """
        return _STEPConstruct.STEPConstruct_AP203Context_SetDefaultPersonAndOrganization(self, *args)


    def DefaultSecurityClassificationLevel(self, *args):
        """
        DefaultSecurityClassificationLevel(STEPConstruct_AP203Context self) -> Handle_StepBasic_SecurityClassificationLevel

        Returns default security_classification_level entity which
        is used when no other data are available

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_SecurityClassificationLevel

        """
        return _STEPConstruct.STEPConstruct_AP203Context_DefaultSecurityClassificationLevel(self, *args)


    def SetDefaultSecurityClassificationLevel(self, *args):
        """
        SetDefaultSecurityClassificationLevel(STEPConstruct_AP203Context self, Handle_StepBasic_SecurityClassificationLevel sc)

        Sets default security_classification_level

        :type sc: OCC.wrapper.StepBasic.Handle_StepBasic_SecurityClassificationLevel

        """
        return _STEPConstruct.STEPConstruct_AP203Context_SetDefaultSecurityClassificationLevel(self, *args)


    def RoleCreator(self, *args):
        """
        RoleCreator(STEPConstruct_AP203Context self) -> Handle_StepBasic_PersonAndOrganizationRole

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_PersonAndOrganizationRole

        """
        return _STEPConstruct.STEPConstruct_AP203Context_RoleCreator(self, *args)


    def RoleDesignOwner(self, *args):
        """
        RoleDesignOwner(STEPConstruct_AP203Context self) -> Handle_StepBasic_PersonAndOrganizationRole

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_PersonAndOrganizationRole

        """
        return _STEPConstruct.STEPConstruct_AP203Context_RoleDesignOwner(self, *args)


    def RoleDesignSupplier(self, *args):
        """
        RoleDesignSupplier(STEPConstruct_AP203Context self) -> Handle_StepBasic_PersonAndOrganizationRole

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_PersonAndOrganizationRole

        """
        return _STEPConstruct.STEPConstruct_AP203Context_RoleDesignSupplier(self, *args)


    def RoleClassificationOfficer(self, *args):
        """
        RoleClassificationOfficer(STEPConstruct_AP203Context self) -> Handle_StepBasic_PersonAndOrganizationRole

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_PersonAndOrganizationRole

        """
        return _STEPConstruct.STEPConstruct_AP203Context_RoleClassificationOfficer(self, *args)


    def RoleCreationDate(self, *args):
        """
        RoleCreationDate(STEPConstruct_AP203Context self) -> Handle_StepBasic_DateTimeRole

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DateTimeRole

        """
        return _STEPConstruct.STEPConstruct_AP203Context_RoleCreationDate(self, *args)


    def RoleClassificationDate(self, *args):
        """
        RoleClassificationDate(STEPConstruct_AP203Context self) -> Handle_StepBasic_DateTimeRole

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_DateTimeRole

        """
        return _STEPConstruct.STEPConstruct_AP203Context_RoleClassificationDate(self, *args)


    def RoleApprover(self, *args):
        """
        RoleApprover(STEPConstruct_AP203Context self) -> Handle_StepBasic_ApprovalRole

        Return predefined PersonAndOrganizationRole and DateTimeRole
        entities named 'creator', 'design owner', 'design supplier',
        'classification officer', 'creation date', 'classification date',
        'approver'

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ApprovalRole

        """
        return _STEPConstruct.STEPConstruct_AP203Context_RoleApprover(self, *args)


    def Init(self, *args):
        """
        Init(STEPConstruct_AP203Context self, Handle_StepShape_ShapeDefinitionRepresentation sdr)
        Init(STEPConstruct_AP203Context self, STEPConstruct_Part SDRTool)
        Init(STEPConstruct_AP203Context self, Handle_StepRepr_NextAssemblyUsageOccurrence nauo)

        Takes NAUO which describes assembly link to component
        and creates the security_classification entity associated to
        it as required by the AP203

        Instantiated (or existing previously) entities concerned
        can be obtained by calls to methods
        GetClassificationOfficer(), GetSecurity(),
        GetClassificationDate(), GetApproval(),
        GetApprover(), GetApprovalDateTime()
        Takes tool which describes standard data around part
        (common for AP203 and AP214) and takes from model (or creates
        if missing) all the additional entities required by AP203

        :type nauo: OCC.wrapper.StepRepr.Handle_StepRepr_NextAssemblyUsageOccurrence

        """
        return _STEPConstruct.STEPConstruct_AP203Context_Init(self, *args)


    def GetCreator(self, *args):
        """
        GetCreator(STEPConstruct_AP203Context self) -> Handle_StepAP203_CcDesignPersonAndOrganizationAssignment

        :rtype: OCC.wrapper.StepAP203.Handle_StepAP203_CcDesignPersonAndOrganizationAssignment

        """
        return _STEPConstruct.STEPConstruct_AP203Context_GetCreator(self, *args)


    def GetDesignOwner(self, *args):
        """
        GetDesignOwner(STEPConstruct_AP203Context self) -> Handle_StepAP203_CcDesignPersonAndOrganizationAssignment

        :rtype: OCC.wrapper.StepAP203.Handle_StepAP203_CcDesignPersonAndOrganizationAssignment

        """
        return _STEPConstruct.STEPConstruct_AP203Context_GetDesignOwner(self, *args)


    def GetDesignSupplier(self, *args):
        """
        GetDesignSupplier(STEPConstruct_AP203Context self) -> Handle_StepAP203_CcDesignPersonAndOrganizationAssignment

        :rtype: OCC.wrapper.StepAP203.Handle_StepAP203_CcDesignPersonAndOrganizationAssignment

        """
        return _STEPConstruct.STEPConstruct_AP203Context_GetDesignSupplier(self, *args)


    def GetClassificationOfficer(self, *args):
        """
        GetClassificationOfficer(STEPConstruct_AP203Context self) -> Handle_StepAP203_CcDesignPersonAndOrganizationAssignment

        :rtype: OCC.wrapper.StepAP203.Handle_StepAP203_CcDesignPersonAndOrganizationAssignment

        """
        return _STEPConstruct.STEPConstruct_AP203Context_GetClassificationOfficer(self, *args)


    def GetSecurity(self, *args):
        """
        GetSecurity(STEPConstruct_AP203Context self) -> Handle_StepAP203_CcDesignSecurityClassification

        :rtype: OCC.wrapper.StepAP203.Handle_StepAP203_CcDesignSecurityClassification

        """
        return _STEPConstruct.STEPConstruct_AP203Context_GetSecurity(self, *args)


    def GetCreationDate(self, *args):
        """
        GetCreationDate(STEPConstruct_AP203Context self) -> Handle_StepAP203_CcDesignDateAndTimeAssignment

        :rtype: OCC.wrapper.StepAP203.Handle_StepAP203_CcDesignDateAndTimeAssignment

        """
        return _STEPConstruct.STEPConstruct_AP203Context_GetCreationDate(self, *args)


    def GetClassificationDate(self, *args):
        """
        GetClassificationDate(STEPConstruct_AP203Context self) -> Handle_StepAP203_CcDesignDateAndTimeAssignment

        :rtype: OCC.wrapper.StepAP203.Handle_StepAP203_CcDesignDateAndTimeAssignment

        """
        return _STEPConstruct.STEPConstruct_AP203Context_GetClassificationDate(self, *args)


    def GetApproval(self, *args):
        """
        GetApproval(STEPConstruct_AP203Context self) -> Handle_StepAP203_CcDesignApproval

        :rtype: OCC.wrapper.StepAP203.Handle_StepAP203_CcDesignApproval

        """
        return _STEPConstruct.STEPConstruct_AP203Context_GetApproval(self, *args)


    def GetApprover(self, *args):
        """
        GetApprover(STEPConstruct_AP203Context self) -> Handle_StepBasic_ApprovalPersonOrganization

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ApprovalPersonOrganization

        """
        return _STEPConstruct.STEPConstruct_AP203Context_GetApprover(self, *args)


    def GetApprovalDateTime(self, *args):
        """
        GetApprovalDateTime(STEPConstruct_AP203Context self) -> Handle_StepBasic_ApprovalDateTime

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ApprovalDateTime

        """
        return _STEPConstruct.STEPConstruct_AP203Context_GetApprovalDateTime(self, *args)


    def GetProductCategoryRelationship(self, *args):
        """
        GetProductCategoryRelationship(STEPConstruct_AP203Context self) -> Handle_StepBasic_ProductCategoryRelationship

        Return entities (roots) instantiated for the part by method Init

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductCategoryRelationship

        """
        return _STEPConstruct.STEPConstruct_AP203Context_GetProductCategoryRelationship(self, *args)


    def Clear(self, *args):
        """
        Clear(STEPConstruct_AP203Context self)

        Clears all fields describing entities specific to each part


        """
        return _STEPConstruct.STEPConstruct_AP203Context_Clear(self, *args)


    def InitRoles(self, *args):
        """
        InitRoles(STEPConstruct_AP203Context self)

        Initializes constant fields (shared entities)


        """
        return _STEPConstruct.STEPConstruct_AP203Context_InitRoles(self, *args)


    def InitAssembly(self, *args):
        """
        InitAssembly(STEPConstruct_AP203Context self, Handle_StepRepr_NextAssemblyUsageOccurrence nauo)

        Initializes all missing data which are required for assembly

        :type nauo: OCC.wrapper.StepRepr.Handle_StepRepr_NextAssemblyUsageOccurrence

        """
        return _STEPConstruct.STEPConstruct_AP203Context_InitAssembly(self, *args)


    def InitSecurityRequisites(self, *args):
        """
        InitSecurityRequisites(STEPConstruct_AP203Context self)

        Initializes ClassificationOfficer and ClassificationDate
        entities according to Security entity


        """
        return _STEPConstruct.STEPConstruct_AP203Context_InitSecurityRequisites(self, *args)


    def InitApprovalRequisites(self, *args):
        """
        InitApprovalRequisites(STEPConstruct_AP203Context self)

        Initializes Approver and ApprovalDateTime
        entities according to Approval entity


        """
        return _STEPConstruct.STEPConstruct_AP203Context_InitApprovalRequisites(self, *args)

    __swig_destroy__ = _STEPConstruct.delete_STEPConstruct_AP203Context
STEPConstruct_AP203Context_swigregister = _STEPConstruct.STEPConstruct_AP203Context_swigregister
STEPConstruct_AP203Context_swigregister(STEPConstruct_AP203Context)

class NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher self) -> NCollection_DataMap< gp_Pnt,opencascade::handle< Standard_Transient >,STEPConstruct_PointHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _STEPConstruct.NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher self) -> NCollection_DataMap< gp_Pnt,opencascade::handle< Standard_Transient >,STEPConstruct_PointHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _STEPConstruct.NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher self) -> NCollection_DataMap< gp_Pnt,opencascade::handle< Standard_Transient >,STEPConstruct_PointHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _STEPConstruct.NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher self) -> NCollection_DataMap< gp_Pnt,opencascade::handle< Standard_Transient >,STEPConstruct_PointHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _STEPConstruct.NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _STEPConstruct.new_NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher self, NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _STEPConstruct.NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher self, NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher theOther) -> NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _STEPConstruct.NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher self, NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher theOther) -> NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _STEPConstruct.NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _STEPConstruct.NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher self, gp_Pnt theKey, Handle_Standard_Transient theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher self, gp_Pnt theKey, Handle_Standard_Transient theItem) -> Handle_Standard_Transient

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _STEPConstruct.NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher self, gp_Pnt theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher self, gp_Pnt theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher self, gp_Pnt theKey) -> Handle_Standard_Transient

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _STEPConstruct.NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _STEPConstruct.NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher self, gp_Pnt theKey) -> Handle_Standard_Transient

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _STEPConstruct.NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher self, gp_Pnt theKey) -> Handle_Standard_Transient

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _STEPConstruct.NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _STEPConstruct.NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _STEPConstruct.NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPConstruct.NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher_Size(self, *args)


    def __iter__(self):
        return _STEPConstruct.NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher___iter__(self)
    __swig_destroy__ = _STEPConstruct.delete_NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher
NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher_swigregister = _STEPConstruct.NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher_swigregister
NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher_swigregister(NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher)

class NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _STEPConstruct.new_NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _STEPConstruct.delete_NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher_IteratorHelper

    def __next__(self):
        return _STEPConstruct.NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher_IteratorHelper___next__(self)
NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher_IteratorHelper_swigregister = _STEPConstruct.NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher_IteratorHelper_swigregister
NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher_IteratorHelper_swigregister(NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher_IteratorHelper)


try:
	STEPConstruct_DataMapOfPointTransient = NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher
except NameError:
	pass # does not exist, probably ignored

class NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString self) -> NCollection_DataMap< TCollection_AsciiString,opencascade::handle< Standard_Transient >,TCollection_AsciiString >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _STEPConstruct.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString self) -> NCollection_DataMap< TCollection_AsciiString,opencascade::handle< Standard_Transient >,TCollection_AsciiString >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _STEPConstruct.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString self) -> NCollection_DataMap< TCollection_AsciiString,opencascade::handle< Standard_Transient >,TCollection_AsciiString >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _STEPConstruct.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString self) -> NCollection_DataMap< TCollection_AsciiString,opencascade::handle< Standard_Transient >,TCollection_AsciiString >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _STEPConstruct.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _STEPConstruct.new_NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString self, NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _STEPConstruct.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString self, NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString theOther) -> NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _STEPConstruct.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString self, NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString theOther) -> NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _STEPConstruct.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _STEPConstruct.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString self, TCollection_AsciiString theKey, Handle_Standard_Transient theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString self, TCollection_AsciiString theKey, Handle_Standard_Transient theItem) -> Handle_Standard_Transient

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _STEPConstruct.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString self, TCollection_AsciiString theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString self, TCollection_AsciiString theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString self, TCollection_AsciiString theKey) -> Handle_Standard_Transient

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _STEPConstruct.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _STEPConstruct.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString self, TCollection_AsciiString theKey) -> Handle_Standard_Transient

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _STEPConstruct.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString self, TCollection_AsciiString theKey) -> Handle_Standard_Transient

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _STEPConstruct.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _STEPConstruct.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _STEPConstruct.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPConstruct.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString_Size(self, *args)


    def __iter__(self):
        return _STEPConstruct.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString___iter__(self)
    __swig_destroy__ = _STEPConstruct.delete_NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString
NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString_swigregister = _STEPConstruct.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString_swigregister
NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString_swigregister(NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString)

class NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _STEPConstruct.new_NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _STEPConstruct.delete_NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString_IteratorHelper

    def __next__(self):
        return _STEPConstruct.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString_IteratorHelper___next__(self)
NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString_IteratorHelper_swigregister = _STEPConstruct.NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString_IteratorHelper_swigregister
NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString_IteratorHelper_swigregister(NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString_IteratorHelper)


try:
	STEPConstruct_DataMapOfAsciiStringTransient = NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString
except NameError:
	pass # does not exist, probably ignored

class STEPConstruct_Styles(STEPConstruct_Tool):
    """
    Provides a mechanism for reading and writing shape styles
    (such as color) to and from the STEP file
    This tool maintains a list of styles, either taking them
    from STEP model (reading), or filling it by calls to
    AddStyle or directly (writing).
    Some methods deal with general structures of styles and
    presentations in STEP, but there are methods which deal
    with particular implementation of colors (as described in RP)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(STEPConstruct_Styles self) -> STEPConstruct_Styles
        __init__(STEPConstruct_Styles self, Handle_XSControl_WorkSession WS) -> STEPConstruct_Styles

        Creates a tool and initializes it

        :type WS: OCC.wrapper.XSControl.Handle_XSControl_WorkSession

        """
        this = _STEPConstruct.new_STEPConstruct_Styles(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(STEPConstruct_Styles self, Handle_XSControl_WorkSession WS) -> Standard_Boolean

        Initializes tool; returns True if succeeded

        :type WS: OCC.wrapper.XSControl.Handle_XSControl_WorkSession
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.STEPConstruct_Styles_Init(self, *args)


    def NbStyles(self, *args):
        """
        NbStyles(STEPConstruct_Styles self) -> Standard_Integer

        Returns number of defined styles

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPConstruct.STEPConstruct_Styles_NbStyles(self, *args)


    def Style(self, *args):
        """
        Style(STEPConstruct_Styles self, Standard_Integer const i) -> Handle_StepVisual_StyledItem

        Returns style with given index

        :type i: int
        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_StyledItem

        """
        return _STEPConstruct.STEPConstruct_Styles_Style(self, *args)


    def ClearStyles(self, *args):
        """
        ClearStyles(STEPConstruct_Styles self)

        Clears all defined styles and PSA sequence


        """
        return _STEPConstruct.STEPConstruct_Styles_ClearStyles(self, *args)


    def AddStyle(self, *args):
        """
        AddStyle(STEPConstruct_Styles self, Handle_StepVisual_StyledItem style)
        AddStyle(STEPConstruct_Styles self, Handle_StepRepr_RepresentationItem item, Handle_StepVisual_PresentationStyleAssignment PSA, Handle_StepVisual_StyledItem Override) -> Handle_StepVisual_StyledItem
        AddStyle(STEPConstruct_Styles self, TopoDS_Shape Shape, Handle_StepVisual_PresentationStyleAssignment PSA, Handle_StepVisual_StyledItem Override) -> Handle_StepVisual_StyledItem

        Create a style linking giving PSA to the Shape, and add it to the
        sequence of stored styles. If Override is not Null, then
        the resulting style will be of the subtype OverridingStyledItem.
        The Sape is used to find corresponding STEP entity by call to
        STEPConstruct::FindEntity(), then previous method is called.

        :type Shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type PSA: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationStyleAssignment
        :type Override: OCC.wrapper.StepVisual.Handle_StepVisual_StyledItem
        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_StyledItem

        """
        return _STEPConstruct.STEPConstruct_Styles_AddStyle(self, *args)


    def CreateMDGPR(self, *args):
        """
        CreateMDGPR(STEPConstruct_Styles self, Handle_StepRepr_RepresentationContext Context, Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation MDGPR) -> Standard_Boolean

        Create MDGPR, fill it with all the styles previously defined,
        and add it to the model

        :type Context: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext
        :type MDGPR: OCC.wrapper.StepVisual.Handle_StepVisual_MechanicalDesignGeometricPresentationRepresentation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.STEPConstruct_Styles_CreateMDGPR(self, *args)


    def CreateNAUOSRD(self, *args):
        """
        CreateNAUOSRD(STEPConstruct_Styles self, Handle_StepRepr_RepresentationContext Context, Handle_StepShape_ContextDependentShapeRepresentation CDSR, Handle_StepRepr_ProductDefinitionShape initPDS) -> Standard_Boolean

        Create MDGPR, fill it with all the styles previously defined,
        and add it to the model
        IMPORTANT: <initPDS> must be null when use for NAUO colors
        <initPDS> initialised only for SHUO case.

        :type Context: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext
        :type CDSR: OCC.wrapper.StepShape.Handle_StepShape_ContextDependentShapeRepresentation
        :type initPDS: OCC.wrapper.STEPConstruct.Handle_StepRepr_ProductDefinitionShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.STEPConstruct_Styles_CreateNAUOSRD(self, *args)


    def FindContext(self, *args):
        """
        FindContext(STEPConstruct_Styles self, TopoDS_Shape Shape) -> Handle_StepRepr_RepresentationContext

        Searches the STEP model for the RepresentationContext in which
        given shape is defined. This context (if found) can be used
        then in call to CreateMDGPR()

        :type Shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext

        """
        return _STEPConstruct.STEPConstruct_Styles_FindContext(self, *args)


    def LoadStyles(self, *args):
        """
        LoadStyles(STEPConstruct_Styles self) -> Standard_Boolean

        Searches the STEP model for the MDGPR or DM entities
        (which bring styles) and fills sequence of styles

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.STEPConstruct_Styles_LoadStyles(self, *args)


    def LoadInvisStyles(self, *args):
        """
        LoadInvisStyles(STEPConstruct_Styles self, Handle_TColStd_HSequenceOfTransient InvSyles) -> Standard_Boolean

        Searches the STEP model for the INISIBILITY enteties
        (which bring styles) and fills out sequence of styles

        :type InvSyles: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.STEPConstruct_Styles_LoadInvisStyles(self, *args)


    def MakeColorPSA(self, *args):
        """
        MakeColorPSA(STEPConstruct_Styles self, Handle_StepRepr_RepresentationItem item, Handle_StepVisual_Colour SurfCol, Handle_StepVisual_Colour CurveCol, Standard_Boolean const isForNAUO) -> Handle_StepVisual_PresentationStyleAssignment

        Create a PresentationStyleAssignment entity which defines
        two colors (for filling surfaces and curves)
        if isForNAUO true then returns PresentationStyleByContext

        :type item: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem
        :type SurfCol: OCC.wrapper.StepVisual.Handle_StepVisual_Colour
        :type CurveCol: OCC.wrapper.StepVisual.Handle_StepVisual_Colour
        :type isForNAUO: bool
        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationStyleAssignment

        """
        return _STEPConstruct.STEPConstruct_Styles_MakeColorPSA(self, *args)


    def GetColorPSA(self, *args):
        """
        GetColorPSA(STEPConstruct_Styles self, Handle_StepRepr_RepresentationItem item, Handle_StepVisual_Colour Col) -> Handle_StepVisual_PresentationStyleAssignment

        Returns a PresentationStyleAssignment entity which defines
        surface and curve colors as Col. This PSA is either created
        or taken from internal map where all PSAs created by this
        method are remembered.

        :type item: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem
        :type Col: OCC.wrapper.StepVisual.Handle_StepVisual_Colour
        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_PresentationStyleAssignment

        """
        return _STEPConstruct.STEPConstruct_Styles_GetColorPSA(self, *args)


    def GetColors(self, *args):
        """
        GetColors(STEPConstruct_Styles self, Handle_StepVisual_StyledItem style, Handle_StepVisual_Colour SurfCol, Handle_StepVisual_Colour BoundCol, Handle_StepVisual_Colour CurveCol) -> Standard_Boolean

        Extract color definitions from the style entity
        For each type of color supported, result can be either
        NULL if it is not defined by that style, or last
        definition (if they are 1 or more)

        :type style: OCC.wrapper.StepVisual.Handle_StepVisual_StyledItem
        :type SurfCol: OCC.wrapper.StepVisual.Handle_StepVisual_Colour
        :type BoundCol: OCC.wrapper.StepVisual.Handle_StepVisual_Colour
        :type CurveCol: OCC.wrapper.StepVisual.Handle_StepVisual_Colour
        :type IsComponent: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.STEPConstruct_Styles_GetColors(self, *args)


    def EncodeColor(*args):
        """
        EncodeColor(Quantity_Color Col) -> Handle_StepVisual_Colour
        EncodeColor(Quantity_Color Col, NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString DPDCs, NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher ColRGBs) -> Handle_StepVisual_Colour

        Create STEP color entity by given Quantity_Color
        The analysis is performed for whether the color corresponds to
        one of standard colors predefined in STEP. In that case,
        PredefinedColour entity is created instead of RGBColour

        :type Col: OCC.wrapper.Quantity.Quantity_Color
        :type DPDCs: OCC.wrapper.STEPConstruct.STEPConstruct_DataMapOfAsciiStringTransient
        :type ColRGBs: OCC.wrapper.STEPConstruct.STEPConstruct_DataMapOfPointTransient
        :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_Colour

        """
        return _STEPConstruct.STEPConstruct_Styles_EncodeColor(*args)

    EncodeColor = staticmethod(EncodeColor)

    def DecodeColor(*args):
        """
        DecodeColor(Handle_StepVisual_Colour Colour, Quantity_Color Col) -> Standard_Boolean

        Decodes STEP color and fills the Quantity_Color.
        Returns True if OK or False if color is not recognized

        :type Colour: OCC.wrapper.StepVisual.Handle_StepVisual_Colour
        :type Col: OCC.wrapper.Quantity.Quantity_Color
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.STEPConstruct_Styles_DecodeColor(*args)

    DecodeColor = staticmethod(DecodeColor)
    __swig_destroy__ = _STEPConstruct.delete_STEPConstruct_Styles
STEPConstruct_Styles_swigregister = _STEPConstruct.STEPConstruct_Styles_swigregister
STEPConstruct_Styles_swigregister(STEPConstruct_Styles)

def STEPConstruct_Styles_EncodeColor(*args):
    """
    EncodeColor(Quantity_Color Col) -> Handle_StepVisual_Colour
    STEPConstruct_Styles_EncodeColor(Quantity_Color Col, NCollection_DataMap_TCollection_AsciiString_Handle_Standard_Transient_TCollection_AsciiString DPDCs, NCollection_DataMap_gp_Pnt_Handle_Standard_Transient_STEPConstruct_PointHasher ColRGBs) -> Handle_StepVisual_Colour

    Create STEP color entity by given Quantity_Color
    The analysis is performed for whether the color corresponds to
    one of standard colors predefined in STEP. In that case,
    PredefinedColour entity is created instead of RGBColour

    :type Col: OCC.wrapper.Quantity.Quantity_Color
    :type DPDCs: OCC.wrapper.STEPConstruct.STEPConstruct_DataMapOfAsciiStringTransient
    :type ColRGBs: OCC.wrapper.STEPConstruct.STEPConstruct_DataMapOfPointTransient
    :rtype: OCC.wrapper.StepVisual.Handle_StepVisual_Colour

    """
    return _STEPConstruct.STEPConstruct_Styles_EncodeColor(*args)

def STEPConstruct_Styles_DecodeColor(*args):
    """
    STEPConstruct_Styles_DecodeColor(Handle_StepVisual_Colour Colour, Quantity_Color Col) -> Standard_Boolean

    Decodes STEP color and fills the Quantity_Color.
    Returns True if OK or False if color is not recognized

    :type Colour: OCC.wrapper.StepVisual.Handle_StepVisual_Colour
    :type Col: OCC.wrapper.Quantity.Quantity_Color
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _STEPConstruct.STEPConstruct_Styles_DecodeColor(*args)

class STEPConstruct_ValidationProps(STEPConstruct_Tool):
    """
    This class provides tools for access (write and read)
    the validation properties on shapes in the STEP file.
    These are surface area, solid volume and centroid.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(STEPConstruct_ValidationProps self) -> STEPConstruct_ValidationProps
        __init__(STEPConstruct_ValidationProps self, Handle_XSControl_WorkSession WS) -> STEPConstruct_ValidationProps

        Creates a tool and loads it with worksession

        :type WS: OCC.wrapper.XSControl.Handle_XSControl_WorkSession

        """
        this = _STEPConstruct.new_STEPConstruct_ValidationProps(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(STEPConstruct_ValidationProps self, Handle_XSControl_WorkSession WS) -> Standard_Boolean

        Load worksession; returns True if succeeded

        :type WS: OCC.wrapper.XSControl.Handle_XSControl_WorkSession
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.STEPConstruct_ValidationProps_Init(self, *args)


    def AddProp(self, *args):
        """
        AddProp(STEPConstruct_ValidationProps self, TopoDS_Shape Shape, Handle_StepRepr_RepresentationItem Prop, Standard_CString const Descr, Standard_Boolean const instance) -> Standard_Boolean
        AddProp(STEPConstruct_ValidationProps self, StepRepr_CharacterizedDefinition target, Handle_StepRepr_RepresentationContext Context, Handle_StepRepr_RepresentationItem Prop, Standard_CString const Descr) -> Standard_Boolean

        General method for adding (writing) a validation property
        for shape which should be already mapped on writing itself.
        It takes target and Context entities which correspond to shape
        Returns True if success, False in case of fail

        :type target: OCC.wrapper.StepRepr.StepRepr_CharacterizedDefinition
        :type Context: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext
        :type Prop: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem
        :type Descr: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.STEPConstruct_ValidationProps_AddProp(self, *args)


    def AddArea(self, *args):
        """
        AddArea(STEPConstruct_ValidationProps self, TopoDS_Shape Shape, Standard_Real const Area) -> Standard_Boolean

        Adds surface area property for given shape (already mapped).
        Returns True if success, False in case of fail

        :type Shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Area: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.STEPConstruct_ValidationProps_AddArea(self, *args)


    def AddVolume(self, *args):
        """
        AddVolume(STEPConstruct_ValidationProps self, TopoDS_Shape Shape, Standard_Real const Vol) -> Standard_Boolean

        Adds volume property for given shape (already mapped).
        Returns True if success, False in case of fail

        :type Shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Vol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.STEPConstruct_ValidationProps_AddVolume(self, *args)


    def AddCentroid(self, *args):
        """
        AddCentroid(STEPConstruct_ValidationProps self, TopoDS_Shape Shape, gp_Pnt Pnt, Standard_Boolean const instance) -> Standard_Boolean

        Adds centroid property for given shape (already mapped).
        Returns True if success, False in case of fail
        If instance is True, then centroid is assigned to
        an instance of component in assembly

        :type Shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Pnt: OCC.wrapper.gp.gp_Pnt
        :type instance: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.STEPConstruct_ValidationProps_AddCentroid(self, *args)


    def FindTarget(self, *args):
        """
        FindTarget(STEPConstruct_ValidationProps self, TopoDS_Shape S, StepRepr_CharacterizedDefinition target, Handle_StepRepr_RepresentationContext Context, Standard_Boolean const instance) -> Standard_Boolean

        Finds target STEP entity to which validation props should
        be assigned, and corresponding context, starting from shape
        Returns True if success, False in case of fail

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type target: OCC.wrapper.StepRepr.StepRepr_CharacterizedDefinition
        :type Context: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext
        :type instance: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.STEPConstruct_ValidationProps_FindTarget(self, *args)


    def LoadProps(self, *args):
        """
        LoadProps(STEPConstruct_ValidationProps self, NCollection_Sequence_Handle_Standard_Transient seq) -> Standard_Boolean

        Searches for entities of the type PropertyDefinitionRepresentation
        in the model and fills the sequence by them

        :type seq: OCC.wrapper.TColStd.TColStd_SequenceOfTransient
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.STEPConstruct_ValidationProps_LoadProps(self, *args)


    def GetPropNAUO(self, *args):
        """
        GetPropNAUO(STEPConstruct_ValidationProps self, Handle_StepRepr_PropertyDefinition PD) -> Handle_StepRepr_NextAssemblyUsageOccurrence

        Returns CDSR associated with given PpD or NULL if not found
        (when, try GetPropSDR)

        :type PD: OCC.wrapper.StepRepr.Handle_StepRepr_PropertyDefinition
        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_NextAssemblyUsageOccurrence

        """
        return _STEPConstruct.STEPConstruct_ValidationProps_GetPropNAUO(self, *args)


    def GetPropPD(self, *args):
        """
        GetPropPD(STEPConstruct_ValidationProps self, Handle_StepRepr_PropertyDefinition PD) -> Handle_StepBasic_ProductDefinition

        Returns SDR associated with given PpD or NULL if not found
        (when, try GetPropCDSR)

        :type PD: OCC.wrapper.StepRepr.Handle_StepRepr_PropertyDefinition
        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinition

        """
        return _STEPConstruct.STEPConstruct_ValidationProps_GetPropPD(self, *args)


    def GetPropShape(self, *args):
        """
        GetPropShape(STEPConstruct_ValidationProps self, Handle_StepBasic_ProductDefinition ProdDef) -> TopoDS_Shape
        GetPropShape(STEPConstruct_ValidationProps self, Handle_StepRepr_PropertyDefinition PD) -> TopoDS_Shape

        Returns Shape associated with given PpD or Null Shape
        if not found

        :type PD: OCC.wrapper.StepRepr.Handle_StepRepr_PropertyDefinition
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _STEPConstruct.STEPConstruct_ValidationProps_GetPropShape(self, *args)


    def GetPropReal(self, *args):
        """
        GetPropReal(STEPConstruct_ValidationProps self, Handle_StepRepr_RepresentationItem item) -> Standard_Boolean

        Returns value of Real-Valued property (Area or Volume)
        If Property is neither Area nor Volume, returns False
        Else returns True and isArea indicates whether property
        is area or volume

        :type item: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem
        :type Val: float
        :type isArea: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.STEPConstruct_ValidationProps_GetPropReal(self, *args)


    def GetPropPnt(self, *args):
        """
        GetPropPnt(STEPConstruct_ValidationProps self, Handle_StepRepr_RepresentationItem item, Handle_StepRepr_RepresentationContext Context, gp_Pnt Pnt) -> Standard_Boolean

        Returns value of Centriod property (or False if it is not)

        :type item: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationItem
        :type Context: OCC.wrapper.StepRepr.Handle_StepRepr_RepresentationContext
        :type Pnt: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.STEPConstruct_ValidationProps_GetPropPnt(self, *args)


    def SetAssemblyShape(self, *args):
        """
        SetAssemblyShape(STEPConstruct_ValidationProps self, TopoDS_Shape shape)

        Sets current assembly shape SDR (for FindCDSR calls)

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _STEPConstruct.STEPConstruct_ValidationProps_SetAssemblyShape(self, *args)

    __swig_destroy__ = _STEPConstruct.delete_STEPConstruct_ValidationProps
STEPConstruct_ValidationProps_swigregister = _STEPConstruct.STEPConstruct_ValidationProps_swigregister
STEPConstruct_ValidationProps_swigregister(STEPConstruct_ValidationProps)

class STEPConstruct_ContextTool(object):
    """
    Maintains global context tool for writing.
    Gives access to Product Definition Context (one per Model)
    Maintains ApplicationProtocolDefinition entity (common for all
    products)
    Also maintains context specific for AP203 and provides set of
    methods to work with various STEP constructs as required
    by Actor
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(STEPConstruct_ContextTool self) -> STEPConstruct_ContextTool
        __init__(STEPConstruct_ContextTool self, Handle_StepData_StepModel aStepModel) -> STEPConstruct_ContextTool

        :type aStepModel: OCC.wrapper.StepData.Handle_StepData_StepModel

        """
        this = _STEPConstruct.new_STEPConstruct_ContextTool(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetModel(self, *args):
        """
        SetModel(STEPConstruct_ContextTool self, Handle_StepData_StepModel aStepModel)

        Initialize ApplicationProtocolDefinition by the first
        entity of that type found in the model

        :type aStepModel: OCC.wrapper.StepData.Handle_StepData_StepModel

        """
        return _STEPConstruct.STEPConstruct_ContextTool_SetModel(self, *args)


    def GetAPD(self, *args):
        """
        GetAPD(STEPConstruct_ContextTool self) -> Handle_StepBasic_ApplicationProtocolDefinition

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationProtocolDefinition

        """
        return _STEPConstruct.STEPConstruct_ContextTool_GetAPD(self, *args)


    def AddAPD(self, *args):
        """
        AddAPD(STEPConstruct_ContextTool self, Standard_Boolean const enforce)

        :type enforce: bool

        """
        return _STEPConstruct.STEPConstruct_ContextTool_AddAPD(self, *args)


    def IsAP203(self, *args):
        """
        IsAP203(STEPConstruct_ContextTool self) -> Standard_Boolean

        Returns True if APD.schema_name is config_control_design

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.STEPConstruct_ContextTool_IsAP203(self, *args)


    def IsAP214(self, *args):
        """
        IsAP214(STEPConstruct_ContextTool self) -> Standard_Boolean

        Returns True if APD.schema_name is automotive_design

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.STEPConstruct_ContextTool_IsAP214(self, *args)


    def IsAP242(self, *args):
        """
        IsAP242(STEPConstruct_ContextTool self) -> Standard_Boolean

        Returns True if APD.schema_name is ap242_managed_model_based_3d_engineering

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.STEPConstruct_ContextTool_IsAP242(self, *args)


    def GetACstatus(self, *args):
        """
        GetACstatus(STEPConstruct_ContextTool self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_ContextTool_GetACstatus(self, *args)


    def GetACschemaName(self, *args):
        """
        GetACschemaName(STEPConstruct_ContextTool self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_ContextTool_GetACschemaName(self, *args)


    def GetACyear(self, *args):
        """
        GetACyear(STEPConstruct_ContextTool self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPConstruct.STEPConstruct_ContextTool_GetACyear(self, *args)


    def GetACname(self, *args):
        """
        GetACname(STEPConstruct_ContextTool self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_ContextTool_GetACname(self, *args)


    def SetACstatus(self, *args):
        """
        SetACstatus(STEPConstruct_ContextTool self, Handle_TCollection_HAsciiString status)

        :type status: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_ContextTool_SetACstatus(self, *args)


    def SetACschemaName(self, *args):
        """
        SetACschemaName(STEPConstruct_ContextTool self, Handle_TCollection_HAsciiString schemaName)

        :type schemaName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_ContextTool_SetACschemaName(self, *args)


    def SetACyear(self, *args):
        """
        SetACyear(STEPConstruct_ContextTool self, Standard_Integer const year)

        :type year: int

        """
        return _STEPConstruct.STEPConstruct_ContextTool_SetACyear(self, *args)


    def SetACname(self, *args):
        """
        SetACname(STEPConstruct_ContextTool self, Handle_TCollection_HAsciiString name)

        :type name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_ContextTool_SetACname(self, *args)


    def GetDefaultAxis(self, *args):
        """
        GetDefaultAxis(STEPConstruct_ContextTool self) -> Handle_StepGeom_Axis2Placement3d

        Returns a default axis placement

        :rtype: OCC.wrapper.STEPConstruct.Handle_StepGeom_Axis2Placement3d

        """
        return _STEPConstruct.STEPConstruct_ContextTool_GetDefaultAxis(self, *args)


    def AP203Context(self, *args):
        """
        AP203Context(STEPConstruct_ContextTool self) -> STEPConstruct_AP203Context

        Returns tool which maintains context specific for AP203

        :rtype: OCC.wrapper.STEPConstruct.STEPConstruct_AP203Context

        """
        return _STEPConstruct.STEPConstruct_ContextTool_AP203Context(self, *args)


    def Level(self, *args):
        """
        Level(STEPConstruct_ContextTool self) -> Standard_Integer

        Returns current assembly level

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPConstruct.STEPConstruct_ContextTool_Level(self, *args)


    def NextLevel(self, *args):
        """NextLevel(STEPConstruct_ContextTool self)"""
        return _STEPConstruct.STEPConstruct_ContextTool_NextLevel(self, *args)


    def PrevLevel(self, *args):
        """PrevLevel(STEPConstruct_ContextTool self)"""
        return _STEPConstruct.STEPConstruct_ContextTool_PrevLevel(self, *args)


    def SetLevel(self, *args):
        """
        SetLevel(STEPConstruct_ContextTool self, Standard_Integer const lev)

        Changes current assembly level

        :type lev: int

        """
        return _STEPConstruct.STEPConstruct_ContextTool_SetLevel(self, *args)


    def Index(self, *args):
        """
        Index(STEPConstruct_ContextTool self) -> Standard_Integer

        Returns current index of assembly component on current level

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPConstruct.STEPConstruct_ContextTool_Index(self, *args)


    def NextIndex(self, *args):
        """NextIndex(STEPConstruct_ContextTool self)"""
        return _STEPConstruct.STEPConstruct_ContextTool_NextIndex(self, *args)


    def PrevIndex(self, *args):
        """PrevIndex(STEPConstruct_ContextTool self)"""
        return _STEPConstruct.STEPConstruct_ContextTool_PrevIndex(self, *args)


    def SetIndex(self, *args):
        """
        SetIndex(STEPConstruct_ContextTool self, Standard_Integer const ind)

        Changes current index of assembly component on current level

        :type ind: int

        """
        return _STEPConstruct.STEPConstruct_ContextTool_SetIndex(self, *args)


    def GetProductName(self, *args):
        """
        GetProductName(STEPConstruct_ContextTool self) -> Handle_TCollection_HAsciiString

        Generates a product name basing on write.step.product.name
        parameter and current position in the assembly structure

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_ContextTool_GetProductName(self, *args)


    def GetRootsForPart(self, *args):
        """
        GetRootsForPart(STEPConstruct_ContextTool self, STEPConstruct_Part SDRTool) -> Handle_TColStd_HSequenceOfTransient

        Produces and returns a full list of root entities required
        for part identified by SDRTool (including SDR itself)

        :type SDRTool: OCC.wrapper.STEPConstruct.STEPConstruct_Part
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _STEPConstruct.STEPConstruct_ContextTool_GetRootsForPart(self, *args)


    def GetRootsForAssemblyLink(self, *args):
        """
        GetRootsForAssemblyLink(STEPConstruct_ContextTool self, STEPConstruct_Assembly assembly) -> Handle_TColStd_HSequenceOfTransient

        Produces and returns a full list of root entities required
        for assembly link identified by assembly (including NAUO and CDSR)

        :type assembly: OCC.wrapper.STEPConstruct.STEPConstruct_Assembly
        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HSequenceOfTransient

        """
        return _STEPConstruct.STEPConstruct_ContextTool_GetRootsForAssemblyLink(self, *args)

    __swig_destroy__ = _STEPConstruct.delete_STEPConstruct_ContextTool
STEPConstruct_ContextTool_swigregister = _STEPConstruct.STEPConstruct_ContextTool_swigregister
STEPConstruct_ContextTool_swigregister(STEPConstruct_ContextTool)

class STEPConstruct_ExternRefs(STEPConstruct_Tool):
    """
    Provides a tool for analyzing (reading) and creating (writing)
    references to external files in STEP

    It maintains a data structure in the form of sequences
    of relevant STEP entities (roots), allowing either to create
    them by convenient API, or load from existing model and
    investigate
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(STEPConstruct_ExternRefs self) -> STEPConstruct_ExternRefs
        __init__(STEPConstruct_ExternRefs self, Handle_XSControl_WorkSession WS) -> STEPConstruct_ExternRefs

        Creates a tool and initializes it

        :type WS: OCC.wrapper.XSControl.Handle_XSControl_WorkSession

        """
        this = _STEPConstruct.new_STEPConstruct_ExternRefs(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(STEPConstruct_ExternRefs self, Handle_XSControl_WorkSession WS) -> Standard_Boolean

        Initializes tool; returns True if succeeded

        :type WS: OCC.wrapper.XSControl.Handle_XSControl_WorkSession
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.STEPConstruct_ExternRefs_Init(self, *args)


    def Clear(self, *args):
        """
        Clear(STEPConstruct_ExternRefs self)

        Clears internal fields (list of defined extern refs)


        """
        return _STEPConstruct.STEPConstruct_ExternRefs_Clear(self, *args)


    def LoadExternRefs(self, *args):
        """
        LoadExternRefs(STEPConstruct_ExternRefs self) -> Standard_Boolean

        Searches current STEP model for external references
        and loads them to the internal data structures
        NOTE: does not clear data structures before loading

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.STEPConstruct_ExternRefs_LoadExternRefs(self, *args)


    def NbExternRefs(self, *args):
        """
        NbExternRefs(STEPConstruct_ExternRefs self) -> Standard_Integer

        Returns number of defined extern references

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPConstruct.STEPConstruct_ExternRefs_NbExternRefs(self, *args)


    def FileName(self, *args):
        """
        FileName(STEPConstruct_ExternRefs self, Standard_Integer const num) -> Standard_CString

        Returns filename for numth extern reference
        Returns Null if FileName is not defined or bad

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _STEPConstruct.STEPConstruct_ExternRefs_FileName(self, *args)


    def ProdDef(self, *args):
        """
        ProdDef(STEPConstruct_ExternRefs self, Standard_Integer const num) -> Handle_StepBasic_ProductDefinition

        Returns ProductDefinition to which numth extern reference
        is associated.
        Returns Null if cannot be detected or if extern reference
        is not associated to SDR in a proper way.

        :type num: int
        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinition

        """
        return _STEPConstruct.STEPConstruct_ExternRefs_ProdDef(self, *args)


    def Format(self, *args):
        """
        Format(STEPConstruct_ExternRefs self, Standard_Integer const num) -> Handle_TCollection_HAsciiString

        Returns format identification string for the extern document
        Returns Null handle if format is not defined

        :type num: int
        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_ExternRefs_Format(self, *args)


    def AddExternRef(self, *args):
        """
        AddExternRef(STEPConstruct_ExternRefs self, Standard_CString const filename, Handle_StepBasic_ProductDefinition PD, Standard_CString const format) -> Standard_Integer

        Create a new external reference with specified attributes
        attached to a given SDR
        <format> can be Null string, in that case this information
        is not written. Else, it can be "STEP AP214" or "STEP AP203"
        Returns index of a new extern ref

        :type filename: OCC.wrapper.Standard.Standard_CString
        :type PD: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinition
        :type format: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPConstruct.STEPConstruct_ExternRefs_AddExternRef(self, *args)


    def checkAP214Shared(self, *args):
        """
        checkAP214Shared(STEPConstruct_ExternRefs self)

        Check (create if it is null) all shared entities for the model


        """
        return _STEPConstruct.STEPConstruct_ExternRefs_checkAP214Shared(self, *args)


    def WriteExternRefs(self, *args):
        """
        WriteExternRefs(STEPConstruct_ExternRefs self, Standard_Integer const num) -> Standard_Integer

        Adds all the currently defined external refs to the model
        Returns number of written extern refs

        :type num: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPConstruct.STEPConstruct_ExternRefs_WriteExternRefs(self, *args)


    def SetAP214APD(self, *args):
        """
        SetAP214APD(STEPConstruct_ExternRefs self, Handle_StepBasic_ApplicationProtocolDefinition APD)

        Set the ApplicationProtocolDefinition of the PDM schema

        :type APD: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationProtocolDefinition

        """
        return _STEPConstruct.STEPConstruct_ExternRefs_SetAP214APD(self, *args)


    def GetAP214APD(self, *args):
        """
        GetAP214APD(STEPConstruct_ExternRefs self) -> Handle_StepBasic_ApplicationProtocolDefinition

        Returns the ApplicationProtocolDefinition of the PDM schema
        NOTE: if not defined then create new APD with new Application Context

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationProtocolDefinition

        """
        return _STEPConstruct.STEPConstruct_ExternRefs_GetAP214APD(self, *args)

    __swig_destroy__ = _STEPConstruct.delete_STEPConstruct_ExternRefs
STEPConstruct_ExternRefs_swigregister = _STEPConstruct.STEPConstruct_ExternRefs_swigregister
STEPConstruct_ExternRefs_swigregister(STEPConstruct_ExternRefs)

class STEPConstruct_Part(object):
    """
    Provides tools for creating STEP structures associated
    with part (SDR), such as PRODUCT, PDF etc., as requied
    by current schema
    Also allows to investigate and modify this data
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(STEPConstruct_Part self) -> STEPConstruct_Part

        Provides tools for creating STEP structures associated
        with part (SDR), such as PRODUCT, PDF etc., as requied
        by current schema
        Also allows to investigate and modify this data
        """
        this = _STEPConstruct.new_STEPConstruct_Part(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def MakeSDR(self, *args):
        """
        MakeSDR(STEPConstruct_Part self, Handle_StepShape_ShapeRepresentation aShape, Handle_TCollection_HAsciiString aName, Handle_StepBasic_ApplicationContext AC)

        :type aShape: OCC.wrapper.StepShape.Handle_StepShape_ShapeRepresentation
        :type aName: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString
        :type AC: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationContext

        """
        return _STEPConstruct.STEPConstruct_Part_MakeSDR(self, *args)


    def ReadSDR(self, *args):
        """
        ReadSDR(STEPConstruct_Part self, Handle_StepShape_ShapeDefinitionRepresentation aShape)

        :type aShape: OCC.wrapper.StepShape.Handle_StepShape_ShapeDefinitionRepresentation

        """
        return _STEPConstruct.STEPConstruct_Part_ReadSDR(self, *args)


    def IsDone(self, *args):
        """
        IsDone(STEPConstruct_Part self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.STEPConstruct_Part_IsDone(self, *args)


    def SDRValue(self, *args):
        """
        SDRValue(STEPConstruct_Part self) -> Handle_StepShape_ShapeDefinitionRepresentation

        Returns SDR or Null if not done

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_ShapeDefinitionRepresentation

        """
        return _STEPConstruct.STEPConstruct_Part_SDRValue(self, *args)


    def SRValue(self, *args):
        """
        SRValue(STEPConstruct_Part self) -> Handle_StepShape_ShapeRepresentation

        Returns SDR->UsedRepresentation() or Null if not done

        :rtype: OCC.wrapper.StepShape.Handle_StepShape_ShapeRepresentation

        """
        return _STEPConstruct.STEPConstruct_Part_SRValue(self, *args)


    def PC(self, *args):
        """
        PC(STEPConstruct_Part self) -> Handle_StepBasic_ProductContext

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductContext

        """
        return _STEPConstruct.STEPConstruct_Part_PC(self, *args)


    def PCname(self, *args):
        """
        PCname(STEPConstruct_Part self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_Part_PCname(self, *args)


    def PCdisciplineType(self, *args):
        """
        PCdisciplineType(STEPConstruct_Part self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_Part_PCdisciplineType(self, *args)


    def SetPCname(self, *args):
        """
        SetPCname(STEPConstruct_Part self, Handle_TCollection_HAsciiString name)

        :type name: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_Part_SetPCname(self, *args)


    def SetPCdisciplineType(self, *args):
        """
        SetPCdisciplineType(STEPConstruct_Part self, Handle_TCollection_HAsciiString label)

        :type label: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_Part_SetPCdisciplineType(self, *args)


    def AC(self, *args):
        """
        AC(STEPConstruct_Part self) -> Handle_StepBasic_ApplicationContext

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ApplicationContext

        """
        return _STEPConstruct.STEPConstruct_Part_AC(self, *args)


    def ACapplication(self, *args):
        """
        ACapplication(STEPConstruct_Part self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_Part_ACapplication(self, *args)


    def SetACapplication(self, *args):
        """
        SetACapplication(STEPConstruct_Part self, Handle_TCollection_HAsciiString text)

        :type text: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_Part_SetACapplication(self, *args)


    def PDC(self, *args):
        """
        PDC(STEPConstruct_Part self) -> Handle_StepBasic_ProductDefinitionContext

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionContext

        """
        return _STEPConstruct.STEPConstruct_Part_PDC(self, *args)


    def PDCname(self, *args):
        """
        PDCname(STEPConstruct_Part self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_Part_PDCname(self, *args)


    def PDCstage(self, *args):
        """
        PDCstage(STEPConstruct_Part self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_Part_PDCstage(self, *args)


    def SetPDCname(self, *args):
        """
        SetPDCname(STEPConstruct_Part self, Handle_TCollection_HAsciiString label)

        :type label: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_Part_SetPDCname(self, *args)


    def SetPDCstage(self, *args):
        """
        SetPDCstage(STEPConstruct_Part self, Handle_TCollection_HAsciiString label)

        :type label: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_Part_SetPDCstage(self, *args)


    def Product(self, *args):
        """
        Product(STEPConstruct_Part self) -> Handle_StepBasic_Product

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_Product

        """
        return _STEPConstruct.STEPConstruct_Part_Product(self, *args)


    def Pid(self, *args):
        """
        Pid(STEPConstruct_Part self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_Part_Pid(self, *args)


    def Pname(self, *args):
        """
        Pname(STEPConstruct_Part self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_Part_Pname(self, *args)


    def Pdescription(self, *args):
        """
        Pdescription(STEPConstruct_Part self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_Part_Pdescription(self, *args)


    def SetPid(self, *args):
        """
        SetPid(STEPConstruct_Part self, Handle_TCollection_HAsciiString id)

        :type id: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_Part_SetPid(self, *args)


    def SetPname(self, *args):
        """
        SetPname(STEPConstruct_Part self, Handle_TCollection_HAsciiString label)

        :type label: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_Part_SetPname(self, *args)


    def SetPdescription(self, *args):
        """
        SetPdescription(STEPConstruct_Part self, Handle_TCollection_HAsciiString text)

        :type text: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_Part_SetPdescription(self, *args)


    def PDF(self, *args):
        """
        PDF(STEPConstruct_Part self) -> Handle_StepBasic_ProductDefinitionFormation

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinitionFormation

        """
        return _STEPConstruct.STEPConstruct_Part_PDF(self, *args)


    def PDFid(self, *args):
        """
        PDFid(STEPConstruct_Part self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_Part_PDFid(self, *args)


    def PDFdescription(self, *args):
        """
        PDFdescription(STEPConstruct_Part self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_Part_PDFdescription(self, *args)


    def SetPDFid(self, *args):
        """
        SetPDFid(STEPConstruct_Part self, Handle_TCollection_HAsciiString id)

        :type id: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_Part_SetPDFid(self, *args)


    def SetPDFdescription(self, *args):
        """
        SetPDFdescription(STEPConstruct_Part self, Handle_TCollection_HAsciiString text)

        :type text: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_Part_SetPDFdescription(self, *args)


    def PD(self, *args):
        """
        PD(STEPConstruct_Part self) -> Handle_StepBasic_ProductDefinition

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductDefinition

        """
        return _STEPConstruct.STEPConstruct_Part_PD(self, *args)


    def PDdescription(self, *args):
        """
        PDdescription(STEPConstruct_Part self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_Part_PDdescription(self, *args)


    def SetPDdescription(self, *args):
        """
        SetPDdescription(STEPConstruct_Part self, Handle_TCollection_HAsciiString text)

        :type text: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_Part_SetPDdescription(self, *args)


    def PDS(self, *args):
        """
        PDS(STEPConstruct_Part self) -> Handle_StepRepr_ProductDefinitionShape

        :rtype: OCC.wrapper.STEPConstruct.Handle_StepRepr_ProductDefinitionShape

        """
        return _STEPConstruct.STEPConstruct_Part_PDS(self, *args)


    def PDSname(self, *args):
        """
        PDSname(STEPConstruct_Part self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_Part_PDSname(self, *args)


    def PDSdescription(self, *args):
        """
        PDSdescription(STEPConstruct_Part self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_Part_PDSdescription(self, *args)


    def SetPDSname(self, *args):
        """
        SetPDSname(STEPConstruct_Part self, Handle_TCollection_HAsciiString label)

        :type label: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_Part_SetPDSname(self, *args)


    def SetPDSdescription(self, *args):
        """
        SetPDSdescription(STEPConstruct_Part self, Handle_TCollection_HAsciiString text)

        :type text: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_Part_SetPDSdescription(self, *args)


    def PRPC(self, *args):
        """
        PRPC(STEPConstruct_Part self) -> Handle_StepBasic_ProductRelatedProductCategory

        :rtype: OCC.wrapper.StepBasic.Handle_StepBasic_ProductRelatedProductCategory

        """
        return _STEPConstruct.STEPConstruct_Part_PRPC(self, *args)


    def PRPCname(self, *args):
        """
        PRPCname(STEPConstruct_Part self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_Part_PRPCname(self, *args)


    def PRPCdescription(self, *args):
        """
        PRPCdescription(STEPConstruct_Part self) -> Handle_TCollection_HAsciiString

        :rtype: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_Part_PRPCdescription(self, *args)


    def SetPRPCname(self, *args):
        """
        SetPRPCname(STEPConstruct_Part self, Handle_TCollection_HAsciiString label)

        :type label: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_Part_SetPRPCname(self, *args)


    def SetPRPCdescription(self, *args):
        """
        SetPRPCdescription(STEPConstruct_Part self, Handle_TCollection_HAsciiString text)

        :type text: OCC.wrapper.TCollection.Handle_TCollection_HAsciiString

        """
        return _STEPConstruct.STEPConstruct_Part_SetPRPCdescription(self, *args)

    __swig_destroy__ = _STEPConstruct.delete_STEPConstruct_Part
STEPConstruct_Part_swigregister = _STEPConstruct.STEPConstruct_Part_swigregister
STEPConstruct_Part_swigregister(STEPConstruct_Part)

class STEPConstruct_UnitContext(object):
    """
    Tool for creation (encoding) and decoding (for writing and reading
    accordingly) context defining units and tolerances (uncerntanties)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(STEPConstruct_UnitContext self) -> STEPConstruct_UnitContext

        Creates empty tool


        """
        this = _STEPConstruct.new_STEPConstruct_UnitContext(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(STEPConstruct_UnitContext self, Standard_Real const Tol3d)

        Creates new context (units are MM and radians,
        uncertainty equal to Tol3d)

        :type Tol3d: float

        """
        return _STEPConstruct.STEPConstruct_UnitContext_Init(self, *args)


    def IsDone(self, *args):
        """
        IsDone(STEPConstruct_UnitContext self) -> Standard_Boolean

        Returns True if Init was called successfully

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.STEPConstruct_UnitContext_IsDone(self, *args)


    def Value(self, *args):
        """
        Value(STEPConstruct_UnitContext self) -> Handle_StepGeom_GeomRepContextAndGlobUnitAssCtxAndGlobUncertaintyAssCtx

        Returns context (or Null if not done)

        :rtype: OCC.wrapper.StepGeom.Handle_StepGeom_GeomRepContextAndGlobUnitAssCtxAndGlobUncertaintyAssCtx

        """
        return _STEPConstruct.STEPConstruct_UnitContext_Value(self, *args)


    def ComputeFactors(self, *args):
        """
        ComputeFactors(STEPConstruct_UnitContext self, Handle_StepRepr_GlobalUnitAssignedContext aContext) -> Standard_Integer
        ComputeFactors(STEPConstruct_UnitContext self, Handle_StepBasic_NamedUnit aUnit) -> Standard_Integer

        :type aUnit: OCC.wrapper.StepBasic.Handle_StepBasic_NamedUnit
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPConstruct.STEPConstruct_UnitContext_ComputeFactors(self, *args)


    def ComputeTolerance(self, *args):
        """
        ComputeTolerance(STEPConstruct_UnitContext self, Handle_StepRepr_GlobalUncertaintyAssignedContext aContext) -> Standard_Integer

        Computes the uncertainty value (for length)

        :type aContext: OCC.wrapper.STEPConstruct.Handle_StepRepr_GlobalUncertaintyAssignedContext
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _STEPConstruct.STEPConstruct_UnitContext_ComputeTolerance(self, *args)


    def LengthFactor(self, *args):
        """
        LengthFactor(STEPConstruct_UnitContext self) -> Standard_Real

        Returns the lengthFactor

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _STEPConstruct.STEPConstruct_UnitContext_LengthFactor(self, *args)


    def PlaneAngleFactor(self, *args):
        """
        PlaneAngleFactor(STEPConstruct_UnitContext self) -> Standard_Real

        Returns the planeAngleFactor

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _STEPConstruct.STEPConstruct_UnitContext_PlaneAngleFactor(self, *args)


    def SolidAngleFactor(self, *args):
        """
        SolidAngleFactor(STEPConstruct_UnitContext self) -> Standard_Real

        Returns the solidAngleFactor

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _STEPConstruct.STEPConstruct_UnitContext_SolidAngleFactor(self, *args)


    def Uncertainty(self, *args):
        """
        Uncertainty(STEPConstruct_UnitContext self) -> Standard_Real

        Returns the Uncertainty value (for length)
        It has been converted  with LengthFactor

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _STEPConstruct.STEPConstruct_UnitContext_Uncertainty(self, *args)


    def AreaFactor(self, *args):
        """
        AreaFactor(STEPConstruct_UnitContext self) -> Standard_Real

        Returns the areaFactor

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _STEPConstruct.STEPConstruct_UnitContext_AreaFactor(self, *args)


    def VolumeFactor(self, *args):
        """
        VolumeFactor(STEPConstruct_UnitContext self) -> Standard_Real

        Returns the volumeFactor

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _STEPConstruct.STEPConstruct_UnitContext_VolumeFactor(self, *args)


    def HasUncertainty(self, *args):
        """
        HasUncertainty(STEPConstruct_UnitContext self) -> Standard_Boolean

        Tells if a Uncertainty (for length) is recorded

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.STEPConstruct_UnitContext_HasUncertainty(self, *args)


    def LengthDone(self, *args):
        """
        LengthDone(STEPConstruct_UnitContext self) -> Standard_Boolean

        Returns true if ComputeFactors has calculated
        a LengthFactor

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.STEPConstruct_UnitContext_LengthDone(self, *args)


    def PlaneAngleDone(self, *args):
        """
        PlaneAngleDone(STEPConstruct_UnitContext self) -> Standard_Boolean

        Returns true if ComputeFactors has calculated
        a PlaneAngleFactor

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.STEPConstruct_UnitContext_PlaneAngleDone(self, *args)


    def SolidAngleDone(self, *args):
        """
        SolidAngleDone(STEPConstruct_UnitContext self) -> Standard_Boolean

        Returns true if ComputeFactors has calculated
        a SolidAngleFactor

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.STEPConstruct_UnitContext_SolidAngleDone(self, *args)


    def AreaDone(self, *args):
        """
        AreaDone(STEPConstruct_UnitContext self) -> Standard_Boolean

        Returns true if areaFactor is computed

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.STEPConstruct_UnitContext_AreaDone(self, *args)


    def VolumeDone(self, *args):
        """
        VolumeDone(STEPConstruct_UnitContext self) -> Standard_Boolean

        Returns true if volumeFactor is computed

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.STEPConstruct_UnitContext_VolumeDone(self, *args)


    def StatusMessage(self, *args):
        """
        StatusMessage(STEPConstruct_UnitContext self, Standard_Integer const status) -> Standard_CString

        Returns a message for a given status (0 - empty)
        This message can then be added as warning for transfer

        :type status: int
        :rtype: OCC.wrapper.Standard.Standard_CString

        """
        return _STEPConstruct.STEPConstruct_UnitContext_StatusMessage(self, *args)


    def ConvertSiPrefix(*args):
        """
        ConvertSiPrefix(StepBasic_SiPrefix const aPrefix) -> Standard_Real

        Convert SI prefix defined by enumertaion to corresponding
        real factor (e.g. 1e6 for mega)

        :type aPrefix: OCC.wrapper.StepBasic.StepBasic_SiPrefix
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _STEPConstruct.STEPConstruct_UnitContext_ConvertSiPrefix(*args)

    ConvertSiPrefix = staticmethod(ConvertSiPrefix)
    __swig_destroy__ = _STEPConstruct.delete_STEPConstruct_UnitContext
STEPConstruct_UnitContext_swigregister = _STEPConstruct.STEPConstruct_UnitContext_swigregister
STEPConstruct_UnitContext_swigregister(STEPConstruct_UnitContext)

def STEPConstruct_UnitContext_ConvertSiPrefix(*args):
    """
    STEPConstruct_UnitContext_ConvertSiPrefix(StepBasic_SiPrefix const aPrefix) -> Standard_Real

    Convert SI prefix defined by enumertaion to corresponding
    real factor (e.g. 1e6 for mega)

    :type aPrefix: OCC.wrapper.StepBasic.StepBasic_SiPrefix
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _STEPConstruct.STEPConstruct_UnitContext_ConvertSiPrefix(*args)

class STEPConstruct_Assembly(object):
    """
    This operator creates and checks an item of an assembly, from its
    basic data : a ShapeRepresentation, a Location ...

    Three ways of coding such item from a ShapeRepresentation :
    - do nothing : i.e. informations for assembly are ignored
    - create a MappedItem
    - create a RepresentationRelationship (WithTransformation)
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(STEPConstruct_Assembly self) -> STEPConstruct_Assembly

        This operator creates and checks an item of an assembly, from its
        basic data : a ShapeRepresentation, a Location ...

        Three ways of coding such item from a ShapeRepresentation :
        - do nothing : i.e. informations for assembly are ignored
        - create a MappedItem
        - create a RepresentationRelationship (WithTransformation)
        """
        this = _STEPConstruct.new_STEPConstruct_Assembly(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(STEPConstruct_Assembly self, Handle_StepShape_ShapeDefinitionRepresentation aSR, Handle_StepShape_ShapeDefinitionRepresentation SDR0, Handle_StepGeom_Axis2Placement3d Ax0, Handle_StepGeom_Axis2Placement3d Loc)

        Initialises with starting values
        Ax0 : origin axis (typically, standard XYZ)
        Loc : location to which place the item
        Makes a MappedItem
        Resulting Value is returned by ItemValue

        :type aSR: OCC.wrapper.StepShape.Handle_StepShape_ShapeDefinitionRepresentation
        :type SDR0: OCC.wrapper.StepShape.Handle_StepShape_ShapeDefinitionRepresentation
        :type Ax0: OCC.wrapper.STEPConstruct.Handle_StepGeom_Axis2Placement3d
        :type Loc: OCC.wrapper.STEPConstruct.Handle_StepGeom_Axis2Placement3d

        """
        return _STEPConstruct.STEPConstruct_Assembly_Init(self, *args)


    def MakeRelationship(self, *args):
        """
        MakeRelationship(STEPConstruct_Assembly self)

        Make a (ShapeRepresentationRelationship,...WithTransformation)
        Resulting Value is returned by ItemValue


        """
        return _STEPConstruct.STEPConstruct_Assembly_MakeRelationship(self, *args)


    def ItemValue(self, *args):
        """
        ItemValue(STEPConstruct_Assembly self) -> Handle_Standard_Transient

        Returns the Value
        If no Make... has been called, returns the starting SR

        :rtype: OCC.wrapper.Standard.Handle_Standard_Transient

        """
        return _STEPConstruct.STEPConstruct_Assembly_ItemValue(self, *args)


    def ItemLocation(self, *args):
        """
        ItemLocation(STEPConstruct_Assembly self) -> Handle_StepGeom_Axis2Placement3d

        Returns the location of the item, computed from starting aLoc

        :rtype: OCC.wrapper.STEPConstruct.Handle_StepGeom_Axis2Placement3d

        """
        return _STEPConstruct.STEPConstruct_Assembly_ItemLocation(self, *args)


    def GetNAUO(self, *args):
        """
        GetNAUO(STEPConstruct_Assembly self) -> Handle_StepRepr_NextAssemblyUsageOccurrence

        Returns NAUO object describing the assembly link

        :rtype: OCC.wrapper.StepRepr.Handle_StepRepr_NextAssemblyUsageOccurrence

        """
        return _STEPConstruct.STEPConstruct_Assembly_GetNAUO(self, *args)


    def CheckSRRReversesNAUO(*args):
        """
        CheckSRRReversesNAUO(Interface_Graph theGraph, Handle_StepShape_ContextDependentShapeRepresentation CDSR) -> Standard_Boolean

        Checks whether SRR's definition of assembly and component contradicts
        with NAUO definition or not, according to model schema (AP214 or AP203)

        :type theGraph: OCC.wrapper.Interface.Interface_Graph
        :type CDSR: OCC.wrapper.StepShape.Handle_StepShape_ContextDependentShapeRepresentation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _STEPConstruct.STEPConstruct_Assembly_CheckSRRReversesNAUO(*args)

    CheckSRRReversesNAUO = staticmethod(CheckSRRReversesNAUO)
    __swig_destroy__ = _STEPConstruct.delete_STEPConstruct_Assembly
STEPConstruct_Assembly_swigregister = _STEPConstruct.STEPConstruct_Assembly_swigregister
STEPConstruct_Assembly_swigregister(STEPConstruct_Assembly)

def STEPConstruct_Assembly_CheckSRRReversesNAUO(*args):
    """
    STEPConstruct_Assembly_CheckSRRReversesNAUO(Interface_Graph theGraph, Handle_StepShape_ContextDependentShapeRepresentation CDSR) -> Standard_Boolean

    Checks whether SRR's definition of assembly and component contradicts
    with NAUO definition or not, according to model schema (AP214 or AP203)

    :type theGraph: OCC.wrapper.Interface.Interface_Graph
    :type CDSR: OCC.wrapper.StepShape.Handle_StepShape_ContextDependentShapeRepresentation
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _STEPConstruct.STEPConstruct_Assembly_CheckSRRReversesNAUO(*args)




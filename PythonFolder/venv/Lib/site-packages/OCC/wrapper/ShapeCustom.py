# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_ShapeCustom')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_ShapeCustom')
    _ShapeCustom = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_ShapeCustom', [dirname(__file__)])
        except ImportError:
            import _ShapeCustom
            return _ShapeCustom
        try:
            _mod = imp.load_module('_ShapeCustom', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _ShapeCustom = swig_import_helper()
    del swig_import_helper
else:
    import _ShapeCustom
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _ShapeCustom.delete_SwigPyIterator

    def value(self):
        return _ShapeCustom.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _ShapeCustom.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _ShapeCustom.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _ShapeCustom.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _ShapeCustom.SwigPyIterator_equal(self, x)

    def copy(self):
        return _ShapeCustom.SwigPyIterator_copy(self)

    def next(self):
        return _ShapeCustom.SwigPyIterator_next(self)

    def __next__(self):
        return _ShapeCustom.SwigPyIterator___next__(self)

    def previous(self):
        return _ShapeCustom.SwigPyIterator_previous(self)

    def advance(self, n):
        return _ShapeCustom.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _ShapeCustom.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _ShapeCustom.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _ShapeCustom.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _ShapeCustom.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _ShapeCustom.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _ShapeCustom.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _ShapeCustom.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _ShapeCustom.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_ShapeCustom.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _ShapeCustom.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _ShapeCustom.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ShapeCustom.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _ShapeCustom.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _ShapeCustom.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _ShapeCustom.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _ShapeCustom.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_ShapeCustom.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _ShapeCustom.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _ShapeCustom.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ShapeCustom.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _ShapeCustom.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _ShapeCustom.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _ShapeCustom.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _ShapeCustom.ptr_to_number(item)
ptr_to_number = _ShapeCustom.ptr_to_number

def HashCode(*args):
    return _ShapeCustom.HashCode(*args)
HashCode = _ShapeCustom.HashCode

def ptr_equal(a, b):
    return _ShapeCustom.ptr_equal(a, b)
ptr_equal = _ShapeCustom.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import ShapeExtend
else:
    import ShapeExtend
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColGeom
else:
    import TColGeom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import ShapeBuild
else:
    import ShapeBuild
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepTools
else:
    import BRepTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Poly
else:
    import Poly
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TShort
else:
    import TShort
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRep
else:
    import BRep
del _swig_python_version_info
class ShapeCustom_Modification(BRepTools.BRepTools_Modification):
    """
    A base class of Modification's from ShapeCustom.
    Implements message sending mechanism.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeCustom_Modification
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeCustom_Modification(self) 
            return h


    def SetMsgRegistrator(self, *args):
        """
        SetMsgRegistrator(ShapeCustom_Modification self, Handle_ShapeExtend_BasicMsgRegistrator msgreg)

        Sets message registrator

        :type msgreg: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeCustom.ShapeCustom_Modification_SetMsgRegistrator(self, *args)


    def MsgRegistrator(self, *args):
        """
        MsgRegistrator(ShapeCustom_Modification self) -> Handle_ShapeExtend_BasicMsgRegistrator

        Returns message registrator

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeCustom.ShapeCustom_Modification_MsgRegistrator(self, *args)


    def SendMsg(self, *args):
        """
        SendMsg(ShapeCustom_Modification self, TopoDS_Shape shape, Message_Msg message, Message_Gravity const gravity=Message_Info)

        Sends a message to be attached to the shape.
        Calls corresponding message of message registrator.

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type message: OCC.wrapper.Message.Message_Msg
        :type gravity: OCC.wrapper.Message.Message_Gravity

        """
        return _ShapeCustom.ShapeCustom_Modification_SendMsg(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeCustom.ShapeCustom_Modification_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeCustom.ShapeCustom_Modification_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeCustom.ShapeCustom_Modification_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeCustom.delete_ShapeCustom_Modification
ShapeCustom_Modification_swigregister = _ShapeCustom.ShapeCustom_Modification_swigregister
ShapeCustom_Modification_swigregister(ShapeCustom_Modification)

def ShapeCustom_Modification_get_type_name(*args):
    """
    ShapeCustom_Modification_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeCustom.ShapeCustom_Modification_get_type_name(*args)

def ShapeCustom_Modification_get_type_descriptor(*args):
    """
    ShapeCustom_Modification_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeCustom.ShapeCustom_Modification_get_type_descriptor(*args)

class ShapeCustom_BSplineRestriction(ShapeCustom_Modification):
    """
    this tool intended for aproximation surfaces, curves and pcurves with
    specified degree , max number of segments, tolerance 2d, tolerance 3d. Specified
    continuity can be reduced if approximation with specified continuity was not done.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeCustom_BSplineRestriction
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeCustom_BSplineRestriction(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeCustom_BSplineRestriction self) -> ShapeCustom_BSplineRestriction
        __init__(ShapeCustom_BSplineRestriction self, Standard_Boolean const anApproxSurfaceFlag, Standard_Boolean const anApproxCurve3dFlag, Standard_Boolean const anApproxCurve2dFlag, Standard_Real const aTol3d, Standard_Real const aTol2d, GeomAbs_Shape const aContinuity3d, GeomAbs_Shape const aContinuity2d, Standard_Integer const aMaxDegree, Standard_Integer const aNbMaxSeg, Standard_Boolean const Degree, Standard_Boolean const Rational) -> ShapeCustom_BSplineRestriction
        __init__(ShapeCustom_BSplineRestriction self, Standard_Boolean const anApproxSurfaceFlag, Standard_Boolean const anApproxCurve3dFlag, Standard_Boolean const anApproxCurve2dFlag, Standard_Real const aTol3d, Standard_Real const aTol2d, GeomAbs_Shape const aContinuity3d, GeomAbs_Shape const aContinuity2d, Standard_Integer const aMaxDegree, Standard_Integer const aNbMaxSeg, Standard_Boolean const Degree, Standard_Boolean const Rational, Handle_ShapeCustom_RestrictionParameters aModes) -> ShapeCustom_BSplineRestriction

        Initializes with specified parameters of aproximation.

        :type anApproxSurfaceFlag: bool
        :type anApproxCurve3dFlag: bool
        :type anApproxCurve2dFlag: bool
        :type aTol3d: float
        :type aTol2d: float
        :type aContinuity3d: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type aContinuity2d: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type aMaxDegree: int
        :type aNbMaxSeg: int
        :type Degree: bool
        :type Rational: bool
        :type aModes: OCC.wrapper.ShapeCustom.Handle_ShapeCustom_RestrictionParameters

        """
        this = _ShapeCustom.new_ShapeCustom_BSplineRestriction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewSurface(self, *args):
        """
        NewSurface(ShapeCustom_BSplineRestriction self, TopoDS_Face F, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True if  the  face <F> has   been
        modified.  In this  case, <S> is the new geometric
        support of  the  face, <L> the new  location,<Tol>
        the new   tolerance.<RevWires>  has to be   set to
        Standard_True when  the modification reverses  the
        normal of  the   surface.(the wires  have   to  be
        reversed).  <RevFace>    has   to   be   set    to
        Standard_True if  the  orientation of the modified
        face changes in the shells which contain it.

        Otherwise, returns Standard_False, and <S>,   <L>,
        <Tol> , <RevWires> ,<RevFace> are not  significant.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :type RevWires: bool
        :type RevFace: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_BSplineRestriction_NewSurface(self, *args)


    def NewCurve(self, *args):
        """
        NewCurve(ShapeCustom_BSplineRestriction self, TopoDS_Edge E, Handle_Geom_Curve C, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True  if  curve from the edge <E> has  been
        modified.  In this case,  <C> is the new geometric
        support of the  edge, <L> the  new location, <Tol>
        the         new    tolerance.
        Otherwise, returns Standard_True if Surface is modified or
        one of pcurves of edge is modified. In this case C is copy of
        geometric support of the edge.
        In other cases returns Standard_False, and  <C>,  <L>,  <Tol> are not
        significant.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_BSplineRestriction_NewCurve(self, *args)


    def NewCurve2d(self, *args):
        """
        NewCurve2d(ShapeCustom_BSplineRestriction self, TopoDS_Edge E, TopoDS_Face F, TopoDS_Edge NewE, TopoDS_Face NewF, Handle_Geom2d_Curve C) -> Standard_Boolean

        Returns Standard_True if  the edge  <E> has been modified.
        In this case,if curve on the surface is modified, <C>
        is the new geometric support of  the edge, <L> the
        new location, <Tol> the new tolerance. If curve on the surface
        is not modified C is copy curve on surface from the edge <E>.

        Otherwise, returns  Standard_False, and <C>,  <L>,
        <Tol> are not significant.

        <NewE> is the new  edge created from  <E>.  <NewF>
        is the new face created from <F>. They may be usefull.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF: OCC.wrapper.TopoDS.TopoDS_Face
        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_BSplineRestriction_NewCurve2d(self, *args)


    def ConvertSurface(self, *args):
        """
        ConvertSurface(ShapeCustom_BSplineRestriction self, Handle_Geom_Surface aSurface, Handle_Geom_Surface S, Standard_Real const UF, Standard_Real const UL, Standard_Real const VF, Standard_Real const VL, Standard_Boolean const IsOf) -> Standard_Boolean

        Returns Standard_True if  the surface has been modified.
        if flag IsOf equals Standard_True Offset surfaces are aproximated to Offset
        if Standard_False to BSpline

        :type aSurface: OCC.wrapper.Geom.Handle_Geom_Surface
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type UF: float
        :type UL: float
        :type VF: float
        :type VL: float
        :type IsOf: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_BSplineRestriction_ConvertSurface(self, *args)


    def ConvertCurve(self, *args):
        """
        ConvertCurve(ShapeCustom_BSplineRestriction self, Handle_Geom_Curve aCurve, Handle_Geom_Curve C, Standard_Boolean const IsConvert, Standard_Real const First, Standard_Real const Last, Standard_Boolean const IsOf) -> Standard_Boolean

        Returns Standard_True if  the curve has been modified.
        if flag IsOf equals Standard_True Offset curves are aproximated to Offset
        if Standard_False to BSpline

        :type aCurve: OCC.wrapper.Geom.Handle_Geom_Curve
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type IsConvert: bool
        :type First: float
        :type Last: float
        :type TolCur: float
        :type IsOf: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_BSplineRestriction_ConvertCurve(self, *args)


    def ConvertCurve2d(self, *args):
        """
        ConvertCurve2d(ShapeCustom_BSplineRestriction self, Handle_Geom2d_Curve aCurve, Handle_Geom2d_Curve C, Standard_Boolean const IsConvert, Standard_Real const First, Standard_Real const Last, Standard_Boolean const IsOf) -> Standard_Boolean

        Returns Standard_True if the pcurve has been modified.
        if flag IsOf equals Standard_True Offset pcurves are aproximated to Offset
        if Standard_False to BSpline

        :type aCurve: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type IsConvert: bool
        :type First: float
        :type Last: float
        :type TolCur: float
        :type IsOf: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_BSplineRestriction_ConvertCurve2d(self, *args)


    def SetTol3d(self, *args):
        """
        SetTol3d(ShapeCustom_BSplineRestriction self, Standard_Real const Tol3d)

        Sets tolerance of aproximation for curve3d and surface

        :type Tol3d: float

        """
        return _ShapeCustom.ShapeCustom_BSplineRestriction_SetTol3d(self, *args)


    def SetTol2d(self, *args):
        """
        SetTol2d(ShapeCustom_BSplineRestriction self, Standard_Real const Tol2d)

        Sets tolerance of aproximation for curve2d

        :type Tol2d: float

        """
        return _ShapeCustom.ShapeCustom_BSplineRestriction_SetTol2d(self, *args)


    def ModifyApproxSurfaceFlag(self, *args):
        """
        ModifyApproxSurfaceFlag(ShapeCustom_BSplineRestriction self) -> Standard_Boolean &

        Returns (modifiable) the flag which defines whether the
        surface is aproximated.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_BSplineRestriction_ModifyApproxSurfaceFlag(self, *args)


    def ModifyApproxCurve3dFlag(self, *args):
        """
        ModifyApproxCurve3dFlag(ShapeCustom_BSplineRestriction self) -> Standard_Boolean &

        Returns (modifiable) the flag which defines whether the
        curve3d is aproximated.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_BSplineRestriction_ModifyApproxCurve3dFlag(self, *args)


    def ModifyApproxCurve2dFlag(self, *args):
        """
        ModifyApproxCurve2dFlag(ShapeCustom_BSplineRestriction self) -> Standard_Boolean &

        Returns (modifiable) the flag which defines whether the curve2d is aproximated.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_BSplineRestriction_ModifyApproxCurve2dFlag(self, *args)


    def SetContinuity3d(self, *args):
        """
        SetContinuity3d(ShapeCustom_BSplineRestriction self, GeomAbs_Shape const Continuity3d)

        Sets continuity3d for aproximation curve3d and surface.

        :type Continuity3d: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _ShapeCustom.ShapeCustom_BSplineRestriction_SetContinuity3d(self, *args)


    def SetContinuity2d(self, *args):
        """
        SetContinuity2d(ShapeCustom_BSplineRestriction self, GeomAbs_Shape const Continuity2d)

        Sets continuity3d for aproximation curve2d.

        :type Continuity2d: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _ShapeCustom.ShapeCustom_BSplineRestriction_SetContinuity2d(self, *args)


    def SetMaxDegree(self, *args):
        """
        SetMaxDegree(ShapeCustom_BSplineRestriction self, Standard_Integer const MaxDegree)

        Sets max degree for aproximation.

        :type MaxDegree: int

        """
        return _ShapeCustom.ShapeCustom_BSplineRestriction_SetMaxDegree(self, *args)


    def SetMaxNbSegments(self, *args):
        """
        SetMaxNbSegments(ShapeCustom_BSplineRestriction self, Standard_Integer const MaxNbSegments)

        Sets max number of segments for aproximation.

        :type MaxNbSegments: int

        """
        return _ShapeCustom.ShapeCustom_BSplineRestriction_SetMaxNbSegments(self, *args)


    def SetPriority(self, *args):
        """
        SetPriority(ShapeCustom_BSplineRestriction self, Standard_Boolean const Degree)

        Sets priority  for aproximation curves and surface.
        If Degree is True approximation is made with degree less
        then specified MaxDegree at the expense of number of spanes.
        If Degree is False approximation is made with number of
        spans less then specified MaxNbSegment at the expense of
        specified MaxDegree.

        :type Degree: bool

        """
        return _ShapeCustom.ShapeCustom_BSplineRestriction_SetPriority(self, *args)


    def SetConvRational(self, *args):
        """
        SetConvRational(ShapeCustom_BSplineRestriction self, Standard_Boolean const Rational)

        Sets flag for define if rational BSpline or Bezier is
        converted to polynomial. If Rational is True approximation
        for rational BSpline and Bezier is made to polynomial even
        if degree is less then MaxDegree and number of spans is less
        then specified MaxNbSegment.

        :type Rational: bool

        """
        return _ShapeCustom.ShapeCustom_BSplineRestriction_SetConvRational(self, *args)


    def GetRestrictionParameters(self, *args):
        """
        GetRestrictionParameters(ShapeCustom_BSplineRestriction self) -> Handle_ShapeCustom_RestrictionParameters

        Returns the container of modes which defines
        what geometry should be converted to BSplines.

        :rtype: OCC.wrapper.ShapeCustom.Handle_ShapeCustom_RestrictionParameters

        """
        return _ShapeCustom.ShapeCustom_BSplineRestriction_GetRestrictionParameters(self, *args)


    def SetRestrictionParameters(self, *args):
        """
        SetRestrictionParameters(ShapeCustom_BSplineRestriction self, Handle_ShapeCustom_RestrictionParameters aModes)

        Sets the container of modes which defines
        what geometry should be converted to BSplines.

        :type aModes: OCC.wrapper.ShapeCustom.Handle_ShapeCustom_RestrictionParameters

        """
        return _ShapeCustom.ShapeCustom_BSplineRestriction_SetRestrictionParameters(self, *args)


    def Curve3dError(self, *args):
        """
        Curve3dError(ShapeCustom_BSplineRestriction self) -> Standard_Real

        Returns error for aproximation curve3d.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeCustom.ShapeCustom_BSplineRestriction_Curve3dError(self, *args)


    def Curve2dError(self, *args):
        """
        Curve2dError(ShapeCustom_BSplineRestriction self) -> Standard_Real

        Returns error for aproximation curve2d.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeCustom.ShapeCustom_BSplineRestriction_Curve2dError(self, *args)


    def SurfaceError(self, *args):
        """
        SurfaceError(ShapeCustom_BSplineRestriction self) -> Standard_Real

        Returns error for aproximation surface.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeCustom.ShapeCustom_BSplineRestriction_SurfaceError(self, *args)


    def NewPoint(self, *args):
        """
        NewPoint(ShapeCustom_BSplineRestriction self, TopoDS_Vertex V, gp_Pnt P) -> Standard_Boolean

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_BSplineRestriction_NewPoint(self, *args)


    def NewParameter(self, *args):
        """
        NewParameter(ShapeCustom_BSplineRestriction self, TopoDS_Vertex V, TopoDS_Edge E) -> Standard_Boolean

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: float
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_BSplineRestriction_NewParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(ShapeCustom_BSplineRestriction self, TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2, TopoDS_Edge NewE, TopoDS_Face NewF1, TopoDS_Face NewF2) -> GeomAbs_Shape

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF1: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewF2: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _ShapeCustom.ShapeCustom_BSplineRestriction_Continuity(self, *args)


    def MaxErrors(self, *args):
        """
        MaxErrors(ShapeCustom_BSplineRestriction self) -> Standard_Real

        Returns error for aproximation surface, curve3d and curve2d.

        :type aCurve3dErr: float
        :type aCurve2dErr: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeCustom.ShapeCustom_BSplineRestriction_MaxErrors(self, *args)


    def NbOfSpan(self, *args):
        """
        NbOfSpan(ShapeCustom_BSplineRestriction self) -> Standard_Integer

        Returns number for aproximation surface, curve3d and curve2d.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeCustom.ShapeCustom_BSplineRestriction_NbOfSpan(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeCustom.ShapeCustom_BSplineRestriction_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeCustom.ShapeCustom_BSplineRestriction_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeCustom.ShapeCustom_BSplineRestriction_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeCustom.delete_ShapeCustom_BSplineRestriction
ShapeCustom_BSplineRestriction_swigregister = _ShapeCustom.ShapeCustom_BSplineRestriction_swigregister
ShapeCustom_BSplineRestriction_swigregister(ShapeCustom_BSplineRestriction)

def ShapeCustom_BSplineRestriction_get_type_name(*args):
    """
    ShapeCustom_BSplineRestriction_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeCustom.ShapeCustom_BSplineRestriction_get_type_name(*args)

def ShapeCustom_BSplineRestriction_get_type_descriptor(*args):
    """
    ShapeCustom_BSplineRestriction_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeCustom.ShapeCustom_BSplineRestriction_get_type_descriptor(*args)

class ShapeCustom_RestrictionParameters(Standard.Standard_Transient):
    """
    This class is axuluary tool which contains parameters for
    BSplineRestriction class.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeCustom_RestrictionParameters
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeCustom_RestrictionParameters(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeCustom_RestrictionParameters self) -> ShapeCustom_RestrictionParameters

        Sets default parameters.


        """
        this = _ShapeCustom.new_ShapeCustom_RestrictionParameters(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def GMaxDegree(self, *args):
        """
        GMaxDegree(ShapeCustom_RestrictionParameters self) -> Standard_Integer &

        Returns (modifiable) maximal degree of approximation.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeCustom.ShapeCustom_RestrictionParameters_GMaxDegree(self, *args)


    def GMaxSeg(self, *args):
        """
        GMaxSeg(ShapeCustom_RestrictionParameters self) -> Standard_Integer &

        Returns (modifiable) maximal number of spans of
        approximation.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeCustom.ShapeCustom_RestrictionParameters_GMaxSeg(self, *args)


    def ConvertPlane(self, *args):
        """
        ConvertPlane(ShapeCustom_RestrictionParameters self) -> Standard_Boolean &

        Sets flag for define if Plane converted to BSpline surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_RestrictionParameters_ConvertPlane(self, *args)


    def ConvertBezierSurf(self, *args):
        """
        ConvertBezierSurf(ShapeCustom_RestrictionParameters self) -> Standard_Boolean &

        Sets flag for define if Bezier surface converted to BSpline
        surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_RestrictionParameters_ConvertBezierSurf(self, *args)


    def ConvertRevolutionSurf(self, *args):
        """
        ConvertRevolutionSurf(ShapeCustom_RestrictionParameters self) -> Standard_Boolean &

        Sets flag for define if surface of Revolution converted to
        BSpline surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_RestrictionParameters_ConvertRevolutionSurf(self, *args)


    def ConvertExtrusionSurf(self, *args):
        """
        ConvertExtrusionSurf(ShapeCustom_RestrictionParameters self) -> Standard_Boolean &

        Sets flag for define if surface of LinearExtrusion converted
        to BSpline surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_RestrictionParameters_ConvertExtrusionSurf(self, *args)


    def ConvertOffsetSurf(self, *args):
        """
        ConvertOffsetSurf(ShapeCustom_RestrictionParameters self) -> Standard_Boolean &

        Sets flag for define if Offset surface converted to BSpline
        surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_RestrictionParameters_ConvertOffsetSurf(self, *args)


    def ConvertCylindricalSurf(self, *args):
        """
        ConvertCylindricalSurf(ShapeCustom_RestrictionParameters self) -> Standard_Boolean &

        Sets flag for define if cylindrical surface converted to BSpline
        surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_RestrictionParameters_ConvertCylindricalSurf(self, *args)


    def ConvertConicalSurf(self, *args):
        """
        ConvertConicalSurf(ShapeCustom_RestrictionParameters self) -> Standard_Boolean &

        Sets flag for define if conical surface converted to BSpline
        surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_RestrictionParameters_ConvertConicalSurf(self, *args)


    def ConvertToroidalSurf(self, *args):
        """
        ConvertToroidalSurf(ShapeCustom_RestrictionParameters self) -> Standard_Boolean &

        Sets flag for define if toroidal surface converted to BSpline
        surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_RestrictionParameters_ConvertToroidalSurf(self, *args)


    def ConvertSphericalSurf(self, *args):
        """
        ConvertSphericalSurf(ShapeCustom_RestrictionParameters self) -> Standard_Boolean &

        Sets flag for define if spherical surface converted to BSpline
        surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_RestrictionParameters_ConvertSphericalSurf(self, *args)


    def SegmentSurfaceMode(self, *args):
        """
        SegmentSurfaceMode(ShapeCustom_RestrictionParameters self) -> Standard_Boolean &

        Sets Segment mode for surface. If Segment is True surface is
        approximated in the bondaries of face lying on this surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_RestrictionParameters_SegmentSurfaceMode(self, *args)


    def ConvertCurve3d(self, *args):
        """
        ConvertCurve3d(ShapeCustom_RestrictionParameters self) -> Standard_Boolean &

        Sets flag for define if 3d curve converted to BSpline curve.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_RestrictionParameters_ConvertCurve3d(self, *args)


    def ConvertOffsetCurv3d(self, *args):
        """
        ConvertOffsetCurv3d(ShapeCustom_RestrictionParameters self) -> Standard_Boolean &

        Sets flag for define if Offset curve3d converted to BSpline
        surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_RestrictionParameters_ConvertOffsetCurv3d(self, *args)


    def ConvertCurve2d(self, *args):
        """
        ConvertCurve2d(ShapeCustom_RestrictionParameters self) -> Standard_Boolean &

        Returns (modifiable) flag for define if 2d curve converted
        to BSpline curve.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_RestrictionParameters_ConvertCurve2d(self, *args)


    def ConvertOffsetCurv2d(self, *args):
        """
        ConvertOffsetCurv2d(ShapeCustom_RestrictionParameters self) -> Standard_Boolean &

        Returns (modifiable) flag for define if Offset curve2d
        converted to BSpline surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_RestrictionParameters_ConvertOffsetCurv2d(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeCustom.ShapeCustom_RestrictionParameters_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeCustom.ShapeCustom_RestrictionParameters_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeCustom.ShapeCustom_RestrictionParameters_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeCustom.delete_ShapeCustom_RestrictionParameters
ShapeCustom_RestrictionParameters_swigregister = _ShapeCustom.ShapeCustom_RestrictionParameters_swigregister
ShapeCustom_RestrictionParameters_swigregister(ShapeCustom_RestrictionParameters)

def ShapeCustom_RestrictionParameters_get_type_name(*args):
    """
    ShapeCustom_RestrictionParameters_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeCustom.ShapeCustom_RestrictionParameters_get_type_name(*args)

def ShapeCustom_RestrictionParameters_get_type_descriptor(*args):
    """
    ShapeCustom_RestrictionParameters_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeCustom.ShapeCustom_RestrictionParameters_get_type_descriptor(*args)

class ShapeCustom_ConvertToRevolution(ShapeCustom_Modification):
    """
    implements a modification for the BRepTools
    Modifier algortihm. Converts all elementary
    surfaces into surfaces of revolution.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeCustom_ConvertToRevolution
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeCustom_ConvertToRevolution(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeCustom_ConvertToRevolution self) -> ShapeCustom_ConvertToRevolution

        implements a modification for the BRepTools
        Modifier algortihm. Converts all elementary
        surfaces into surfaces of revolution.
        """
        this = _ShapeCustom.new_ShapeCustom_ConvertToRevolution(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewSurface(self, *args):
        """
        NewSurface(ShapeCustom_ConvertToRevolution self, TopoDS_Face F, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True if the face <F> has  been
        modified. In this case, <S> is the new geometric
        support of the face, <L> the new location,  <Tol>
        the new tolerance.  Otherwise, returns
        Standard_False, and <S>, <L>, <Tol> are  not
        significant.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :type RevWires: bool
        :type RevFace: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_ConvertToRevolution_NewSurface(self, *args)


    def NewCurve(self, *args):
        """
        NewCurve(ShapeCustom_ConvertToRevolution self, TopoDS_Edge E, Handle_Geom_Curve C, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True  if  the edge  <E> has  been
        modified.  In this case,  <C> is the new geometric
        support of the  edge, <L> the  new location, <Tol>
        the         new    tolerance.   Otherwise, returns
        Standard_False,    and  <C>,  <L>,   <Tol> are not
        significant.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_ConvertToRevolution_NewCurve(self, *args)


    def NewPoint(self, *args):
        """
        NewPoint(ShapeCustom_ConvertToRevolution self, TopoDS_Vertex V, gp_Pnt P) -> Standard_Boolean

        Returns  Standard_True if the  vertex <V> has been
        modified.  In this  case, <P> is the new geometric
        support of the vertex,   <Tol> the new  tolerance.
        Otherwise, returns Standard_False, and <P>,  <Tol>
        are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_ConvertToRevolution_NewPoint(self, *args)


    def NewCurve2d(self, *args):
        """
        NewCurve2d(ShapeCustom_ConvertToRevolution self, TopoDS_Edge E, TopoDS_Face F, TopoDS_Edge NewE, TopoDS_Face NewF, Handle_Geom2d_Curve C) -> Standard_Boolean

        Returns Standard_True if  the edge  <E> has a  new
        curve on surface on the face <F>.In this case, <C>
        is the new geometric support of  the edge, <L> the
        new location, <Tol> the new tolerance.

        Otherwise, returns  Standard_False, and <C>,  <L>,
        <Tol> are not significant.

        <NewE> is the new  edge created from  <E>.  <NewF>
        is the new face created from <F>. They may be usefull.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF: OCC.wrapper.TopoDS.TopoDS_Face
        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_ConvertToRevolution_NewCurve2d(self, *args)


    def NewParameter(self, *args):
        """
        NewParameter(ShapeCustom_ConvertToRevolution self, TopoDS_Vertex V, TopoDS_Edge E) -> Standard_Boolean

        Returns Standard_True if the Vertex  <V> has a new
        parameter on the  edge <E>. In  this case,  <P> is
        the parameter,    <Tol>  the     new    tolerance.
        Otherwise, returns Standard_False, and <P>,  <Tol>
        are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: float
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_ConvertToRevolution_NewParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(ShapeCustom_ConvertToRevolution self, TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2, TopoDS_Edge NewE, TopoDS_Face NewF1, TopoDS_Face NewF2) -> GeomAbs_Shape

        Returns the  continuity of  <NewE> between <NewF1>
        and <NewF2>.

        <NewE> is the new  edge created from <E>.  <NewF1>
        (resp. <NewF2>) is the new  face created from <F1>
        (resp. <F2>).

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF1: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewF2: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _ShapeCustom.ShapeCustom_ConvertToRevolution_Continuity(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeCustom.ShapeCustom_ConvertToRevolution_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeCustom.ShapeCustom_ConvertToRevolution_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeCustom.ShapeCustom_ConvertToRevolution_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeCustom.delete_ShapeCustom_ConvertToRevolution
ShapeCustom_ConvertToRevolution_swigregister = _ShapeCustom.ShapeCustom_ConvertToRevolution_swigregister
ShapeCustom_ConvertToRevolution_swigregister(ShapeCustom_ConvertToRevolution)

def ShapeCustom_ConvertToRevolution_get_type_name(*args):
    """
    ShapeCustom_ConvertToRevolution_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeCustom.ShapeCustom_ConvertToRevolution_get_type_name(*args)

def ShapeCustom_ConvertToRevolution_get_type_descriptor(*args):
    """
    ShapeCustom_ConvertToRevolution_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeCustom.ShapeCustom_ConvertToRevolution_get_type_descriptor(*args)

class ShapeCustom_TrsfModification(BRepTools.BRepTools_TrsfModification):
    """
    Complements BRepTools_TrsfModification to provide reversible
    scaling regarding tolerances.
    Uses actual tolerances (attached to the shapes) not ones
    returned by BRep_Tool::Tolerance to work with tolerances
    lower than Precision::Confusion.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeCustom_TrsfModification
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeCustom_TrsfModification(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeCustom_TrsfModification self, gp_Trsf T) -> ShapeCustom_TrsfModification

        Empty constructor

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        this = _ShapeCustom.new_ShapeCustom_TrsfModification(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewSurface(self, *args):
        """
        NewSurface(ShapeCustom_TrsfModification self, TopoDS_Face F, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Calls inherited method.
        Sets <Tol> as actual tolerance of <F> multiplied with scale
        factor.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :type RevWires: bool
        :type RevFace: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_TrsfModification_NewSurface(self, *args)


    def NewCurve(self, *args):
        """
        NewCurve(ShapeCustom_TrsfModification self, TopoDS_Edge E, Handle_Geom_Curve C, TopLoc_Location L) -> Standard_Boolean

        Calls inherited method.
        Sets <Tol> as actual tolerance of <E> multiplied with scale
        factor.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_TrsfModification_NewCurve(self, *args)


    def NewPoint(self, *args):
        """
        NewPoint(ShapeCustom_TrsfModification self, TopoDS_Vertex V, gp_Pnt P) -> Standard_Boolean

        Calls inherited method.
        Sets <Tol> as actual tolerance of <V> multiplied with scale
        factor.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_TrsfModification_NewPoint(self, *args)


    def NewCurve2d(self, *args):
        """
        NewCurve2d(ShapeCustom_TrsfModification self, TopoDS_Edge E, TopoDS_Face F, TopoDS_Edge NewE, TopoDS_Face NewF, Handle_Geom2d_Curve C) -> Standard_Boolean

        Calls inherited method.
        Sets <Tol> as actual tolerance of <E> multiplied with scale
        factor.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF: OCC.wrapper.TopoDS.TopoDS_Face
        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_TrsfModification_NewCurve2d(self, *args)


    def NewParameter(self, *args):
        """
        NewParameter(ShapeCustom_TrsfModification self, TopoDS_Vertex V, TopoDS_Edge E) -> Standard_Boolean

        Calls inherited method.
        Sets <Tol> as actual tolerance of <V> multiplied with scale
        factor.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: float
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_TrsfModification_NewParameter(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeCustom.ShapeCustom_TrsfModification_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeCustom.ShapeCustom_TrsfModification_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeCustom.ShapeCustom_TrsfModification_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeCustom.delete_ShapeCustom_TrsfModification
ShapeCustom_TrsfModification_swigregister = _ShapeCustom.ShapeCustom_TrsfModification_swigregister
ShapeCustom_TrsfModification_swigregister(ShapeCustom_TrsfModification)

def ShapeCustom_TrsfModification_get_type_name(*args):
    """
    ShapeCustom_TrsfModification_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeCustom.ShapeCustom_TrsfModification_get_type_name(*args)

def ShapeCustom_TrsfModification_get_type_descriptor(*args):
    """
    ShapeCustom_TrsfModification_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeCustom.ShapeCustom_TrsfModification_get_type_descriptor(*args)

class Handle_ShapeCustom_ConvertToRevolution(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeCustom_ConvertToRevolution self)

        Nullify the handle


        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToRevolution_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeCustom_ConvertToRevolution self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToRevolution_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeCustom_ConvertToRevolution self, ShapeCustom_ConvertToRevolution thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToRevolution_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeCustom_ConvertToRevolution self, Handle_ShapeCustom_ConvertToRevolution theHandle) -> Handle_ShapeCustom_ConvertToRevolution
        assign(Handle_ShapeCustom_ConvertToRevolution self, ShapeCustom_ConvertToRevolution thePtr) -> Handle_ShapeCustom_ConvertToRevolution
        assign(Handle_ShapeCustom_ConvertToRevolution self, Handle_ShapeCustom_ConvertToRevolution theHandle) -> Handle_ShapeCustom_ConvertToRevolution

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToRevolution_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeCustom_ConvertToRevolution self) -> ShapeCustom_ConvertToRevolution

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToRevolution_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeCustom_ConvertToRevolution self) -> ShapeCustom_ConvertToRevolution

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToRevolution___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeCustom_ConvertToRevolution self) -> ShapeCustom_ConvertToRevolution

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToRevolution___ref__(self, *args)


    def __hash__(self):
        return _ShapeCustom.Handle_ShapeCustom_ConvertToRevolution___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeCustom.Handle_ShapeCustom_ConvertToRevolution___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeCustom.new_Handle_ShapeCustom_ConvertToRevolution(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeCustom.Handle_ShapeCustom_ConvertToRevolution_DownCast)
    __swig_destroy__ = _ShapeCustom.delete_Handle_ShapeCustom_ConvertToRevolution

    def NewSurface(self, *args):
        """
        NewSurface(Handle_ShapeCustom_ConvertToRevolution self, TopoDS_Face F, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True if the face <F> has  been
        modified. In this case, <S> is the new geometric
        support of the face, <L> the new location,  <Tol>
        the new tolerance.  Otherwise, returns
        Standard_False, and <S>, <L>, <Tol> are  not
        significant.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :type RevWires: bool
        :type RevFace: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToRevolution_NewSurface(self, *args)


    def NewCurve(self, *args):
        """
        NewCurve(Handle_ShapeCustom_ConvertToRevolution self, TopoDS_Edge E, Handle_Geom_Curve C, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True  if  the edge  <E> has  been
        modified.  In this case,  <C> is the new geometric
        support of the  edge, <L> the  new location, <Tol>
        the         new    tolerance.   Otherwise, returns
        Standard_False,    and  <C>,  <L>,   <Tol> are not
        significant.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToRevolution_NewCurve(self, *args)


    def NewPoint(self, *args):
        """
        NewPoint(Handle_ShapeCustom_ConvertToRevolution self, TopoDS_Vertex V, gp_Pnt P) -> Standard_Boolean

        Returns  Standard_True if the  vertex <V> has been
        modified.  In this  case, <P> is the new geometric
        support of the vertex,   <Tol> the new  tolerance.
        Otherwise, returns Standard_False, and <P>,  <Tol>
        are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToRevolution_NewPoint(self, *args)


    def NewCurve2d(self, *args):
        """
        NewCurve2d(Handle_ShapeCustom_ConvertToRevolution self, TopoDS_Edge E, TopoDS_Face F, TopoDS_Edge NewE, TopoDS_Face NewF, Handle_Geom2d_Curve C) -> Standard_Boolean

        Returns Standard_True if  the edge  <E> has a  new
        curve on surface on the face <F>.In this case, <C>
        is the new geometric support of  the edge, <L> the
        new location, <Tol> the new tolerance.

        Otherwise, returns  Standard_False, and <C>,  <L>,
        <Tol> are not significant.

        <NewE> is the new  edge created from  <E>.  <NewF>
        is the new face created from <F>. They may be usefull.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF: OCC.wrapper.TopoDS.TopoDS_Face
        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToRevolution_NewCurve2d(self, *args)


    def NewParameter(self, *args):
        """
        NewParameter(Handle_ShapeCustom_ConvertToRevolution self, TopoDS_Vertex V, TopoDS_Edge E) -> Standard_Boolean

        Returns Standard_True if the Vertex  <V> has a new
        parameter on the  edge <E>. In  this case,  <P> is
        the parameter,    <Tol>  the     new    tolerance.
        Otherwise, returns Standard_False, and <P>,  <Tol>
        are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: float
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToRevolution_NewParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_ShapeCustom_ConvertToRevolution self, TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2, TopoDS_Edge NewE, TopoDS_Face NewF1, TopoDS_Face NewF2) -> GeomAbs_Shape

        Returns the  continuity of  <NewE> between <NewF1>
        and <NewF2>.

        <NewE> is the new  edge created from <E>.  <NewF1>
        (resp. <NewF2>) is the new  face created from <F1>
        (resp. <F2>).

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF1: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewF2: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToRevolution_Continuity(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeCustom_ConvertToRevolution self) -> char const *

        :rtype: const char *

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToRevolution_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeCustom.Handle_ShapeCustom_ConvertToRevolution_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeCustom.Handle_ShapeCustom_ConvertToRevolution_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMsgRegistrator(self, *args):
        """
        SetMsgRegistrator(Handle_ShapeCustom_ConvertToRevolution self, Handle_ShapeExtend_BasicMsgRegistrator msgreg)

        Sets message registrator

        :type msgreg: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToRevolution_SetMsgRegistrator(self, *args)


    def MsgRegistrator(self, *args):
        """
        MsgRegistrator(Handle_ShapeCustom_ConvertToRevolution self) -> Handle_ShapeExtend_BasicMsgRegistrator

        Returns message registrator

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToRevolution_MsgRegistrator(self, *args)


    def SendMsg(self, *args):
        """
        SendMsg(Handle_ShapeCustom_ConvertToRevolution self, TopoDS_Shape shape, Message_Msg message, Message_Gravity const gravity=Message_Info)

        Sends a message to be attached to the shape.
        Calls corresponding message of message registrator.

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type message: OCC.wrapper.Message.Message_Msg
        :type gravity: OCC.wrapper.Message.Message_Gravity

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToRevolution_SendMsg(self, *args)


    def NewTriangulation(self, *args):
        """
        NewTriangulation(Handle_ShapeCustom_ConvertToRevolution self, TopoDS_Face F, Handle_Poly_Triangulation T) -> Standard_Boolean

        Returns true if the face has been modified according to changed triangulation.
        If the face has been modified:
        - T is a new triangulation on the face

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type T: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToRevolution_NewTriangulation(self, *args)


    def NewPolygon(self, *args):
        """
        NewPolygon(Handle_ShapeCustom_ConvertToRevolution self, TopoDS_Edge E, Handle_Poly_Polygon3D P) -> Standard_Boolean

        Returns true if the edge has been modified according to changed polygon.
        If the edge has been modified:
        - P is a new polygon

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: OCC.wrapper.Poly.Handle_Poly_Polygon3D
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToRevolution_NewPolygon(self, *args)


    def NewPolygonOnTriangulation(self, *args):
        """
        NewPolygonOnTriangulation(Handle_ShapeCustom_ConvertToRevolution self, TopoDS_Edge E, TopoDS_Face F, Handle_Poly_PolygonOnTriangulation P) -> Standard_Boolean

        Returns true if the edge has been modified according to changed polygon on triangulation.
        If the edge has been modified:
        - P is a new polygon on triangulation

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type P: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToRevolution_NewPolygonOnTriangulation(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeCustom_ConvertToRevolution self)

        Memory deallocator for transient classes


        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToRevolution_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeCustom_ConvertToRevolution self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeCustom_ConvertToRevolution self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToRevolution_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeCustom_ConvertToRevolution self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeCustom_ConvertToRevolution self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToRevolution_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeCustom_ConvertToRevolution self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToRevolution_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeCustom_ConvertToRevolution self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToRevolution_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeCustom_ConvertToRevolution self)

        Increments the reference counter of this object


        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToRevolution_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeCustom_ConvertToRevolution self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToRevolution_DecrementRefCounter(self, *args)

Handle_ShapeCustom_ConvertToRevolution_swigregister = _ShapeCustom.Handle_ShapeCustom_ConvertToRevolution_swigregister
Handle_ShapeCustom_ConvertToRevolution_swigregister(Handle_ShapeCustom_ConvertToRevolution)

def Handle_ShapeCustom_ConvertToRevolution_DownCast(thing):
    return _ShapeCustom.Handle_ShapeCustom_ConvertToRevolution_DownCast(thing)
Handle_ShapeCustom_ConvertToRevolution_DownCast = _ShapeCustom.Handle_ShapeCustom_ConvertToRevolution_DownCast

class Handle_ShapeCustom_BSplineRestriction(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeCustom_BSplineRestriction self)

        Nullify the handle


        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeCustom_BSplineRestriction self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeCustom_BSplineRestriction self, ShapeCustom_BSplineRestriction thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeCustom_BSplineRestriction self, Handle_ShapeCustom_BSplineRestriction theHandle) -> Handle_ShapeCustom_BSplineRestriction
        assign(Handle_ShapeCustom_BSplineRestriction self, ShapeCustom_BSplineRestriction thePtr) -> Handle_ShapeCustom_BSplineRestriction
        assign(Handle_ShapeCustom_BSplineRestriction self, Handle_ShapeCustom_BSplineRestriction theHandle) -> Handle_ShapeCustom_BSplineRestriction

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeCustom_BSplineRestriction self) -> ShapeCustom_BSplineRestriction

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeCustom_BSplineRestriction self) -> ShapeCustom_BSplineRestriction

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeCustom_BSplineRestriction self) -> ShapeCustom_BSplineRestriction

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction___ref__(self, *args)


    def __hash__(self):
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeCustom.new_Handle_ShapeCustom_BSplineRestriction(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeCustom.Handle_ShapeCustom_BSplineRestriction_DownCast)
    __swig_destroy__ = _ShapeCustom.delete_Handle_ShapeCustom_BSplineRestriction

    def NewSurface(self, *args):
        """
        NewSurface(Handle_ShapeCustom_BSplineRestriction self, TopoDS_Face F, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True if  the  face <F> has   been
        modified.  In this  case, <S> is the new geometric
        support of  the  face, <L> the new  location,<Tol>
        the new   tolerance.<RevWires>  has to be   set to
        Standard_True when  the modification reverses  the
        normal of  the   surface.(the wires  have   to  be
        reversed).  <RevFace>    has   to   be   set    to
        Standard_True if  the  orientation of the modified
        face changes in the shells which contain it.

        Otherwise, returns Standard_False, and <S>,   <L>,
        <Tol> , <RevWires> ,<RevFace> are not  significant.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :type RevWires: bool
        :type RevFace: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_NewSurface(self, *args)


    def NewCurve(self, *args):
        """
        NewCurve(Handle_ShapeCustom_BSplineRestriction self, TopoDS_Edge E, Handle_Geom_Curve C, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True  if  curve from the edge <E> has  been
        modified.  In this case,  <C> is the new geometric
        support of the  edge, <L> the  new location, <Tol>
        the         new    tolerance.
        Otherwise, returns Standard_True if Surface is modified or
        one of pcurves of edge is modified. In this case C is copy of
        geometric support of the edge.
        In other cases returns Standard_False, and  <C>,  <L>,  <Tol> are not
        significant.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_NewCurve(self, *args)


    def NewCurve2d(self, *args):
        """
        NewCurve2d(Handle_ShapeCustom_BSplineRestriction self, TopoDS_Edge E, TopoDS_Face F, TopoDS_Edge NewE, TopoDS_Face NewF, Handle_Geom2d_Curve C) -> Standard_Boolean

        Returns Standard_True if  the edge  <E> has been modified.
        In this case,if curve on the surface is modified, <C>
        is the new geometric support of  the edge, <L> the
        new location, <Tol> the new tolerance. If curve on the surface
        is not modified C is copy curve on surface from the edge <E>.

        Otherwise, returns  Standard_False, and <C>,  <L>,
        <Tol> are not significant.

        <NewE> is the new  edge created from  <E>.  <NewF>
        is the new face created from <F>. They may be usefull.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF: OCC.wrapper.TopoDS.TopoDS_Face
        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_NewCurve2d(self, *args)


    def ConvertSurface(self, *args):
        """
        ConvertSurface(Handle_ShapeCustom_BSplineRestriction self, Handle_Geom_Surface aSurface, Handle_Geom_Surface S, Standard_Real const UF, Standard_Real const UL, Standard_Real const VF, Standard_Real const VL, Standard_Boolean const IsOf) -> Standard_Boolean

        Returns Standard_True if  the surface has been modified.
        if flag IsOf equals Standard_True Offset surfaces are aproximated to Offset
        if Standard_False to BSpline

        :type aSurface: OCC.wrapper.Geom.Handle_Geom_Surface
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type UF: float
        :type UL: float
        :type VF: float
        :type VL: float
        :type IsOf: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_ConvertSurface(self, *args)


    def ConvertCurve(self, *args):
        """
        ConvertCurve(Handle_ShapeCustom_BSplineRestriction self, Handle_Geom_Curve aCurve, Handle_Geom_Curve C, Standard_Boolean const IsConvert, Standard_Real const First, Standard_Real const Last, Standard_Boolean const IsOf) -> Standard_Boolean

        Returns Standard_True if  the curve has been modified.
        if flag IsOf equals Standard_True Offset curves are aproximated to Offset
        if Standard_False to BSpline

        :type aCurve: OCC.wrapper.Geom.Handle_Geom_Curve
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type IsConvert: bool
        :type First: float
        :type Last: float
        :type TolCur: float
        :type IsOf: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_ConvertCurve(self, *args)


    def ConvertCurve2d(self, *args):
        """
        ConvertCurve2d(Handle_ShapeCustom_BSplineRestriction self, Handle_Geom2d_Curve aCurve, Handle_Geom2d_Curve C, Standard_Boolean const IsConvert, Standard_Real const First, Standard_Real const Last, Standard_Boolean const IsOf) -> Standard_Boolean

        Returns Standard_True if the pcurve has been modified.
        if flag IsOf equals Standard_True Offset pcurves are aproximated to Offset
        if Standard_False to BSpline

        :type aCurve: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type IsConvert: bool
        :type First: float
        :type Last: float
        :type TolCur: float
        :type IsOf: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_ConvertCurve2d(self, *args)


    def SetTol3d(self, *args):
        """
        SetTol3d(Handle_ShapeCustom_BSplineRestriction self, Standard_Real const Tol3d)

        Sets tolerance of aproximation for curve3d and surface

        :type Tol3d: float

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_SetTol3d(self, *args)


    def SetTol2d(self, *args):
        """
        SetTol2d(Handle_ShapeCustom_BSplineRestriction self, Standard_Real const Tol2d)

        Sets tolerance of aproximation for curve2d

        :type Tol2d: float

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_SetTol2d(self, *args)


    def ModifyApproxSurfaceFlag(self, *args):
        """
        ModifyApproxSurfaceFlag(Handle_ShapeCustom_BSplineRestriction self) -> Standard_Boolean &

        Returns (modifiable) the flag which defines whether the
        surface is aproximated.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_ModifyApproxSurfaceFlag(self, *args)


    def ModifyApproxCurve3dFlag(self, *args):
        """
        ModifyApproxCurve3dFlag(Handle_ShapeCustom_BSplineRestriction self) -> Standard_Boolean &

        Returns (modifiable) the flag which defines whether the
        curve3d is aproximated.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_ModifyApproxCurve3dFlag(self, *args)


    def ModifyApproxCurve2dFlag(self, *args):
        """
        ModifyApproxCurve2dFlag(Handle_ShapeCustom_BSplineRestriction self) -> Standard_Boolean &

        Returns (modifiable) the flag which defines whether the curve2d is aproximated.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_ModifyApproxCurve2dFlag(self, *args)


    def SetContinuity3d(self, *args):
        """
        SetContinuity3d(Handle_ShapeCustom_BSplineRestriction self, GeomAbs_Shape const Continuity3d)

        Sets continuity3d for aproximation curve3d and surface.

        :type Continuity3d: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_SetContinuity3d(self, *args)


    def SetContinuity2d(self, *args):
        """
        SetContinuity2d(Handle_ShapeCustom_BSplineRestriction self, GeomAbs_Shape const Continuity2d)

        Sets continuity3d for aproximation curve2d.

        :type Continuity2d: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_SetContinuity2d(self, *args)


    def SetMaxDegree(self, *args):
        """
        SetMaxDegree(Handle_ShapeCustom_BSplineRestriction self, Standard_Integer const MaxDegree)

        Sets max degree for aproximation.

        :type MaxDegree: int

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_SetMaxDegree(self, *args)


    def SetMaxNbSegments(self, *args):
        """
        SetMaxNbSegments(Handle_ShapeCustom_BSplineRestriction self, Standard_Integer const MaxNbSegments)

        Sets max number of segments for aproximation.

        :type MaxNbSegments: int

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_SetMaxNbSegments(self, *args)


    def SetPriority(self, *args):
        """
        SetPriority(Handle_ShapeCustom_BSplineRestriction self, Standard_Boolean const Degree)

        Sets priority  for aproximation curves and surface.
        If Degree is True approximation is made with degree less
        then specified MaxDegree at the expense of number of spanes.
        If Degree is False approximation is made with number of
        spans less then specified MaxNbSegment at the expense of
        specified MaxDegree.

        :type Degree: bool

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_SetPriority(self, *args)


    def SetConvRational(self, *args):
        """
        SetConvRational(Handle_ShapeCustom_BSplineRestriction self, Standard_Boolean const Rational)

        Sets flag for define if rational BSpline or Bezier is
        converted to polynomial. If Rational is True approximation
        for rational BSpline and Bezier is made to polynomial even
        if degree is less then MaxDegree and number of spans is less
        then specified MaxNbSegment.

        :type Rational: bool

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_SetConvRational(self, *args)


    def GetRestrictionParameters(self, *args):
        """
        GetRestrictionParameters(Handle_ShapeCustom_BSplineRestriction self) -> Handle_ShapeCustom_RestrictionParameters

        Returns the container of modes which defines
        what geometry should be converted to BSplines.

        :rtype: OCC.wrapper.ShapeCustom.Handle_ShapeCustom_RestrictionParameters

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_GetRestrictionParameters(self, *args)


    def SetRestrictionParameters(self, *args):
        """
        SetRestrictionParameters(Handle_ShapeCustom_BSplineRestriction self, Handle_ShapeCustom_RestrictionParameters aModes)

        Sets the container of modes which defines
        what geometry should be converted to BSplines.

        :type aModes: OCC.wrapper.ShapeCustom.Handle_ShapeCustom_RestrictionParameters

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_SetRestrictionParameters(self, *args)


    def Curve3dError(self, *args):
        """
        Curve3dError(Handle_ShapeCustom_BSplineRestriction self) -> Standard_Real

        Returns error for aproximation curve3d.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_Curve3dError(self, *args)


    def Curve2dError(self, *args):
        """
        Curve2dError(Handle_ShapeCustom_BSplineRestriction self) -> Standard_Real

        Returns error for aproximation curve2d.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_Curve2dError(self, *args)


    def SurfaceError(self, *args):
        """
        SurfaceError(Handle_ShapeCustom_BSplineRestriction self) -> Standard_Real

        Returns error for aproximation surface.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_SurfaceError(self, *args)


    def NewPoint(self, *args):
        """
        NewPoint(Handle_ShapeCustom_BSplineRestriction self, TopoDS_Vertex V, gp_Pnt P) -> Standard_Boolean

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_NewPoint(self, *args)


    def NewParameter(self, *args):
        """
        NewParameter(Handle_ShapeCustom_BSplineRestriction self, TopoDS_Vertex V, TopoDS_Edge E) -> Standard_Boolean

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: float
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_NewParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_ShapeCustom_BSplineRestriction self, TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2, TopoDS_Edge NewE, TopoDS_Face NewF1, TopoDS_Face NewF2) -> GeomAbs_Shape

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF1: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewF2: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_Continuity(self, *args)


    def MaxErrors(self, *args):
        """
        MaxErrors(Handle_ShapeCustom_BSplineRestriction self) -> Standard_Real

        Returns error for aproximation surface, curve3d and curve2d.

        :type aCurve3dErr: float
        :type aCurve2dErr: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_MaxErrors(self, *args)


    def NbOfSpan(self, *args):
        """
        NbOfSpan(Handle_ShapeCustom_BSplineRestriction self) -> Standard_Integer

        Returns number for aproximation surface, curve3d and curve2d.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_NbOfSpan(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeCustom_BSplineRestriction self) -> char const *

        :rtype: const char *

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMsgRegistrator(self, *args):
        """
        SetMsgRegistrator(Handle_ShapeCustom_BSplineRestriction self, Handle_ShapeExtend_BasicMsgRegistrator msgreg)

        Sets message registrator

        :type msgreg: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_SetMsgRegistrator(self, *args)


    def MsgRegistrator(self, *args):
        """
        MsgRegistrator(Handle_ShapeCustom_BSplineRestriction self) -> Handle_ShapeExtend_BasicMsgRegistrator

        Returns message registrator

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_MsgRegistrator(self, *args)


    def SendMsg(self, *args):
        """
        SendMsg(Handle_ShapeCustom_BSplineRestriction self, TopoDS_Shape shape, Message_Msg message, Message_Gravity const gravity=Message_Info)

        Sends a message to be attached to the shape.
        Calls corresponding message of message registrator.

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type message: OCC.wrapper.Message.Message_Msg
        :type gravity: OCC.wrapper.Message.Message_Gravity

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_SendMsg(self, *args)


    def NewTriangulation(self, *args):
        """
        NewTriangulation(Handle_ShapeCustom_BSplineRestriction self, TopoDS_Face F, Handle_Poly_Triangulation T) -> Standard_Boolean

        Returns true if the face has been modified according to changed triangulation.
        If the face has been modified:
        - T is a new triangulation on the face

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type T: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_NewTriangulation(self, *args)


    def NewPolygon(self, *args):
        """
        NewPolygon(Handle_ShapeCustom_BSplineRestriction self, TopoDS_Edge E, Handle_Poly_Polygon3D P) -> Standard_Boolean

        Returns true if the edge has been modified according to changed polygon.
        If the edge has been modified:
        - P is a new polygon

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: OCC.wrapper.Poly.Handle_Poly_Polygon3D
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_NewPolygon(self, *args)


    def NewPolygonOnTriangulation(self, *args):
        """
        NewPolygonOnTriangulation(Handle_ShapeCustom_BSplineRestriction self, TopoDS_Edge E, TopoDS_Face F, Handle_Poly_PolygonOnTriangulation P) -> Standard_Boolean

        Returns true if the edge has been modified according to changed polygon on triangulation.
        If the edge has been modified:
        - P is a new polygon on triangulation

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type P: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_NewPolygonOnTriangulation(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeCustom_BSplineRestriction self)

        Memory deallocator for transient classes


        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeCustom_BSplineRestriction self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeCustom_BSplineRestriction self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeCustom_BSplineRestriction self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeCustom_BSplineRestriction self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeCustom_BSplineRestriction self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeCustom_BSplineRestriction self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeCustom_BSplineRestriction self)

        Increments the reference counter of this object


        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeCustom_BSplineRestriction self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_DecrementRefCounter(self, *args)

Handle_ShapeCustom_BSplineRestriction_swigregister = _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_swigregister
Handle_ShapeCustom_BSplineRestriction_swigregister(Handle_ShapeCustom_BSplineRestriction)

def Handle_ShapeCustom_BSplineRestriction_DownCast(thing):
    return _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_DownCast(thing)
Handle_ShapeCustom_BSplineRestriction_DownCast = _ShapeCustom.Handle_ShapeCustom_BSplineRestriction_DownCast

class ShapeCustom_ConvertToBSpline(ShapeCustom_Modification):
    """
    implement a modification for BRepTools
    Modifier algortihm. Converts Surface of
    Linear Exctrusion, Revolution and Offset
    surfaces into BSpline Surface according to
    flags.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeCustom_ConvertToBSpline
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeCustom_ConvertToBSpline(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeCustom_ConvertToBSpline self) -> ShapeCustom_ConvertToBSpline

        implement a modification for BRepTools
        Modifier algortihm. Converts Surface of
        Linear Exctrusion, Revolution and Offset
        surfaces into BSpline Surface according to
        flags.
        """
        this = _ShapeCustom.new_ShapeCustom_ConvertToBSpline(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def SetExtrusionMode(self, *args):
        """
        SetExtrusionMode(ShapeCustom_ConvertToBSpline self, Standard_Boolean const extrMode)

        Sets mode for convertion of Surfaces of Linear
        extrusion.

        :type extrMode: bool

        """
        return _ShapeCustom.ShapeCustom_ConvertToBSpline_SetExtrusionMode(self, *args)


    def SetRevolutionMode(self, *args):
        """
        SetRevolutionMode(ShapeCustom_ConvertToBSpline self, Standard_Boolean const revolMode)

        Sets mode for convertion of Surfaces of Revolution.

        :type revolMode: bool

        """
        return _ShapeCustom.ShapeCustom_ConvertToBSpline_SetRevolutionMode(self, *args)


    def SetOffsetMode(self, *args):
        """
        SetOffsetMode(ShapeCustom_ConvertToBSpline self, Standard_Boolean const offsetMode)

        Sets mode for convertion of Offset surfaces.

        :type offsetMode: bool

        """
        return _ShapeCustom.ShapeCustom_ConvertToBSpline_SetOffsetMode(self, *args)


    def SetPlaneMode(self, *args):
        """
        SetPlaneMode(ShapeCustom_ConvertToBSpline self, Standard_Boolean const planeMode)

        Sets mode for convertion of Plane surfaces.

        :type planeMode: bool

        """
        return _ShapeCustom.ShapeCustom_ConvertToBSpline_SetPlaneMode(self, *args)


    def NewSurface(self, *args):
        """
        NewSurface(ShapeCustom_ConvertToBSpline self, TopoDS_Face F, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True if the face <F> has  been
        modified. In this case, <S> is the new geometric
        support of the face, <L> the new location,  <Tol>
        the new tolerance.  Otherwise, returns
        Standard_False, and <S>, <L>, <Tol> are  not
        significant.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :type RevWires: bool
        :type RevFace: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_ConvertToBSpline_NewSurface(self, *args)


    def NewCurve(self, *args):
        """
        NewCurve(ShapeCustom_ConvertToBSpline self, TopoDS_Edge E, Handle_Geom_Curve C, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True  if  the edge  <E> has  been
        modified.  In this case,  <C> is the new geometric
        support of the  edge, <L> the  new location, <Tol>
        the         new    tolerance.   Otherwise, returns
        Standard_False,    and  <C>,  <L>,   <Tol> are not
        significant.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_ConvertToBSpline_NewCurve(self, *args)


    def NewPoint(self, *args):
        """
        NewPoint(ShapeCustom_ConvertToBSpline self, TopoDS_Vertex V, gp_Pnt P) -> Standard_Boolean

        Returns  Standard_True if the  vertex <V> has been
        modified.  In this  case, <P> is the new geometric
        support of the vertex,   <Tol> the new  tolerance.
        Otherwise, returns Standard_False, and <P>,  <Tol>
        are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_ConvertToBSpline_NewPoint(self, *args)


    def NewCurve2d(self, *args):
        """
        NewCurve2d(ShapeCustom_ConvertToBSpline self, TopoDS_Edge E, TopoDS_Face F, TopoDS_Edge NewE, TopoDS_Face NewF, Handle_Geom2d_Curve C) -> Standard_Boolean

        Returns Standard_True if  the edge  <E> has a  new
        curve on surface on the face <F>.In this case, <C>
        is the new geometric support of  the edge, <L> the
        new location, <Tol> the new tolerance.

        Otherwise, returns  Standard_False, and <C>,  <L>,
        <Tol> are not significant.

        <NewE> is the new  edge created from  <E>.  <NewF>
        is the new face created from <F>. They may be usefull.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF: OCC.wrapper.TopoDS.TopoDS_Face
        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_ConvertToBSpline_NewCurve2d(self, *args)


    def NewParameter(self, *args):
        """
        NewParameter(ShapeCustom_ConvertToBSpline self, TopoDS_Vertex V, TopoDS_Edge E) -> Standard_Boolean

        Returns Standard_True if the Vertex  <V> has a new
        parameter on the  edge <E>. In  this case,  <P> is
        the parameter,    <Tol>  the     new    tolerance.
        Otherwise, returns Standard_False, and <P>,  <Tol>
        are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: float
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_ConvertToBSpline_NewParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(ShapeCustom_ConvertToBSpline self, TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2, TopoDS_Edge NewE, TopoDS_Face NewF1, TopoDS_Face NewF2) -> GeomAbs_Shape

        Returns the  continuity of  <NewE> between <NewF1>
        and <NewF2>.

        <NewE> is the new  edge created from <E>.  <NewF1>
        (resp. <NewF2>) is the new  face created from <F1>
        (resp. <F2>).

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF1: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewF2: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _ShapeCustom.ShapeCustom_ConvertToBSpline_Continuity(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeCustom.ShapeCustom_ConvertToBSpline_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeCustom.ShapeCustom_ConvertToBSpline_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeCustom.ShapeCustom_ConvertToBSpline_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeCustom.delete_ShapeCustom_ConvertToBSpline
ShapeCustom_ConvertToBSpline_swigregister = _ShapeCustom.ShapeCustom_ConvertToBSpline_swigregister
ShapeCustom_ConvertToBSpline_swigregister(ShapeCustom_ConvertToBSpline)

def ShapeCustom_ConvertToBSpline_get_type_name(*args):
    """
    ShapeCustom_ConvertToBSpline_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeCustom.ShapeCustom_ConvertToBSpline_get_type_name(*args)

def ShapeCustom_ConvertToBSpline_get_type_descriptor(*args):
    """
    ShapeCustom_ConvertToBSpline_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeCustom.ShapeCustom_ConvertToBSpline_get_type_descriptor(*args)

class Handle_ShapeCustom_Modification(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeCustom_Modification self)

        Nullify the handle


        """
        return _ShapeCustom.Handle_ShapeCustom_Modification_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeCustom_Modification self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeCustom.Handle_ShapeCustom_Modification_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeCustom_Modification self, ShapeCustom_Modification thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeCustom.Handle_ShapeCustom_Modification_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeCustom_Modification self, Handle_ShapeCustom_Modification theHandle) -> Handle_ShapeCustom_Modification
        assign(Handle_ShapeCustom_Modification self, ShapeCustom_Modification thePtr) -> Handle_ShapeCustom_Modification
        assign(Handle_ShapeCustom_Modification self, Handle_ShapeCustom_Modification theHandle) -> Handle_ShapeCustom_Modification

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeCustom.Handle_ShapeCustom_Modification_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeCustom_Modification self) -> ShapeCustom_Modification

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeCustom.Handle_ShapeCustom_Modification_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeCustom_Modification self) -> ShapeCustom_Modification

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeCustom.Handle_ShapeCustom_Modification___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeCustom_Modification self) -> ShapeCustom_Modification

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeCustom.Handle_ShapeCustom_Modification___ref__(self, *args)


    def __hash__(self):
        return _ShapeCustom.Handle_ShapeCustom_Modification___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeCustom.Handle_ShapeCustom_Modification___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeCustom.new_Handle_ShapeCustom_Modification(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeCustom.Handle_ShapeCustom_Modification_DownCast)
    __swig_destroy__ = _ShapeCustom.delete_Handle_ShapeCustom_Modification

    def SetMsgRegistrator(self, *args):
        """
        SetMsgRegistrator(Handle_ShapeCustom_Modification self, Handle_ShapeExtend_BasicMsgRegistrator msgreg)

        Sets message registrator

        :type msgreg: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeCustom.Handle_ShapeCustom_Modification_SetMsgRegistrator(self, *args)


    def MsgRegistrator(self, *args):
        """
        MsgRegistrator(Handle_ShapeCustom_Modification self) -> Handle_ShapeExtend_BasicMsgRegistrator

        Returns message registrator

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeCustom.Handle_ShapeCustom_Modification_MsgRegistrator(self, *args)


    def SendMsg(self, *args):
        """
        SendMsg(Handle_ShapeCustom_Modification self, TopoDS_Shape shape, Message_Msg message, Message_Gravity const gravity=Message_Info)

        Sends a message to be attached to the shape.
        Calls corresponding message of message registrator.

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type message: OCC.wrapper.Message.Message_Msg
        :type gravity: OCC.wrapper.Message.Message_Gravity

        """
        return _ShapeCustom.Handle_ShapeCustom_Modification_SendMsg(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeCustom_Modification self) -> char const *

        :rtype: const char *

        """
        return _ShapeCustom.Handle_ShapeCustom_Modification_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeCustom.Handle_ShapeCustom_Modification_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeCustom.Handle_ShapeCustom_Modification_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NewSurface(self, *args):
        """
        NewSurface(Handle_ShapeCustom_Modification self, TopoDS_Face F, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Returns true if the face, F, has been modified.
        If the face has been modified:
        - S is the new geometry of the face,
        - L is its new location, and
        - Tol is the new tolerance.
        The flag, RevWires, is set to true when the
        modification reverses the normal of the surface, (i.e.
        the wires have to be reversed).
        The flag, RevFace, is set to true if the orientation of
        the modified face changes in the shells which contain it.
        If the face has not been modified this function returns
        false, and the values of S, L, Tol, RevWires and
        RevFace are not significant.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :type RevWires: bool
        :type RevFace: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_Modification_NewSurface(self, *args)


    def NewTriangulation(self, *args):
        """
        NewTriangulation(Handle_ShapeCustom_Modification self, TopoDS_Face F, Handle_Poly_Triangulation T) -> Standard_Boolean

        Returns true if the face has been modified according to changed triangulation.
        If the face has been modified:
        - T is a new triangulation on the face

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type T: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_Modification_NewTriangulation(self, *args)


    def NewCurve(self, *args):
        """
        NewCurve(Handle_ShapeCustom_Modification self, TopoDS_Edge E, Handle_Geom_Curve C, TopLoc_Location L) -> Standard_Boolean

        Returns true if the edge, E, has been modified.
        If the edge has been modified:
        - C is the new geometry associated with the edge,
        - L is its new location, and
        - Tol is the new tolerance.
        If the edge has not been modified, this function
        returns false, and the values of C, L and Tol are not significant.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_Modification_NewCurve(self, *args)


    def NewPolygon(self, *args):
        """
        NewPolygon(Handle_ShapeCustom_Modification self, TopoDS_Edge E, Handle_Poly_Polygon3D P) -> Standard_Boolean

        Returns true if the edge has been modified according to changed polygon.
        If the edge has been modified:
        - P is a new polygon

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: OCC.wrapper.Poly.Handle_Poly_Polygon3D
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_Modification_NewPolygon(self, *args)


    def NewPolygonOnTriangulation(self, *args):
        """
        NewPolygonOnTriangulation(Handle_ShapeCustom_Modification self, TopoDS_Edge E, TopoDS_Face F, Handle_Poly_PolygonOnTriangulation P) -> Standard_Boolean

        Returns true if the edge has been modified according to changed polygon on triangulation.
        If the edge has been modified:
        - P is a new polygon on triangulation

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type P: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_Modification_NewPolygonOnTriangulation(self, *args)


    def NewPoint(self, *args):
        """
        NewPoint(Handle_ShapeCustom_Modification self, TopoDS_Vertex V, gp_Pnt P) -> Standard_Boolean

        Returns true if the vertex V has been modified.
        If V has been modified:
        - P is the new geometry of the vertex, and
        - Tol is the new tolerance.
        If the vertex has not been modified this function
        returns false, and the values of P and Tol are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_Modification_NewPoint(self, *args)


    def NewCurve2d(self, *args):
        """
        NewCurve2d(Handle_ShapeCustom_Modification self, TopoDS_Edge E, TopoDS_Face F, TopoDS_Edge NewE, TopoDS_Face NewF, Handle_Geom2d_Curve C) -> Standard_Boolean

        Returns true if the edge, E, has a new curve on
        surface on the face, F.
        If a new curve exists:
        - C is the new geometry of the edge,
        - L is the new location, and
        - Tol is the new tolerance.
        NewE is the new edge created from E, and NewF is
        the new face created from F.
        If there is no new curve on the face, this function
        returns false, and the values of C, L and Tol are not significant.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF: OCC.wrapper.TopoDS.TopoDS_Face
        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_Modification_NewCurve2d(self, *args)


    def NewParameter(self, *args):
        """
        NewParameter(Handle_ShapeCustom_Modification self, TopoDS_Vertex V, TopoDS_Edge E) -> Standard_Boolean

        Returns true if the vertex V has a new parameter on the edge E.
        If a new parameter exists:
        - P is the parameter, and
        - Tol is the new tolerance.
        If there is no new parameter this function returns
        false, and the values of P and Tol are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: float
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_Modification_NewParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_ShapeCustom_Modification self, TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2, TopoDS_Edge NewE, TopoDS_Face NewF1, TopoDS_Face NewF2) -> GeomAbs_Shape

        Returns the  continuity of  <NewE> between <NewF1>
        and <NewF2>.
        <NewE> is the new  edge created from <E>.  <NewF1>
        (resp. <NewF2>) is the new  face created from <F1>
        (resp. <F2>).

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF1: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewF2: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _ShapeCustom.Handle_ShapeCustom_Modification_Continuity(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeCustom_Modification self)

        Memory deallocator for transient classes


        """
        return _ShapeCustom.Handle_ShapeCustom_Modification_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeCustom_Modification self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeCustom_Modification self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_Modification_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeCustom_Modification self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeCustom_Modification self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_Modification_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeCustom_Modification self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeCustom.Handle_ShapeCustom_Modification_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeCustom_Modification self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeCustom.Handle_ShapeCustom_Modification_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeCustom_Modification self)

        Increments the reference counter of this object


        """
        return _ShapeCustom.Handle_ShapeCustom_Modification_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeCustom_Modification self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeCustom.Handle_ShapeCustom_Modification_DecrementRefCounter(self, *args)

Handle_ShapeCustom_Modification_swigregister = _ShapeCustom.Handle_ShapeCustom_Modification_swigregister
Handle_ShapeCustom_Modification_swigregister(Handle_ShapeCustom_Modification)

def Handle_ShapeCustom_Modification_DownCast(thing):
    return _ShapeCustom.Handle_ShapeCustom_Modification_DownCast(thing)
Handle_ShapeCustom_Modification_DownCast = _ShapeCustom.Handle_ShapeCustom_Modification_DownCast

class ShapeCustom_Curve(object):
    """Converts BSpline curve to periodic"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ShapeCustom_Curve self) -> ShapeCustom_Curve
        __init__(ShapeCustom_Curve self, Handle_Geom_Curve C) -> ShapeCustom_Curve

        :type C: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        this = _ShapeCustom.new_ShapeCustom_Curve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(ShapeCustom_Curve self, Handle_Geom_Curve C)

        :type C: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _ShapeCustom.ShapeCustom_Curve_Init(self, *args)


    def ConvertToPeriodic(self, *args):
        """
        ConvertToPeriodic(ShapeCustom_Curve self, Standard_Boolean const substitute, Standard_Real const preci=-1) -> Handle_Geom_Curve

        Tries to convert the Curve to the Periodic form
        Returns the resulting curve
        Works only if the Curve is BSpline and is closed with
        Precision::Confusion()
        Else, or in case of failure, returns a Null Handle

        :type substitute: bool
        :type preci: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _ShapeCustom.ShapeCustom_Curve_ConvertToPeriodic(self, *args)

    __swig_destroy__ = _ShapeCustom.delete_ShapeCustom_Curve
ShapeCustom_Curve_swigregister = _ShapeCustom.ShapeCustom_Curve_swigregister
ShapeCustom_Curve_swigregister(ShapeCustom_Curve)

class Handle_ShapeCustom_TrsfModification(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeCustom_TrsfModification self)

        Nullify the handle


        """
        return _ShapeCustom.Handle_ShapeCustom_TrsfModification_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeCustom_TrsfModification self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeCustom.Handle_ShapeCustom_TrsfModification_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeCustom_TrsfModification self, ShapeCustom_TrsfModification thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeCustom.Handle_ShapeCustom_TrsfModification_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeCustom_TrsfModification self, Handle_ShapeCustom_TrsfModification theHandle) -> Handle_ShapeCustom_TrsfModification
        assign(Handle_ShapeCustom_TrsfModification self, ShapeCustom_TrsfModification thePtr) -> Handle_ShapeCustom_TrsfModification
        assign(Handle_ShapeCustom_TrsfModification self, Handle_ShapeCustom_TrsfModification theHandle) -> Handle_ShapeCustom_TrsfModification

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeCustom.Handle_ShapeCustom_TrsfModification_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeCustom_TrsfModification self) -> ShapeCustom_TrsfModification

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeCustom.Handle_ShapeCustom_TrsfModification_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeCustom_TrsfModification self) -> ShapeCustom_TrsfModification

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeCustom.Handle_ShapeCustom_TrsfModification___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeCustom_TrsfModification self) -> ShapeCustom_TrsfModification

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeCustom.Handle_ShapeCustom_TrsfModification___ref__(self, *args)


    def __hash__(self):
        return _ShapeCustom.Handle_ShapeCustom_TrsfModification___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeCustom.Handle_ShapeCustom_TrsfModification___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeCustom.new_Handle_ShapeCustom_TrsfModification(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeCustom.Handle_ShapeCustom_TrsfModification_DownCast)
    __swig_destroy__ = _ShapeCustom.delete_Handle_ShapeCustom_TrsfModification

    def NewSurface(self, *args):
        """
        NewSurface(Handle_ShapeCustom_TrsfModification self, TopoDS_Face F, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Calls inherited method.
        Sets <Tol> as actual tolerance of <F> multiplied with scale
        factor.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :type RevWires: bool
        :type RevFace: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_TrsfModification_NewSurface(self, *args)


    def NewCurve(self, *args):
        """
        NewCurve(Handle_ShapeCustom_TrsfModification self, TopoDS_Edge E, Handle_Geom_Curve C, TopLoc_Location L) -> Standard_Boolean

        Calls inherited method.
        Sets <Tol> as actual tolerance of <E> multiplied with scale
        factor.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_TrsfModification_NewCurve(self, *args)


    def NewPoint(self, *args):
        """
        NewPoint(Handle_ShapeCustom_TrsfModification self, TopoDS_Vertex V, gp_Pnt P) -> Standard_Boolean

        Calls inherited method.
        Sets <Tol> as actual tolerance of <V> multiplied with scale
        factor.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_TrsfModification_NewPoint(self, *args)


    def NewCurve2d(self, *args):
        """
        NewCurve2d(Handle_ShapeCustom_TrsfModification self, TopoDS_Edge E, TopoDS_Face F, TopoDS_Edge NewE, TopoDS_Face NewF, Handle_Geom2d_Curve C) -> Standard_Boolean

        Calls inherited method.
        Sets <Tol> as actual tolerance of <E> multiplied with scale
        factor.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF: OCC.wrapper.TopoDS.TopoDS_Face
        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_TrsfModification_NewCurve2d(self, *args)


    def NewParameter(self, *args):
        """
        NewParameter(Handle_ShapeCustom_TrsfModification self, TopoDS_Vertex V, TopoDS_Edge E) -> Standard_Boolean

        Calls inherited method.
        Sets <Tol> as actual tolerance of <V> multiplied with scale
        factor.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: float
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_TrsfModification_NewParameter(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeCustom_TrsfModification self) -> char const *

        :rtype: const char *

        """
        return _ShapeCustom.Handle_ShapeCustom_TrsfModification_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeCustom.Handle_ShapeCustom_TrsfModification_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeCustom.Handle_ShapeCustom_TrsfModification_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Trsf(self, *args):
        """
        Trsf(Handle_ShapeCustom_TrsfModification self) -> gp_Trsf

        Provides access to the gp_Trsf associated with this
        modification. The transformation can be changed.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        return _ShapeCustom.Handle_ShapeCustom_TrsfModification_Trsf(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_ShapeCustom_TrsfModification self, TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2, TopoDS_Edge NewE, TopoDS_Face NewF1, TopoDS_Face NewF2) -> GeomAbs_Shape

        Returns the  continuity of  <NewE> between <NewF1>
        and <NewF2>.

        <NewE> is the new  edge created from <E>.  <NewF1>
        (resp. <NewF2>) is the new  face created from <F1>
        (resp. <F2>).

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF1: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewF2: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _ShapeCustom.Handle_ShapeCustom_TrsfModification_Continuity(self, *args)


    def NewTriangulation(self, *args):
        """
        NewTriangulation(Handle_ShapeCustom_TrsfModification self, TopoDS_Face F, Handle_Poly_Triangulation T) -> Standard_Boolean

        Returns true if the face has been modified according to changed triangulation.
        If the face has been modified:
        - T is a new triangulation on the face

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type T: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_TrsfModification_NewTriangulation(self, *args)


    def NewPolygon(self, *args):
        """
        NewPolygon(Handle_ShapeCustom_TrsfModification self, TopoDS_Edge E, Handle_Poly_Polygon3D P) -> Standard_Boolean

        Returns true if the edge has been modified according to changed polygon.
        If the edge has been modified:
        - P is a new polygon

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: OCC.wrapper.Poly.Handle_Poly_Polygon3D
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_TrsfModification_NewPolygon(self, *args)


    def NewPolygonOnTriangulation(self, *args):
        """
        NewPolygonOnTriangulation(Handle_ShapeCustom_TrsfModification self, TopoDS_Edge E, TopoDS_Face F, Handle_Poly_PolygonOnTriangulation P) -> Standard_Boolean

        Returns true if the edge has been modified according to changed polygon on triangulation.
        If the edge has been modified:
        - P is a new polygon on triangulation

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type P: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_TrsfModification_NewPolygonOnTriangulation(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeCustom_TrsfModification self)

        Memory deallocator for transient classes


        """
        return _ShapeCustom.Handle_ShapeCustom_TrsfModification_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeCustom_TrsfModification self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeCustom_TrsfModification self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_TrsfModification_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeCustom_TrsfModification self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeCustom_TrsfModification self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_TrsfModification_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeCustom_TrsfModification self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeCustom.Handle_ShapeCustom_TrsfModification_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeCustom_TrsfModification self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeCustom.Handle_ShapeCustom_TrsfModification_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeCustom_TrsfModification self)

        Increments the reference counter of this object


        """
        return _ShapeCustom.Handle_ShapeCustom_TrsfModification_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeCustom_TrsfModification self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeCustom.Handle_ShapeCustom_TrsfModification_DecrementRefCounter(self, *args)

Handle_ShapeCustom_TrsfModification_swigregister = _ShapeCustom.Handle_ShapeCustom_TrsfModification_swigregister
Handle_ShapeCustom_TrsfModification_swigregister(Handle_ShapeCustom_TrsfModification)

def Handle_ShapeCustom_TrsfModification_DownCast(thing):
    return _ShapeCustom.Handle_ShapeCustom_TrsfModification_DownCast(thing)
Handle_ShapeCustom_TrsfModification_DownCast = _ShapeCustom.Handle_ShapeCustom_TrsfModification_DownCast

class ShapeCustom_SweptToElementary(ShapeCustom_Modification):
    """
    implements a modification for the BRepTools
    Modifier algortihm. Converts all elementary
    surfaces into surfaces of revolution.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeCustom_SweptToElementary
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeCustom_SweptToElementary(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeCustom_SweptToElementary self) -> ShapeCustom_SweptToElementary

        implements a modification for the BRepTools
        Modifier algortihm. Converts all elementary
        surfaces into surfaces of revolution.
        """
        this = _ShapeCustom.new_ShapeCustom_SweptToElementary(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewSurface(self, *args):
        """
        NewSurface(ShapeCustom_SweptToElementary self, TopoDS_Face F, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True if the face <F> has  been
        modified. In this case, <S> is the new geometric
        support of the face, <L> the new location,  <Tol>
        the new tolerance.  Otherwise, returns
        Standard_False, and <S>, <L>, <Tol> are  not
        significant.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :type RevWires: bool
        :type RevFace: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_SweptToElementary_NewSurface(self, *args)


    def NewCurve(self, *args):
        """
        NewCurve(ShapeCustom_SweptToElementary self, TopoDS_Edge E, Handle_Geom_Curve C, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True  if  the edge  <E> has  been
        modified.  In this case,  <C> is the new geometric
        support of the  edge, <L> the  new location, <Tol>
        the         new    tolerance.   Otherwise, returns
        Standard_False,    and  <C>,  <L>,   <Tol> are not
        significant.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_SweptToElementary_NewCurve(self, *args)


    def NewPoint(self, *args):
        """
        NewPoint(ShapeCustom_SweptToElementary self, TopoDS_Vertex V, gp_Pnt P) -> Standard_Boolean

        Returns  Standard_True if the  vertex <V> has been
        modified.  In this  case, <P> is the new geometric
        support of the vertex,   <Tol> the new  tolerance.
        Otherwise, returns Standard_False, and <P>,  <Tol>
        are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_SweptToElementary_NewPoint(self, *args)


    def NewCurve2d(self, *args):
        """
        NewCurve2d(ShapeCustom_SweptToElementary self, TopoDS_Edge E, TopoDS_Face F, TopoDS_Edge NewE, TopoDS_Face NewF, Handle_Geom2d_Curve C) -> Standard_Boolean

        Returns Standard_True if  the edge  <E> has a  new
        curve on surface on the face <F>.In this case, <C>
        is the new geometric support of  the edge, <L> the
        new location, <Tol> the new tolerance.

        Otherwise, returns  Standard_False, and <C>,  <L>,
        <Tol> are not significant.

        <NewE> is the new  edge created from  <E>.  <NewF>
        is the new face created from <F>. They may be usefull.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF: OCC.wrapper.TopoDS.TopoDS_Face
        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_SweptToElementary_NewCurve2d(self, *args)


    def NewParameter(self, *args):
        """
        NewParameter(ShapeCustom_SweptToElementary self, TopoDS_Vertex V, TopoDS_Edge E) -> Standard_Boolean

        Returns Standard_True if the Vertex  <V> has a new
        parameter on the  edge <E>. In  this case,  <P> is
        the parameter,    <Tol>  the     new    tolerance.
        Otherwise, returns Standard_False, and <P>,  <Tol>
        are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: float
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_SweptToElementary_NewParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(ShapeCustom_SweptToElementary self, TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2, TopoDS_Edge NewE, TopoDS_Face NewF1, TopoDS_Face NewF2) -> GeomAbs_Shape

        Returns the  continuity of  <NewE> between <NewF1>
        and <NewF2>.

        <NewE> is the new  edge created from <E>.  <NewF1>
        (resp. <NewF2>) is the new  face created from <F1>
        (resp. <F2>).

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF1: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewF2: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _ShapeCustom.ShapeCustom_SweptToElementary_Continuity(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeCustom.ShapeCustom_SweptToElementary_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeCustom.ShapeCustom_SweptToElementary_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeCustom.ShapeCustom_SweptToElementary_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeCustom.delete_ShapeCustom_SweptToElementary
ShapeCustom_SweptToElementary_swigregister = _ShapeCustom.ShapeCustom_SweptToElementary_swigregister
ShapeCustom_SweptToElementary_swigregister(ShapeCustom_SweptToElementary)

def ShapeCustom_SweptToElementary_get_type_name(*args):
    """
    ShapeCustom_SweptToElementary_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeCustom.ShapeCustom_SweptToElementary_get_type_name(*args)

def ShapeCustom_SweptToElementary_get_type_descriptor(*args):
    """
    ShapeCustom_SweptToElementary_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeCustom.ShapeCustom_SweptToElementary_get_type_descriptor(*args)

class Handle_ShapeCustom_RestrictionParameters(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeCustom_RestrictionParameters self)

        Nullify the handle


        """
        return _ShapeCustom.Handle_ShapeCustom_RestrictionParameters_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeCustom_RestrictionParameters self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeCustom.Handle_ShapeCustom_RestrictionParameters_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeCustom_RestrictionParameters self, ShapeCustom_RestrictionParameters thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeCustom.Handle_ShapeCustom_RestrictionParameters_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeCustom_RestrictionParameters self, Handle_ShapeCustom_RestrictionParameters theHandle) -> Handle_ShapeCustom_RestrictionParameters
        assign(Handle_ShapeCustom_RestrictionParameters self, ShapeCustom_RestrictionParameters thePtr) -> Handle_ShapeCustom_RestrictionParameters
        assign(Handle_ShapeCustom_RestrictionParameters self, Handle_ShapeCustom_RestrictionParameters theHandle) -> Handle_ShapeCustom_RestrictionParameters

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeCustom.Handle_ShapeCustom_RestrictionParameters_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeCustom_RestrictionParameters self) -> ShapeCustom_RestrictionParameters

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeCustom.Handle_ShapeCustom_RestrictionParameters_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeCustom_RestrictionParameters self) -> ShapeCustom_RestrictionParameters

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeCustom.Handle_ShapeCustom_RestrictionParameters___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeCustom_RestrictionParameters self) -> ShapeCustom_RestrictionParameters

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeCustom.Handle_ShapeCustom_RestrictionParameters___ref__(self, *args)


    def __hash__(self):
        return _ShapeCustom.Handle_ShapeCustom_RestrictionParameters___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeCustom.Handle_ShapeCustom_RestrictionParameters___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeCustom.new_Handle_ShapeCustom_RestrictionParameters(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeCustom.Handle_ShapeCustom_RestrictionParameters_DownCast)
    __swig_destroy__ = _ShapeCustom.delete_Handle_ShapeCustom_RestrictionParameters

    def GMaxDegree(self, *args):
        """
        GMaxDegree(Handle_ShapeCustom_RestrictionParameters self) -> Standard_Integer &

        Returns (modifiable) maximal degree of approximation.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeCustom.Handle_ShapeCustom_RestrictionParameters_GMaxDegree(self, *args)


    def GMaxSeg(self, *args):
        """
        GMaxSeg(Handle_ShapeCustom_RestrictionParameters self) -> Standard_Integer &

        Returns (modifiable) maximal number of spans of
        approximation.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeCustom.Handle_ShapeCustom_RestrictionParameters_GMaxSeg(self, *args)


    def ConvertPlane(self, *args):
        """
        ConvertPlane(Handle_ShapeCustom_RestrictionParameters self) -> Standard_Boolean &

        Sets flag for define if Plane converted to BSpline surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_RestrictionParameters_ConvertPlane(self, *args)


    def ConvertBezierSurf(self, *args):
        """
        ConvertBezierSurf(Handle_ShapeCustom_RestrictionParameters self) -> Standard_Boolean &

        Sets flag for define if Bezier surface converted to BSpline
        surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_RestrictionParameters_ConvertBezierSurf(self, *args)


    def ConvertRevolutionSurf(self, *args):
        """
        ConvertRevolutionSurf(Handle_ShapeCustom_RestrictionParameters self) -> Standard_Boolean &

        Sets flag for define if surface of Revolution converted to
        BSpline surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_RestrictionParameters_ConvertRevolutionSurf(self, *args)


    def ConvertExtrusionSurf(self, *args):
        """
        ConvertExtrusionSurf(Handle_ShapeCustom_RestrictionParameters self) -> Standard_Boolean &

        Sets flag for define if surface of LinearExtrusion converted
        to BSpline surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_RestrictionParameters_ConvertExtrusionSurf(self, *args)


    def ConvertOffsetSurf(self, *args):
        """
        ConvertOffsetSurf(Handle_ShapeCustom_RestrictionParameters self) -> Standard_Boolean &

        Sets flag for define if Offset surface converted to BSpline
        surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_RestrictionParameters_ConvertOffsetSurf(self, *args)


    def ConvertCylindricalSurf(self, *args):
        """
        ConvertCylindricalSurf(Handle_ShapeCustom_RestrictionParameters self) -> Standard_Boolean &

        Sets flag for define if cylindrical surface converted to BSpline
        surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_RestrictionParameters_ConvertCylindricalSurf(self, *args)


    def ConvertConicalSurf(self, *args):
        """
        ConvertConicalSurf(Handle_ShapeCustom_RestrictionParameters self) -> Standard_Boolean &

        Sets flag for define if conical surface converted to BSpline
        surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_RestrictionParameters_ConvertConicalSurf(self, *args)


    def ConvertToroidalSurf(self, *args):
        """
        ConvertToroidalSurf(Handle_ShapeCustom_RestrictionParameters self) -> Standard_Boolean &

        Sets flag for define if toroidal surface converted to BSpline
        surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_RestrictionParameters_ConvertToroidalSurf(self, *args)


    def ConvertSphericalSurf(self, *args):
        """
        ConvertSphericalSurf(Handle_ShapeCustom_RestrictionParameters self) -> Standard_Boolean &

        Sets flag for define if spherical surface converted to BSpline
        surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_RestrictionParameters_ConvertSphericalSurf(self, *args)


    def SegmentSurfaceMode(self, *args):
        """
        SegmentSurfaceMode(Handle_ShapeCustom_RestrictionParameters self) -> Standard_Boolean &

        Sets Segment mode for surface. If Segment is True surface is
        approximated in the bondaries of face lying on this surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_RestrictionParameters_SegmentSurfaceMode(self, *args)


    def ConvertCurve3d(self, *args):
        """
        ConvertCurve3d(Handle_ShapeCustom_RestrictionParameters self) -> Standard_Boolean &

        Sets flag for define if 3d curve converted to BSpline curve.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_RestrictionParameters_ConvertCurve3d(self, *args)


    def ConvertOffsetCurv3d(self, *args):
        """
        ConvertOffsetCurv3d(Handle_ShapeCustom_RestrictionParameters self) -> Standard_Boolean &

        Sets flag for define if Offset curve3d converted to BSpline
        surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_RestrictionParameters_ConvertOffsetCurv3d(self, *args)


    def ConvertCurve2d(self, *args):
        """
        ConvertCurve2d(Handle_ShapeCustom_RestrictionParameters self) -> Standard_Boolean &

        Returns (modifiable) flag for define if 2d curve converted
        to BSpline curve.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_RestrictionParameters_ConvertCurve2d(self, *args)


    def ConvertOffsetCurv2d(self, *args):
        """
        ConvertOffsetCurv2d(Handle_ShapeCustom_RestrictionParameters self) -> Standard_Boolean &

        Returns (modifiable) flag for define if Offset curve2d
        converted to BSpline surface.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_RestrictionParameters_ConvertOffsetCurv2d(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeCustom_RestrictionParameters self) -> char const *

        :rtype: const char *

        """
        return _ShapeCustom.Handle_ShapeCustom_RestrictionParameters_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeCustom.Handle_ShapeCustom_RestrictionParameters_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeCustom.Handle_ShapeCustom_RestrictionParameters_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_ShapeCustom_RestrictionParameters self)

        Memory deallocator for transient classes


        """
        return _ShapeCustom.Handle_ShapeCustom_RestrictionParameters_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeCustom_RestrictionParameters self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeCustom_RestrictionParameters self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_RestrictionParameters_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeCustom_RestrictionParameters self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeCustom_RestrictionParameters self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_RestrictionParameters_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeCustom_RestrictionParameters self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeCustom.Handle_ShapeCustom_RestrictionParameters_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeCustom_RestrictionParameters self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeCustom.Handle_ShapeCustom_RestrictionParameters_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeCustom_RestrictionParameters self)

        Increments the reference counter of this object


        """
        return _ShapeCustom.Handle_ShapeCustom_RestrictionParameters_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeCustom_RestrictionParameters self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeCustom.Handle_ShapeCustom_RestrictionParameters_DecrementRefCounter(self, *args)

Handle_ShapeCustom_RestrictionParameters_swigregister = _ShapeCustom.Handle_ShapeCustom_RestrictionParameters_swigregister
Handle_ShapeCustom_RestrictionParameters_swigregister(Handle_ShapeCustom_RestrictionParameters)

def Handle_ShapeCustom_RestrictionParameters_DownCast(thing):
    return _ShapeCustom.Handle_ShapeCustom_RestrictionParameters_DownCast(thing)
Handle_ShapeCustom_RestrictionParameters_DownCast = _ShapeCustom.Handle_ShapeCustom_RestrictionParameters_DownCast

class Handle_ShapeCustom_ConvertToBSpline(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeCustom_ConvertToBSpline self)

        Nullify the handle


        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeCustom_ConvertToBSpline self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeCustom_ConvertToBSpline self, ShapeCustom_ConvertToBSpline thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeCustom_ConvertToBSpline self, Handle_ShapeCustom_ConvertToBSpline theHandle) -> Handle_ShapeCustom_ConvertToBSpline
        assign(Handle_ShapeCustom_ConvertToBSpline self, ShapeCustom_ConvertToBSpline thePtr) -> Handle_ShapeCustom_ConvertToBSpline
        assign(Handle_ShapeCustom_ConvertToBSpline self, Handle_ShapeCustom_ConvertToBSpline theHandle) -> Handle_ShapeCustom_ConvertToBSpline

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeCustom_ConvertToBSpline self) -> ShapeCustom_ConvertToBSpline

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeCustom_ConvertToBSpline self) -> ShapeCustom_ConvertToBSpline

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeCustom_ConvertToBSpline self) -> ShapeCustom_ConvertToBSpline

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline___ref__(self, *args)


    def __hash__(self):
        return _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeCustom.new_Handle_ShapeCustom_ConvertToBSpline(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_DownCast)
    __swig_destroy__ = _ShapeCustom.delete_Handle_ShapeCustom_ConvertToBSpline

    def SetExtrusionMode(self, *args):
        """
        SetExtrusionMode(Handle_ShapeCustom_ConvertToBSpline self, Standard_Boolean const extrMode)

        Sets mode for convertion of Surfaces of Linear
        extrusion.

        :type extrMode: bool

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_SetExtrusionMode(self, *args)


    def SetRevolutionMode(self, *args):
        """
        SetRevolutionMode(Handle_ShapeCustom_ConvertToBSpline self, Standard_Boolean const revolMode)

        Sets mode for convertion of Surfaces of Revolution.

        :type revolMode: bool

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_SetRevolutionMode(self, *args)


    def SetOffsetMode(self, *args):
        """
        SetOffsetMode(Handle_ShapeCustom_ConvertToBSpline self, Standard_Boolean const offsetMode)

        Sets mode for convertion of Offset surfaces.

        :type offsetMode: bool

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_SetOffsetMode(self, *args)


    def SetPlaneMode(self, *args):
        """
        SetPlaneMode(Handle_ShapeCustom_ConvertToBSpline self, Standard_Boolean const planeMode)

        Sets mode for convertion of Plane surfaces.

        :type planeMode: bool

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_SetPlaneMode(self, *args)


    def NewSurface(self, *args):
        """
        NewSurface(Handle_ShapeCustom_ConvertToBSpline self, TopoDS_Face F, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True if the face <F> has  been
        modified. In this case, <S> is the new geometric
        support of the face, <L> the new location,  <Tol>
        the new tolerance.  Otherwise, returns
        Standard_False, and <S>, <L>, <Tol> are  not
        significant.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :type RevWires: bool
        :type RevFace: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_NewSurface(self, *args)


    def NewCurve(self, *args):
        """
        NewCurve(Handle_ShapeCustom_ConvertToBSpline self, TopoDS_Edge E, Handle_Geom_Curve C, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True  if  the edge  <E> has  been
        modified.  In this case,  <C> is the new geometric
        support of the  edge, <L> the  new location, <Tol>
        the         new    tolerance.   Otherwise, returns
        Standard_False,    and  <C>,  <L>,   <Tol> are not
        significant.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_NewCurve(self, *args)


    def NewPoint(self, *args):
        """
        NewPoint(Handle_ShapeCustom_ConvertToBSpline self, TopoDS_Vertex V, gp_Pnt P) -> Standard_Boolean

        Returns  Standard_True if the  vertex <V> has been
        modified.  In this  case, <P> is the new geometric
        support of the vertex,   <Tol> the new  tolerance.
        Otherwise, returns Standard_False, and <P>,  <Tol>
        are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_NewPoint(self, *args)


    def NewCurve2d(self, *args):
        """
        NewCurve2d(Handle_ShapeCustom_ConvertToBSpline self, TopoDS_Edge E, TopoDS_Face F, TopoDS_Edge NewE, TopoDS_Face NewF, Handle_Geom2d_Curve C) -> Standard_Boolean

        Returns Standard_True if  the edge  <E> has a  new
        curve on surface on the face <F>.In this case, <C>
        is the new geometric support of  the edge, <L> the
        new location, <Tol> the new tolerance.

        Otherwise, returns  Standard_False, and <C>,  <L>,
        <Tol> are not significant.

        <NewE> is the new  edge created from  <E>.  <NewF>
        is the new face created from <F>. They may be usefull.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF: OCC.wrapper.TopoDS.TopoDS_Face
        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_NewCurve2d(self, *args)


    def NewParameter(self, *args):
        """
        NewParameter(Handle_ShapeCustom_ConvertToBSpline self, TopoDS_Vertex V, TopoDS_Edge E) -> Standard_Boolean

        Returns Standard_True if the Vertex  <V> has a new
        parameter on the  edge <E>. In  this case,  <P> is
        the parameter,    <Tol>  the     new    tolerance.
        Otherwise, returns Standard_False, and <P>,  <Tol>
        are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: float
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_NewParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_ShapeCustom_ConvertToBSpline self, TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2, TopoDS_Edge NewE, TopoDS_Face NewF1, TopoDS_Face NewF2) -> GeomAbs_Shape

        Returns the  continuity of  <NewE> between <NewF1>
        and <NewF2>.

        <NewE> is the new  edge created from <E>.  <NewF1>
        (resp. <NewF2>) is the new  face created from <F1>
        (resp. <F2>).

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF1: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewF2: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_Continuity(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeCustom_ConvertToBSpline self) -> char const *

        :rtype: const char *

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMsgRegistrator(self, *args):
        """
        SetMsgRegistrator(Handle_ShapeCustom_ConvertToBSpline self, Handle_ShapeExtend_BasicMsgRegistrator msgreg)

        Sets message registrator

        :type msgreg: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_SetMsgRegistrator(self, *args)


    def MsgRegistrator(self, *args):
        """
        MsgRegistrator(Handle_ShapeCustom_ConvertToBSpline self) -> Handle_ShapeExtend_BasicMsgRegistrator

        Returns message registrator

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_MsgRegistrator(self, *args)


    def SendMsg(self, *args):
        """
        SendMsg(Handle_ShapeCustom_ConvertToBSpline self, TopoDS_Shape shape, Message_Msg message, Message_Gravity const gravity=Message_Info)

        Sends a message to be attached to the shape.
        Calls corresponding message of message registrator.

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type message: OCC.wrapper.Message.Message_Msg
        :type gravity: OCC.wrapper.Message.Message_Gravity

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_SendMsg(self, *args)


    def NewTriangulation(self, *args):
        """
        NewTriangulation(Handle_ShapeCustom_ConvertToBSpline self, TopoDS_Face F, Handle_Poly_Triangulation T) -> Standard_Boolean

        Returns true if the face has been modified according to changed triangulation.
        If the face has been modified:
        - T is a new triangulation on the face

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type T: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_NewTriangulation(self, *args)


    def NewPolygon(self, *args):
        """
        NewPolygon(Handle_ShapeCustom_ConvertToBSpline self, TopoDS_Edge E, Handle_Poly_Polygon3D P) -> Standard_Boolean

        Returns true if the edge has been modified according to changed polygon.
        If the edge has been modified:
        - P is a new polygon

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: OCC.wrapper.Poly.Handle_Poly_Polygon3D
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_NewPolygon(self, *args)


    def NewPolygonOnTriangulation(self, *args):
        """
        NewPolygonOnTriangulation(Handle_ShapeCustom_ConvertToBSpline self, TopoDS_Edge E, TopoDS_Face F, Handle_Poly_PolygonOnTriangulation P) -> Standard_Boolean

        Returns true if the edge has been modified according to changed polygon on triangulation.
        If the edge has been modified:
        - P is a new polygon on triangulation

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type P: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_NewPolygonOnTriangulation(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeCustom_ConvertToBSpline self)

        Memory deallocator for transient classes


        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeCustom_ConvertToBSpline self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeCustom_ConvertToBSpline self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeCustom_ConvertToBSpline self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeCustom_ConvertToBSpline self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeCustom_ConvertToBSpline self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeCustom_ConvertToBSpline self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeCustom_ConvertToBSpline self)

        Increments the reference counter of this object


        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeCustom_ConvertToBSpline self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_DecrementRefCounter(self, *args)

Handle_ShapeCustom_ConvertToBSpline_swigregister = _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_swigregister
Handle_ShapeCustom_ConvertToBSpline_swigregister(Handle_ShapeCustom_ConvertToBSpline)

def Handle_ShapeCustom_ConvertToBSpline_DownCast(thing):
    return _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_DownCast(thing)
Handle_ShapeCustom_ConvertToBSpline_DownCast = _ShapeCustom.Handle_ShapeCustom_ConvertToBSpline_DownCast

class ShapeCustom_Surface(object):
    """
    Converts a surface to the analitical form with given
    precision. Conversion is done only the surface is bspline
    of bezier and this can be approximed by some analytical
    surface with that precision.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(ShapeCustom_Surface self) -> ShapeCustom_Surface
        __init__(ShapeCustom_Surface self, Handle_Geom_Surface S) -> ShapeCustom_Surface

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        this = _ShapeCustom.new_ShapeCustom_Surface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(ShapeCustom_Surface self, Handle_Geom_Surface S)

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _ShapeCustom.ShapeCustom_Surface_Init(self, *args)


    def Gap(self, *args):
        """
        Gap(ShapeCustom_Surface self) -> Standard_Real

        Returns maximal deviation of converted surface from the original
        one computed by last call to ConvertToAnalytical

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _ShapeCustom.ShapeCustom_Surface_Gap(self, *args)


    def ConvertToAnalytical(self, *args):
        """
        ConvertToAnalytical(ShapeCustom_Surface self, Standard_Real const tol, Standard_Boolean const substitute) -> Handle_Geom_Surface

        Tries to convert the Surface to an Analytic form
        Returns the result
        Works only if the Surface is BSpline or Bezier.
        Else, or in case of failure, returns a Null Handle

        If <substitute> is True, the new surface replaces the actual
        one in <me>

        It works by analysing the case which can apply, creating the
        corresponding analytic surface, then checking coincidence
        Warning: Parameter laws are not kept, hence PCurves should be redone

        :type tol: float
        :type substitute: bool
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _ShapeCustom.ShapeCustom_Surface_ConvertToAnalytical(self, *args)


    def ConvertToPeriodic(self, *args):
        """
        ConvertToPeriodic(ShapeCustom_Surface self, Standard_Boolean const substitute, Standard_Real const preci=-1) -> Handle_Geom_Surface

        Tries to convert the Surface to the Periodic form
        Returns the resulting surface
        Works only if the Surface is BSpline and is closed with
        Precision::Confusion()
        Else, or in case of failure, returns a Null Handle

        :type substitute: bool
        :type preci: float
        :rtype: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _ShapeCustom.ShapeCustom_Surface_ConvertToPeriodic(self, *args)

    __swig_destroy__ = _ShapeCustom.delete_ShapeCustom_Surface
ShapeCustom_Surface_swigregister = _ShapeCustom.ShapeCustom_Surface_swigregister
ShapeCustom_Surface_swigregister(ShapeCustom_Surface)

class ShapeCustom_(object):
    """
    This package is intended to
    convert geometrical objects and topological. The
    modifications of one geometrical object to another
    (one) geometrical object are provided. The supported
    modifications are the following:
    conversion of BSpline and Bezier surfaces to analytical form,
    conversion of indirect elementary surfaces (with left-handed
    coordinate systems) into  direct ones,
    conversion of elementary surfaces to surfaces of revolution,
    conversion of surface of linear extrusion, revolution, offset
    surface to bspline,
    modification of parameterization, degree, number of segments of bspline
    surfaces,  scale the shape.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ApplyModifier(*args):
        """
        ApplyModifier(TopoDS_Shape S, Handle_BRepTools_Modification M, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher context, BRepTools_Modifier MD, Handle_Message_ProgressIndicator aProgress=0, Handle_ShapeBuild_ReShape aReShape=0) -> TopoDS_Shape

        Applies modifier to shape and checks sharing in the case assemblies.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type M: OCC.wrapper.BRepTools.Handle_BRepTools_Modification
        :type context: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape
        :type MD: OCC.wrapper.BRepTools.BRepTools_Modifier
        :type aProgress: OCC.wrapper.Message.Handle_Message_ProgressIndicator
        :type aReShape: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeCustom.ShapeCustom__ApplyModifier(*args)

    ApplyModifier = staticmethod(ApplyModifier)

    def DirectFaces(*args):
        """
        DirectFaces(TopoDS_Shape S) -> TopoDS_Shape

        Returns a new shape without indirect surfaces.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeCustom.ShapeCustom__DirectFaces(*args)

    DirectFaces = staticmethod(DirectFaces)

    def ScaleShape(*args):
        """
        ScaleShape(TopoDS_Shape S, Standard_Real const scale) -> TopoDS_Shape

        Returns a new shape which is scaled original

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type scale: float
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeCustom.ShapeCustom__ScaleShape(*args)

    ScaleShape = staticmethod(ScaleShape)

    def BSplineRestriction(*args):
        """
        BSplineRestriction(TopoDS_Shape S, Standard_Real const Tol3d, Standard_Real const Tol2d, Standard_Integer const MaxDegree, Standard_Integer const MaxNbSegment, GeomAbs_Shape const Continuity3d, GeomAbs_Shape const Continuity2d, Standard_Boolean const Degree, Standard_Boolean const Rational, Handle_ShapeCustom_RestrictionParameters aParameters) -> TopoDS_Shape

        Returns a new shape with all surfaces, curves and pcurves
        which type is BSpline/Bezier or based on them converted
        having Degree less than <MaxDegree> or number of spans less
        than <NbMaxSegment> in dependence on parameter priority <Degree>.
        <GmaxDegree> and <GMaxSegments> are maximum possible degree
        and number of spans correspondingly.
        These values will be used in those cases when approximation with
        specified parameters is impossible and one of GmaxDegree or
        GMaxSegments is selected in dependence on priority.
        Note that even if approximation is impossible with <GMaxDegree>
        then number of spans can exceed specified <GMaxSegment>
        <Rational> specifies if to convert Rational BSpline/Bezier into
        polynomial B-Spline.
        If flags ConvOffSurf,ConvOffCurve3d,ConvOffCurve2d are Standard_True there are means
        that Offset surfaces , Offset curves 3d and Offset curves 2d are converted to BSPline
        correspondingly.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Tol3d: float
        :type Tol2d: float
        :type MaxDegree: int
        :type MaxNbSegment: int
        :type Continuity3d: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type Continuity2d: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type Degree: bool
        :type Rational: bool
        :type aParameters: OCC.wrapper.ShapeCustom.Handle_ShapeCustom_RestrictionParameters
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeCustom.ShapeCustom__BSplineRestriction(*args)

    BSplineRestriction = staticmethod(BSplineRestriction)

    def ConvertToRevolution(*args):
        """
        ConvertToRevolution(TopoDS_Shape S) -> TopoDS_Shape

        Returns a new shape with all elementary periodic surfaces converted
        to Geom_SurfaceOfRevolution

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeCustom.ShapeCustom__ConvertToRevolution(*args)

    ConvertToRevolution = staticmethod(ConvertToRevolution)

    def SweptToElementary(*args):
        """
        SweptToElementary(TopoDS_Shape S) -> TopoDS_Shape

        Returns a new shape with all surfaces of revolution and linear extrusion
        convert to elementary periodic surfaces

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeCustom.ShapeCustom__SweptToElementary(*args)

    SweptToElementary = staticmethod(SweptToElementary)

    def ConvertToBSpline(*args):
        """
        ConvertToBSpline(TopoDS_Shape S, Standard_Boolean const extrMode, Standard_Boolean const revolMode, Standard_Boolean const offsetMode, Standard_Boolean const planeMode) -> TopoDS_Shape

        Returns a new shape with all surfaces of linear extrusion, revolution,
        offset, and planar surfaces converted according to flags to
        Geom_BSplineSurface (with same parameterisation).

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type extrMode: bool
        :type revolMode: bool
        :type offsetMode: bool
        :type planeMode: bool
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _ShapeCustom.ShapeCustom__ConvertToBSpline(*args)

    ConvertToBSpline = staticmethod(ConvertToBSpline)

    def __init__(self):
        """
        This package is intended to
        convert geometrical objects and topological. The
        modifications of one geometrical object to another
        (one) geometrical object are provided. The supported
        modifications are the following:
        conversion of BSpline and Bezier surfaces to analytical form,
        conversion of indirect elementary surfaces (with left-handed
        coordinate systems) into  direct ones,
        conversion of elementary surfaces to surfaces of revolution,
        conversion of surface of linear extrusion, revolution, offset
        surface to bspline,
        modification of parameterization, degree, number of segments of bspline
        surfaces,  scale the shape.
        """
        this = _ShapeCustom.new_ShapeCustom_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ShapeCustom.delete_ShapeCustom_
ShapeCustom__swigregister = _ShapeCustom.ShapeCustom__swigregister
ShapeCustom__swigregister(ShapeCustom_)

def ShapeCustom__ApplyModifier(*args):
    """
    ShapeCustom__ApplyModifier(TopoDS_Shape S, Handle_BRepTools_Modification M, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher context, BRepTools_Modifier MD, Handle_Message_ProgressIndicator aProgress=0, Handle_ShapeBuild_ReShape aReShape=0) -> TopoDS_Shape

    Applies modifier to shape and checks sharing in the case assemblies.

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type M: OCC.wrapper.BRepTools.Handle_BRepTools_Modification
    :type context: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape
    :type MD: OCC.wrapper.BRepTools.BRepTools_Modifier
    :type aProgress: OCC.wrapper.Message.Handle_Message_ProgressIndicator
    :type aReShape: OCC.wrapper.ShapeBuild.Handle_ShapeBuild_ReShape
    :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _ShapeCustom.ShapeCustom__ApplyModifier(*args)

def ShapeCustom__DirectFaces(*args):
    """
    ShapeCustom__DirectFaces(TopoDS_Shape S) -> TopoDS_Shape

    Returns a new shape without indirect surfaces.

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _ShapeCustom.ShapeCustom__DirectFaces(*args)

def ShapeCustom__ScaleShape(*args):
    """
    ShapeCustom__ScaleShape(TopoDS_Shape S, Standard_Real const scale) -> TopoDS_Shape

    Returns a new shape which is scaled original

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type scale: float
    :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _ShapeCustom.ShapeCustom__ScaleShape(*args)

def ShapeCustom__BSplineRestriction(*args):
    """
    ShapeCustom__BSplineRestriction(TopoDS_Shape S, Standard_Real const Tol3d, Standard_Real const Tol2d, Standard_Integer const MaxDegree, Standard_Integer const MaxNbSegment, GeomAbs_Shape const Continuity3d, GeomAbs_Shape const Continuity2d, Standard_Boolean const Degree, Standard_Boolean const Rational, Handle_ShapeCustom_RestrictionParameters aParameters) -> TopoDS_Shape

    Returns a new shape with all surfaces, curves and pcurves
    which type is BSpline/Bezier or based on them converted
    having Degree less than <MaxDegree> or number of spans less
    than <NbMaxSegment> in dependence on parameter priority <Degree>.
    <GmaxDegree> and <GMaxSegments> are maximum possible degree
    and number of spans correspondingly.
    These values will be used in those cases when approximation with
    specified parameters is impossible and one of GmaxDegree or
    GMaxSegments is selected in dependence on priority.
    Note that even if approximation is impossible with <GMaxDegree>
    then number of spans can exceed specified <GMaxSegment>
    <Rational> specifies if to convert Rational BSpline/Bezier into
    polynomial B-Spline.
    If flags ConvOffSurf,ConvOffCurve3d,ConvOffCurve2d are Standard_True there are means
    that Offset surfaces , Offset curves 3d and Offset curves 2d are converted to BSPline
    correspondingly.

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type Tol3d: float
    :type Tol2d: float
    :type MaxDegree: int
    :type MaxNbSegment: int
    :type Continuity3d: OCC.wrapper.GeomAbs.GeomAbs_Shape
    :type Continuity2d: OCC.wrapper.GeomAbs.GeomAbs_Shape
    :type Degree: bool
    :type Rational: bool
    :type aParameters: OCC.wrapper.ShapeCustom.Handle_ShapeCustom_RestrictionParameters
    :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _ShapeCustom.ShapeCustom__BSplineRestriction(*args)

def ShapeCustom__ConvertToRevolution(*args):
    """
    ShapeCustom__ConvertToRevolution(TopoDS_Shape S) -> TopoDS_Shape

    Returns a new shape with all elementary periodic surfaces converted
    to Geom_SurfaceOfRevolution

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _ShapeCustom.ShapeCustom__ConvertToRevolution(*args)

def ShapeCustom__SweptToElementary(*args):
    """
    ShapeCustom__SweptToElementary(TopoDS_Shape S) -> TopoDS_Shape

    Returns a new shape with all surfaces of revolution and linear extrusion
    convert to elementary periodic surfaces

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _ShapeCustom.ShapeCustom__SweptToElementary(*args)

def ShapeCustom__ConvertToBSpline(*args):
    """
    ShapeCustom__ConvertToBSpline(TopoDS_Shape S, Standard_Boolean const extrMode, Standard_Boolean const revolMode, Standard_Boolean const offsetMode, Standard_Boolean const planeMode) -> TopoDS_Shape

    Returns a new shape with all surfaces of linear extrusion, revolution,
    offset, and planar surfaces converted according to flags to
    Geom_BSplineSurface (with same parameterisation).

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type extrMode: bool
    :type revolMode: bool
    :type offsetMode: bool
    :type planeMode: bool
    :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _ShapeCustom.ShapeCustom__ConvertToBSpline(*args)

class ShapeCustom_DirectModification(ShapeCustom_Modification):
    """
    implements a modification for the BRepTools
    Modifier algortihm. Will redress indirect
    surfaces.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_ShapeCustom_DirectModification
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_ShapeCustom_DirectModification(self) 
            return h


    def __init__(self, *args):
        """
        __init__(ShapeCustom_DirectModification self) -> ShapeCustom_DirectModification

        implements a modification for the BRepTools
        Modifier algortihm. Will redress indirect
        surfaces.
        """
        this = _ShapeCustom.new_ShapeCustom_DirectModification(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def NewSurface(self, *args):
        """
        NewSurface(ShapeCustom_DirectModification self, TopoDS_Face F, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True if the face <F> has  been
        modified. In this case, <S> is the new geometric
        support of the face, <L> the new location,  <Tol>
        the new tolerance.  Otherwise, returns
        Standard_False, and <S>, <L>, <Tol> are  not
        significant.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :type RevWires: bool
        :type RevFace: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_DirectModification_NewSurface(self, *args)


    def NewCurve(self, *args):
        """
        NewCurve(ShapeCustom_DirectModification self, TopoDS_Edge E, Handle_Geom_Curve C, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True  if  the edge  <E> has  been
        modified.  In this case,  <C> is the new geometric
        support of the  edge, <L> the  new location, <Tol>
        the         new    tolerance.   Otherwise, returns
        Standard_False,    and  <C>,  <L>,   <Tol> are not
        significant.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_DirectModification_NewCurve(self, *args)


    def NewPoint(self, *args):
        """
        NewPoint(ShapeCustom_DirectModification self, TopoDS_Vertex V, gp_Pnt P) -> Standard_Boolean

        Returns  Standard_True if the  vertex <V> has been
        modified.  In this  case, <P> is the new geometric
        support of the vertex,   <Tol> the new  tolerance.
        Otherwise, returns Standard_False, and <P>,  <Tol>
        are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_DirectModification_NewPoint(self, *args)


    def NewCurve2d(self, *args):
        """
        NewCurve2d(ShapeCustom_DirectModification self, TopoDS_Edge E, TopoDS_Face F, TopoDS_Edge NewE, TopoDS_Face NewF, Handle_Geom2d_Curve C) -> Standard_Boolean

        Returns Standard_True if  the edge  <E> has a  new
        curve on surface on the face <F>.In this case, <C>
        is the new geometric support of  the edge, <L> the
        new location, <Tol> the new tolerance.

        Otherwise, returns  Standard_False, and <C>,  <L>,
        <Tol> are not significant.

        <NewE> is the new  edge created from  <E>.  <NewF>
        is the new face created from <F>. They may be usefull.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF: OCC.wrapper.TopoDS.TopoDS_Face
        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_DirectModification_NewCurve2d(self, *args)


    def NewParameter(self, *args):
        """
        NewParameter(ShapeCustom_DirectModification self, TopoDS_Vertex V, TopoDS_Edge E) -> Standard_Boolean

        Returns Standard_True if the Vertex  <V> has a new
        parameter on the  edge <E>. In  this case,  <P> is
        the parameter,    <Tol>  the     new    tolerance.
        Otherwise, returns Standard_False, and <P>,  <Tol>
        are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: float
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_DirectModification_NewParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(ShapeCustom_DirectModification self, TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2, TopoDS_Edge NewE, TopoDS_Face NewF1, TopoDS_Face NewF2) -> GeomAbs_Shape

        Returns the  continuity of  <NewE> between <NewF1>
        and <NewF2>.

        <NewE> is the new  edge created from <E>.  <NewF1>
        (resp. <NewF2>) is the new  face created from <F1>
        (resp. <F2>).

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF1: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewF2: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _ShapeCustom.ShapeCustom_DirectModification_Continuity(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _ShapeCustom.ShapeCustom_DirectModification_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _ShapeCustom.ShapeCustom_DirectModification_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeCustom.ShapeCustom_DirectModification_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _ShapeCustom.delete_ShapeCustom_DirectModification
ShapeCustom_DirectModification_swigregister = _ShapeCustom.ShapeCustom_DirectModification_swigregister
ShapeCustom_DirectModification_swigregister(ShapeCustom_DirectModification)

def ShapeCustom_DirectModification_get_type_name(*args):
    """
    ShapeCustom_DirectModification_get_type_name() -> char const *

    :rtype: const char *

    """
    return _ShapeCustom.ShapeCustom_DirectModification_get_type_name(*args)

def ShapeCustom_DirectModification_get_type_descriptor(*args):
    """
    ShapeCustom_DirectModification_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _ShapeCustom.ShapeCustom_DirectModification_get_type_descriptor(*args)

class Handle_ShapeCustom_DirectModification(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeCustom_DirectModification self)

        Nullify the handle


        """
        return _ShapeCustom.Handle_ShapeCustom_DirectModification_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeCustom_DirectModification self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeCustom.Handle_ShapeCustom_DirectModification_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeCustom_DirectModification self, ShapeCustom_DirectModification thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeCustom.Handle_ShapeCustom_DirectModification_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeCustom_DirectModification self, Handle_ShapeCustom_DirectModification theHandle) -> Handle_ShapeCustom_DirectModification
        assign(Handle_ShapeCustom_DirectModification self, ShapeCustom_DirectModification thePtr) -> Handle_ShapeCustom_DirectModification
        assign(Handle_ShapeCustom_DirectModification self, Handle_ShapeCustom_DirectModification theHandle) -> Handle_ShapeCustom_DirectModification

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeCustom.Handle_ShapeCustom_DirectModification_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeCustom_DirectModification self) -> ShapeCustom_DirectModification

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeCustom.Handle_ShapeCustom_DirectModification_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeCustom_DirectModification self) -> ShapeCustom_DirectModification

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeCustom.Handle_ShapeCustom_DirectModification___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeCustom_DirectModification self) -> ShapeCustom_DirectModification

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeCustom.Handle_ShapeCustom_DirectModification___ref__(self, *args)


    def __hash__(self):
        return _ShapeCustom.Handle_ShapeCustom_DirectModification___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeCustom.Handle_ShapeCustom_DirectModification___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeCustom.new_Handle_ShapeCustom_DirectModification(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeCustom.Handle_ShapeCustom_DirectModification_DownCast)
    __swig_destroy__ = _ShapeCustom.delete_Handle_ShapeCustom_DirectModification

    def NewSurface(self, *args):
        """
        NewSurface(Handle_ShapeCustom_DirectModification self, TopoDS_Face F, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True if the face <F> has  been
        modified. In this case, <S> is the new geometric
        support of the face, <L> the new location,  <Tol>
        the new tolerance.  Otherwise, returns
        Standard_False, and <S>, <L>, <Tol> are  not
        significant.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :type RevWires: bool
        :type RevFace: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_DirectModification_NewSurface(self, *args)


    def NewCurve(self, *args):
        """
        NewCurve(Handle_ShapeCustom_DirectModification self, TopoDS_Edge E, Handle_Geom_Curve C, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True  if  the edge  <E> has  been
        modified.  In this case,  <C> is the new geometric
        support of the  edge, <L> the  new location, <Tol>
        the         new    tolerance.   Otherwise, returns
        Standard_False,    and  <C>,  <L>,   <Tol> are not
        significant.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_DirectModification_NewCurve(self, *args)


    def NewPoint(self, *args):
        """
        NewPoint(Handle_ShapeCustom_DirectModification self, TopoDS_Vertex V, gp_Pnt P) -> Standard_Boolean

        Returns  Standard_True if the  vertex <V> has been
        modified.  In this  case, <P> is the new geometric
        support of the vertex,   <Tol> the new  tolerance.
        Otherwise, returns Standard_False, and <P>,  <Tol>
        are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_DirectModification_NewPoint(self, *args)


    def NewCurve2d(self, *args):
        """
        NewCurve2d(Handle_ShapeCustom_DirectModification self, TopoDS_Edge E, TopoDS_Face F, TopoDS_Edge NewE, TopoDS_Face NewF, Handle_Geom2d_Curve C) -> Standard_Boolean

        Returns Standard_True if  the edge  <E> has a  new
        curve on surface on the face <F>.In this case, <C>
        is the new geometric support of  the edge, <L> the
        new location, <Tol> the new tolerance.

        Otherwise, returns  Standard_False, and <C>,  <L>,
        <Tol> are not significant.

        <NewE> is the new  edge created from  <E>.  <NewF>
        is the new face created from <F>. They may be usefull.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF: OCC.wrapper.TopoDS.TopoDS_Face
        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_DirectModification_NewCurve2d(self, *args)


    def NewParameter(self, *args):
        """
        NewParameter(Handle_ShapeCustom_DirectModification self, TopoDS_Vertex V, TopoDS_Edge E) -> Standard_Boolean

        Returns Standard_True if the Vertex  <V> has a new
        parameter on the  edge <E>. In  this case,  <P> is
        the parameter,    <Tol>  the     new    tolerance.
        Otherwise, returns Standard_False, and <P>,  <Tol>
        are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: float
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_DirectModification_NewParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_ShapeCustom_DirectModification self, TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2, TopoDS_Edge NewE, TopoDS_Face NewF1, TopoDS_Face NewF2) -> GeomAbs_Shape

        Returns the  continuity of  <NewE> between <NewF1>
        and <NewF2>.

        <NewE> is the new  edge created from <E>.  <NewF1>
        (resp. <NewF2>) is the new  face created from <F1>
        (resp. <F2>).

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF1: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewF2: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _ShapeCustom.Handle_ShapeCustom_DirectModification_Continuity(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeCustom_DirectModification self) -> char const *

        :rtype: const char *

        """
        return _ShapeCustom.Handle_ShapeCustom_DirectModification_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeCustom.Handle_ShapeCustom_DirectModification_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeCustom.Handle_ShapeCustom_DirectModification_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMsgRegistrator(self, *args):
        """
        SetMsgRegistrator(Handle_ShapeCustom_DirectModification self, Handle_ShapeExtend_BasicMsgRegistrator msgreg)

        Sets message registrator

        :type msgreg: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeCustom.Handle_ShapeCustom_DirectModification_SetMsgRegistrator(self, *args)


    def MsgRegistrator(self, *args):
        """
        MsgRegistrator(Handle_ShapeCustom_DirectModification self) -> Handle_ShapeExtend_BasicMsgRegistrator

        Returns message registrator

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeCustom.Handle_ShapeCustom_DirectModification_MsgRegistrator(self, *args)


    def SendMsg(self, *args):
        """
        SendMsg(Handle_ShapeCustom_DirectModification self, TopoDS_Shape shape, Message_Msg message, Message_Gravity const gravity=Message_Info)

        Sends a message to be attached to the shape.
        Calls corresponding message of message registrator.

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type message: OCC.wrapper.Message.Message_Msg
        :type gravity: OCC.wrapper.Message.Message_Gravity

        """
        return _ShapeCustom.Handle_ShapeCustom_DirectModification_SendMsg(self, *args)


    def NewTriangulation(self, *args):
        """
        NewTriangulation(Handle_ShapeCustom_DirectModification self, TopoDS_Face F, Handle_Poly_Triangulation T) -> Standard_Boolean

        Returns true if the face has been modified according to changed triangulation.
        If the face has been modified:
        - T is a new triangulation on the face

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type T: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_DirectModification_NewTriangulation(self, *args)


    def NewPolygon(self, *args):
        """
        NewPolygon(Handle_ShapeCustom_DirectModification self, TopoDS_Edge E, Handle_Poly_Polygon3D P) -> Standard_Boolean

        Returns true if the edge has been modified according to changed polygon.
        If the edge has been modified:
        - P is a new polygon

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: OCC.wrapper.Poly.Handle_Poly_Polygon3D
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_DirectModification_NewPolygon(self, *args)


    def NewPolygonOnTriangulation(self, *args):
        """
        NewPolygonOnTriangulation(Handle_ShapeCustom_DirectModification self, TopoDS_Edge E, TopoDS_Face F, Handle_Poly_PolygonOnTriangulation P) -> Standard_Boolean

        Returns true if the edge has been modified according to changed polygon on triangulation.
        If the edge has been modified:
        - P is a new polygon on triangulation

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type P: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_DirectModification_NewPolygonOnTriangulation(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeCustom_DirectModification self)

        Memory deallocator for transient classes


        """
        return _ShapeCustom.Handle_ShapeCustom_DirectModification_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeCustom_DirectModification self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeCustom_DirectModification self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_DirectModification_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeCustom_DirectModification self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeCustom_DirectModification self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_DirectModification_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeCustom_DirectModification self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeCustom.Handle_ShapeCustom_DirectModification_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeCustom_DirectModification self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeCustom.Handle_ShapeCustom_DirectModification_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeCustom_DirectModification self)

        Increments the reference counter of this object


        """
        return _ShapeCustom.Handle_ShapeCustom_DirectModification_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeCustom_DirectModification self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeCustom.Handle_ShapeCustom_DirectModification_DecrementRefCounter(self, *args)

Handle_ShapeCustom_DirectModification_swigregister = _ShapeCustom.Handle_ShapeCustom_DirectModification_swigregister
Handle_ShapeCustom_DirectModification_swigregister(Handle_ShapeCustom_DirectModification)

def Handle_ShapeCustom_DirectModification_DownCast(thing):
    return _ShapeCustom.Handle_ShapeCustom_DirectModification_DownCast(thing)
Handle_ShapeCustom_DirectModification_DownCast = _ShapeCustom.Handle_ShapeCustom_DirectModification_DownCast

class Handle_ShapeCustom_SweptToElementary(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_ShapeCustom_SweptToElementary self)

        Nullify the handle


        """
        return _ShapeCustom.Handle_ShapeCustom_SweptToElementary_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_ShapeCustom_SweptToElementary self) -> bool

        Check for being null

        :rtype: bool

        """
        return _ShapeCustom.Handle_ShapeCustom_SweptToElementary_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_ShapeCustom_SweptToElementary self, ShapeCustom_SweptToElementary thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _ShapeCustom.Handle_ShapeCustom_SweptToElementary_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_ShapeCustom_SweptToElementary self, Handle_ShapeCustom_SweptToElementary theHandle) -> Handle_ShapeCustom_SweptToElementary
        assign(Handle_ShapeCustom_SweptToElementary self, ShapeCustom_SweptToElementary thePtr) -> Handle_ShapeCustom_SweptToElementary
        assign(Handle_ShapeCustom_SweptToElementary self, Handle_ShapeCustom_SweptToElementary theHandle) -> Handle_ShapeCustom_SweptToElementary

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _ShapeCustom.Handle_ShapeCustom_SweptToElementary_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_ShapeCustom_SweptToElementary self) -> ShapeCustom_SweptToElementary

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _ShapeCustom.Handle_ShapeCustom_SweptToElementary_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_ShapeCustom_SweptToElementary self) -> ShapeCustom_SweptToElementary

        Member access operator (note non-const)

        :rtype: T *

        """
        return _ShapeCustom.Handle_ShapeCustom_SweptToElementary___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_ShapeCustom_SweptToElementary self) -> ShapeCustom_SweptToElementary

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _ShapeCustom.Handle_ShapeCustom_SweptToElementary___ref__(self, *args)


    def __hash__(self):
        return _ShapeCustom.Handle_ShapeCustom_SweptToElementary___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _ShapeCustom.Handle_ShapeCustom_SweptToElementary___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _ShapeCustom.new_Handle_ShapeCustom_SweptToElementary(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_ShapeCustom.Handle_ShapeCustom_SweptToElementary_DownCast)
    __swig_destroy__ = _ShapeCustom.delete_Handle_ShapeCustom_SweptToElementary

    def NewSurface(self, *args):
        """
        NewSurface(Handle_ShapeCustom_SweptToElementary self, TopoDS_Face F, Handle_Geom_Surface S, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True if the face <F> has  been
        modified. In this case, <S> is the new geometric
        support of the face, <L> the new location,  <Tol>
        the new tolerance.  Otherwise, returns
        Standard_False, and <S>, <L>, <Tol> are  not
        significant.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :type RevWires: bool
        :type RevFace: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_SweptToElementary_NewSurface(self, *args)


    def NewCurve(self, *args):
        """
        NewCurve(Handle_ShapeCustom_SweptToElementary self, TopoDS_Edge E, Handle_Geom_Curve C, TopLoc_Location L) -> Standard_Boolean

        Returns Standard_True  if  the edge  <E> has  been
        modified.  In this case,  <C> is the new geometric
        support of the  edge, <L> the  new location, <Tol>
        the         new    tolerance.   Otherwise, returns
        Standard_False,    and  <C>,  <L>,   <Tol> are not
        significant.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type L: OCC.wrapper.TopLoc.TopLoc_Location
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_SweptToElementary_NewCurve(self, *args)


    def NewPoint(self, *args):
        """
        NewPoint(Handle_ShapeCustom_SweptToElementary self, TopoDS_Vertex V, gp_Pnt P) -> Standard_Boolean

        Returns  Standard_True if the  vertex <V> has been
        modified.  In this  case, <P> is the new geometric
        support of the vertex,   <Tol> the new  tolerance.
        Otherwise, returns Standard_False, and <P>,  <Tol>
        are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type P: OCC.wrapper.gp.gp_Pnt
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_SweptToElementary_NewPoint(self, *args)


    def NewCurve2d(self, *args):
        """
        NewCurve2d(Handle_ShapeCustom_SweptToElementary self, TopoDS_Edge E, TopoDS_Face F, TopoDS_Edge NewE, TopoDS_Face NewF, Handle_Geom2d_Curve C) -> Standard_Boolean

        Returns Standard_True if  the edge  <E> has a  new
        curve on surface on the face <F>.In this case, <C>
        is the new geometric support of  the edge, <L> the
        new location, <Tol> the new tolerance.

        Otherwise, returns  Standard_False, and <C>,  <L>,
        <Tol> are not significant.

        <NewE> is the new  edge created from  <E>.  <NewF>
        is the new face created from <F>. They may be usefull.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF: OCC.wrapper.TopoDS.TopoDS_Face
        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_SweptToElementary_NewCurve2d(self, *args)


    def NewParameter(self, *args):
        """
        NewParameter(Handle_ShapeCustom_SweptToElementary self, TopoDS_Vertex V, TopoDS_Edge E) -> Standard_Boolean

        Returns Standard_True if the Vertex  <V> has a new
        parameter on the  edge <E>. In  this case,  <P> is
        the parameter,    <Tol>  the     new    tolerance.
        Otherwise, returns Standard_False, and <P>,  <Tol>
        are not significant.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: float
        :type Tol: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_SweptToElementary_NewParameter(self, *args)


    def Continuity(self, *args):
        """
        Continuity(Handle_ShapeCustom_SweptToElementary self, TopoDS_Edge E, TopoDS_Face F1, TopoDS_Face F2, TopoDS_Edge NewE, TopoDS_Face NewF1, TopoDS_Face NewF2) -> GeomAbs_Shape

        Returns the  continuity of  <NewE> between <NewF1>
        and <NewF2>.

        <NewE> is the new  edge created from <E>.  <NewF1>
        (resp. <NewF2>) is the new  face created from <F1>
        (resp. <F2>).

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewE: OCC.wrapper.TopoDS.TopoDS_Edge
        :type NewF1: OCC.wrapper.TopoDS.TopoDS_Face
        :type NewF2: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.GeomAbs.GeomAbs_Shape

        """
        return _ShapeCustom.Handle_ShapeCustom_SweptToElementary_Continuity(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_ShapeCustom_SweptToElementary self) -> char const *

        :rtype: const char *

        """
        return _ShapeCustom.Handle_ShapeCustom_SweptToElementary_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeCustom.Handle_ShapeCustom_SweptToElementary_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _ShapeCustom.Handle_ShapeCustom_SweptToElementary_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetMsgRegistrator(self, *args):
        """
        SetMsgRegistrator(Handle_ShapeCustom_SweptToElementary self, Handle_ShapeExtend_BasicMsgRegistrator msgreg)

        Sets message registrator

        :type msgreg: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeCustom.Handle_ShapeCustom_SweptToElementary_SetMsgRegistrator(self, *args)


    def MsgRegistrator(self, *args):
        """
        MsgRegistrator(Handle_ShapeCustom_SweptToElementary self) -> Handle_ShapeExtend_BasicMsgRegistrator

        Returns message registrator

        :rtype: OCC.wrapper.ShapeExtend.Handle_ShapeExtend_BasicMsgRegistrator

        """
        return _ShapeCustom.Handle_ShapeCustom_SweptToElementary_MsgRegistrator(self, *args)


    def SendMsg(self, *args):
        """
        SendMsg(Handle_ShapeCustom_SweptToElementary self, TopoDS_Shape shape, Message_Msg message, Message_Gravity const gravity=Message_Info)

        Sends a message to be attached to the shape.
        Calls corresponding message of message registrator.

        :type shape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type message: OCC.wrapper.Message.Message_Msg
        :type gravity: OCC.wrapper.Message.Message_Gravity

        """
        return _ShapeCustom.Handle_ShapeCustom_SweptToElementary_SendMsg(self, *args)


    def NewTriangulation(self, *args):
        """
        NewTriangulation(Handle_ShapeCustom_SweptToElementary self, TopoDS_Face F, Handle_Poly_Triangulation T) -> Standard_Boolean

        Returns true if the face has been modified according to changed triangulation.
        If the face has been modified:
        - T is a new triangulation on the face

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type T: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_SweptToElementary_NewTriangulation(self, *args)


    def NewPolygon(self, *args):
        """
        NewPolygon(Handle_ShapeCustom_SweptToElementary self, TopoDS_Edge E, Handle_Poly_Polygon3D P) -> Standard_Boolean

        Returns true if the edge has been modified according to changed polygon.
        If the edge has been modified:
        - P is a new polygon

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type P: OCC.wrapper.Poly.Handle_Poly_Polygon3D
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_SweptToElementary_NewPolygon(self, *args)


    def NewPolygonOnTriangulation(self, *args):
        """
        NewPolygonOnTriangulation(Handle_ShapeCustom_SweptToElementary self, TopoDS_Edge E, TopoDS_Face F, Handle_Poly_PolygonOnTriangulation P) -> Standard_Boolean

        Returns true if the edge has been modified according to changed polygon on triangulation.
        If the edge has been modified:
        - P is a new polygon on triangulation

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type P: OCC.wrapper.Poly.Handle_Poly_PolygonOnTriangulation
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_SweptToElementary_NewPolygonOnTriangulation(self, *args)


    def Delete(self, *args):
        """
        Delete(Handle_ShapeCustom_SweptToElementary self)

        Memory deallocator for transient classes


        """
        return _ShapeCustom.Handle_ShapeCustom_SweptToElementary_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_ShapeCustom_SweptToElementary self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_ShapeCustom_SweptToElementary self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_SweptToElementary_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_ShapeCustom_SweptToElementary self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_ShapeCustom_SweptToElementary self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.Handle_ShapeCustom_SweptToElementary_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_ShapeCustom_SweptToElementary self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _ShapeCustom.Handle_ShapeCustom_SweptToElementary_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_ShapeCustom_SweptToElementary self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeCustom.Handle_ShapeCustom_SweptToElementary_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_ShapeCustom_SweptToElementary self)

        Increments the reference counter of this object


        """
        return _ShapeCustom.Handle_ShapeCustom_SweptToElementary_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_ShapeCustom_SweptToElementary self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _ShapeCustom.Handle_ShapeCustom_SweptToElementary_DecrementRefCounter(self, *args)

Handle_ShapeCustom_SweptToElementary_swigregister = _ShapeCustom.Handle_ShapeCustom_SweptToElementary_swigregister
Handle_ShapeCustom_SweptToElementary_swigregister(Handle_ShapeCustom_SweptToElementary)

def Handle_ShapeCustom_SweptToElementary_DownCast(thing):
    return _ShapeCustom.Handle_ShapeCustom_SweptToElementary_DownCast(thing)
Handle_ShapeCustom_SweptToElementary_DownCast = _ShapeCustom.Handle_ShapeCustom_SweptToElementary_DownCast

class ShapeCustom_Curve2d(object):
    """
    Converts curve2d to analytical form with given
    precision or simpify curve2d.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def IsLinear(*args):
        """
        IsLinear(NCollection_Array1_gp_Pnt2d thePoles, Standard_Real const theTolerance) -> Standard_Boolean

        Check if poleses is in the plane with given precision
        Returns false if no.

        :type thePoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
        :type theTolerance: float
        :type theDeviation: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_Curve2d_IsLinear(*args)

    IsLinear = staticmethod(IsLinear)

    def ConvertToLine2d(*args):
        """
        ConvertToLine2d(Handle_Geom2d_Curve theCurve, Standard_Real const theFirstIn, Standard_Real const theLastIn, Standard_Real const theTolerance) -> Handle_Geom2d_Line

        Try to convert BSpline2d or Bezier2d to line 2d
        only if it is linear. Recalculate first and last parameters.
        Returns line2d or null curve2d.

        :type theCurve: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type theFirstIn: float
        :type theLastIn: float
        :type theTolerance: float
        :type theNewFirst: float
        :type theNewLast: float
        :type theDeviation: float
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Line

        """
        return _ShapeCustom.ShapeCustom_Curve2d_ConvertToLine2d(*args)

    ConvertToLine2d = staticmethod(ConvertToLine2d)

    def SimplifyBSpline2d(*args):
        """
        SimplifyBSpline2d(Handle_Geom2d_BSplineCurve theBSpline2d, Standard_Real const theTolerance) -> Standard_Boolean

        Try to remove knots from bspline where local derivatives are the same.
        Remove knots with given precision.
        Returns false if Bsplien was not modified

        :type theBSpline2d: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve
        :type theTolerance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _ShapeCustom.ShapeCustom_Curve2d_SimplifyBSpline2d(*args)

    SimplifyBSpline2d = staticmethod(SimplifyBSpline2d)

    def __init__(self):
        """
        Converts curve2d to analytical form with given
        precision or simpify curve2d.
        """
        this = _ShapeCustom.new_ShapeCustom_Curve2d()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _ShapeCustom.delete_ShapeCustom_Curve2d
ShapeCustom_Curve2d_swigregister = _ShapeCustom.ShapeCustom_Curve2d_swigregister
ShapeCustom_Curve2d_swigregister(ShapeCustom_Curve2d)

def ShapeCustom_Curve2d_IsLinear(*args):
    """
    ShapeCustom_Curve2d_IsLinear(NCollection_Array1_gp_Pnt2d thePoles, Standard_Real const theTolerance) -> Standard_Boolean

    Check if poleses is in the plane with given precision
    Returns false if no.

    :type thePoles: OCC.wrapper.TColgp.TColgp_Array1OfPnt2d
    :type theTolerance: float
    :type theDeviation: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _ShapeCustom.ShapeCustom_Curve2d_IsLinear(*args)

def ShapeCustom_Curve2d_ConvertToLine2d(*args):
    """
    ShapeCustom_Curve2d_ConvertToLine2d(Handle_Geom2d_Curve theCurve, Standard_Real const theFirstIn, Standard_Real const theLastIn, Standard_Real const theTolerance) -> Handle_Geom2d_Line

    Try to convert BSpline2d or Bezier2d to line 2d
    only if it is linear. Recalculate first and last parameters.
    Returns line2d or null curve2d.

    :type theCurve: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
    :type theFirstIn: float
    :type theLastIn: float
    :type theTolerance: float
    :type theNewFirst: float
    :type theNewLast: float
    :type theDeviation: float
    :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Line

    """
    return _ShapeCustom.ShapeCustom_Curve2d_ConvertToLine2d(*args)

def ShapeCustom_Curve2d_SimplifyBSpline2d(*args):
    """
    ShapeCustom_Curve2d_SimplifyBSpline2d(Handle_Geom2d_BSplineCurve theBSpline2d, Standard_Real const theTolerance) -> Standard_Boolean

    Try to remove knots from bspline where local derivatives are the same.
    Remove knots with given precision.
    Returns false if Bsplien was not modified

    :type theBSpline2d: OCC.wrapper.Geom2d.Handle_Geom2d_BSplineCurve
    :type theTolerance: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _ShapeCustom.ShapeCustom_Curve2d_SimplifyBSpline2d(*args)




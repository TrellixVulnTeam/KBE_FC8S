# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_Precision')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_Precision')
    _Precision = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_Precision', [dirname(__file__)])
        except ImportError:
            import _Precision
            return _Precision
        try:
            _mod = imp.load_module('_Precision', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _Precision = swig_import_helper()
    del swig_import_helper
else:
    import _Precision
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _Precision.delete_SwigPyIterator

    def value(self):
        return _Precision.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _Precision.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _Precision.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _Precision.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _Precision.SwigPyIterator_equal(self, x)

    def copy(self):
        return _Precision.SwigPyIterator_copy(self)

    def next(self):
        return _Precision.SwigPyIterator_next(self)

    def __next__(self):
        return _Precision.SwigPyIterator___next__(self)

    def previous(self):
        return _Precision.SwigPyIterator_previous(self)

    def advance(self, n):
        return _Precision.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _Precision.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _Precision.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _Precision.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _Precision.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _Precision.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _Precision.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _Precision.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Precision.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_Precision.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _Precision.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Precision.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Precision.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _Precision.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _Precision.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _Precision.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _Precision.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_Precision.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _Precision.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _Precision.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Precision.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _Precision.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _Precision.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _Precision.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _Precision.ptr_to_number(item)
ptr_to_number = _Precision.ptr_to_number

def HashCode(*args):
    return _Precision.HashCode(*args)
HashCode = _Precision.HashCode

def ptr_equal(a, b):
    return _Precision.ptr_equal(a, b)
ptr_equal = _Precision.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
class Precision_(object):
    """
    The Precision package offers a set of functions defining precision criteria
    for use in conventional situations when comparing two numbers.
    Generalities
    It is not advisable to use floating number equality. Instead, the difference
    between numbers must be compared with a given precision, i.e. :
    Standard_Real x1, x2 ;
    x1 = ...
    x2 = ...
    If ( x1 == x2 ) ...
    should not be used and must be written as indicated below:
    Standard_Real x1, x2 ;
    Standard_Real Precision = ...
    x1 = ...
    x2 = ...
    If ( Abs ( x1 - x2 ) < Precision ) ...
    Likewise, when ordering floating numbers, you must take the following into account :
    Standard_Real x1, x2 ;
    Standard_Real Precision = ...
    x1 = ...       ! a large number
    x2 = ...       ! another large number
    If ( x1 < x2 - Precision ) ...
    is incorrect when x1 and x2 are large numbers ; it is better to write :
    Standard_Real x1, x2 ;
    Standard_Real Precision = ...
    x1 = ...       ! a large number
    x2 = ...       ! another large number
    If ( x2 - x1 > Precision ) ...
    Precision in Cas.Cade
    Generally speaking, the precision criterion is not implicit in Cas.Cade. Low-level geometric algorithms accept
    precision criteria as arguments. As a rule, they should not refer directly to the precision criteria provided by the
    Precision package.
    On the other hand, high-level modeling algorithms have to provide the low-level geometric algorithms that they
    call, with a precision criteria. One way of doing this is to use the above precision criteria.
    Alternatively, the high-level algorithms can have their own system for precision management. For example, the
    Topology Data Structure stores precision criteria for each elementary shape (as a vertex, an edge or a face). When
    a new topological object is constructed, the precision criteria are taken from those provided by the Precision
    package, and stored in the related data structure. Later, a topological algorithm which analyses these objects will
    work with the values stored in the data structure. Also, if this algorithm is to build a new topological object, from
    these precision criteria, it will compute a new precision criterion for the new topological object, and write it into the
    data structure of the new topological object.
    The different precision criteria offered by the Precision package, cover the most common requirements of
    geometric algorithms, such as intersections, approximations, and so on.
    The choice of precision depends on the algorithm and on the geometric space. The geometric space may be :
    -   a "real" 2D or 3D space, where the lengths are measured in meters, millimeters, microns, inches, etc ..., or
    -   a "parametric" space, 1D on a curve or 2D on a surface, where lengths have no dimension.
    The choice of precision criteria for real space depends on the choice of the product, as it is based on the accuracy
    of the machine and the unit of measurement.
    The choice of precision criteria for parametric space depends on both the accuracy of the machine and the
    dimensions of the curve or the surface, since the parametric precision criterion and the real precision criterion are
    linked : if the curve is defined by the equation P(t), the inequation :
    Abs ( t2 - t1 ) < ParametricPrecision
    means that the parameters t1 and t2 are considered to be equal, and the inequation :
    Distance ( P(t2) , P(t1) ) < RealPrecision
    means that the points P(t1) and P(t2) are considered to be coincident. It seems to be the same idea, and it
    would be wonderful if these two inequations were equivalent. Note that this is rarely the case !
    What is provided in this package?
    The Precision package provides :
    -   a set of real space precision criteria for the algorithms, in view of checking distances and angles,
    -   a set of parametric space precision criteria for the algorithms, in view of checking both :
    -   the equality of parameters in a parametric space,
    -   or the coincidence of points in the real space, by using parameter values,
    -   the notion of infinite value, composed of a value assumed to be infinite, and checking tests designed to verify
    if any value could be considered as infinite.
    All the provided functions are very simple. The returned values result from the adaptation of the applications
    developed by the Open CASCADE company to Open CASCADE algorithms. The main interest of these functions
    lies in that it incites engineers developing applications to ask questions on precision factors. Which one is to be
    used in such or such case ? Tolerance criteria are context dependent. They must first choose :
    -   either to work in real space,
    -   or to work in parametric space,
    -   or to work in a combined real and parametric space.
    They must next decide which precision factor will give the best answer to the current problem. Within an application
    environment, it is crucial to master precision even though this process may take a great deal of time.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Angular(*args):
        """
        Angular() -> Standard_Real

        Returns the recommended precision value
        when checking the equality of two angles (given in radians).
        Standard_Real Angle1 = ... , Angle2 = ... ;
        If ( Abs( Angle2 - Angle1 ) < Precision::Angular() ) ...
        The tolerance of angular equality may be used to check the parallelism of two vectors :
        gp_Vec V1, V2 ;
        V1 = ...
        V2 = ...
        If ( V1.IsParallel (V2, Precision::Angular() ) ) ...
        The tolerance of angular equality is equal to 1.e-12.
        Note : The tolerance of angular equality can be used when working with scalar products or
        cross products since sines and angles are equivalent for small angles. Therefore, in order to
        check whether two unit vectors are perpendicular :
        gp_Dir D1, D2 ;
        D1 = ...
        D2 = ...
        you can use :
        If ( Abs( D1.D2 ) < Precision::Angular() ) ...
        (although the function IsNormal does exist).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Precision.Precision__Angular(*args)

    Angular = staticmethod(Angular)

    def Confusion(*args):
        """
        Confusion() -> Standard_Real

        Returns the recommended precision value when
        checking coincidence of two points in real space.
        The tolerance of confusion is used for testing a 3D
        distance :
        -   Two points are considered to be coincident if their
        distance is smaller than the tolerance of confusion.
        gp_Pnt P1, P2 ;
        P1 = ...
        P2 = ...
        if ( P1.IsEqual ( P2 , Precision::Confusion() ) )
        then ...
        -   A vector is considered to be null if it has a null length :
        gp_Vec V ;
        V = ...
        if ( V.Magnitude() < Precision::Confusion() ) then ...
        The tolerance of confusion is equal to 1.e-7.
        The value of the tolerance of confusion is also used to
        define :
        -   the tolerance of intersection, and
        -   the tolerance of approximation.
        Note : As a rule, coordinate values in Cas.Cade are not
        dimensioned, so 1. represents one user unit, whatever
        value the unit may have : the millimeter, the meter, the
        inch, or any other unit. Let's say that Cas.Cade
        algorithms are written to be tuned essentially with
        mechanical design applications, on the basis of the
        millimeter. However, these algorithms may be used with
        any other unit but the tolerance criterion does no longer
        have the same signification.
        So pay particular attention to the type of your application,
        in relation with the impact of your unit on the precision criterion.
        -   For example in mechanical design, if the unit is the
        millimeter, the tolerance of confusion corresponds to a
        distance of 1 / 10000 micron, which is rather difficult to measure.
        -   However in other types of applications, such as
        cartography, where the kilometer is frequently used,
        the tolerance of confusion corresponds to a greater
        distance (1 / 10 millimeter). This distance
        becomes easily measurable, but only within a restricted
        space which contains some small objects of the complete scene.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Precision.Precision__Confusion(*args)

    Confusion = staticmethod(Confusion)

    def SquareConfusion(*args):
        """
        SquareConfusion() -> Standard_Real

        Returns square of Confusion.
        Created for speed and convenience.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Precision.Precision__SquareConfusion(*args)

    SquareConfusion = staticmethod(SquareConfusion)

    def Intersection(*args):
        """
        Intersection() -> Standard_Real

        Returns the precision value in real space, frequently
        used by intersection algorithms to decide that a solution is reached.
        This function provides an acceptable level of precision
        for an intersection process to define the adjustment limits.
        The tolerance of intersection is designed to ensure
        that a point computed by an iterative algorithm as the
        intersection between two curves is indeed on the
        intersection. It is obvious that two tangent curves are
        close to each other, on a large distance. An iterative
        algorithm of intersection may find points on these
        curves within the scope of the confusion tolerance, but
        still far from the true intersection point. In order to force
        the intersection algorithm to continue the iteration
        process until a correct point is found on the tangent
        objects, the tolerance of intersection must be smaller
        than the tolerance of confusion.
        On the other hand, the tolerance of intersection must
        be large enough to minimize the time required by the
        process to converge to a solution.
        The tolerance of intersection is equal to :
        Precision::Confusion() / 100.
        (that is, 1.e-9).

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Precision.Precision__Intersection(*args)

    Intersection = staticmethod(Intersection)

    def Approximation(*args):
        """
        Approximation() -> Standard_Real

        Returns the precision value in real space, frequently used
        by approximation algorithms.
        This function provides an acceptable level of precision for
        an approximation process to define adjustment limits.
        The tolerance of approximation is designed to ensure
        an acceptable computation time when performing an
        approximation process. That is why the tolerance of
        approximation is greater than the tolerance of confusion.
        The tolerance of approximation is equal to :
        Precision::Confusion() * 10.
        (that is, 1.e-6).
        You may use a smaller tolerance in an approximation
        algorithm, but this option might be costly.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Precision.Precision__Approximation(*args)

    Approximation = staticmethod(Approximation)

    def SquarePConfusion(*args):
        """
        SquarePConfusion() -> Standard_Real

        Returns square of PConfusion.
        Created for speed and convenience.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Precision.Precision__SquarePConfusion(*args)

    SquarePConfusion = staticmethod(SquarePConfusion)

    def Parametric(*args):
        """
        Parametric(Standard_Real const P, Standard_Real const T) -> Standard_Real
        Parametric(Standard_Real const P) -> Standard_Real

        Convert a real  space precision  to  a  parametric
        space precision on a default curve.

        Value is Parametric(P,1.e+2)

        :type P: float
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Precision.Precision__Parametric(*args)

    Parametric = staticmethod(Parametric)

    def PConfusion(*args):
        """
        PConfusion(Standard_Real const T) -> Standard_Real
        PConfusion() -> Standard_Real

        Used  to test distances  in parametric  space on a
        default curve.

        This is Precision::Parametric(Precision::Confusion())

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Precision.Precision__PConfusion(*args)

    PConfusion = staticmethod(PConfusion)

    def PIntersection(*args):
        """
        PIntersection(Standard_Real const T) -> Standard_Real
        PIntersection() -> Standard_Real

        Used for Intersections  in parametric  space  on a
        default curve.

        This is Precision::Parametric(Precision::Intersection())

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Precision.Precision__PIntersection(*args)

    PIntersection = staticmethod(PIntersection)

    def PApproximation(*args):
        """
        PApproximation(Standard_Real const T) -> Standard_Real
        PApproximation() -> Standard_Real

        Used for  Approximations  in parametric space on a
        default curve.

        This is Precision::Parametric(Precision::Approximation())

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Precision.Precision__PApproximation(*args)

    PApproximation = staticmethod(PApproximation)

    def IsInfinite(*args):
        """
        IsInfinite(Standard_Real const R) -> Standard_Boolean

        Returns True if R may be considered as an infinite
        number. Currently Abs(R) > 1e100

        :type R: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Precision.Precision__IsInfinite(*args)

    IsInfinite = staticmethod(IsInfinite)

    def IsPositiveInfinite(*args):
        """
        IsPositiveInfinite(Standard_Real const R) -> Standard_Boolean

        Returns True if R may be considered as  a positive
        infinite number. Currently R > 1e100

        :type R: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Precision.Precision__IsPositiveInfinite(*args)

    IsPositiveInfinite = staticmethod(IsPositiveInfinite)

    def IsNegativeInfinite(*args):
        """
        IsNegativeInfinite(Standard_Real const R) -> Standard_Boolean

        Returns True if R may  be considered as a negative
        infinite number. Currently R < -1e100

        :type R: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _Precision.Precision__IsNegativeInfinite(*args)

    IsNegativeInfinite = staticmethod(IsNegativeInfinite)

    def Infinite(*args):
        """
        Infinite() -> Standard_Real

        Returns a  big number that  can  be  considered as
        infinite. Use -Infinite() for a negative big number.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _Precision.Precision__Infinite(*args)

    Infinite = staticmethod(Infinite)

    def __init__(self):
        """
        The Precision package offers a set of functions defining precision criteria
        for use in conventional situations when comparing two numbers.
        Generalities
        It is not advisable to use floating number equality. Instead, the difference
        between numbers must be compared with a given precision, i.e. :
        Standard_Real x1, x2 ;
        x1 = ...
        x2 = ...
        If ( x1 == x2 ) ...
        should not be used and must be written as indicated below:
        Standard_Real x1, x2 ;
        Standard_Real Precision = ...
        x1 = ...
        x2 = ...
        If ( Abs ( x1 - x2 ) < Precision ) ...
        Likewise, when ordering floating numbers, you must take the following into account :
        Standard_Real x1, x2 ;
        Standard_Real Precision = ...
        x1 = ...       ! a large number
        x2 = ...       ! another large number
        If ( x1 < x2 - Precision ) ...
        is incorrect when x1 and x2 are large numbers ; it is better to write :
        Standard_Real x1, x2 ;
        Standard_Real Precision = ...
        x1 = ...       ! a large number
        x2 = ...       ! another large number
        If ( x2 - x1 > Precision ) ...
        Precision in Cas.Cade
        Generally speaking, the precision criterion is not implicit in Cas.Cade. Low-level geometric algorithms accept
        precision criteria as arguments. As a rule, they should not refer directly to the precision criteria provided by the
        Precision package.
        On the other hand, high-level modeling algorithms have to provide the low-level geometric algorithms that they
        call, with a precision criteria. One way of doing this is to use the above precision criteria.
        Alternatively, the high-level algorithms can have their own system for precision management. For example, the
        Topology Data Structure stores precision criteria for each elementary shape (as a vertex, an edge or a face). When
        a new topological object is constructed, the precision criteria are taken from those provided by the Precision
        package, and stored in the related data structure. Later, a topological algorithm which analyses these objects will
        work with the values stored in the data structure. Also, if this algorithm is to build a new topological object, from
        these precision criteria, it will compute a new precision criterion for the new topological object, and write it into the
        data structure of the new topological object.
        The different precision criteria offered by the Precision package, cover the most common requirements of
        geometric algorithms, such as intersections, approximations, and so on.
        The choice of precision depends on the algorithm and on the geometric space. The geometric space may be :
        -   a "real" 2D or 3D space, where the lengths are measured in meters, millimeters, microns, inches, etc ..., or
        -   a "parametric" space, 1D on a curve or 2D on a surface, where lengths have no dimension.
        The choice of precision criteria for real space depends on the choice of the product, as it is based on the accuracy
        of the machine and the unit of measurement.
        The choice of precision criteria for parametric space depends on both the accuracy of the machine and the
        dimensions of the curve or the surface, since the parametric precision criterion and the real precision criterion are
        linked : if the curve is defined by the equation P(t), the inequation :
        Abs ( t2 - t1 ) < ParametricPrecision
        means that the parameters t1 and t2 are considered to be equal, and the inequation :
        Distance ( P(t2) , P(t1) ) < RealPrecision
        means that the points P(t1) and P(t2) are considered to be coincident. It seems to be the same idea, and it
        would be wonderful if these two inequations were equivalent. Note that this is rarely the case !
        What is provided in this package?
        The Precision package provides :
        -   a set of real space precision criteria for the algorithms, in view of checking distances and angles,
        -   a set of parametric space precision criteria for the algorithms, in view of checking both :
        -   the equality of parameters in a parametric space,
        -   or the coincidence of points in the real space, by using parameter values,
        -   the notion of infinite value, composed of a value assumed to be infinite, and checking tests designed to verify
        if any value could be considered as infinite.
        All the provided functions are very simple. The returned values result from the adaptation of the applications
        developed by the Open CASCADE company to Open CASCADE algorithms. The main interest of these functions
        lies in that it incites engineers developing applications to ask questions on precision factors. Which one is to be
        used in such or such case ? Tolerance criteria are context dependent. They must first choose :
        -   either to work in real space,
        -   or to work in parametric space,
        -   or to work in a combined real and parametric space.
        They must next decide which precision factor will give the best answer to the current problem. Within an application
        environment, it is crucial to master precision even though this process may take a great deal of time.
        """
        this = _Precision.new_Precision_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _Precision.delete_Precision_
Precision__swigregister = _Precision.Precision__swigregister
Precision__swigregister(Precision_)

def Precision__Angular(*args):
    """
    Precision__Angular() -> Standard_Real

    Returns the recommended precision value
    when checking the equality of two angles (given in radians).
    Standard_Real Angle1 = ... , Angle2 = ... ;
    If ( Abs( Angle2 - Angle1 ) < Precision::Angular() ) ...
    The tolerance of angular equality may be used to check the parallelism of two vectors :
    gp_Vec V1, V2 ;
    V1 = ...
    V2 = ...
    If ( V1.IsParallel (V2, Precision::Angular() ) ) ...
    The tolerance of angular equality is equal to 1.e-12.
    Note : The tolerance of angular equality can be used when working with scalar products or
    cross products since sines and angles are equivalent for small angles. Therefore, in order to
    check whether two unit vectors are perpendicular :
    gp_Dir D1, D2 ;
    D1 = ...
    D2 = ...
    you can use :
    If ( Abs( D1.D2 ) < Precision::Angular() ) ...
    (although the function IsNormal does exist).

    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Precision.Precision__Angular(*args)

def Precision__Confusion(*args):
    """
    Precision__Confusion() -> Standard_Real

    Returns the recommended precision value when
    checking coincidence of two points in real space.
    The tolerance of confusion is used for testing a 3D
    distance :
    -   Two points are considered to be coincident if their
    distance is smaller than the tolerance of confusion.
    gp_Pnt P1, P2 ;
    P1 = ...
    P2 = ...
    if ( P1.IsEqual ( P2 , Precision::Confusion() ) )
    then ...
    -   A vector is considered to be null if it has a null length :
    gp_Vec V ;
    V = ...
    if ( V.Magnitude() < Precision::Confusion() ) then ...
    The tolerance of confusion is equal to 1.e-7.
    The value of the tolerance of confusion is also used to
    define :
    -   the tolerance of intersection, and
    -   the tolerance of approximation.
    Note : As a rule, coordinate values in Cas.Cade are not
    dimensioned, so 1. represents one user unit, whatever
    value the unit may have : the millimeter, the meter, the
    inch, or any other unit. Let's say that Cas.Cade
    algorithms are written to be tuned essentially with
    mechanical design applications, on the basis of the
    millimeter. However, these algorithms may be used with
    any other unit but the tolerance criterion does no longer
    have the same signification.
    So pay particular attention to the type of your application,
    in relation with the impact of your unit on the precision criterion.
    -   For example in mechanical design, if the unit is the
    millimeter, the tolerance of confusion corresponds to a
    distance of 1 / 10000 micron, which is rather difficult to measure.
    -   However in other types of applications, such as
    cartography, where the kilometer is frequently used,
    the tolerance of confusion corresponds to a greater
    distance (1 / 10 millimeter). This distance
    becomes easily measurable, but only within a restricted
    space which contains some small objects of the complete scene.

    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Precision.Precision__Confusion(*args)

def Precision__SquareConfusion(*args):
    """
    Precision__SquareConfusion() -> Standard_Real

    Returns square of Confusion.
    Created for speed and convenience.

    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Precision.Precision__SquareConfusion(*args)

def Precision__Intersection(*args):
    """
    Precision__Intersection() -> Standard_Real

    Returns the precision value in real space, frequently
    used by intersection algorithms to decide that a solution is reached.
    This function provides an acceptable level of precision
    for an intersection process to define the adjustment limits.
    The tolerance of intersection is designed to ensure
    that a point computed by an iterative algorithm as the
    intersection between two curves is indeed on the
    intersection. It is obvious that two tangent curves are
    close to each other, on a large distance. An iterative
    algorithm of intersection may find points on these
    curves within the scope of the confusion tolerance, but
    still far from the true intersection point. In order to force
    the intersection algorithm to continue the iteration
    process until a correct point is found on the tangent
    objects, the tolerance of intersection must be smaller
    than the tolerance of confusion.
    On the other hand, the tolerance of intersection must
    be large enough to minimize the time required by the
    process to converge to a solution.
    The tolerance of intersection is equal to :
    Precision::Confusion() / 100.
    (that is, 1.e-9).

    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Precision.Precision__Intersection(*args)

def Precision__Approximation(*args):
    """
    Precision__Approximation() -> Standard_Real

    Returns the precision value in real space, frequently used
    by approximation algorithms.
    This function provides an acceptable level of precision for
    an approximation process to define adjustment limits.
    The tolerance of approximation is designed to ensure
    an acceptable computation time when performing an
    approximation process. That is why the tolerance of
    approximation is greater than the tolerance of confusion.
    The tolerance of approximation is equal to :
    Precision::Confusion() * 10.
    (that is, 1.e-6).
    You may use a smaller tolerance in an approximation
    algorithm, but this option might be costly.

    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Precision.Precision__Approximation(*args)

def Precision__SquarePConfusion(*args):
    """
    Precision__SquarePConfusion() -> Standard_Real

    Returns square of PConfusion.
    Created for speed and convenience.

    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Precision.Precision__SquarePConfusion(*args)

def Precision__Parametric(*args):
    """
    Parametric(Standard_Real const P, Standard_Real const T) -> Standard_Real
    Precision__Parametric(Standard_Real const P) -> Standard_Real

    Convert a real  space precision  to  a  parametric
    space precision on a default curve.

    Value is Parametric(P,1.e+2)

    :type P: float
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Precision.Precision__Parametric(*args)

def Precision__PConfusion(*args):
    """
    PConfusion(Standard_Real const T) -> Standard_Real
    Precision__PConfusion() -> Standard_Real

    Used  to test distances  in parametric  space on a
    default curve.

    This is Precision::Parametric(Precision::Confusion())

    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Precision.Precision__PConfusion(*args)

def Precision__PIntersection(*args):
    """
    PIntersection(Standard_Real const T) -> Standard_Real
    Precision__PIntersection() -> Standard_Real

    Used for Intersections  in parametric  space  on a
    default curve.

    This is Precision::Parametric(Precision::Intersection())

    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Precision.Precision__PIntersection(*args)

def Precision__PApproximation(*args):
    """
    PApproximation(Standard_Real const T) -> Standard_Real
    Precision__PApproximation() -> Standard_Real

    Used for  Approximations  in parametric space on a
    default curve.

    This is Precision::Parametric(Precision::Approximation())

    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Precision.Precision__PApproximation(*args)

def Precision__IsInfinite(*args):
    """
    Precision__IsInfinite(Standard_Real const R) -> Standard_Boolean

    Returns True if R may be considered as an infinite
    number. Currently Abs(R) > 1e100

    :type R: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Precision.Precision__IsInfinite(*args)

def Precision__IsPositiveInfinite(*args):
    """
    Precision__IsPositiveInfinite(Standard_Real const R) -> Standard_Boolean

    Returns True if R may be considered as  a positive
    infinite number. Currently R > 1e100

    :type R: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Precision.Precision__IsPositiveInfinite(*args)

def Precision__IsNegativeInfinite(*args):
    """
    Precision__IsNegativeInfinite(Standard_Real const R) -> Standard_Boolean

    Returns True if R may  be considered as a negative
    infinite number. Currently R < -1e100

    :type R: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _Precision.Precision__IsNegativeInfinite(*args)

def Precision__Infinite(*args):
    """
    Precision__Infinite() -> Standard_Real

    Returns a  big number that  can  be  considered as
    infinite. Use -Infinite() for a negative big number.

    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _Precision.Precision__Infinite(*args)




# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BRepFeat')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BRepFeat')
    _BRepFeat = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BRepFeat', [dirname(__file__)])
        except ImportError:
            import _BRepFeat
            return _BRepFeat
        try:
            _mod = imp.load_module('_BRepFeat', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BRepFeat = swig_import_helper()
    del swig_import_helper
else:
    import _BRepFeat
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BRepFeat.delete_SwigPyIterator

    def value(self):
        return _BRepFeat.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _BRepFeat.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _BRepFeat.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _BRepFeat.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _BRepFeat.SwigPyIterator_equal(self, x)

    def copy(self):
        return _BRepFeat.SwigPyIterator_copy(self)

    def next(self):
        return _BRepFeat.SwigPyIterator_next(self)

    def __next__(self):
        return _BRepFeat.SwigPyIterator___next__(self)

    def previous(self):
        return _BRepFeat.SwigPyIterator_previous(self)

    def advance(self, n):
        return _BRepFeat.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _BRepFeat.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _BRepFeat.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _BRepFeat.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _BRepFeat.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _BRepFeat.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _BRepFeat.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _BRepFeat.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepFeat.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_BRepFeat.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepFeat.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepFeat.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepFeat.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _BRepFeat.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _BRepFeat.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _BRepFeat.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepFeat.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_BRepFeat.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepFeat.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepFeat.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepFeat.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _BRepFeat.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _BRepFeat.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _BRepFeat.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _BRepFeat.ptr_to_number(item)
ptr_to_number = _BRepFeat.ptr_to_number

def HashCode(*args):
    return _BRepFeat.HashCode(*args)
HashCode = _BRepFeat.HashCode

def ptr_equal(a, b):
    return _BRepFeat.ptr_equal(a, b)
ptr_equal = _BRepFeat.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BOPAlgo
else:
    import BOPAlgo
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BOPTools
else:
    import BOPTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntTools
else:
    import IntTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAPI
else:
    import GeomAPI
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Approx
else:
    import Approx
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppCont
else:
    import AppCont
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppParCurves
else:
    import AppParCurves
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AdvApprox
else:
    import AdvApprox
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import PLib
else:
    import PLib
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Extrema
else:
    import Extrema
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dHatch
else:
    import Geom2dHatch
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import HatchGen
else:
    import HatchGen
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntRes2d
else:
    import IntRes2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dAdaptor
else:
    import Geom2dAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dInt
else:
    import Geom2dInt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Intf
else:
    import Intf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurve
else:
    import IntCurve
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntPatch
else:
    import IntPatch
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntSurf
else:
    import IntSurf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntAna
else:
    import IntAna
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntWalk
else:
    import IntWalk
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntImp
else:
    import IntImp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepClass3d
else:
    import BRepClass3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurveSurface
else:
    import IntCurveSurface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurvesFace
else:
    import IntCurvesFace
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepAdaptor
else:
    import BRepAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomInt
else:
    import GeomInt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import ApproxInt
else:
    import ApproxInt
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BOPDS
else:
    import BOPDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepTools
else:
    import BRepTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Poly
else:
    import Poly
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TShort
else:
    import TShort
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRep
else:
    import BRep
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import LocOpe
else:
    import LocOpe
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColGeom
else:
    import TColGeom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepAlgoAPI
else:
    import BRepAlgoAPI
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepBuilderAPI
else:
    import BRepBuilderAPI
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepTopAdaptor
else:
    import BRepTopAdaptor
del _swig_python_version_info
BRepFeat_OK = _BRepFeat.BRepFeat_OK
BRepFeat_BadDirect = _BRepFeat.BRepFeat_BadDirect
BRepFeat_BadIntersect = _BRepFeat.BRepFeat_BadIntersect
BRepFeat_EmptyBaryCurve = _BRepFeat.BRepFeat_EmptyBaryCurve
BRepFeat_EmptyCutResult = _BRepFeat.BRepFeat_EmptyCutResult
BRepFeat_FalseSide = _BRepFeat.BRepFeat_FalseSide
BRepFeat_IncDirection = _BRepFeat.BRepFeat_IncDirection
BRepFeat_IncSlidFace = _BRepFeat.BRepFeat_IncSlidFace
BRepFeat_IncParameter = _BRepFeat.BRepFeat_IncParameter
BRepFeat_IncTypes = _BRepFeat.BRepFeat_IncTypes
BRepFeat_IntervalOverlap = _BRepFeat.BRepFeat_IntervalOverlap
BRepFeat_InvFirstShape = _BRepFeat.BRepFeat_InvFirstShape
BRepFeat_InvOption = _BRepFeat.BRepFeat_InvOption
BRepFeat_InvShape = _BRepFeat.BRepFeat_InvShape
BRepFeat_LocOpeNotDone = _BRepFeat.BRepFeat_LocOpeNotDone
BRepFeat_LocOpeInvNotDone = _BRepFeat.BRepFeat_LocOpeInvNotDone
BRepFeat_NoExtFace = _BRepFeat.BRepFeat_NoExtFace
BRepFeat_NoFaceProf = _BRepFeat.BRepFeat_NoFaceProf
BRepFeat_NoGluer = _BRepFeat.BRepFeat_NoGluer
BRepFeat_NoIntersectF = _BRepFeat.BRepFeat_NoIntersectF
BRepFeat_NoIntersectU = _BRepFeat.BRepFeat_NoIntersectU
BRepFeat_NoParts = _BRepFeat.BRepFeat_NoParts
BRepFeat_NoProjPt = _BRepFeat.BRepFeat_NoProjPt
BRepFeat_NotInitialized = _BRepFeat.BRepFeat_NotInitialized
BRepFeat_NotYetImplemented = _BRepFeat.BRepFeat_NotYetImplemented
BRepFeat_NullRealTool = _BRepFeat.BRepFeat_NullRealTool
BRepFeat_NullToolF = _BRepFeat.BRepFeat_NullToolF
BRepFeat_NullToolU = _BRepFeat.BRepFeat_NullToolU
BRepFeat_NoSelection = _BRepFeat.BRepFeat_NoSelection
BRepFeat_SelectionFU = _BRepFeat.BRepFeat_SelectionFU
BRepFeat_SelectionU = _BRepFeat.BRepFeat_SelectionU
BRepFeat_SelectionSh = _BRepFeat.BRepFeat_SelectionSh
BRepFeat_SelectionShU = _BRepFeat.BRepFeat_SelectionShU
BRepFeat_NoError = _BRepFeat.BRepFeat_NoError
BRepFeat_InvalidPlacement = _BRepFeat.BRepFeat_InvalidPlacement
BRepFeat_HoleTooLong = _BRepFeat.BRepFeat_HoleTooLong
class BRepFeat_Form(BRepBuilderAPI.BRepBuilderAPI_MakeShape):
    """
    Provides general functions to build form features.
    Form features can be depressions or protrusions and include the following types:
    -          Cylinder
    -          Draft Prism
    -          Prism
    -          Revolved feature
    -          Pipe
    In each case, you have a choice of operation type between the following:
    -          removing matter (a Boolean cut: Fuse setting 0)
    -          adding matter (Boolean fusion: Fuse setting 1)
    The semantics of form feature creation is based on the construction of shapes:
    -      along a length
    -      up to a limiting face
    -      from a limiting face to a  height
    -      above and/or below a plane
    The shape defining construction of the feature can be either the
    supporting edge or the concerned area of a face.
    In case of the supporting edge, this contour can be attached to a
    face of the basis shape by binding. When the contour is bound to this
    face, the information that the contour will slide on the face
    becomes available to the relevant class methods. In case of the
    concerned area of a face, you could, for example, cut it out and
    move it to a different height which will define the limiting face of a
    protrusion or depression.
    Topological definition with local operations of this sort makes
    calculations simpler and faster than a global operation. The latter
    would entail a second phase of removing unwanted matter to get the same result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Modified(self, *args):
        """
        returns the list of generated Faces.

        :type F: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepFeat.BRepFeat_Form_Modified(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Generated(self, *args):
        """
        returns a list of the created faces
        from the shape <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepFeat.BRepFeat_Form_Generated(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDeleted(self, *args):
        """
        IsDeleted(BRepFeat_Form self, TopoDS_Shape S) -> Standard_Boolean

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFeat.BRepFeat_Form_IsDeleted(self, *args)


    def FirstShape(self, *args):
        """
        Returns the list  of shapes created  at the bottom  of
        the created form.  It may be an empty list.

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepFeat.BRepFeat_Form_FirstShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LastShape(self, *args):
        """
        Returns  the list of shapes  created at the top of the
        created form.  It may be an empty list.

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepFeat.BRepFeat_Form_LastShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NewEdges(self, *args):
        """
        Returns a list of the limiting and glueing edges
        generated by the feature. These edges did not originally
        exist in the basis shape.
        The list provides the information necessary for
        subsequent addition of fillets. It may be an empty list.

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepFeat.BRepFeat_Form_NewEdges(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TgtEdges(self, *args):
        """
        Returns a list of the tangent edges among the limiting
        and glueing edges generated by the feature. These
        edges did not originally exist in the basis shape and are
        tangent to the face against which the feature is built.
        The list provides the information necessary for
        subsequent addition of fillets. It may be an empty list.
        If an edge is tangent, no fillet is possible, and the edge
        must subsequently be removed if you want to add a fillet.

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepFeat.BRepFeat_Form_TgtEdges(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def BasisShapeValid(self, *args):
        """
        BasisShapeValid(BRepFeat_Form self)

        Initializes the topological construction if the basis shape is present.


        """
        return _BRepFeat.BRepFeat_Form_BasisShapeValid(self, *args)


    def GeneratedShapeValid(self, *args):
        """
        GeneratedShapeValid(BRepFeat_Form self)

        Initializes the topological construction if the generated shape S is present.


        """
        return _BRepFeat.BRepFeat_Form_GeneratedShapeValid(self, *args)


    def ShapeFromValid(self, *args):
        """
        ShapeFromValid(BRepFeat_Form self)

        Initializes the topological construction if the shape is
        present from the specified integer on.


        """
        return _BRepFeat.BRepFeat_Form_ShapeFromValid(self, *args)


    def ShapeUntilValid(self, *args):
        """
        ShapeUntilValid(BRepFeat_Form self)

        Initializes the topological construction if the shape is
        present until the specified integer.


        """
        return _BRepFeat.BRepFeat_Form_ShapeUntilValid(self, *args)


    def GluedFacesValid(self, *args):
        """
        GluedFacesValid(BRepFeat_Form self)

        Initializes the topological construction if the glued face is present.


        """
        return _BRepFeat.BRepFeat_Form_GluedFacesValid(self, *args)


    def SketchFaceValid(self, *args):
        """
        SketchFaceValid(BRepFeat_Form self)

        Initializes the topological construction if the sketch face
        is present. If the sketch face is inside the basis shape,
        local operations such as glueing can be performed.


        """
        return _BRepFeat.BRepFeat_Form_SketchFaceValid(self, *args)


    def PerfSelectionValid(self, *args):
        """
        PerfSelectionValid(BRepFeat_Form self)

        Initializes the topological construction if the selected face is present.


        """
        return _BRepFeat.BRepFeat_Form_PerfSelectionValid(self, *args)


    def Curves(self, *args):
        """
        Curves(BRepFeat_Form self, NCollection_Sequence_Handle_Geom_Curve S)

        :type S: OCC.wrapper.TColGeom.TColGeom_SequenceOfCurve

        """
        return _BRepFeat.BRepFeat_Form_Curves(self, *args)


    def BarycCurve(self, *args):
        """
        BarycCurve(BRepFeat_Form self) -> Handle_Geom_Curve

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _BRepFeat.BRepFeat_Form_BarycCurve(self, *args)


    def CurrentStatusError(self, *args):
        """
        CurrentStatusError(BRepFeat_Form self) -> BRepFeat_StatusError

        :rtype: OCC.wrapper.BRepFeat.BRepFeat_StatusError

        """
        return _BRepFeat.BRepFeat_Form_CurrentStatusError(self, *args)

    __swig_destroy__ = _BRepFeat.delete_BRepFeat_Form
BRepFeat_Form_swigregister = _BRepFeat.BRepFeat_Form_swigregister
BRepFeat_Form_swigregister(BRepFeat_Form)

class BRepFeat_Builder(BOPAlgo.BOPAlgo_BOP):
    """
    Provides a basic tool to implement features topological
    operations. The main goal of the algorithm is to perform
    the result of the operation according to the
    kept parts of the tool.
    Input data: a) DS;
    b) The kept parts of the tool;
    If the map of the kept parts of the tool
    is not filled boolean operation of the
    given type will be performed;
    c) Operation required.
    Steps: a) Fill myShapes, myRemoved maps;
    b) Rebuild edges and faces;
    c) Build images of the object;
    d) Build the result of the operation.
    Result: Result shape of the operation required.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepFeat_Builder self) -> BRepFeat_Builder

        Provides a basic tool to implement features topological
        operations. The main goal of the algorithm is to perform
        the result of the operation according to the
        kept parts of the tool.
        Input data: a) DS;
        b) The kept parts of the tool;
        If the map of the kept parts of the tool
        is not filled boolean operation of the
        given type will be performed;
        c) Operation required.
        Steps: a) Fill myShapes, myRemoved maps;
        b) Rebuild edges and faces;
        c) Build images of the object;
        d) Build the result of the operation.
        Result: Result shape of the operation required.
        """
        this = _BRepFeat.new_BRepFeat_Builder(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Clear(self, *args):
        """
        Clear(BRepFeat_Builder self)

        Clears internal fields and arguments.


        """
        return _BRepFeat.BRepFeat_Builder_Clear(self, *args)


    def Init(self, *args):
        """
        Init(BRepFeat_Builder self, TopoDS_Shape theShape)
        Init(BRepFeat_Builder self, TopoDS_Shape theShape, TopoDS_Shape theTool)

        Initialyzes the arguments of local boolean operation.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theTool: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepFeat.BRepFeat_Builder_Init(self, *args)


    def SetOperation(self, *args):
        """
        SetOperation(BRepFeat_Builder self, Standard_Integer const theFuse)
        SetOperation(BRepFeat_Builder self, Standard_Integer const theFuse, Standard_Boolean const theFlag)

        Sets the operation of local boolean operation.
        If theFlag = TRUE it means that no selection of parts
        of the tool is needed, t.e. no second part. In that case
        if theFuse = 0 than operation is COMMON, otherwise CUT21.
        If theFlag = FALSE SetOperation(theFuse) function  is called.

        :type theFuse: int
        :type theFlag: bool

        """
        return _BRepFeat.BRepFeat_Builder_SetOperation(self, *args)


    def PartsOfTool(self, *args):
        """
        PartsOfTool(BRepFeat_Builder self, NCollection_List_TopoDS_Shape theLT)

        Collects parts of the tool.

        :type theLT: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepFeat.BRepFeat_Builder_PartsOfTool(self, *args)


    def KeepParts(self, *args):
        """
        KeepParts(BRepFeat_Builder self, NCollection_List_TopoDS_Shape theIm)

        Initialyzes parts of the tool for second step of algorithm.
        Collects shapes and all sub-shapes into myShapes map.

        :type theIm: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepFeat.BRepFeat_Builder_KeepParts(self, *args)


    def KeepPart(self, *args):
        """
        KeepPart(BRepFeat_Builder self, TopoDS_Shape theS)

        Adds shape theS and all its sub-shapes into myShapes map.

        :type theS: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepFeat.BRepFeat_Builder_KeepPart(self, *args)


    def PerformResult(self, *args):
        """
        PerformResult(BRepFeat_Builder self)

        Main function to build the result of the
        local operation required.


        """
        return _BRepFeat.BRepFeat_Builder_PerformResult(self, *args)


    def RebuildFaces(self, *args):
        """
        RebuildFaces(BRepFeat_Builder self)

        Rebuilds faces in accordance with the kept parts of the tool.


        """
        return _BRepFeat.BRepFeat_Builder_RebuildFaces(self, *args)


    def RebuildEdge(self, *args):
        """
        RebuildEdge(BRepFeat_Builder self, TopoDS_Shape theE, TopoDS_Face theF, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theME, NCollection_List_TopoDS_Shape aLEIm)

        Rebuilds edges in accordance with the kept parts of the tool.

        :type theE: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theF: OCC.wrapper.TopoDS.TopoDS_Face
        :type theME: OCC.wrapper.TopTools.TopTools_MapOfShape
        :type aLEIm: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepFeat.BRepFeat_Builder_RebuildEdge(self, *args)


    def CheckSolidImages(self, *args):
        """
        CheckSolidImages(BRepFeat_Builder self)

        Collects the images of the object, that contains in
        the images of the tool.


        """
        return _BRepFeat.BRepFeat_Builder_CheckSolidImages(self, *args)


    def FillRemoved(self, *args):
        """
        FillRemoved(BRepFeat_Builder self)
        FillRemoved(BRepFeat_Builder self, TopoDS_Shape theS, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher theM)

        Adds the shape S and its sub-shapes into myRemoved map.

        :type theS: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theM: OCC.wrapper.TopTools.TopTools_MapOfShape

        """
        return _BRepFeat.BRepFeat_Builder_FillRemoved(self, *args)

    __swig_destroy__ = _BRepFeat.delete_BRepFeat_Builder
BRepFeat_Builder_swigregister = _BRepFeat.BRepFeat_Builder_swigregister
BRepFeat_Builder_swigregister(BRepFeat_Builder)

class BRepFeat_RibSlot(BRepBuilderAPI.BRepBuilderAPI_MakeShape):
    """
    Provides functions to build mechanical features.
    Mechanical features include ribs - protrusions and grooves (or slots) - depressions along
    planar (linear) surfaces or revolution surfaces. The semantics of mechanical features is built
    around giving thickness to a contour. This thickness can either be unilateral - on one side
    of the contour - or bilateral - on both sides.
    As in the semantics of form features, the thickness is defined by construction of shapes
    in specific contexts. The development contexts differ, however,in case of mechanical features.
    Here they include extrusion:
    -   to a limiting face of the basis shape
    -   to or from a limiting plane
    -   to a height.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def IsDeleted(self, *args):
        """
        IsDeleted(BRepFeat_RibSlot self, TopoDS_Shape F) -> Standard_Boolean

        Returns true if F a TopoDS_Shape of type edge or face has been deleted.

        :type F: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFeat.BRepFeat_RibSlot_IsDeleted(self, *args)


    def Modified(self, *args):
        """
        Returns the list of generated Faces F. This list may be empty.

        :type F: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepFeat.BRepFeat_RibSlot_Modified(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Generated(self, *args):
        """
        Returns a list TopTools_ListOfShape of the faces S created in the shape.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepFeat.BRepFeat_RibSlot_Generated(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FirstShape(self, *args):
        """
        Returns the list  of shapes created  at the bottom  of
        the created form.  It may be an empty list.

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepFeat.BRepFeat_RibSlot_FirstShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LastShape(self, *args):
        """
        Returns  the list of shapes  created at the top of the
        created form.  It may be an empty list.

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepFeat.BRepFeat_RibSlot_LastShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FacesForDraft(self, *args):
        """
        Returns a list of the limiting and glueing faces
        generated by the feature. These faces did not originally exist in the basis shape.
        The list provides the information necessary for
        subsequent addition of a draft to a face. It may be an empty list.
        If a face has tangent edges, no draft is possible, and the tangent edges must
        subsequently be removed if you want to add a draft to the face.

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepFeat.BRepFeat_RibSlot_FacesForDraft(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NewEdges(self, *args):
        """
        Returns a list of the limiting and glueing edges
        generated by the feature. These edges did not originally exist in the basis shape.
        The list provides the information necessary for
        subsequent addition of fillets. It may be an empty list.

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepFeat.BRepFeat_RibSlot_NewEdges(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TgtEdges(self, *args):
        """
        Returns a list of the tangent edges among the
        limiting and glueing edges generated by the
        feature. These edges did not originally exist in
        the basis shape and are tangent to the face
        against which the feature is built.
        The list provides the information necessary for
        subsequent addition of fillets. It may be an empty list.
        If an edge is tangent, no fillet is possible, and
        the edge must subsequently be removed if you want to add a fillet.

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepFeat.BRepFeat_RibSlot_TgtEdges(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IntPar(*args):
        """
        IntPar(Handle_Geom_Curve C, gp_Pnt P) -> Standard_Real

        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type P: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepFeat.BRepFeat_RibSlot_IntPar(*args)

    IntPar = staticmethod(IntPar)

    def ChoiceOfFaces(*args):
        """
        ChoiceOfFaces(NCollection_List_TopoDS_Shape faces, Handle_Geom_Curve cc, Standard_Real const par, Standard_Real const bnd, Handle_Geom_Plane Pln) -> TopoDS_Face

        :type faces: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type cc: OCC.wrapper.Geom.Handle_Geom_Curve
        :type par: float
        :type bnd: float
        :type Pln: OCC.wrapper.Geom.Handle_Geom_Plane
        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepFeat.BRepFeat_RibSlot_ChoiceOfFaces(*args)

    ChoiceOfFaces = staticmethod(ChoiceOfFaces)

    def CurrentStatusError(self, *args):
        """
        CurrentStatusError(BRepFeat_RibSlot self) -> BRepFeat_StatusError

        :rtype: OCC.wrapper.BRepFeat.BRepFeat_StatusError

        """
        return _BRepFeat.BRepFeat_RibSlot_CurrentStatusError(self, *args)

    __swig_destroy__ = _BRepFeat.delete_BRepFeat_RibSlot
BRepFeat_RibSlot_swigregister = _BRepFeat.BRepFeat_RibSlot_swigregister
BRepFeat_RibSlot_swigregister(BRepFeat_RibSlot)

def BRepFeat_RibSlot_IntPar(*args):
    """
    BRepFeat_RibSlot_IntPar(Handle_Geom_Curve C, gp_Pnt P) -> Standard_Real

    :type C: OCC.wrapper.Geom.Handle_Geom_Curve
    :type P: OCC.wrapper.gp.gp_Pnt
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRepFeat.BRepFeat_RibSlot_IntPar(*args)

def BRepFeat_RibSlot_ChoiceOfFaces(*args):
    """
    BRepFeat_RibSlot_ChoiceOfFaces(NCollection_List_TopoDS_Shape faces, Handle_Geom_Curve cc, Standard_Real const par, Standard_Real const bnd, Handle_Geom_Plane Pln) -> TopoDS_Face

    :type faces: OCC.wrapper.TopTools.TopTools_ListOfShape
    :type cc: OCC.wrapper.Geom.Handle_Geom_Curve
    :type par: float
    :type bnd: float
    :type Pln: OCC.wrapper.Geom.Handle_Geom_Plane
    :rtype: OCC.wrapper.TopoDS.TopoDS_Face

    """
    return _BRepFeat.BRepFeat_RibSlot_ChoiceOfFaces(*args)

class BRepFeat_MakePrism(BRepFeat_Form):
    """
    Describes functions to build prism features.
    These can be depressions or protrusions.
    The semantics of prism feature creation is
    based on the construction of shapes:
    -   along a length
    -   up to a limiting face
    -   from a limiting face to a height.
    The shape defining construction of the prism feature can be
    either the supporting edge or the concerned area of a face.
    In case of the supporting edge, this contour
    can be attached to a face of the basis shape by
    binding. When the contour is bound to this face,
    the information that the contour will slide on the
    face becomes available to the relevant class methods.
    In case of the concerned area of a face, you
    could, for example, cut it out and move it to a
    different height which will define the limiting
    face of a protrusion or depression.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepFeat_MakePrism self) -> BRepFeat_MakePrism
        __init__(BRepFeat_MakePrism self, TopoDS_Shape Sbase, TopoDS_Shape Pbase, TopoDS_Face Skface, gp_Dir Direction, Standard_Integer const Fuse, Standard_Boolean const Modify) -> BRepFeat_MakePrism

        Builds a prism by projecting a
        wire along the face of a shape. a face Pbase is selected in
        the shape Sbase to serve as the basis for
        the prism. The orientation of the prism will
        be defined by the vector Direction.
        Fuse offers a choice between:
        -   removing matter with a Boolean cut using the setting 0
        -   adding matter with Boolean fusion using the setting 1.
        The sketch face Skface serves to determine
        the type of operation. If it is inside the basis
        shape, a local operation such as glueing can be performed.
        Exceptions
        Standard_ConstructionError if the face
        does not belong to the basis or the prism shape.

        :type Sbase: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Pbase: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Skface: OCC.wrapper.TopoDS.TopoDS_Face
        :type Direction: OCC.wrapper.gp.gp_Dir
        :type Fuse: int
        :type Modify: bool

        """
        this = _BRepFeat.new_BRepFeat_MakePrism(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepFeat_MakePrism self, TopoDS_Shape Sbase, TopoDS_Shape Pbase, TopoDS_Face Skface, gp_Dir Direction, Standard_Integer const Fuse, Standard_Boolean const Modify)

        Initializes this algorithm for building prisms along surfaces.
        A face Pbase is selected in the shape Sbase
        to serve as the basis for the prism. The
        orientation of the prism will be defined by the vector Direction.
        Fuse offers a choice between:
        -   removing matter with a Boolean cut using the setting 0
        -   adding matter with Boolean fusion using the setting 1.
        The sketch face Skface serves to determine
        the type of operation. If it is inside the basis
        shape, a local operation such as glueing can be performed.

        :type Sbase: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Pbase: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Skface: OCC.wrapper.TopoDS.TopoDS_Face
        :type Direction: OCC.wrapper.gp.gp_Dir
        :type Fuse: int
        :type Modify: bool

        """
        return _BRepFeat.BRepFeat_MakePrism_Init(self, *args)


    def Add(self, *args):
        """
        Add(BRepFeat_MakePrism self, TopoDS_Edge E, TopoDS_Face OnFace)

        Indicates that the edge <E> will slide on the face
        <OnFace>. Raises ConstructionError if the  face does not belong to the
        basis shape, or the edge to the prismed shape.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type OnFace: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepFeat.BRepFeat_MakePrism_Add(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepFeat_MakePrism self, Standard_Real const Length)
        Perform(BRepFeat_MakePrism self, TopoDS_Shape Until)
        Perform(BRepFeat_MakePrism self, TopoDS_Shape From, TopoDS_Shape Until)

        Assigns one of the following semantics
        -   to a height Length
        -   to a face Until
        -   from a face From to a height Until.
        Reconstructs the feature topologically according to the semantic option chosen.

        :type From: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Until: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepFeat.BRepFeat_MakePrism_Perform(self, *args)


    def PerformUntilEnd(self, *args):
        """
        PerformUntilEnd(BRepFeat_MakePrism self)

        Realizes a semi-infinite prism, limited by the
        position of the prism base. All other faces extend infinitely.


        """
        return _BRepFeat.BRepFeat_MakePrism_PerformUntilEnd(self, *args)


    def PerformFromEnd(self, *args):
        """
        PerformFromEnd(BRepFeat_MakePrism self, TopoDS_Shape FUntil)

        Realizes a semi-infinite prism, limited by the face Funtil.

        :type FUntil: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepFeat.BRepFeat_MakePrism_PerformFromEnd(self, *args)


    def PerformThruAll(self, *args):
        """
        PerformThruAll(BRepFeat_MakePrism self)

        Builds an infinite prism. The infinite descendants will not be kept in the result.


        """
        return _BRepFeat.BRepFeat_MakePrism_PerformThruAll(self, *args)


    def PerformUntilHeight(self, *args):
        """
        PerformUntilHeight(BRepFeat_MakePrism self, TopoDS_Shape Until, Standard_Real const Length)

        Assigns both a limiting shape, Until from
        TopoDS_Shape, and a height, Length at which to stop generation of the prism feature.

        :type Until: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Length: float

        """
        return _BRepFeat.BRepFeat_MakePrism_PerformUntilHeight(self, *args)


    def Curves(self, *args):
        """
        Curves(BRepFeat_MakePrism self, NCollection_Sequence_Handle_Geom_Curve S)

        Returns the list of curves S parallel to the axis of the prism.

        :type S: OCC.wrapper.TColGeom.TColGeom_SequenceOfCurve

        """
        return _BRepFeat.BRepFeat_MakePrism_Curves(self, *args)


    def BarycCurve(self, *args):
        """
        BarycCurve(BRepFeat_MakePrism self) -> Handle_Geom_Curve

        Generates a curve along the center of mass of the primitive.

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _BRepFeat.BRepFeat_MakePrism_BarycCurve(self, *args)

    __swig_destroy__ = _BRepFeat.delete_BRepFeat_MakePrism
BRepFeat_MakePrism_swigregister = _BRepFeat.BRepFeat_MakePrism_swigregister
BRepFeat_MakePrism_swigregister(BRepFeat_MakePrism)

class BRepFeat_MakeRevol(BRepFeat_Form):
    """Describes functions to build revolved shells from basis shapes."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepFeat_MakeRevol self) -> BRepFeat_MakeRevol
        __init__(BRepFeat_MakeRevol self, TopoDS_Shape Sbase, TopoDS_Shape Pbase, TopoDS_Face Skface, gp_Ax1 Axis, Standard_Integer const Fuse, Standard_Boolean const Modify) -> BRepFeat_MakeRevol

        a face Pbase is selected in the
        shape Sbase to serve as the basis for the
        revolved shell. The revolution will be defined
        by the axis Axis and Fuse offers a choice between:
        -   removing matter with a Boolean cut using the setting 0
        -   adding matter with Boolean fusion using the setting 1.
        The sketch face Skface serves to determine
        the type of operation. If it is inside the basis
        shape, a local operation such as glueing can be performed.

        :type Sbase: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Pbase: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Skface: OCC.wrapper.TopoDS.TopoDS_Face
        :type Axis: OCC.wrapper.gp.gp_Ax1
        :type Fuse: int
        :type Modify: bool

        """
        this = _BRepFeat.new_BRepFeat_MakeRevol(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepFeat_MakeRevol self, TopoDS_Shape Sbase, TopoDS_Shape Pbase, TopoDS_Face Skface, gp_Ax1 Axis, Standard_Integer const Fuse, Standard_Boolean const Modify)

        :type Sbase: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Pbase: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Skface: OCC.wrapper.TopoDS.TopoDS_Face
        :type Axis: OCC.wrapper.gp.gp_Ax1
        :type Fuse: int
        :type Modify: bool

        """
        return _BRepFeat.BRepFeat_MakeRevol_Init(self, *args)


    def Add(self, *args):
        """
        Add(BRepFeat_MakeRevol self, TopoDS_Edge E, TopoDS_Face OnFace)

        Indicates that the edge <E> will slide on the face
        <OnFace>. Raises ConstructionError if the  face does not belong to the
        basis shape, or the edge to the prismed shape.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type OnFace: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepFeat.BRepFeat_MakeRevol_Add(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepFeat_MakeRevol self, Standard_Real const Angle)
        Perform(BRepFeat_MakeRevol self, TopoDS_Shape Until)
        Perform(BRepFeat_MakeRevol self, TopoDS_Shape From, TopoDS_Shape Until)

        Reconstructs the feature topologically.

        :type From: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Until: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepFeat.BRepFeat_MakeRevol_Perform(self, *args)


    def PerformThruAll(self, *args):
        """
        PerformThruAll(BRepFeat_MakeRevol self)

        Builds an infinite shell. The infinite descendants
        will not be kept in the result.


        """
        return _BRepFeat.BRepFeat_MakeRevol_PerformThruAll(self, *args)


    def PerformUntilAngle(self, *args):
        """
        PerformUntilAngle(BRepFeat_MakeRevol self, TopoDS_Shape Until, Standard_Real const Angle)

        Assigns both a limiting shape, Until from
        TopoDS_Shape, and an angle, Angle at
        which to stop generation of the revolved shell feature.

        :type Until: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Angle: float

        """
        return _BRepFeat.BRepFeat_MakeRevol_PerformUntilAngle(self, *args)


    def Curves(self, *args):
        """
        Curves(BRepFeat_MakeRevol self, NCollection_Sequence_Handle_Geom_Curve S)

        :type S: OCC.wrapper.TColGeom.TColGeom_SequenceOfCurve

        """
        return _BRepFeat.BRepFeat_MakeRevol_Curves(self, *args)


    def BarycCurve(self, *args):
        """
        BarycCurve(BRepFeat_MakeRevol self) -> Handle_Geom_Curve

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _BRepFeat.BRepFeat_MakeRevol_BarycCurve(self, *args)

    __swig_destroy__ = _BRepFeat.delete_BRepFeat_MakeRevol
BRepFeat_MakeRevol_swigregister = _BRepFeat.BRepFeat_MakeRevol_swigregister
BRepFeat_MakeRevol_swigregister(BRepFeat_MakeRevol)

class BRepFeat_MakeDPrism(BRepFeat_Form):
    """
    Describes functions to build draft
    prism topologies from basis shape surfaces. These can be depressions or protrusions.
    The semantics of draft prism feature creation is based on the
    construction of shapes:
    -          along a length
    -          up to a limiting face
    -          from a limiting face to a height.
    The shape defining construction of the draft prism feature can be
    either the supporting edge or the concerned area of a face.
    In case of the supporting edge, this contour can be attached to a
    face of the basis shape by binding. When the contour is bound to this
    face, the information that the contour will slide on the face
    becomes available to the relevant class methods.
    In case of the concerned area of a face, you could, for example, cut
    it out and move it to a different height which will define the
    limiting face of a protrusion or depression.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepFeat_MakeDPrism self, TopoDS_Shape Sbase, TopoDS_Face Pbase, TopoDS_Face Skface, Standard_Real const Angle, Standard_Integer const Fuse, Standard_Boolean const Modify) -> BRepFeat_MakeDPrism
        __init__(BRepFeat_MakeDPrism self) -> BRepFeat_MakeDPrism

        A face Pbase is selected in the shape
        Sbase to serve as the basis for the draft prism. The
        draft will be defined by the angle Angle and Fuse offers a choice between:
        - removing matter with a Boolean cut using the setting 0
        - adding matter with Boolean fusion using the setting 1.
        The sketch face Skface serves to determine the type of
        operation. If it is inside the basis shape, a local
        operation such as glueing can be performed.
        Initializes the draft prism class

        :type Sbase: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Pbase: OCC.wrapper.TopoDS.TopoDS_Face
        :type Skface: OCC.wrapper.TopoDS.TopoDS_Face
        :type Angle: float
        :type Fuse: int
        :type Modify: bool

        """
        this = _BRepFeat.new_BRepFeat_MakeDPrism(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepFeat_MakeDPrism self, TopoDS_Shape Sbase, TopoDS_Face Pbase, TopoDS_Face Skface, Standard_Real const Angle, Standard_Integer const Fuse, Standard_Boolean const Modify)

        Initializes this algorithm for building draft prisms along surfaces.
        A face Pbase is selected in the basis shape Sbase to
        serve as the basis from the draft prism. The draft will be
        defined by the angle Angle and Fuse offers a choice between:
        -   removing matter with a Boolean cut using the setting 0
        -   adding matter with Boolean fusion using the setting  1.
        The sketch face Skface serves to determine the type of
        operation. If it is inside the basis shape, a local
        operation such as glueing can be performed.

        :type Sbase: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Pbase: OCC.wrapper.TopoDS.TopoDS_Face
        :type Skface: OCC.wrapper.TopoDS.TopoDS_Face
        :type Angle: float
        :type Fuse: int
        :type Modify: bool

        """
        return _BRepFeat.BRepFeat_MakeDPrism_Init(self, *args)


    def Add(self, *args):
        """
        Add(BRepFeat_MakeDPrism self, TopoDS_Edge E, TopoDS_Face OnFace)

        Indicates that the edge <E> will slide on the face
        <OnFace>.
        Raises ConstructionError if the  face does not belong to the
        basis shape, or the edge to the prismed shape.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type OnFace: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepFeat.BRepFeat_MakeDPrism_Add(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepFeat_MakeDPrism self, Standard_Real const Height)
        Perform(BRepFeat_MakeDPrism self, TopoDS_Shape Until)
        Perform(BRepFeat_MakeDPrism self, TopoDS_Shape From, TopoDS_Shape Until)

        Assigns one of the following semantics
        -   to a height Height
        -   to a face Until
        -   from a face From to a height Until.
        Reconstructs the feature topologically according to the semantic option chosen.

        :type From: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Until: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepFeat.BRepFeat_MakeDPrism_Perform(self, *args)


    def PerformUntilEnd(self, *args):
        """
        PerformUntilEnd(BRepFeat_MakeDPrism self)

        Realizes a semi-infinite prism, limited by the position of the prism base.


        """
        return _BRepFeat.BRepFeat_MakeDPrism_PerformUntilEnd(self, *args)


    def PerformFromEnd(self, *args):
        """
        PerformFromEnd(BRepFeat_MakeDPrism self, TopoDS_Shape FUntil)

        Realizes a semi-infinite prism, limited by the face Funtil.

        :type FUntil: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepFeat.BRepFeat_MakeDPrism_PerformFromEnd(self, *args)


    def PerformThruAll(self, *args):
        """
        PerformThruAll(BRepFeat_MakeDPrism self)

        Builds an infinite prism. The infinite descendants will not be kept in the result.


        """
        return _BRepFeat.BRepFeat_MakeDPrism_PerformThruAll(self, *args)


    def PerformUntilHeight(self, *args):
        """
        PerformUntilHeight(BRepFeat_MakeDPrism self, TopoDS_Shape Until, Standard_Real const Height)

        Assigns both a limiting shape, Until from
        TopoDS_Shape, and a height, Height at which to stop
        generation of the prism feature.

        :type Until: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Height: float

        """
        return _BRepFeat.BRepFeat_MakeDPrism_PerformUntilHeight(self, *args)


    def Curves(self, *args):
        """
        Curves(BRepFeat_MakeDPrism self, NCollection_Sequence_Handle_Geom_Curve S)

        :type S: OCC.wrapper.TColGeom.TColGeom_SequenceOfCurve

        """
        return _BRepFeat.BRepFeat_MakeDPrism_Curves(self, *args)


    def BarycCurve(self, *args):
        """
        BarycCurve(BRepFeat_MakeDPrism self) -> Handle_Geom_Curve

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _BRepFeat.BRepFeat_MakeDPrism_BarycCurve(self, *args)


    def BossEdges(self, *args):
        """
        BossEdges(BRepFeat_MakeDPrism self, Standard_Integer const sig)

        Determination of TopEdges and LatEdges.
        sig = 1 -> TopEdges = FirstShape of the DPrism
        sig = 2 -> TOpEdges = LastShape of the DPrism

        :type sig: int

        """
        return _BRepFeat.BRepFeat_MakeDPrism_BossEdges(self, *args)


    def TopEdges(self, *args):
        """
        Returns the list of TopoDS Edges of the top of the boss.

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepFeat.BRepFeat_MakeDPrism_TopEdges(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LatEdges(self, *args):
        """
        Returns the list of TopoDS Edges of the bottom of the boss.

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepFeat.BRepFeat_MakeDPrism_LatEdges(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepFeat.delete_BRepFeat_MakeDPrism
BRepFeat_MakeDPrism_swigregister = _BRepFeat.BRepFeat_MakeDPrism_swigregister
BRepFeat_MakeDPrism_swigregister(BRepFeat_MakeDPrism)

class BRepFeat_MakeCylindricalHole(BRepFeat_Builder):
    """Provides a tool to make cylindrical holes on a shape."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepFeat_MakeCylindricalHole self) -> BRepFeat_MakeCylindricalHole

        Empty constructor.


        """
        this = _BRepFeat.new_BRepFeat_MakeCylindricalHole(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepFeat_MakeCylindricalHole self, gp_Ax1 Axis)
        Init(BRepFeat_MakeCylindricalHole self, TopoDS_Shape S, gp_Ax1 Axis)

        Sets the shape and  axis on which hole(s)  will be
        performed.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Axis: OCC.wrapper.gp.gp_Ax1

        """
        return _BRepFeat.BRepFeat_MakeCylindricalHole_Init(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepFeat_MakeCylindricalHole self, Standard_Real const Radius)
        Perform(BRepFeat_MakeCylindricalHole self, Standard_Real const Radius, Standard_Real const PFrom, Standard_Real const PTo, Standard_Boolean const WithControl)

        Performs evry   hole  of  radius  <Radius> located
        between PFrom  and  PTo  on the  given  axis.   If
        <WithControl> is set  to Standard_False no control
        are  done  on   the  resulting  shape   after  the
        operation is performed.

        :type Radius: float
        :type PFrom: float
        :type PTo: float
        :type WithControl: bool

        """
        return _BRepFeat.BRepFeat_MakeCylindricalHole_Perform(self, *args)


    def PerformThruNext(self, *args):
        """
        PerformThruNext(BRepFeat_MakeCylindricalHole self, Standard_Real const Radius, Standard_Boolean const WithControl)

        Performs the first hole of radius <Radius>, in the
        direction of  the defined axis. First hole signify
        first encountered after the origin of the axis. If
        <WithControl> is set  to Standard_False no control
        are  done  on   the  resulting  shape   after  the
        operation is performed.

        :type Radius: float
        :type WithControl: bool

        """
        return _BRepFeat.BRepFeat_MakeCylindricalHole_PerformThruNext(self, *args)


    def PerformUntilEnd(self, *args):
        """
        PerformUntilEnd(BRepFeat_MakeCylindricalHole self, Standard_Real const Radius, Standard_Boolean const WithControl)

        Performs  evry  holes of  radius  <Radius> located
        after  the   origin  of   the given    axis.    If
        <WithControl> is  set to Standard_False no control
        are done   on   the  resulting  shape   after  the
        operation is performed.

        :type Radius: float
        :type WithControl: bool

        """
        return _BRepFeat.BRepFeat_MakeCylindricalHole_PerformUntilEnd(self, *args)


    def PerformBlind(self, *args):
        """
        PerformBlind(BRepFeat_MakeCylindricalHole self, Standard_Real const Radius, Standard_Real const Length, Standard_Boolean const WithControl)

        Performs a  blind   hole of radius    <Radius> and
        length <Length>.  The length is  measured from the
        origin of the given  axis. If <WithControl> is set
        to  Standard_False no  control  are done after the
        operation is performed.

        :type Radius: float
        :type Length: float
        :type WithControl: bool

        """
        return _BRepFeat.BRepFeat_MakeCylindricalHole_PerformBlind(self, *args)


    def Status(self, *args):
        """
        Status(BRepFeat_MakeCylindricalHole self) -> BRepFeat_Status

        Returns the status after a hole is performed.

        :rtype: OCC.wrapper.BRepFeat.BRepFeat_Status

        """
        return _BRepFeat.BRepFeat_MakeCylindricalHole_Status(self, *args)


    def Build(self, *args):
        """
        Build(BRepFeat_MakeCylindricalHole self)

        Builds the    resulting shape  (redefined     from
        MakeShape). Invalidates the  given parts  of tools
        if  any,   and performs the  result   of the local
        operation.


        """
        return _BRepFeat.BRepFeat_MakeCylindricalHole_Build(self, *args)

    __swig_destroy__ = _BRepFeat.delete_BRepFeat_MakeCylindricalHole
BRepFeat_MakeCylindricalHole_swigregister = _BRepFeat.BRepFeat_MakeCylindricalHole_swigregister
BRepFeat_MakeCylindricalHole_swigregister(BRepFeat_MakeCylindricalHole)

class BRepFeat_MakeLinearForm(BRepFeat_RibSlot):
    """
    Builds a rib or a groove along a developable, planar surface.
    The semantics of mechanical features is built around
    giving thickness to a contour. This thickness can either
    be symmetrical - on one side of the contour - or
    dissymmetrical - on both sides. As in the semantics of
    form features, the thickness is defined by construction of
    shapes in specific contexts.
    The development contexts differ, however, in case of
    mechanical features. Here they include extrusion:
    -   to a limiting face of the basis shape
    -   to or from a limiting plane
    -   to a height.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepFeat_MakeLinearForm self) -> BRepFeat_MakeLinearForm
        __init__(BRepFeat_MakeLinearForm self, TopoDS_Shape Sbase, TopoDS_Wire W, Handle_Geom_Plane P, gp_Vec Direction, gp_Vec Direction1, Standard_Integer const Fuse, Standard_Boolean const Modify) -> BRepFeat_MakeLinearForm

        contour W, a shape Sbase and a
        plane P are initialized to serve as the basic
        elements in the construction of the rib or groove.
        Direction and Direction1 give The vectors for
        defining the direction(s) in which thickness will be built up.
        Fuse offers a choice between:
        -   removing matter with a Boolean cut using the
        setting 0 in case of the groove
        -   adding matter with Boolean fusion using the
        setting 1 in case of the rib.

        :type Sbase: OCC.wrapper.TopoDS.TopoDS_Shape
        :type W: OCC.wrapper.TopoDS.TopoDS_Wire
        :type P: OCC.wrapper.Geom.Handle_Geom_Plane
        :type Direction: OCC.wrapper.gp.gp_Vec
        :type Direction1: OCC.wrapper.gp.gp_Vec
        :type Fuse: int
        :type Modify: bool

        """
        this = _BRepFeat.new_BRepFeat_MakeLinearForm(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepFeat_MakeLinearForm self, TopoDS_Shape Sbase, TopoDS_Wire W, Handle_Geom_Plane P, gp_Vec Direction, gp_Vec Direction1, Standard_Integer const Fuse, Standard_Boolean const Modify)

        Initializes this construction algorithm.
        A contour W, a shape Sbase and a plane P are
        initialized to serve as the basic elements in the
        construction of the rib or groove. The vectors for
        defining the direction(s) in which thickness will be built
        up are given by Direction and Direction1.
        Fuse offers a choice between:
        -   removing matter with a Boolean cut using the setting
        0 in case of the groove
        -   adding matter with Boolean fusion using the setting 1
        in case of the rib.

        :type Sbase: OCC.wrapper.TopoDS.TopoDS_Shape
        :type W: OCC.wrapper.TopoDS.TopoDS_Wire
        :type P: OCC.wrapper.Geom.Handle_Geom_Plane
        :type Direction: OCC.wrapper.gp.gp_Vec
        :type Direction1: OCC.wrapper.gp.gp_Vec
        :type Fuse: int
        :type Modify: bool

        """
        return _BRepFeat.BRepFeat_MakeLinearForm_Init(self, *args)


    def Add(self, *args):
        """
        Add(BRepFeat_MakeLinearForm self, TopoDS_Edge E, TopoDS_Face OnFace)

        Indicates that the edge <E> will slide on the face
        <OnFace>.
        Raises ConstructionError if the  face does not belong to the
        basis shape, or the edge to the prismed shape.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type OnFace: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepFeat.BRepFeat_MakeLinearForm_Add(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepFeat_MakeLinearForm self)

        Performs a prism from the wire to the plane along the
        basis shape Sbase. Reconstructs the feature topologically.


        """
        return _BRepFeat.BRepFeat_MakeLinearForm_Perform(self, *args)


    def Propagate(self, *args):
        """
        Propagate(BRepFeat_MakeLinearForm self, NCollection_List_TopoDS_Shape L, TopoDS_Face F, gp_Pnt FPoint, gp_Pnt LPoint) -> Standard_Boolean

        :type L: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type FPoint: OCC.wrapper.gp.gp_Pnt
        :type LPoint: OCC.wrapper.gp.gp_Pnt
        :type falseside: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFeat.BRepFeat_MakeLinearForm_Propagate(self, *args)

    __swig_destroy__ = _BRepFeat.delete_BRepFeat_MakeLinearForm
BRepFeat_MakeLinearForm_swigregister = _BRepFeat.BRepFeat_MakeLinearForm_swigregister
BRepFeat_MakeLinearForm_swigregister(BRepFeat_MakeLinearForm)

class BRepFeat_(object):
    """
    BRepFeat is necessary for the
    creation and manipulation of both form and mechanical features in a
    Boundary Representation framework. Form features can be depressions or
    protrusions and include the following types:
    -          Cylinder
    -          Draft Prism
    -          Prism
    -          Revolved feature
    -          Pipe
    Depending on whether you wish to make a depression or a protrusion,
    you can choose your operation type between the following:
    - removing matter (a Boolean cut: Fuse setting 0)
    - adding matter (Boolean fusion: Fuse setting 1)
    The semantics of form feature creation is based on the
    construction of shapes:
    -          for a certain length in a certain direction
    -          up to a limiting face
    -          from a limiting face at a height
    -          above and/or below a plane
    The shape defining the construction of a feature can be either a
    supporting edge or a concerned area of a face.
    In case of supporting edge, this contour can be attached to a face
    of the basis shape by binding. When the contour is bound to this face,
    the information that the contour will slide on the face becomes
    available to the relevant class methods. In case of the concerned
    area of a face, you could, for example, cut it out and move it at
    a different height, which will define the limiting face of a
    protrusion or depression. Topological definition with local
    operations of this sort makes calculations simpler and faster
    than a global operation. The latter would entail a second phase of
    removing unwanted matter to get the same result.
    Mechanical features include ribs - protrusions - and grooves (or
    slots) - depressions along planar (linear) surfaces or revolution surfaces.
    The semantics of mechanical features is based on giving
    thickness to a contour. This thickness can either be unilateral
    - on one side of the contour - or bilateral - on both sides. As in
    the semantics of form features, the thickness is defined by
    construction of shapes in specific contexts.
    However, in case of mechanical features, development contexts
    differ. Here they include extrusion:
    -          to a limiting face of the basis shape
    -          to or from a limiting plane
    -          to a height.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def SampleEdges(*args):
        """
        SampleEdges(TopoDS_Shape S, NCollection_Sequence_gp_Pnt Pt)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Pt: OCC.wrapper.TColgp.TColgp_SequenceOfPnt

        """
        return _BRepFeat.BRepFeat__SampleEdges(*args)

    SampleEdges = staticmethod(SampleEdges)

    def Barycenter(*args):
        """
        Barycenter(TopoDS_Shape S, gp_Pnt Pt)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Pt: OCC.wrapper.gp.gp_Pnt

        """
        return _BRepFeat.BRepFeat__Barycenter(*args)

    Barycenter = staticmethod(Barycenter)

    def ParametricBarycenter(*args):
        """
        ParametricBarycenter(TopoDS_Shape S, Handle_Geom_Curve C) -> Standard_Real

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _BRepFeat.BRepFeat__ParametricBarycenter(*args)

    ParametricBarycenter = staticmethod(ParametricBarycenter)

    def ParametricMinMax(*args):
        """
        ParametricMinMax(TopoDS_Shape S, Handle_Geom_Curve C, Standard_Boolean const Ori)

        Ori = True taking account the orientation

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type prmin: float
        :type prmax: float
        :type prbmin: float
        :type prbmax: float
        :type flag: bool
        :type Ori: bool

        """
        return _BRepFeat.BRepFeat__ParametricMinMax(*args)

    ParametricMinMax = staticmethod(ParametricMinMax)

    def IsInside(*args):
        """
        IsInside(TopoDS_Face F1, TopoDS_Face F2) -> Standard_Boolean

        :type F1: OCC.wrapper.TopoDS.TopoDS_Face
        :type F2: OCC.wrapper.TopoDS.TopoDS_Face
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFeat.BRepFeat__IsInside(*args)

    IsInside = staticmethod(IsInside)

    def FaceUntil(*args):
        """
        FaceUntil(TopoDS_Shape S, TopoDS_Face F)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepFeat.BRepFeat__FaceUntil(*args)

    FaceUntil = staticmethod(FaceUntil)

    def Tool(*args):
        """
        Tool(TopoDS_Shape SRef, TopoDS_Face Fac, TopAbs_Orientation const Orf) -> TopoDS_Solid

        :type SRef: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Fac: OCC.wrapper.TopoDS.TopoDS_Face
        :type Orf: OCC.wrapper.TopAbs.TopAbs_Orientation
        :rtype: OCC.wrapper.TopoDS.TopoDS_Solid

        """
        return _BRepFeat.BRepFeat__Tool(*args)

    Tool = staticmethod(Tool)

    def Print(*args):
        """
        Print(BRepFeat_StatusError const SE, Standard_OStream & S) -> Standard_OStream &

        Prints the Error description of the State <St> as a String on
        the Stream <S> and returns <S>.

        :type SE: OCC.wrapper.BRepFeat.BRepFeat_StatusError
        :type S: OCC.wrapper.Standard.Standard_OStream
        :rtype: OCC.wrapper.Standard.Standard_OStream

        """
        return _BRepFeat.BRepFeat__Print(*args)

    Print = staticmethod(Print)

    def __init__(self):
        """
        BRepFeat is necessary for the
        creation and manipulation of both form and mechanical features in a
        Boundary Representation framework. Form features can be depressions or
        protrusions and include the following types:
        -          Cylinder
        -          Draft Prism
        -          Prism
        -          Revolved feature
        -          Pipe
        Depending on whether you wish to make a depression or a protrusion,
        you can choose your operation type between the following:
        - removing matter (a Boolean cut: Fuse setting 0)
        - adding matter (Boolean fusion: Fuse setting 1)
        The semantics of form feature creation is based on the
        construction of shapes:
        -          for a certain length in a certain direction
        -          up to a limiting face
        -          from a limiting face at a height
        -          above and/or below a plane
        The shape defining the construction of a feature can be either a
        supporting edge or a concerned area of a face.
        In case of supporting edge, this contour can be attached to a face
        of the basis shape by binding. When the contour is bound to this face,
        the information that the contour will slide on the face becomes
        available to the relevant class methods. In case of the concerned
        area of a face, you could, for example, cut it out and move it at
        a different height, which will define the limiting face of a
        protrusion or depression. Topological definition with local
        operations of this sort makes calculations simpler and faster
        than a global operation. The latter would entail a second phase of
        removing unwanted matter to get the same result.
        Mechanical features include ribs - protrusions - and grooves (or
        slots) - depressions along planar (linear) surfaces or revolution surfaces.
        The semantics of mechanical features is based on giving
        thickness to a contour. This thickness can either be unilateral
        - on one side of the contour - or bilateral - on both sides. As in
        the semantics of form features, the thickness is defined by
        construction of shapes in specific contexts.
        However, in case of mechanical features, development contexts
        differ. Here they include extrusion:
        -          to a limiting face of the basis shape
        -          to or from a limiting plane
        -          to a height.
        """
        this = _BRepFeat.new_BRepFeat_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepFeat.delete_BRepFeat_
BRepFeat__swigregister = _BRepFeat.BRepFeat__swigregister
BRepFeat__swigregister(BRepFeat_)

def BRepFeat__SampleEdges(*args):
    """
    BRepFeat__SampleEdges(TopoDS_Shape S, NCollection_Sequence_gp_Pnt Pt)

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type Pt: OCC.wrapper.TColgp.TColgp_SequenceOfPnt

    """
    return _BRepFeat.BRepFeat__SampleEdges(*args)

def BRepFeat__Barycenter(*args):
    """
    BRepFeat__Barycenter(TopoDS_Shape S, gp_Pnt Pt)

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type Pt: OCC.wrapper.gp.gp_Pnt

    """
    return _BRepFeat.BRepFeat__Barycenter(*args)

def BRepFeat__ParametricBarycenter(*args):
    """
    BRepFeat__ParametricBarycenter(TopoDS_Shape S, Handle_Geom_Curve C) -> Standard_Real

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type C: OCC.wrapper.Geom.Handle_Geom_Curve
    :rtype: OCC.wrapper.Standard.Standard_Real

    """
    return _BRepFeat.BRepFeat__ParametricBarycenter(*args)

def BRepFeat__ParametricMinMax(*args):
    """
    BRepFeat__ParametricMinMax(TopoDS_Shape S, Handle_Geom_Curve C, Standard_Boolean const Ori)

    Ori = True taking account the orientation

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type C: OCC.wrapper.Geom.Handle_Geom_Curve
    :type prmin: float
    :type prmax: float
    :type prbmin: float
    :type prbmax: float
    :type flag: bool
    :type Ori: bool

    """
    return _BRepFeat.BRepFeat__ParametricMinMax(*args)

def BRepFeat__IsInside(*args):
    """
    BRepFeat__IsInside(TopoDS_Face F1, TopoDS_Face F2) -> Standard_Boolean

    :type F1: OCC.wrapper.TopoDS.TopoDS_Face
    :type F2: OCC.wrapper.TopoDS.TopoDS_Face
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepFeat.BRepFeat__IsInside(*args)

def BRepFeat__FaceUntil(*args):
    """
    BRepFeat__FaceUntil(TopoDS_Shape S, TopoDS_Face F)

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type F: OCC.wrapper.TopoDS.TopoDS_Face

    """
    return _BRepFeat.BRepFeat__FaceUntil(*args)

def BRepFeat__Tool(*args):
    """
    BRepFeat__Tool(TopoDS_Shape SRef, TopoDS_Face Fac, TopAbs_Orientation const Orf) -> TopoDS_Solid

    :type SRef: OCC.wrapper.TopoDS.TopoDS_Shape
    :type Fac: OCC.wrapper.TopoDS.TopoDS_Face
    :type Orf: OCC.wrapper.TopAbs.TopAbs_Orientation
    :rtype: OCC.wrapper.TopoDS.TopoDS_Solid

    """
    return _BRepFeat.BRepFeat__Tool(*args)

def BRepFeat__Print(*args):
    """
    BRepFeat__Print(BRepFeat_StatusError const SE, Standard_OStream & S) -> Standard_OStream &

    Prints the Error description of the State <St> as a String on
    the Stream <S> and returns <S>.

    :type SE: OCC.wrapper.BRepFeat.BRepFeat_StatusError
    :type S: OCC.wrapper.Standard.Standard_OStream
    :rtype: OCC.wrapper.Standard.Standard_OStream

    """
    return _BRepFeat.BRepFeat__Print(*args)

class BRepFeat_MakeRevolutionForm(BRepFeat_RibSlot):
    """
    MakeRevolutionForm Generates a surface of
    revolution in the feature as it slides along a
    revolved face in the basis shape.
    The semantics of mechanical features is built
    around giving thickness to a contour. This
    thickness can either be unilateral - on one side
    of the contour - or bilateral - on both sides. As
    in the semantics of form features, the thickness
    is defined by construction of shapes in specific contexts.
    The development contexts differ, however,in
    case of mechanical features. Here they include extrusion:
    -   to a limiting face of the basis shape
    -   to or from a limiting plane
    -   to a height.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepFeat_MakeRevolutionForm self) -> BRepFeat_MakeRevolutionForm
        __init__(BRepFeat_MakeRevolutionForm self, TopoDS_Shape Sbase, TopoDS_Wire W, Handle_Geom_Plane Plane, gp_Ax1 Axis, Standard_Real const Height1, Standard_Real const Height2, Standard_Integer const Fuse) -> BRepFeat_MakeRevolutionForm

        a contour W, a shape Sbase and a plane P are initialized to serve as
        the basic elements in the construction of the rib or groove. The axis Axis of the
        revolved surface in the basis shape defines the feature's axis of revolution.
        Height1 and Height2 may be used as limits to the construction of the feature.
        Fuse offers a choice between:
        -   removing matter with a Boolean cut using the setting 0 in case of the groove
        -   adding matter with Boolean fusion using the setting 1 in case of the rib.

        :type Sbase: OCC.wrapper.TopoDS.TopoDS_Shape
        :type W: OCC.wrapper.TopoDS.TopoDS_Wire
        :type Plane: OCC.wrapper.Geom.Handle_Geom_Plane
        :type Axis: OCC.wrapper.gp.gp_Ax1
        :type Height1: float
        :type Height2: float
        :type Fuse: int
        :type Sliding: bool

        """
        this = _BRepFeat.new_BRepFeat_MakeRevolutionForm(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepFeat_MakeRevolutionForm self, TopoDS_Shape Sbase, TopoDS_Wire W, Handle_Geom_Plane Plane, gp_Ax1 Axis, Standard_Real const Height1, Standard_Real const Height2, Standard_Integer const Fuse)

        Initializes this construction algorithm
        A contour W, a shape Sbase and a plane P are initialized to serve as the basic elements
        in the construction of the rib or groove. The axis Axis of the revolved surface in the basis
        shape defines the feature's axis of revolution. Height1 and Height2 may be
        used as limits to the construction of the feature.
        Fuse offers a choice between:
        -   removing matter with a Boolean cut using the setting 0 in case of the groove
        -   adding matter with Boolean fusion using the setting 1 in case of the rib.

        :type Sbase: OCC.wrapper.TopoDS.TopoDS_Shape
        :type W: OCC.wrapper.TopoDS.TopoDS_Wire
        :type Plane: OCC.wrapper.Geom.Handle_Geom_Plane
        :type Axis: OCC.wrapper.gp.gp_Ax1
        :type Height1: float
        :type Height2: float
        :type Fuse: int
        :type Sliding: bool

        """
        return _BRepFeat.BRepFeat_MakeRevolutionForm_Init(self, *args)


    def Add(self, *args):
        """
        Add(BRepFeat_MakeRevolutionForm self, TopoDS_Edge E, TopoDS_Face OnFace)

        Indicates that the edge <E> will slide on the face
        <OnFace>. Raises ConstructionError  if the  face does not belong to the
        basis shape, or the edge to the prismed shape.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type OnFace: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepFeat.BRepFeat_MakeRevolutionForm_Add(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepFeat_MakeRevolutionForm self)

        Performs a prism from the wire to the plane
        along the basis shape S. Reconstructs the feature topologically.


        """
        return _BRepFeat.BRepFeat_MakeRevolutionForm_Perform(self, *args)


    def Propagate(self, *args):
        """
        Propagate(BRepFeat_MakeRevolutionForm self, NCollection_List_TopoDS_Shape L, TopoDS_Face F, gp_Pnt FPoint, gp_Pnt LPoint) -> Standard_Boolean

        :type L: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type FPoint: OCC.wrapper.gp.gp_Pnt
        :type LPoint: OCC.wrapper.gp.gp_Pnt
        :type falseside: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFeat.BRepFeat_MakeRevolutionForm_Propagate(self, *args)

    __swig_destroy__ = _BRepFeat.delete_BRepFeat_MakeRevolutionForm
BRepFeat_MakeRevolutionForm_swigregister = _BRepFeat.BRepFeat_MakeRevolutionForm_swigregister
BRepFeat_MakeRevolutionForm_swigregister(BRepFeat_MakeRevolutionForm)

class BRepFeat_SplitShape(BRepBuilderAPI.BRepBuilderAPI_MakeShape):
    """
    One of the most significant aspects of BRepFeat functionality is the use of local
    operations as opposed to global ones. In a global operation, you would first construct a
    form of the type you wanted in your final feature, and then remove matter so that it could
    fit into your initial basis object. In a local operation, however, you specify the domain of
    the feature construction with aspects of the shape on which the feature is being created.
    These semantics are expressed in terms of a member shape of the basis shape from which -
    or up to which - matter will be added or removed. As a result, local operations make
    calculations simpler and faster than global operations.
    In BRepFeat, the semantics of local operations define features constructed from a contour or a
    part of the basis shape referred to as the tool. In a SplitShape object, wires or edges of a
    face in the basis shape to be used as a part of the feature are cut out and projected to a plane
    outside or inside the basis shape. By rebuilding the initial shape incorporating the edges and
    the faces of the tool, protrusion or depression features can be constructed.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepFeat_SplitShape self) -> BRepFeat_SplitShape
        __init__(BRepFeat_SplitShape self, TopoDS_Shape S) -> BRepFeat_SplitShape

        Creates the process  with the shape <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _BRepFeat.new_BRepFeat_SplitShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepFeat_SplitShape self, TopoDS_Shape S)

        Initializes the process on the shape <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepFeat.BRepFeat_SplitShape_Init(self, *args)


    def SetCheckInterior(self, *args):
        """
        SetCheckInterior(BRepFeat_SplitShape self, Standard_Boolean const ToCheckInterior)

        Set the flag of check internal intersections
        default value is True (to check)

        :type ToCheckInterior: bool

        """
        return _BRepFeat.BRepFeat_SplitShape_SetCheckInterior(self, *args)


    def Add(self, *args):
        """
        Add(BRepFeat_SplitShape self, NCollection_Sequence_TopoDS_Shape theEdges) -> Standard_Boolean
        Add(BRepFeat_SplitShape self, TopoDS_Wire W, TopoDS_Face F)
        Add(BRepFeat_SplitShape self, TopoDS_Edge E, TopoDS_Face F)
        Add(BRepFeat_SplitShape self, TopoDS_Compound Comp, TopoDS_Face F)
        Add(BRepFeat_SplitShape self, TopoDS_Edge E, TopoDS_Edge EOn)

        Adds the edge <E> on the existing edge <EOn>.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type EOn: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _BRepFeat.BRepFeat_SplitShape_Add(self, *args)


    def DirectLeft(self, *args):
        """
        Returns  the faces   which  are the  left of   the
        projected wires.

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepFeat.BRepFeat_SplitShape_DirectLeft(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Left(self, *args):
        """
        Returns the faces of the "left" part on the shape.
        (It  is build   from  DirectLeft,  with  the faces
        connected to this set, and so on...).
        Raises NotDone if IsDone returns <Standard_False>.

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepFeat.BRepFeat_SplitShape_Left(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Build(self, *args):
        """
        Build(BRepFeat_SplitShape self)

        Builds the cut and the resulting faces and edges as well.


        """
        return _BRepFeat.BRepFeat_SplitShape_Build(self, *args)


    def IsDeleted(self, *args):
        """
        IsDeleted(BRepFeat_SplitShape self, TopoDS_Shape S) -> Standard_Boolean

        Returns true if the shape has been deleted.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFeat.BRepFeat_SplitShape_IsDeleted(self, *args)


    def Modified(self, *args):
        """
        Returns the list of generated Faces.

        :type F: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepFeat.BRepFeat_SplitShape_Modified(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepFeat.delete_BRepFeat_SplitShape
BRepFeat_SplitShape_swigregister = _BRepFeat.BRepFeat_SplitShape_swigregister
BRepFeat_SplitShape_swigregister(BRepFeat_SplitShape)

class BRepFeat_Gluer(BRepBuilderAPI.BRepBuilderAPI_MakeShape):
    """
    One of the most significant aspects
    of BRepFeat functionality is the use of local operations as opposed
    to global ones. In a global operation, you would first
    construct a form of the type you wanted in your final feature, and
    then remove matter so that it could fit into your initial basis object.
    In a local operation, however, you specify the domain of the feature
    construction with aspects of the shape on which the feature is being
    created. These semantics are expressed in terms of a member
    shape of the basis shape from which - or up to which - matter will be
    added or removed. As a result, local operations make calculations
    simpler and faster than global operations.
    Glueing uses wires or edges of a face in the basis shape. These are
    to become a part of the feature. They are first cut out and then
    projected to a plane outside or inside the basis shape. By
    rebuilding the initial shape incorporating the edges and the
    faces of the tool, protrusion features can be constructed.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepFeat_Gluer self) -> BRepFeat_Gluer
        __init__(BRepFeat_Gluer self, TopoDS_Shape Snew, TopoDS_Shape Sbase) -> BRepFeat_Gluer

        Initializes the shapes to be glued, the new shape
        Snew and the basis shape Sbase.

        :type Snew: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Sbase: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _BRepFeat.new_BRepFeat_Gluer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepFeat_Gluer self, TopoDS_Shape Snew, TopoDS_Shape Sbase)

        Initializes the new shape Snew and the basis shape
        Sbase for the local glueing operation.

        :type Snew: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Sbase: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepFeat.BRepFeat_Gluer_Init(self, *args)


    def Bind(self, *args):
        """
        Bind(BRepFeat_Gluer self, TopoDS_Face Fnew, TopoDS_Face Fbase)
        Bind(BRepFeat_Gluer self, TopoDS_Edge Enew, TopoDS_Edge Ebase)

        nforms other methods that the edge Enew in the new
        shape is the same as the edge Ebase in the basis
        shape and is therefore attached to the basis shape. This
        indicates that glueing is possible.

        :type Enew: OCC.wrapper.TopoDS.TopoDS_Edge
        :type Ebase: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _BRepFeat.BRepFeat_Gluer_Bind(self, *args)


    def OpeType(self, *args):
        """
        OpeType(BRepFeat_Gluer self) -> LocOpe_Operation

        Determine which operation type to use glueing or sliding.

        :rtype: OCC.wrapper.LocOpe.LocOpe_Operation

        """
        return _BRepFeat.BRepFeat_Gluer_OpeType(self, *args)


    def BasisShape(self, *args):
        """
        Returns the basis shape of the compound shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepFeat.BRepFeat_Gluer_BasisShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GluedShape(self, *args):
        """
        Returns the resulting compound shape.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepFeat.BRepFeat_Gluer_GluedShape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Build(self, *args):
        """
        Build(BRepFeat_Gluer self)

        This is  called by  Shape().  It does  nothing but
        may be redefined.


        """
        return _BRepFeat.BRepFeat_Gluer_Build(self, *args)


    def IsDeleted(self, *args):
        """
        IsDeleted(BRepFeat_Gluer self, TopoDS_Shape F) -> Standard_Boolean

        returns the status of the Face after
        the shape creation.

        :type F: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepFeat.BRepFeat_Gluer_IsDeleted(self, *args)


    def Modified(self, *args):
        """
        returns the list of generated Faces.

        :type F: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepFeat.BRepFeat_Gluer_Modified(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepFeat.delete_BRepFeat_Gluer
BRepFeat_Gluer_swigregister = _BRepFeat.BRepFeat_Gluer_swigregister
BRepFeat_Gluer_swigregister(BRepFeat_Gluer)

class BRepFeat_MakePipe(BRepFeat_Form):
    """
    Constructs compound shapes with pipe
    features. These can be depressions or protrusions.
    The semantics of pipe feature creation is based on the construction of shapes:
    -   along a length
    -   up to a limiting face
    -   from a limiting face to a height.
    The shape defining construction of the pipe feature can be either the supporting edge or
    the concerned area of a face.
    In case of the supporting edge, this contour
    can be attached to a face of the basis shape
    by binding. When the contour is bound to this
    face, the information that the contour will
    slide on the face becomes available to the relevant class methods.
    In case of the concerned area of a face, you
    could, for example, cut it out and move it to a
    different height which will define the limiting
    face of a protrusion or depression.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepFeat_MakePipe self) -> BRepFeat_MakePipe
        __init__(BRepFeat_MakePipe self, TopoDS_Shape Sbase, TopoDS_Shape Pbase, TopoDS_Face Skface, TopoDS_Wire Spine, Standard_Integer const Fuse, Standard_Boolean const Modify) -> BRepFeat_MakePipe

        A face Pbase is selected in the
        shape Sbase to serve as the basis for the
        pipe. It will be defined by the wire Spine.
        Fuse offers a choice between:
        -   removing matter with a Boolean cut using the setting 0
        -   adding matter with Boolean fusion using the setting 1.
        The sketch face Skface serves to determine
        the type of operation. If it is inside the basis
        shape, a local operation such as glueing can be performed.

        :type Sbase: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Pbase: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Skface: OCC.wrapper.TopoDS.TopoDS_Face
        :type Spine: OCC.wrapper.TopoDS.TopoDS_Wire
        :type Fuse: int
        :type Modify: bool

        """
        this = _BRepFeat.new_BRepFeat_MakePipe(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepFeat_MakePipe self, TopoDS_Shape Sbase, TopoDS_Shape Pbase, TopoDS_Face Skface, TopoDS_Wire Spine, Standard_Integer const Fuse, Standard_Boolean const Modify)

        Initializes this algorithm for adding pipes to shapes.
        A face Pbase is selected in the shape Sbase to
        serve as the basis for the pipe. It will be defined by the wire Spine.
        Fuse offers a choice between:
        -   removing matter with a Boolean cut using the setting 0
        -   adding matter with Boolean fusion using the setting 1.
        The sketch face Skface serves to determine
        the type of operation. If it is inside the basis
        shape, a local operation such as glueing can be performed.

        :type Sbase: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Pbase: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Skface: OCC.wrapper.TopoDS.TopoDS_Face
        :type Spine: OCC.wrapper.TopoDS.TopoDS_Wire
        :type Fuse: int
        :type Modify: bool

        """
        return _BRepFeat.BRepFeat_MakePipe_Init(self, *args)


    def Add(self, *args):
        """
        Add(BRepFeat_MakePipe self, TopoDS_Edge E, TopoDS_Face OnFace)

        Indicates that the edge <E> will slide on the face
        <OnFace>. Raises ConstructionError  if the  face does not belong to the
        basis shape, or the edge to the prismed shape.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type OnFace: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepFeat.BRepFeat_MakePipe_Add(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepFeat_MakePipe self)
        Perform(BRepFeat_MakePipe self, TopoDS_Shape Until)
        Perform(BRepFeat_MakePipe self, TopoDS_Shape From, TopoDS_Shape Until)

        Assigns one of the following semantics
        -   to a face Until
        -   from a face From to a height Until.
        Reconstructs the feature topologically according to the semantic option chosen.

        :type From: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Until: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepFeat.BRepFeat_MakePipe_Perform(self, *args)


    def Curves(self, *args):
        """
        Curves(BRepFeat_MakePipe self, NCollection_Sequence_Handle_Geom_Curve S)

        :type S: OCC.wrapper.TColGeom.TColGeom_SequenceOfCurve

        """
        return _BRepFeat.BRepFeat_MakePipe_Curves(self, *args)


    def BarycCurve(self, *args):
        """
        BarycCurve(BRepFeat_MakePipe self) -> Handle_Geom_Curve

        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _BRepFeat.BRepFeat_MakePipe_BarycCurve(self, *args)

    __swig_destroy__ = _BRepFeat.delete_BRepFeat_MakePipe
BRepFeat_MakePipe_swigregister = _BRepFeat.BRepFeat_MakePipe_swigregister
BRepFeat_MakePipe_swigregister(BRepFeat_MakePipe)




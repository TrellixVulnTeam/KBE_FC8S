# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_StdPrs')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_StdPrs')
    _StdPrs = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_StdPrs', [dirname(__file__)])
        except ImportError:
            import _StdPrs
            return _StdPrs
        try:
            _mod = imp.load_module('_StdPrs', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _StdPrs = swig_import_helper()
    del swig_import_helper
else:
    import _StdPrs
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _StdPrs.delete_SwigPyIterator

    def value(self):
        return _StdPrs.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _StdPrs.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _StdPrs.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _StdPrs.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _StdPrs.SwigPyIterator_equal(self, x)

    def copy(self):
        return _StdPrs.SwigPyIterator_copy(self)

    def next(self):
        return _StdPrs.SwigPyIterator_next(self)

    def __next__(self):
        return _StdPrs.SwigPyIterator___next__(self)

    def previous(self):
        return _StdPrs.SwigPyIterator_previous(self)

    def advance(self, n):
        return _StdPrs.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _StdPrs.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _StdPrs.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _StdPrs.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _StdPrs.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _StdPrs.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _StdPrs.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _StdPrs.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _StdPrs.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_StdPrs.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _StdPrs.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _StdPrs.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StdPrs.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _StdPrs.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _StdPrs.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _StdPrs.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _StdPrs.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_StdPrs.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _StdPrs.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _StdPrs.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StdPrs.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _StdPrs.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _StdPrs.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _StdPrs.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _StdPrs.ptr_to_number(item)
ptr_to_number = _StdPrs.ptr_to_number

def HashCode(*args):
    return _StdPrs.HashCode(*args)
HashCode = _StdPrs.HashCode

def ptr_equal(a, b):
    return _StdPrs.ptr_equal(a, b)
ptr_equal = _StdPrs.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Prs3d
else:
    import Prs3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import HLRAlgo
else:
    import HLRAlgo
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Poly
else:
    import Poly
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TShort
else:
    import TShort
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Graphic3d
else:
    import Graphic3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BVH
else:
    import BVH
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Image
else:
    import Image
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Quantity
else:
    import Quantity
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Aspect
else:
    import Aspect
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Font
else:
    import Font
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import OSD
else:
    import OSD
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRep
else:
    import BRep
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepAdaptor
else:
    import BRepAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dAdaptor
else:
    import Geom2dAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
StdPrs_Volume_Autodetection = _StdPrs.StdPrs_Volume_Autodetection
StdPrs_Volume_Closed = _StdPrs.StdPrs_Volume_Closed
StdPrs_Volume_Opened = _StdPrs.StdPrs_Volume_Opened
class StdPrs_ToolPoint(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Coord(*args):
        """
        Coord(Handle_Geom_Point aPoint)

        :type aPoint: OCC.wrapper.Geom.Handle_Geom_Point
        :type X: float
        :type Y: float
        :type Z: float

        """
        return _StdPrs.StdPrs_ToolPoint_Coord(*args)

    Coord = staticmethod(Coord)

    def __init__(self):
        this = _StdPrs.new_StdPrs_ToolPoint()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StdPrs.delete_StdPrs_ToolPoint
StdPrs_ToolPoint_swigregister = _StdPrs.StdPrs_ToolPoint_swigregister
StdPrs_ToolPoint_swigregister(StdPrs_ToolPoint)

def StdPrs_ToolPoint_Coord(*args):
    """
    StdPrs_ToolPoint_Coord(Handle_Geom_Point aPoint)

    :type aPoint: OCC.wrapper.Geom.Handle_Geom_Point
    :type X: float
    :type Y: float
    :type Z: float

    """
    return _StdPrs.StdPrs_ToolPoint_Coord(*args)

class StdPrs_HLRToolShape(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StdPrs_HLRToolShape self, TopoDS_Shape TheShape, HLRAlgo_Projector TheProjector) -> StdPrs_HLRToolShape

        :type TheShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type TheProjector: OCC.wrapper.HLRAlgo.HLRAlgo_Projector

        """
        this = _StdPrs.new_StdPrs_HLRToolShape(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbEdges(self, *args):
        """
        NbEdges(StdPrs_HLRToolShape self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StdPrs.StdPrs_HLRToolShape_NbEdges(self, *args)


    def InitVisible(self, *args):
        """
        InitVisible(StdPrs_HLRToolShape self, Standard_Integer const EdgeNumber)

        :type EdgeNumber: int

        """
        return _StdPrs.StdPrs_HLRToolShape_InitVisible(self, *args)


    def MoreVisible(self, *args):
        """
        MoreVisible(StdPrs_HLRToolShape self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StdPrs.StdPrs_HLRToolShape_MoreVisible(self, *args)


    def NextVisible(self, *args):
        """NextVisible(StdPrs_HLRToolShape self)"""
        return _StdPrs.StdPrs_HLRToolShape_NextVisible(self, *args)


    def Visible(self, *args):
        """
        Visible(StdPrs_HLRToolShape self, BRepAdaptor_Curve TheEdge)

        :type TheEdge: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :type U1: float
        :type U2: float

        """
        return _StdPrs.StdPrs_HLRToolShape_Visible(self, *args)


    def InitHidden(self, *args):
        """
        InitHidden(StdPrs_HLRToolShape self, Standard_Integer const EdgeNumber)

        :type EdgeNumber: int

        """
        return _StdPrs.StdPrs_HLRToolShape_InitHidden(self, *args)


    def MoreHidden(self, *args):
        """
        MoreHidden(StdPrs_HLRToolShape self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StdPrs.StdPrs_HLRToolShape_MoreHidden(self, *args)


    def NextHidden(self, *args):
        """NextHidden(StdPrs_HLRToolShape self)"""
        return _StdPrs.StdPrs_HLRToolShape_NextHidden(self, *args)


    def Hidden(self, *args):
        """
        Hidden(StdPrs_HLRToolShape self, BRepAdaptor_Curve TheEdge)

        :type TheEdge: OCC.wrapper.BRepAdaptor.BRepAdaptor_Curve
        :type U1: float
        :type U2: float

        """
        return _StdPrs.StdPrs_HLRToolShape_Hidden(self, *args)

    __swig_destroy__ = _StdPrs.delete_StdPrs_HLRToolShape
StdPrs_HLRToolShape_swigregister = _StdPrs.StdPrs_HLRToolShape_swigregister
StdPrs_HLRToolShape_swigregister(StdPrs_HLRToolShape)

class StdPrs_WFDeflectionSurface(Prs3d.Prs3d_Root):
    """
    Draws a surface by drawing the isoparametric curves with respect to
    a maximal chordial deviation.
    The number of isoparametric curves to be drawn and their color are
    controlled by the furnished Drawer.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args):
        """
        Add(Handle_Prs3d_Presentation aPresentation, Handle_Adaptor3d_HSurface aSurface, Handle_Prs3d_Drawer aDrawer)

        Adds the surface aSurface to the presentation object
        aPresentation, and defines its boundaries and isoparameters.
        The shape's display attributes are set in the attribute
        manager aDrawer. These include whether deflection
        is absolute or relative to the size of the shape.
        The surface aSurface is a surface object from
        Adaptor, and provides data from a Geom surface.
        This makes it possible to use the surface in a geometric algorithm.
        Note that this surface object is manipulated by handles.

        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type aSurface: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _StdPrs.StdPrs_WFDeflectionSurface_Add(*args)

    Add = staticmethod(Add)

    def __init__(self):
        """
        Draws a surface by drawing the isoparametric curves with respect to
        a maximal chordial deviation.
        The number of isoparametric curves to be drawn and their color are
        controlled by the furnished Drawer.
        """
        this = _StdPrs.new_StdPrs_WFDeflectionSurface()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StdPrs.delete_StdPrs_WFDeflectionSurface
StdPrs_WFDeflectionSurface_swigregister = _StdPrs.StdPrs_WFDeflectionSurface_swigregister
StdPrs_WFDeflectionSurface_swigregister(StdPrs_WFDeflectionSurface)

def StdPrs_WFDeflectionSurface_Add(*args):
    """
    StdPrs_WFDeflectionSurface_Add(Handle_Prs3d_Presentation aPresentation, Handle_Adaptor3d_HSurface aSurface, Handle_Prs3d_Drawer aDrawer)

    Adds the surface aSurface to the presentation object
    aPresentation, and defines its boundaries and isoparameters.
    The shape's display attributes are set in the attribute
    manager aDrawer. These include whether deflection
    is absolute or relative to the size of the shape.
    The surface aSurface is a surface object from
    Adaptor, and provides data from a Geom surface.
    This makes it possible to use the surface in a geometric algorithm.
    Note that this surface object is manipulated by handles.

    :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
    :type aSurface: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

    """
    return _StdPrs.StdPrs_WFDeflectionSurface_Add(*args)

class StdPrs_ToolVertex(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Coord(*args):
        """
        Coord(TopoDS_Vertex aPoint)

        :type aPoint: OCC.wrapper.TopoDS.TopoDS_Vertex
        :type X: float
        :type Y: float
        :type Z: float

        """
        return _StdPrs.StdPrs_ToolVertex_Coord(*args)

    Coord = staticmethod(Coord)

    def __init__(self):
        this = _StdPrs.new_StdPrs_ToolVertex()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StdPrs.delete_StdPrs_ToolVertex
StdPrs_ToolVertex_swigregister = _StdPrs.StdPrs_ToolVertex_swigregister
StdPrs_ToolVertex_swigregister(StdPrs_ToolVertex)

def StdPrs_ToolVertex_Coord(*args):
    """
    StdPrs_ToolVertex_Coord(TopoDS_Vertex aPoint)

    :type aPoint: OCC.wrapper.TopoDS.TopoDS_Vertex
    :type X: float
    :type Y: float
    :type Z: float

    """
    return _StdPrs.StdPrs_ToolVertex_Coord(*args)

class StdPrs_ToolTriangulatedShape(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def IsTriangulated(*args):
        """
        IsTriangulated(TopoDS_Shape theShape) -> Standard_Boolean

        Similar to BRepTools::Triangulation() but without extra checks.
        @return true if all faces within shape are triangulated.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StdPrs.StdPrs_ToolTriangulatedShape_IsTriangulated(*args)

    IsTriangulated = staticmethod(IsTriangulated)

    def IsClosed(*args):
        """
        IsClosed(TopoDS_Shape theShape) -> Standard_Boolean

        Checks back faces visibility for specified shape (to activate back-face culling). <br>
        @return true if shape is closed manifold Solid or compound of such Solids. <br>

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StdPrs.StdPrs_ToolTriangulatedShape_IsClosed(*args)

    IsClosed = staticmethod(IsClosed)

    def ComputeNormals(*args):
        """
        ComputeNormals(TopoDS_Face theFace, Handle_Poly_Triangulation theTris)
        ComputeNormals(TopoDS_Face theFace, Handle_Poly_Triangulation theTris, Poly_Connect thePolyConnect)

        Computes nodal normals for Poly_Triangulation structure using UV coordinates and surface.
        Does nothing if triangulation already defines normals.
        @param theFace [in] the face
        @param theTris [in] the definition of a face triangulation
        @param thePolyConnect [in,out] optional, initialized tool for exploring triangulation

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theTris: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :type thePolyConnect: OCC.wrapper.Poly.Poly_Connect

        """
        return _StdPrs.StdPrs_ToolTriangulatedShape_ComputeNormals(*args)

    ComputeNormals = staticmethod(ComputeNormals)

    def Normal(*args):
        """
        Normal(TopoDS_Face theFace, Poly_Connect thePolyConnect, NCollection_Array1_gp_Dir theNormals)

        Evaluate normals for a triangle of a face.
        @param theFace [in] the face.
        @param thePolyConnect [in] the definition of a face triangulation.
        @param theNormal [out] the array of normals for each triangle.

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type thePolyConnect: OCC.wrapper.Poly.Poly_Connect
        :type theNormals: OCC.wrapper.TColgp.TColgp_Array1OfDir

        """
        return _StdPrs.StdPrs_ToolTriangulatedShape_Normal(*args)

    Normal = staticmethod(Normal)

    def IsTessellated(*args):
        """
        IsTessellated(TopoDS_Shape theShape, Handle_Prs3d_Drawer theDrawer) -> Standard_Boolean

        Checks whether the shape is properly triangulated for a given display settings.
        @param theShape [in] the shape.
        @param theDrawer [in] the display settings.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StdPrs.StdPrs_ToolTriangulatedShape_IsTessellated(*args)

    IsTessellated = staticmethod(IsTessellated)

    def Tessellate(*args):
        """
        Tessellate(TopoDS_Shape theShape, Handle_Prs3d_Drawer theDrawer) -> Standard_Boolean

        Validates triangulation within the shape and performs tessellation if necessary.
        @param theShape [in] the shape.
        @param theDrawer [in] the display settings.
        @return true if tesselation was recomputed and false otherwise.

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StdPrs.StdPrs_ToolTriangulatedShape_Tessellate(*args)

    Tessellate = staticmethod(Tessellate)

    def ClearOnOwnDeflectionChange(*args):
        """
        ClearOnOwnDeflectionChange(TopoDS_Shape theShape, Handle_Prs3d_Drawer theDrawer, Standard_Boolean const theToResetCoeff)

        If presentation has own deviation coefficient and IsAutoTriangulation() is true,
        function will compare actual coefficients with previous values and will clear triangulation on their change
        (regardless actual tessellation quality).
        Function is placed here for compatibility reasons - new code should avoid using IsAutoTriangulation().
        @param theShape  [in] the shape
        @param theDrawer [in] the display settings
        @param theToResetCoeff [in] updates coefficients in theDrawer to actual state to avoid redundant recomputations

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theToResetCoeff: bool

        """
        return _StdPrs.StdPrs_ToolTriangulatedShape_ClearOnOwnDeflectionChange(*args)

    ClearOnOwnDeflectionChange = staticmethod(ClearOnOwnDeflectionChange)

    def __init__(self):
        this = _StdPrs.new_StdPrs_ToolTriangulatedShape()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StdPrs.delete_StdPrs_ToolTriangulatedShape
StdPrs_ToolTriangulatedShape_swigregister = _StdPrs.StdPrs_ToolTriangulatedShape_swigregister
StdPrs_ToolTriangulatedShape_swigregister(StdPrs_ToolTriangulatedShape)

def StdPrs_ToolTriangulatedShape_IsTriangulated(*args):
    """
    StdPrs_ToolTriangulatedShape_IsTriangulated(TopoDS_Shape theShape) -> Standard_Boolean

    Similar to BRepTools::Triangulation() but without extra checks.
    @return true if all faces within shape are triangulated.

    :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _StdPrs.StdPrs_ToolTriangulatedShape_IsTriangulated(*args)

def StdPrs_ToolTriangulatedShape_IsClosed(*args):
    """
    StdPrs_ToolTriangulatedShape_IsClosed(TopoDS_Shape theShape) -> Standard_Boolean

    Checks back faces visibility for specified shape (to activate back-face culling). <br>
    @return true if shape is closed manifold Solid or compound of such Solids. <br>

    :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _StdPrs.StdPrs_ToolTriangulatedShape_IsClosed(*args)

def StdPrs_ToolTriangulatedShape_ComputeNormals(*args):
    """
    ComputeNormals(TopoDS_Face theFace, Handle_Poly_Triangulation theTris)
    StdPrs_ToolTriangulatedShape_ComputeNormals(TopoDS_Face theFace, Handle_Poly_Triangulation theTris, Poly_Connect thePolyConnect)

    Computes nodal normals for Poly_Triangulation structure using UV coordinates and surface.
    Does nothing if triangulation already defines normals.
    @param theFace [in] the face
    @param theTris [in] the definition of a face triangulation
    @param thePolyConnect [in,out] optional, initialized tool for exploring triangulation

    :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
    :type theTris: OCC.wrapper.Poly.Handle_Poly_Triangulation
    :type thePolyConnect: OCC.wrapper.Poly.Poly_Connect

    """
    return _StdPrs.StdPrs_ToolTriangulatedShape_ComputeNormals(*args)

def StdPrs_ToolTriangulatedShape_Normal(*args):
    """
    StdPrs_ToolTriangulatedShape_Normal(TopoDS_Face theFace, Poly_Connect thePolyConnect, NCollection_Array1_gp_Dir theNormals)

    Evaluate normals for a triangle of a face.
    @param theFace [in] the face.
    @param thePolyConnect [in] the definition of a face triangulation.
    @param theNormal [out] the array of normals for each triangle.

    :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
    :type thePolyConnect: OCC.wrapper.Poly.Poly_Connect
    :type theNormals: OCC.wrapper.TColgp.TColgp_Array1OfDir

    """
    return _StdPrs.StdPrs_ToolTriangulatedShape_Normal(*args)

def StdPrs_ToolTriangulatedShape_IsTessellated(*args):
    """
    StdPrs_ToolTriangulatedShape_IsTessellated(TopoDS_Shape theShape, Handle_Prs3d_Drawer theDrawer) -> Standard_Boolean

    Checks whether the shape is properly triangulated for a given display settings.
    @param theShape [in] the shape.
    @param theDrawer [in] the display settings.

    :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _StdPrs.StdPrs_ToolTriangulatedShape_IsTessellated(*args)

def StdPrs_ToolTriangulatedShape_Tessellate(*args):
    """
    StdPrs_ToolTriangulatedShape_Tessellate(TopoDS_Shape theShape, Handle_Prs3d_Drawer theDrawer) -> Standard_Boolean

    Validates triangulation within the shape and performs tessellation if necessary.
    @param theShape [in] the shape.
    @param theDrawer [in] the display settings.
    @return true if tesselation was recomputed and false otherwise.

    :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _StdPrs.StdPrs_ToolTriangulatedShape_Tessellate(*args)

def StdPrs_ToolTriangulatedShape_ClearOnOwnDeflectionChange(*args):
    """
    StdPrs_ToolTriangulatedShape_ClearOnOwnDeflectionChange(TopoDS_Shape theShape, Handle_Prs3d_Drawer theDrawer, Standard_Boolean const theToResetCoeff)

    If presentation has own deviation coefficient and IsAutoTriangulation() is true,
    function will compare actual coefficients with previous values and will clear triangulation on their change
    (regardless actual tessellation quality).
    Function is placed here for compatibility reasons - new code should avoid using IsAutoTriangulation().
    @param theShape  [in] the shape
    @param theDrawer [in] the display settings
    @param theToResetCoeff [in] updates coefficients in theDrawer to actual state to avoid redundant recomputations

    :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
    :type theToResetCoeff: bool

    """
    return _StdPrs.StdPrs_ToolTriangulatedShape_ClearOnOwnDeflectionChange(*args)

class StdPrs_DeflectionCurve(Prs3d.Prs3d_Root):
    """
    A framework to provide display of any curve with
    respect to the maximal chordal deviation defined in
    the Prs3d_Drawer attributes manager.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args):
        """
        Add(Handle_Prs3d_Presentation aPresentation, Adaptor3d_Curve aCurve, Handle_Prs3d_Drawer aDrawer, Standard_Boolean const drawCurve)
        Add(Handle_Prs3d_Presentation aPresentation, Adaptor3d_Curve aCurve, Standard_Real const U1, Standard_Real const U2, Handle_Prs3d_Drawer aDrawer, Standard_Boolean const drawCurve)
        Add(Handle_Prs3d_Presentation aPresentation, Adaptor3d_Curve aCurve, Standard_Real const aDeflection, Standard_Real const aLimit, Standard_Real const anAngle=0.2, Standard_Boolean const drawCurve)
        Add(Handle_Prs3d_Presentation aPresentation, Adaptor3d_Curve aCurve, Standard_Real const aDeflection, Handle_Prs3d_Drawer aDrawer, NCollection_Sequence_gp_Pnt Points, Standard_Boolean const drawCurve)
        Add(Handle_Prs3d_Presentation aPresentation, Adaptor3d_Curve aCurve, Standard_Real const U1, Standard_Real const U2, Standard_Real const aDeflection, NCollection_Sequence_gp_Pnt Points, Standard_Real const anAngle=0.2, Standard_Boolean const drawCurve)

        adds to the presentation aPresentation the drawing of the curve
        aCurve with respect to the maximal chordial deviation aDeflection.
        The aspect is the current aspect
        The drawing will be limited between the points of parameter U1 and U2.
        Points give a sequence of curve points.
        If drawCurve equals Standard_False the curve will not be displayed,
        it is used if the curve is a part of some shape and PrimitiveArray
        visualization approach is activated (it is activated by default).

        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type aCurve: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type U1: float
        :type U2: float
        :type aDeflection: float
        :type Points: OCC.wrapper.TColgp.TColgp_SequenceOfPnt
        :type anAngle: float
        :type drawCurve: bool

        """
        return _StdPrs.StdPrs_DeflectionCurve_Add(*args)

    Add = staticmethod(Add)

    def Match(*args):
        """
        Match(Standard_Real const X, Standard_Real const Y, Standard_Real const Z, Standard_Real const aDistance, Adaptor3d_Curve aCurve, Handle_Prs3d_Drawer aDrawer) -> Standard_Boolean
        Match(Standard_Real const X, Standard_Real const Y, Standard_Real const Z, Standard_Real const aDistance, Adaptor3d_Curve aCurve, Standard_Real const U1, Standard_Real const U2, Handle_Prs3d_Drawer aDrawer) -> Standard_Boolean
        Match(Standard_Real const theX, Standard_Real const theY, Standard_Real const theZ, Standard_Real const theDistance, Adaptor3d_Curve theCurve, Standard_Real const theDeflection, Standard_Real const theLimit, Standard_Real const theAngle) -> Standard_Boolean
        Match(Standard_Real const theX, Standard_Real const theY, Standard_Real const theZ, Standard_Real const theDistance, Adaptor3d_Curve theCurve, Standard_Real const theU1, Standard_Real const theU2, Standard_Real const theDeflection, Standard_Real const theAngle) -> Standard_Boolean

        Returns true if the distance between the point (theX, theY, theZ)
        and the drawing with respect of the maximal chordial deviation theDeflection is less then theDistance.
        The drawing is considered between the points of parameter theU1 and theU2.

        :type theX: float
        :type theY: float
        :type theZ: float
        :type theDistance: float
        :type theCurve: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type theU1: float
        :type theU2: float
        :type theDeflection: float
        :type theAngle: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StdPrs.StdPrs_DeflectionCurve_Match(*args)

    Match = staticmethod(Match)

    def __init__(self):
        """
        A framework to provide display of any curve with
        respect to the maximal chordal deviation defined in
        the Prs3d_Drawer attributes manager.
        """
        this = _StdPrs.new_StdPrs_DeflectionCurve()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StdPrs.delete_StdPrs_DeflectionCurve
StdPrs_DeflectionCurve_swigregister = _StdPrs.StdPrs_DeflectionCurve_swigregister
StdPrs_DeflectionCurve_swigregister(StdPrs_DeflectionCurve)

def StdPrs_DeflectionCurve_Add(*args):
    """
    Add(Handle_Prs3d_Presentation aPresentation, Adaptor3d_Curve aCurve, Handle_Prs3d_Drawer aDrawer, Standard_Boolean const drawCurve)
    Add(Handle_Prs3d_Presentation aPresentation, Adaptor3d_Curve aCurve, Standard_Real const U1, Standard_Real const U2, Handle_Prs3d_Drawer aDrawer, Standard_Boolean const drawCurve)
    Add(Handle_Prs3d_Presentation aPresentation, Adaptor3d_Curve aCurve, Standard_Real const aDeflection, Standard_Real const aLimit, Standard_Real const anAngle=0.2, Standard_Boolean const drawCurve)
    Add(Handle_Prs3d_Presentation aPresentation, Adaptor3d_Curve aCurve, Standard_Real const aDeflection, Handle_Prs3d_Drawer aDrawer, NCollection_Sequence_gp_Pnt Points, Standard_Boolean const drawCurve)
    StdPrs_DeflectionCurve_Add(Handle_Prs3d_Presentation aPresentation, Adaptor3d_Curve aCurve, Standard_Real const U1, Standard_Real const U2, Standard_Real const aDeflection, NCollection_Sequence_gp_Pnt Points, Standard_Real const anAngle=0.2, Standard_Boolean const drawCurve)

    adds to the presentation aPresentation the drawing of the curve
    aCurve with respect to the maximal chordial deviation aDeflection.
    The aspect is the current aspect
    The drawing will be limited between the points of parameter U1 and U2.
    Points give a sequence of curve points.
    If drawCurve equals Standard_False the curve will not be displayed,
    it is used if the curve is a part of some shape and PrimitiveArray
    visualization approach is activated (it is activated by default).

    :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
    :type aCurve: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :type U1: float
    :type U2: float
    :type aDeflection: float
    :type Points: OCC.wrapper.TColgp.TColgp_SequenceOfPnt
    :type anAngle: float
    :type drawCurve: bool

    """
    return _StdPrs.StdPrs_DeflectionCurve_Add(*args)

def StdPrs_DeflectionCurve_Match(*args):
    """
    Match(Standard_Real const X, Standard_Real const Y, Standard_Real const Z, Standard_Real const aDistance, Adaptor3d_Curve aCurve, Handle_Prs3d_Drawer aDrawer) -> Standard_Boolean
    Match(Standard_Real const X, Standard_Real const Y, Standard_Real const Z, Standard_Real const aDistance, Adaptor3d_Curve aCurve, Standard_Real const U1, Standard_Real const U2, Handle_Prs3d_Drawer aDrawer) -> Standard_Boolean
    Match(Standard_Real const theX, Standard_Real const theY, Standard_Real const theZ, Standard_Real const theDistance, Adaptor3d_Curve theCurve, Standard_Real const theDeflection, Standard_Real const theLimit, Standard_Real const theAngle) -> Standard_Boolean
    StdPrs_DeflectionCurve_Match(Standard_Real const theX, Standard_Real const theY, Standard_Real const theZ, Standard_Real const theDistance, Adaptor3d_Curve theCurve, Standard_Real const theU1, Standard_Real const theU2, Standard_Real const theDeflection, Standard_Real const theAngle) -> Standard_Boolean

    Returns true if the distance between the point (theX, theY, theZ)
    and the drawing with respect of the maximal chordial deviation theDeflection is less then theDistance.
    The drawing is considered between the points of parameter theU1 and theU2.

    :type theX: float
    :type theY: float
    :type theZ: float
    :type theDistance: float
    :type theCurve: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :type theU1: float
    :type theU2: float
    :type theDeflection: float
    :type theAngle: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _StdPrs.StdPrs_DeflectionCurve_Match(*args)

class StdPrs_WFPoleSurface(Prs3d.Prs3d_Root):
    """
    Computes the presentation of surfaces by drawing a
    double network of lines linking the poles of the surface
    in the two parametric direction.
    The number of lines to be drawn is controlled
    by the NetworkNumber of the given Drawer.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args):
        """
        Add(Handle_Prs3d_Presentation aPresentation, Adaptor3d_Surface aSurface, Handle_Prs3d_Drawer aDrawer)

        Adds the surface aSurface to the presentation object aPresentation.
        The shape's display attributes are set in the attribute manager aDrawer.
        The surface aSurface is a surface object from
        Adaptor3d, and provides data from a Geom surface.
        This makes it possible to use the surface in a geometric algorithm.

        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type aSurface: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
        :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _StdPrs.StdPrs_WFPoleSurface_Add(*args)

    Add = staticmethod(Add)

    def __init__(self):
        """
        Computes the presentation of surfaces by drawing a
        double network of lines linking the poles of the surface
        in the two parametric direction.
        The number of lines to be drawn is controlled
        by the NetworkNumber of the given Drawer.
        """
        this = _StdPrs.new_StdPrs_WFPoleSurface()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StdPrs.delete_StdPrs_WFPoleSurface
StdPrs_WFPoleSurface_swigregister = _StdPrs.StdPrs_WFPoleSurface_swigregister
StdPrs_WFPoleSurface_swigregister(StdPrs_WFPoleSurface)

def StdPrs_WFPoleSurface_Add(*args):
    """
    StdPrs_WFPoleSurface_Add(Handle_Prs3d_Presentation aPresentation, Adaptor3d_Surface aSurface, Handle_Prs3d_Drawer aDrawer)

    Adds the surface aSurface to the presentation object aPresentation.
    The shape's display attributes are set in the attribute manager aDrawer.
    The surface aSurface is a surface object from
    Adaptor3d, and provides data from a Geom surface.
    This makes it possible to use the surface in a geometric algorithm.

    :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
    :type aSurface: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
    :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

    """
    return _StdPrs.StdPrs_WFPoleSurface_Add(*args)

class StdPrs_ShadedShape(Prs3d.Prs3d_Root):
    """Auxiliary procedures to prepare Shaded presentation of specified shape."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args):
        """
        Add(Handle_Prs3d_Presentation thePresentation, TopoDS_Shape theShape, Handle_Prs3d_Drawer theDrawer, StdPrs_Volume const theVolume=StdPrs_Volume_Autodetection)
        Add(Handle_Prs3d_Presentation thePresentation, TopoDS_Shape theShape, Handle_Prs3d_Drawer theDrawer, Standard_Boolean const theHasTexels, gp_Pnt2d theUVOrigin, gp_Pnt2d theUVRepeat, gp_Pnt2d theUVScale, StdPrs_Volume const theVolume=StdPrs_Volume_Autodetection)

        Shades <theShape> with texture coordinates.
        @param theVolumeType defines the way how to interpret input shapes - as Closed volumes (to activate back-face
        culling and capping plane algorithms), as Open volumes (shells or solids with holes)
        or to perform Autodetection (would split input shape into two groups)

        :type thePresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theHasTexels: bool
        :type theUVOrigin: OCC.wrapper.gp.gp_Pnt2d
        :type theUVRepeat: OCC.wrapper.gp.gp_Pnt2d
        :type theUVScale: OCC.wrapper.gp.gp_Pnt2d
        :type theVolume: OCC.wrapper.StdPrs.StdPrs_Volume

        """
        return _StdPrs.StdPrs_ShadedShape_Add(*args)

    Add = staticmethod(Add)

    def ExploreSolids(*args):
        """
        ExploreSolids(TopoDS_Shape theShape, BRep_Builder theBuilder, TopoDS_Compound theClosed, TopoDS_Compound theOpened, Standard_Boolean const theIgnore1DSubShape)

        Searches closed and unclosed subshapes in shape structure and puts them
        into two compounds for separate processing of closed and unclosed sub-shapes

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theBuilder: OCC.wrapper.BRep.BRep_Builder
        :type theClosed: OCC.wrapper.TopoDS.TopoDS_Compound
        :type theOpened: OCC.wrapper.TopoDS.TopoDS_Compound
        :type theIgnore1DSubShape: bool

        """
        return _StdPrs.StdPrs_ShadedShape_ExploreSolids(*args)

    ExploreSolids = staticmethod(ExploreSolids)

    def AddWireframeForFreeElements(*args):
        """
        AddWireframeForFreeElements(Handle_Prs3d_Presentation thePrs, TopoDS_Shape theShape, Handle_Prs3d_Drawer theDrawer)

        Computes wireframe presentation for free wires and vertices

        :type thePrs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _StdPrs.StdPrs_ShadedShape_AddWireframeForFreeElements(*args)

    AddWireframeForFreeElements = staticmethod(AddWireframeForFreeElements)

    def AddWireframeForFacesWithoutTriangles(*args):
        """
        AddWireframeForFacesWithoutTriangles(Handle_Prs3d_Presentation thePrs, TopoDS_Shape theShape, Handle_Prs3d_Drawer theDrawer)

        Computes special wireframe presentation for faces without triangulation.

        :type thePrs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _StdPrs.StdPrs_ShadedShape_AddWireframeForFacesWithoutTriangles(*args)

    AddWireframeForFacesWithoutTriangles = staticmethod(AddWireframeForFacesWithoutTriangles)

    def FillTriangles(*args):
        """
        FillTriangles(TopoDS_Shape theShape) -> Handle_Graphic3d_ArrayOfTriangles
        FillTriangles(TopoDS_Shape theShape, Standard_Boolean const theHasTexels, gp_Pnt2d theUVOrigin, gp_Pnt2d theUVRepeat, gp_Pnt2d theUVScale) -> Handle_Graphic3d_ArrayOfTriangles

        Create primitive array of triangles for specified shape.
        @param theShape     the shape with precomputed triangulation
        @param theHasTexels define UV coordinates in primitive array
        @param theUVOrigin  origin for UV coordinates
        @param theUVRepeat  repeat parameters  for UV coordinates
        @param theUVScale   scale coefficients for UV coordinates
        @return triangles array or NULL if specified face does not have computed triangulation

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theHasTexels: bool
        :type theUVOrigin: OCC.wrapper.gp.gp_Pnt2d
        :type theUVRepeat: OCC.wrapper.gp.gp_Pnt2d
        :type theUVScale: OCC.wrapper.gp.gp_Pnt2d
        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_ArrayOfTriangles

        """
        return _StdPrs.StdPrs_ShadedShape_FillTriangles(*args)

    FillTriangles = staticmethod(FillTriangles)

    def FillFaceBoundaries(*args):
        """
        FillFaceBoundaries(TopoDS_Shape theShape) -> Handle_Graphic3d_ArrayOfSegments

        Define primitive array of boundary segments for specified shape.
        @param theShape segments array or NULL if specified face does not have computed triangulation

        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_ArrayOfSegments

        """
        return _StdPrs.StdPrs_ShadedShape_FillFaceBoundaries(*args)

    FillFaceBoundaries = staticmethod(FillFaceBoundaries)

    def __init__(self):
        """Auxiliary procedures to prepare Shaded presentation of specified shape."""
        this = _StdPrs.new_StdPrs_ShadedShape()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StdPrs.delete_StdPrs_ShadedShape
StdPrs_ShadedShape_swigregister = _StdPrs.StdPrs_ShadedShape_swigregister
StdPrs_ShadedShape_swigregister(StdPrs_ShadedShape)

def StdPrs_ShadedShape_Add(*args):
    """
    Add(Handle_Prs3d_Presentation thePresentation, TopoDS_Shape theShape, Handle_Prs3d_Drawer theDrawer, StdPrs_Volume const theVolume=StdPrs_Volume_Autodetection)
    StdPrs_ShadedShape_Add(Handle_Prs3d_Presentation thePresentation, TopoDS_Shape theShape, Handle_Prs3d_Drawer theDrawer, Standard_Boolean const theHasTexels, gp_Pnt2d theUVOrigin, gp_Pnt2d theUVRepeat, gp_Pnt2d theUVScale, StdPrs_Volume const theVolume=StdPrs_Volume_Autodetection)

    Shades <theShape> with texture coordinates.
    @param theVolumeType defines the way how to interpret input shapes - as Closed volumes (to activate back-face
    culling and capping plane algorithms), as Open volumes (shells or solids with holes)
    or to perform Autodetection (would split input shape into two groups)

    :type thePresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
    :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
    :type theHasTexels: bool
    :type theUVOrigin: OCC.wrapper.gp.gp_Pnt2d
    :type theUVRepeat: OCC.wrapper.gp.gp_Pnt2d
    :type theUVScale: OCC.wrapper.gp.gp_Pnt2d
    :type theVolume: OCC.wrapper.StdPrs.StdPrs_Volume

    """
    return _StdPrs.StdPrs_ShadedShape_Add(*args)

def StdPrs_ShadedShape_ExploreSolids(*args):
    """
    StdPrs_ShadedShape_ExploreSolids(TopoDS_Shape theShape, BRep_Builder theBuilder, TopoDS_Compound theClosed, TopoDS_Compound theOpened, Standard_Boolean const theIgnore1DSubShape)

    Searches closed and unclosed subshapes in shape structure and puts them
    into two compounds for separate processing of closed and unclosed sub-shapes

    :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theBuilder: OCC.wrapper.BRep.BRep_Builder
    :type theClosed: OCC.wrapper.TopoDS.TopoDS_Compound
    :type theOpened: OCC.wrapper.TopoDS.TopoDS_Compound
    :type theIgnore1DSubShape: bool

    """
    return _StdPrs.StdPrs_ShadedShape_ExploreSolids(*args)

def StdPrs_ShadedShape_AddWireframeForFreeElements(*args):
    """
    StdPrs_ShadedShape_AddWireframeForFreeElements(Handle_Prs3d_Presentation thePrs, TopoDS_Shape theShape, Handle_Prs3d_Drawer theDrawer)

    Computes wireframe presentation for free wires and vertices

    :type thePrs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
    :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

    """
    return _StdPrs.StdPrs_ShadedShape_AddWireframeForFreeElements(*args)

def StdPrs_ShadedShape_AddWireframeForFacesWithoutTriangles(*args):
    """
    StdPrs_ShadedShape_AddWireframeForFacesWithoutTriangles(Handle_Prs3d_Presentation thePrs, TopoDS_Shape theShape, Handle_Prs3d_Drawer theDrawer)

    Computes special wireframe presentation for faces without triangulation.

    :type thePrs: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
    :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

    """
    return _StdPrs.StdPrs_ShadedShape_AddWireframeForFacesWithoutTriangles(*args)

def StdPrs_ShadedShape_FillTriangles(*args):
    """
    FillTriangles(TopoDS_Shape theShape) -> Handle_Graphic3d_ArrayOfTriangles
    StdPrs_ShadedShape_FillTriangles(TopoDS_Shape theShape, Standard_Boolean const theHasTexels, gp_Pnt2d theUVOrigin, gp_Pnt2d theUVRepeat, gp_Pnt2d theUVScale) -> Handle_Graphic3d_ArrayOfTriangles

    Create primitive array of triangles for specified shape.
    @param theShape     the shape with precomputed triangulation
    @param theHasTexels define UV coordinates in primitive array
    @param theUVOrigin  origin for UV coordinates
    @param theUVRepeat  repeat parameters  for UV coordinates
    @param theUVScale   scale coefficients for UV coordinates
    @return triangles array or NULL if specified face does not have computed triangulation

    :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theHasTexels: bool
    :type theUVOrigin: OCC.wrapper.gp.gp_Pnt2d
    :type theUVRepeat: OCC.wrapper.gp.gp_Pnt2d
    :type theUVScale: OCC.wrapper.gp.gp_Pnt2d
    :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_ArrayOfTriangles

    """
    return _StdPrs.StdPrs_ShadedShape_FillTriangles(*args)

def StdPrs_ShadedShape_FillFaceBoundaries(*args):
    """
    StdPrs_ShadedShape_FillFaceBoundaries(TopoDS_Shape theShape) -> Handle_Graphic3d_ArrayOfSegments

    Define primitive array of boundary segments for specified shape.
    @param theShape segments array or NULL if specified face does not have computed triangulation

    :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.Graphic3d.Handle_Graphic3d_ArrayOfSegments

    """
    return _StdPrs.StdPrs_ShadedShape_FillFaceBoundaries(*args)

class StdPrs_HLRShape(Prs3d.Prs3d_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args):
        """
        Add(Handle_Prs3d_Presentation thePresentation, TopoDS_Shape theShape, Handle_Prs3d_Drawer theDrawer, Handle_Prs3d_Projector theProjector)

        :type thePresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector

        """
        return _StdPrs.StdPrs_HLRShape_Add(*args)

    Add = staticmethod(Add)

    def __init__(self):
        this = _StdPrs.new_StdPrs_HLRShape()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StdPrs.delete_StdPrs_HLRShape
StdPrs_HLRShape_swigregister = _StdPrs.StdPrs_HLRShape_swigregister
StdPrs_HLRShape_swigregister(StdPrs_HLRShape)

def StdPrs_HLRShape_Add(*args):
    """
    StdPrs_HLRShape_Add(Handle_Prs3d_Presentation thePresentation, TopoDS_Shape theShape, Handle_Prs3d_Drawer theDrawer, Handle_Prs3d_Projector theProjector)

    :type thePresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
    :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
    :type theProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector

    """
    return _StdPrs.StdPrs_HLRShape_Add(*args)

class StdPrs_WFRestrictedFace(Prs3d.Prs3d_Root):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args):
        """
        Add(Handle_Prs3d_Presentation thePresentation, Handle_BRepAdaptor_HSurface theFace, Standard_Boolean const theDrawUIso, Standard_Boolean const theDrawVIso, Standard_Integer const theNbUIso, Standard_Integer const theNbVIso, Handle_Prs3d_Drawer theDrawer, NCollection_List_Handle_TColgp_HSequenceOfPnt theCurves)
        Add(Handle_Prs3d_Presentation thePresentation, Handle_BRepAdaptor_HSurface theFace, Handle_Prs3d_Drawer theDrawer)

        :type thePresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type theFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _StdPrs.StdPrs_WFRestrictedFace_Add(*args)

    Add = staticmethod(Add)

    def Match(*args):
        """
        Match(Standard_Real const theX, Standard_Real const theY, Standard_Real const theZ, Standard_Real const theDistance, Handle_BRepAdaptor_HSurface theFace, Standard_Boolean const theDrawUIso, Standard_Boolean const theDrawVIso, Standard_Real const theDeflection, Standard_Integer const theNbUIso, Standard_Integer const theNbVIso, Handle_Prs3d_Drawer theDrawer) -> Standard_Boolean
        Match(Standard_Real const theX, Standard_Real const theY, Standard_Real const theZ, Standard_Real const theDistance, Handle_BRepAdaptor_HSurface theFace, Handle_Prs3d_Drawer theDrawer) -> Standard_Boolean

        :type theX: float
        :type theY: float
        :type theZ: float
        :type theDistance: float
        :type theFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StdPrs.StdPrs_WFRestrictedFace_Match(*args)

    Match = staticmethod(Match)

    def MatchUIso(*args):
        """
        MatchUIso(Standard_Real const theX, Standard_Real const theY, Standard_Real const theZ, Standard_Real const theDistance, Handle_BRepAdaptor_HSurface theFace, Handle_Prs3d_Drawer theDrawer) -> Standard_Boolean

        :type theX: float
        :type theY: float
        :type theZ: float
        :type theDistance: float
        :type theFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StdPrs.StdPrs_WFRestrictedFace_MatchUIso(*args)

    MatchUIso = staticmethod(MatchUIso)

    def MatchVIso(*args):
        """
        MatchVIso(Standard_Real const theX, Standard_Real const theY, Standard_Real const theZ, Standard_Real const theDistance, Handle_BRepAdaptor_HSurface theFace, Handle_Prs3d_Drawer theDrawer) -> Standard_Boolean

        :type theX: float
        :type theY: float
        :type theZ: float
        :type theDistance: float
        :type theFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StdPrs.StdPrs_WFRestrictedFace_MatchVIso(*args)

    MatchVIso = staticmethod(MatchVIso)

    def AddUIso(*args):
        """
        AddUIso(Handle_Prs3d_Presentation thePresentation, Handle_BRepAdaptor_HSurface theFace, Handle_Prs3d_Drawer theDrawer)

        :type thePresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type theFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _StdPrs.StdPrs_WFRestrictedFace_AddUIso(*args)

    AddUIso = staticmethod(AddUIso)

    def AddVIso(*args):
        """
        AddVIso(Handle_Prs3d_Presentation thePresentation, Handle_BRepAdaptor_HSurface theFace, Handle_Prs3d_Drawer theDrawer)

        :type thePresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type theFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _StdPrs.StdPrs_WFRestrictedFace_AddVIso(*args)

    AddVIso = staticmethod(AddVIso)

    def __init__(self):
        this = _StdPrs.new_StdPrs_WFRestrictedFace()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StdPrs.delete_StdPrs_WFRestrictedFace
StdPrs_WFRestrictedFace_swigregister = _StdPrs.StdPrs_WFRestrictedFace_swigregister
StdPrs_WFRestrictedFace_swigregister(StdPrs_WFRestrictedFace)

def StdPrs_WFRestrictedFace_Add(*args):
    """
    Add(Handle_Prs3d_Presentation thePresentation, Handle_BRepAdaptor_HSurface theFace, Standard_Boolean const theDrawUIso, Standard_Boolean const theDrawVIso, Standard_Integer const theNbUIso, Standard_Integer const theNbVIso, Handle_Prs3d_Drawer theDrawer, NCollection_List_Handle_TColgp_HSequenceOfPnt theCurves)
    StdPrs_WFRestrictedFace_Add(Handle_Prs3d_Presentation thePresentation, Handle_BRepAdaptor_HSurface theFace, Handle_Prs3d_Drawer theDrawer)

    :type thePresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
    :type theFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
    :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

    """
    return _StdPrs.StdPrs_WFRestrictedFace_Add(*args)

def StdPrs_WFRestrictedFace_Match(*args):
    """
    Match(Standard_Real const theX, Standard_Real const theY, Standard_Real const theZ, Standard_Real const theDistance, Handle_BRepAdaptor_HSurface theFace, Standard_Boolean const theDrawUIso, Standard_Boolean const theDrawVIso, Standard_Real const theDeflection, Standard_Integer const theNbUIso, Standard_Integer const theNbVIso, Handle_Prs3d_Drawer theDrawer) -> Standard_Boolean
    StdPrs_WFRestrictedFace_Match(Standard_Real const theX, Standard_Real const theY, Standard_Real const theZ, Standard_Real const theDistance, Handle_BRepAdaptor_HSurface theFace, Handle_Prs3d_Drawer theDrawer) -> Standard_Boolean

    :type theX: float
    :type theY: float
    :type theZ: float
    :type theDistance: float
    :type theFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
    :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _StdPrs.StdPrs_WFRestrictedFace_Match(*args)

def StdPrs_WFRestrictedFace_MatchUIso(*args):
    """
    StdPrs_WFRestrictedFace_MatchUIso(Standard_Real const theX, Standard_Real const theY, Standard_Real const theZ, Standard_Real const theDistance, Handle_BRepAdaptor_HSurface theFace, Handle_Prs3d_Drawer theDrawer) -> Standard_Boolean

    :type theX: float
    :type theY: float
    :type theZ: float
    :type theDistance: float
    :type theFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
    :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _StdPrs.StdPrs_WFRestrictedFace_MatchUIso(*args)

def StdPrs_WFRestrictedFace_MatchVIso(*args):
    """
    StdPrs_WFRestrictedFace_MatchVIso(Standard_Real const theX, Standard_Real const theY, Standard_Real const theZ, Standard_Real const theDistance, Handle_BRepAdaptor_HSurface theFace, Handle_Prs3d_Drawer theDrawer) -> Standard_Boolean

    :type theX: float
    :type theY: float
    :type theZ: float
    :type theDistance: float
    :type theFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
    :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _StdPrs.StdPrs_WFRestrictedFace_MatchVIso(*args)

def StdPrs_WFRestrictedFace_AddUIso(*args):
    """
    StdPrs_WFRestrictedFace_AddUIso(Handle_Prs3d_Presentation thePresentation, Handle_BRepAdaptor_HSurface theFace, Handle_Prs3d_Drawer theDrawer)

    :type thePresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
    :type theFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
    :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

    """
    return _StdPrs.StdPrs_WFRestrictedFace_AddUIso(*args)

def StdPrs_WFRestrictedFace_AddVIso(*args):
    """
    StdPrs_WFRestrictedFace_AddVIso(Handle_Prs3d_Presentation thePresentation, Handle_BRepAdaptor_HSurface theFace, Handle_Prs3d_Drawer theDrawer)

    :type thePresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
    :type theFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
    :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

    """
    return _StdPrs.StdPrs_WFRestrictedFace_AddVIso(*args)

class StdPrs_ToolRFace(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(StdPrs_ToolRFace self) -> StdPrs_ToolRFace
        __init__(StdPrs_ToolRFace self, Handle_BRepAdaptor_HSurface aSurface) -> StdPrs_ToolRFace

        :type aSurface: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface

        """
        this = _StdPrs.new_StdPrs_ToolRFace(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsOriented(self, *args):
        """
        IsOriented(StdPrs_ToolRFace self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StdPrs.StdPrs_ToolRFace_IsOriented(self, *args)


    def Init(self, *args):
        """Init(StdPrs_ToolRFace self)"""
        return _StdPrs.StdPrs_ToolRFace_Init(self, *args)


    def More(self, *args):
        """
        More(StdPrs_ToolRFace self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StdPrs.StdPrs_ToolRFace_More(self, *args)


    def Next(self, *args):
        """Next(StdPrs_ToolRFace self)"""
        return _StdPrs.StdPrs_ToolRFace_Next(self, *args)


    def Value(self, *args):
        """
        Value(StdPrs_ToolRFace self) -> Adaptor2d_Curve2d

        :rtype: OCC.wrapper.Adaptor2d.Adaptor2d_Curve2dPtr

        """
        return _StdPrs.StdPrs_ToolRFace_Value(self, *args)


    def Orientation(self, *args):
        """
        Orientation(StdPrs_ToolRFace self) -> TopAbs_Orientation

        :rtype: OCC.wrapper.TopAbs.TopAbs_Orientation

        """
        return _StdPrs.StdPrs_ToolRFace_Orientation(self, *args)

    __swig_destroy__ = _StdPrs.delete_StdPrs_ToolRFace
StdPrs_ToolRFace_swigregister = _StdPrs.StdPrs_ToolRFace_swigregister
StdPrs_ToolRFace_swigregister(StdPrs_ToolRFace)

class StdPrs_PoleCurve(Prs3d.Prs3d_Root):
    """
    A framework to provide display of Bezier or BSpline curves
    (by drawing a broken line linking the poles of the curve).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args):
        """
        Add(Handle_Prs3d_Presentation aPresentation, Adaptor3d_Curve aCurve, Handle_Prs3d_Drawer aDrawer)

        Defines display of BSpline and Bezier curves.
        Adds the 3D curve aCurve to the
        StdPrs_PoleCurve algorithm. This shape is found in
        the presentation object aPresentation, and its display
        attributes are set in the attribute manager aDrawer.
        The curve object from Adaptor3d provides data from
        a Geom curve. This makes it possible to use the
        surface in a geometric algorithm.

        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type aCurve: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _StdPrs.StdPrs_PoleCurve_Add(*args)

    Add = staticmethod(Add)

    def Match(*args):
        """
        Match(Standard_Real const X, Standard_Real const Y, Standard_Real const Z, Standard_Real const aDistance, Adaptor3d_Curve aCurve, Handle_Prs3d_Drawer aDrawer) -> Standard_Boolean

        returns true if the distance between the point (X,Y,Z) and the
        broken line made of the poles is less then aDistance.

        :type X: float
        :type Y: float
        :type Z: float
        :type aDistance: float
        :type aCurve: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StdPrs.StdPrs_PoleCurve_Match(*args)

    Match = staticmethod(Match)

    def Pick(*args):
        """
        Pick(Standard_Real const X, Standard_Real const Y, Standard_Real const Z, Standard_Real const aDistance, Adaptor3d_Curve aCurve, Handle_Prs3d_Drawer aDrawer) -> Standard_Integer

        returns the pole  the most near of the point (X,Y,Z) and
        returns its range. The distance between the pole and
        (X,Y,Z) must be less then aDistance. If no pole corresponds, 0 is returned.

        :type X: float
        :type Y: float
        :type Z: float
        :type aDistance: float
        :type aCurve: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _StdPrs.StdPrs_PoleCurve_Pick(*args)

    Pick = staticmethod(Pick)

    def __init__(self):
        """
        A framework to provide display of Bezier or BSpline curves
        (by drawing a broken line linking the poles of the curve).
        """
        this = _StdPrs.new_StdPrs_PoleCurve()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StdPrs.delete_StdPrs_PoleCurve
StdPrs_PoleCurve_swigregister = _StdPrs.StdPrs_PoleCurve_swigregister
StdPrs_PoleCurve_swigregister(StdPrs_PoleCurve)

def StdPrs_PoleCurve_Add(*args):
    """
    StdPrs_PoleCurve_Add(Handle_Prs3d_Presentation aPresentation, Adaptor3d_Curve aCurve, Handle_Prs3d_Drawer aDrawer)

    Defines display of BSpline and Bezier curves.
    Adds the 3D curve aCurve to the
    StdPrs_PoleCurve algorithm. This shape is found in
    the presentation object aPresentation, and its display
    attributes are set in the attribute manager aDrawer.
    The curve object from Adaptor3d provides data from
    a Geom curve. This makes it possible to use the
    surface in a geometric algorithm.

    :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
    :type aCurve: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

    """
    return _StdPrs.StdPrs_PoleCurve_Add(*args)

def StdPrs_PoleCurve_Match(*args):
    """
    StdPrs_PoleCurve_Match(Standard_Real const X, Standard_Real const Y, Standard_Real const Z, Standard_Real const aDistance, Adaptor3d_Curve aCurve, Handle_Prs3d_Drawer aDrawer) -> Standard_Boolean

    returns true if the distance between the point (X,Y,Z) and the
    broken line made of the poles is less then aDistance.

    :type X: float
    :type Y: float
    :type Z: float
    :type aDistance: float
    :type aCurve: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _StdPrs.StdPrs_PoleCurve_Match(*args)

def StdPrs_PoleCurve_Pick(*args):
    """
    StdPrs_PoleCurve_Pick(Standard_Real const X, Standard_Real const Y, Standard_Real const Z, Standard_Real const aDistance, Adaptor3d_Curve aCurve, Handle_Prs3d_Drawer aDrawer) -> Standard_Integer

    returns the pole  the most near of the point (X,Y,Z) and
    returns its range. The distance between the pole and
    (X,Y,Z) must be less then aDistance. If no pole corresponds, 0 is returned.

    :type X: float
    :type Y: float
    :type Z: float
    :type aDistance: float
    :type aCurve: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _StdPrs.StdPrs_PoleCurve_Pick(*args)

class StdPrs_Curve(Prs3d.Prs3d_Root):
    """
    A framework to define display of lines, arcs of circles
    and conic sections.
    This is done with a fixed number of points, which can be modified.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args):
        """
        Add(Handle_Prs3d_Presentation aPresentation, Adaptor3d_Curve aCurve, Handle_Prs3d_Drawer aDrawer, Standard_Boolean const drawCurve)
        Add(Handle_Prs3d_Presentation aPresentation, Adaptor3d_Curve aCurve, Standard_Real const U1, Standard_Real const U2, Handle_Prs3d_Drawer aDrawer, Standard_Boolean const drawCurve)
        Add(Handle_Prs3d_Presentation aPresentation, Adaptor3d_Curve aCurve, Handle_Prs3d_Drawer aDrawer, NCollection_Sequence_gp_Pnt Points, Standard_Boolean const drawCurve)
        Add(Handle_Prs3d_Presentation aPresentation, Adaptor3d_Curve aCurve, Standard_Real const U1, Standard_Real const U2, NCollection_Sequence_gp_Pnt Points, Standard_Integer const aNbPoints=30, Standard_Boolean const drawCurve)

        adds to the presentation aPresentation the drawing of the curve
        aCurve.
        The aspect is the current aspect.
        The drawing will be limited between the points of parameter
        U1 and U2.
        aDeflection is used in the circle case.
        Points give a sequence of curve points.
        If drawCurve equals Standard_False the curve will not be displayed,
        it is used if the curve is a part of some shape and PrimitiveArray
        visualization approach is activated (it is activated by default).

        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type aCurve: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type U1: float
        :type U2: float
        :type Points: OCC.wrapper.TColgp.TColgp_SequenceOfPnt
        :type aNbPoints: int
        :type drawCurve: bool

        """
        return _StdPrs.StdPrs_Curve_Add(*args)

    Add = staticmethod(Add)

    def Match(*args):
        """
        Match(Standard_Real const X, Standard_Real const Y, Standard_Real const Z, Standard_Real const aDistance, Adaptor3d_Curve aCurve, Handle_Prs3d_Drawer aDrawer) -> Standard_Boolean
        Match(Standard_Real const X, Standard_Real const Y, Standard_Real const Z, Standard_Real const aDistance, Adaptor3d_Curve aCurve, Standard_Real const aDeflection, Standard_Real const aLimit, Standard_Integer const aNbPoints) -> Standard_Boolean
        Match(Standard_Real const X, Standard_Real const Y, Standard_Real const Z, Standard_Real const aDistance, Adaptor3d_Curve aCurve, Standard_Real const U1, Standard_Real const U2, Handle_Prs3d_Drawer aDrawer) -> Standard_Boolean
        Match(Standard_Real const X, Standard_Real const Y, Standard_Real const Z, Standard_Real const aDistance, Adaptor3d_Curve aCurve, Standard_Real const U1, Standard_Real const U2, Standard_Real const aDeflection, Standard_Integer const aNbPoints) -> Standard_Boolean

        returns true if the distance between the point (X,Y,Z) and the
        drawing of the curve aCurve is less than aDistance.
        The drawing is considered between the points
        of parameter U1 and U2;

        :type X: float
        :type Y: float
        :type Z: float
        :type aDistance: float
        :type aCurve: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :type U1: float
        :type U2: float
        :type aDeflection: float
        :type aNbPoints: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StdPrs.StdPrs_Curve_Match(*args)

    Match = staticmethod(Match)

    def __init__(self):
        """
        A framework to define display of lines, arcs of circles
        and conic sections.
        This is done with a fixed number of points, which can be modified.
        """
        this = _StdPrs.new_StdPrs_Curve()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StdPrs.delete_StdPrs_Curve
StdPrs_Curve_swigregister = _StdPrs.StdPrs_Curve_swigregister
StdPrs_Curve_swigregister(StdPrs_Curve)

def StdPrs_Curve_Add(*args):
    """
    Add(Handle_Prs3d_Presentation aPresentation, Adaptor3d_Curve aCurve, Handle_Prs3d_Drawer aDrawer, Standard_Boolean const drawCurve)
    Add(Handle_Prs3d_Presentation aPresentation, Adaptor3d_Curve aCurve, Standard_Real const U1, Standard_Real const U2, Handle_Prs3d_Drawer aDrawer, Standard_Boolean const drawCurve)
    Add(Handle_Prs3d_Presentation aPresentation, Adaptor3d_Curve aCurve, Handle_Prs3d_Drawer aDrawer, NCollection_Sequence_gp_Pnt Points, Standard_Boolean const drawCurve)
    StdPrs_Curve_Add(Handle_Prs3d_Presentation aPresentation, Adaptor3d_Curve aCurve, Standard_Real const U1, Standard_Real const U2, NCollection_Sequence_gp_Pnt Points, Standard_Integer const aNbPoints=30, Standard_Boolean const drawCurve)

    adds to the presentation aPresentation the drawing of the curve
    aCurve.
    The aspect is the current aspect.
    The drawing will be limited between the points of parameter
    U1 and U2.
    aDeflection is used in the circle case.
    Points give a sequence of curve points.
    If drawCurve equals Standard_False the curve will not be displayed,
    it is used if the curve is a part of some shape and PrimitiveArray
    visualization approach is activated (it is activated by default).

    :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
    :type aCurve: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :type U1: float
    :type U2: float
    :type Points: OCC.wrapper.TColgp.TColgp_SequenceOfPnt
    :type aNbPoints: int
    :type drawCurve: bool

    """
    return _StdPrs.StdPrs_Curve_Add(*args)

def StdPrs_Curve_Match(*args):
    """
    Match(Standard_Real const X, Standard_Real const Y, Standard_Real const Z, Standard_Real const aDistance, Adaptor3d_Curve aCurve, Handle_Prs3d_Drawer aDrawer) -> Standard_Boolean
    Match(Standard_Real const X, Standard_Real const Y, Standard_Real const Z, Standard_Real const aDistance, Adaptor3d_Curve aCurve, Standard_Real const aDeflection, Standard_Real const aLimit, Standard_Integer const aNbPoints) -> Standard_Boolean
    Match(Standard_Real const X, Standard_Real const Y, Standard_Real const Z, Standard_Real const aDistance, Adaptor3d_Curve aCurve, Standard_Real const U1, Standard_Real const U2, Handle_Prs3d_Drawer aDrawer) -> Standard_Boolean
    StdPrs_Curve_Match(Standard_Real const X, Standard_Real const Y, Standard_Real const Z, Standard_Real const aDistance, Adaptor3d_Curve aCurve, Standard_Real const U1, Standard_Real const U2, Standard_Real const aDeflection, Standard_Integer const aNbPoints) -> Standard_Boolean

    returns true if the distance between the point (X,Y,Z) and the
    drawing of the curve aCurve is less than aDistance.
    The drawing is considered between the points
    of parameter U1 and U2;

    :type X: float
    :type Y: float
    :type Z: float
    :type aDistance: float
    :type aCurve: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
    :type U1: float
    :type U2: float
    :type aDeflection: float
    :type aNbPoints: int
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _StdPrs.StdPrs_Curve_Match(*args)

class StdPrs_Plane(Prs3d.Prs3d_Root):
    """A framework to display infinite planes."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args):
        """
        Add(Handle_Prs3d_Presentation aPresentation, Adaptor3d_Surface aPlane, Handle_Prs3d_Drawer aDrawer)

        Defines display of infinite planes.
        The infinite plane aPlane is added to the display
        aPresentation, and the attributes of the display are
        defined by the attribute manager aDrawer.

        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type aPlane: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
        :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _StdPrs.StdPrs_Plane_Add(*args)

    Add = staticmethod(Add)

    def Match(*args):
        """
        Match(Standard_Real const X, Standard_Real const Y, Standard_Real const Z, Standard_Real const aDistance, Adaptor3d_Surface aPlane, Handle_Prs3d_Drawer aDrawer) -> Standard_Boolean

        returns true if the distance between the point (X,Y,Z) and the
        plane is less than aDistance.

        :type X: float
        :type Y: float
        :type Z: float
        :type aDistance: float
        :type aPlane: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
        :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StdPrs.StdPrs_Plane_Match(*args)

    Match = staticmethod(Match)

    def __init__(self):
        """A framework to display infinite planes."""
        this = _StdPrs.new_StdPrs_Plane()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StdPrs.delete_StdPrs_Plane
StdPrs_Plane_swigregister = _StdPrs.StdPrs_Plane_swigregister
StdPrs_Plane_swigregister(StdPrs_Plane)

def StdPrs_Plane_Add(*args):
    """
    StdPrs_Plane_Add(Handle_Prs3d_Presentation aPresentation, Adaptor3d_Surface aPlane, Handle_Prs3d_Drawer aDrawer)

    Defines display of infinite planes.
    The infinite plane aPlane is added to the display
    aPresentation, and the attributes of the display are
    defined by the attribute manager aDrawer.

    :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
    :type aPlane: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
    :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

    """
    return _StdPrs.StdPrs_Plane_Add(*args)

def StdPrs_Plane_Match(*args):
    """
    StdPrs_Plane_Match(Standard_Real const X, Standard_Real const Y, Standard_Real const Z, Standard_Real const aDistance, Adaptor3d_Surface aPlane, Handle_Prs3d_Drawer aDrawer) -> Standard_Boolean

    returns true if the distance between the point (X,Y,Z) and the
    plane is less than aDistance.

    :type X: float
    :type Y: float
    :type Z: float
    :type aDistance: float
    :type aPlane: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
    :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _StdPrs.StdPrs_Plane_Match(*args)

class StdPrs_Isolines(Prs3d.Prs3d_Root):
    """
    Tool for computing isoline representation for a face or surface.
    Depending on a flags set to the given Prs3d_Drawer instance, on-surface (is used
    by default) or on-triangulation isoline builder algorithm will be used.
    If the given shape is not triangulated, on-surface isoline builder will be applied
    regardless of Prs3d_Drawer flags.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args):
        """
        Add(Handle_Prs3d_Presentation thePresentation, TopoDS_Face theFace, Handle_Prs3d_Drawer theDrawer, Standard_Real const theDeflection)
        Add(TopoDS_Face theFace, Handle_Prs3d_Drawer theDrawer, Standard_Real const theDeflection, NCollection_List_Handle_TColgp_HSequenceOfPnt theUPolylines, NCollection_List_Handle_TColgp_HSequenceOfPnt theVPolylines)

        Computes isolines presentation for a TopoDS face.
        This method chooses proper version of isoline builder algorithm : on triangulation
        or surface depending on the flag passed from Prs3d_Drawer attributes.
        This method is a default way to display isolines for a given TopoDS face.
        @param theFace [in] the face.
        @param theDrawer [in] the display settings.
        @param theDeflection [in] the deflection for isolines-on-surface version.

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theDeflection: float
        :type theUPolylines: OCC.wrapper.Prs3d.Prs3d_NListOfSequenceOfPnt
        :type theVPolylines: OCC.wrapper.Prs3d.Prs3d_NListOfSequenceOfPnt

        """
        return _StdPrs.StdPrs_Isolines_Add(*args)

    Add = staticmethod(Add)

    def AddOnTriangulation(*args):
        """
        AddOnTriangulation(Handle_Prs3d_Presentation thePresentation, TopoDS_Face theFace, Handle_Prs3d_Drawer theDrawer)
        AddOnTriangulation(TopoDS_Face theFace, Handle_Prs3d_Drawer theDrawer, NCollection_List_Handle_TColgp_HSequenceOfPnt theUPolylines, NCollection_List_Handle_TColgp_HSequenceOfPnt theVPolylines)
        AddOnTriangulation(Handle_Prs3d_Presentation thePresentation, Handle_Poly_Triangulation theTriangulation, Handle_Geom_Surface theSurface, TopLoc_Location theLocation, Handle_Prs3d_Drawer theDrawer, NCollection_Sequence_Standard_Real theUIsoParams, NCollection_Sequence_Standard_Real theVIsoParams)

        Computes isolines on triangulation and adds them to a presentation.
        @param thePresentation [in] the presentation.
        @param theTriangulation [in] the triangulation.
        @param theSurface [in] the definition of triangulated surface. The surface
        adapter is used to precisely evaluate isoline points using surface
        law and fit them on triangulation. If NULL is passed, the method will
        use linear interpolation of triangle node's UV coordinates to evaluate
        isoline points.
        @param theLocation [in] the location transformation defined for triangulation (surface).
        @param theDrawer [in] the display settings.
        @param theUIsoParams [in] the parameters of u isolines to compute.
        @param theVIsoParams [in] the parameters of v isolines to compute.

        :type thePresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type theTriangulation: OCC.wrapper.Poly.Handle_Poly_Triangulation
        :type theSurface: OCC.wrapper.Geom.Handle_Geom_Surface
        :type theLocation: OCC.wrapper.TopLoc.TopLoc_Location
        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theUIsoParams: OCC.wrapper.TColStd.TColStd_SequenceOfReal
        :type theVIsoParams: OCC.wrapper.TColStd.TColStd_SequenceOfReal

        """
        return _StdPrs.StdPrs_Isolines_AddOnTriangulation(*args)

    AddOnTriangulation = staticmethod(AddOnTriangulation)

    def AddOnSurface(*args):
        """
        AddOnSurface(Handle_Prs3d_Presentation thePresentation, TopoDS_Face theFace, Handle_Prs3d_Drawer theDrawer, Standard_Real const theDeflection)
        AddOnSurface(TopoDS_Face theFace, Handle_Prs3d_Drawer theDrawer, Standard_Real const theDeflection, NCollection_List_Handle_TColgp_HSequenceOfPnt theUPolylines, NCollection_List_Handle_TColgp_HSequenceOfPnt theVPolylines)
        AddOnSurface(Handle_Prs3d_Presentation thePresentation, Handle_BRepAdaptor_HSurface theSurface, Handle_Prs3d_Drawer theDrawer, Standard_Real const theDeflection, NCollection_Sequence_Standard_Real theUIsoParams, NCollection_Sequence_Standard_Real theVIsoParams)

        Computes isolines on surface and adds them to presentation.
        @param thePresentation [in] the presentation.
        @param theSurface [in] the surface.
        @param theDrawer [in] the display settings.
        @param theDeflection [in] the deflection value.
        @param theUIsoParams [in] the parameters of u isolines to compute.
        @param theVIsoParams [in] the parameters of v isolines to compute.

        :type thePresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type theSurface: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theDeflection: float
        :type theUIsoParams: OCC.wrapper.TColStd.TColStd_SequenceOfReal
        :type theVIsoParams: OCC.wrapper.TColStd.TColStd_SequenceOfReal

        """
        return _StdPrs.StdPrs_Isolines_AddOnSurface(*args)

    AddOnSurface = staticmethod(AddOnSurface)

    def UVIsoParameters(*args):
        """
        UVIsoParameters(TopoDS_Face theFace, Standard_Integer const theNbIsoU, Standard_Integer const theNbIsoV, Standard_Real const theUVLimit, NCollection_Sequence_Standard_Real theUIsoParams, NCollection_Sequence_Standard_Real theVIsoParams)

        Evalute sequence of parameters for drawing uv isolines for a given face.
        @param theFace [in] the face.
        @param theNbIsoU [in] the number of u isolines.
        @param theNbIsoV [in] the number of v isolines.
        @param theUVLimit [in] the u, v parameter value limit.
        @param theUIsoParams [out] the sequence of u isoline parameters.
        @param theVIsoParams [out] the sequence of v isoline parameters.

        :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
        :type theNbIsoU: int
        :type theNbIsoV: int
        :type theUVLimit: float
        :type theUIsoParams: OCC.wrapper.TColStd.TColStd_SequenceOfReal
        :type theVIsoParams: OCC.wrapper.TColStd.TColStd_SequenceOfReal

        """
        return _StdPrs.StdPrs_Isolines_UVIsoParameters(*args)

    UVIsoParameters = staticmethod(UVIsoParameters)

    def __init__(self):
        """
        Tool for computing isoline representation for a face or surface.
        Depending on a flags set to the given Prs3d_Drawer instance, on-surface (is used
        by default) or on-triangulation isoline builder algorithm will be used.
        If the given shape is not triangulated, on-surface isoline builder will be applied
        regardless of Prs3d_Drawer flags.
        """
        this = _StdPrs.new_StdPrs_Isolines()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StdPrs.delete_StdPrs_Isolines
StdPrs_Isolines_swigregister = _StdPrs.StdPrs_Isolines_swigregister
StdPrs_Isolines_swigregister(StdPrs_Isolines)

def StdPrs_Isolines_Add(*args):
    """
    Add(Handle_Prs3d_Presentation thePresentation, TopoDS_Face theFace, Handle_Prs3d_Drawer theDrawer, Standard_Real const theDeflection)
    StdPrs_Isolines_Add(TopoDS_Face theFace, Handle_Prs3d_Drawer theDrawer, Standard_Real const theDeflection, NCollection_List_Handle_TColgp_HSequenceOfPnt theUPolylines, NCollection_List_Handle_TColgp_HSequenceOfPnt theVPolylines)

    Computes isolines presentation for a TopoDS face.
    This method chooses proper version of isoline builder algorithm : on triangulation
    or surface depending on the flag passed from Prs3d_Drawer attributes.
    This method is a default way to display isolines for a given TopoDS face.
    @param theFace [in] the face.
    @param theDrawer [in] the display settings.
    @param theDeflection [in] the deflection for isolines-on-surface version.

    :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
    :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
    :type theDeflection: float
    :type theUPolylines: OCC.wrapper.Prs3d.Prs3d_NListOfSequenceOfPnt
    :type theVPolylines: OCC.wrapper.Prs3d.Prs3d_NListOfSequenceOfPnt

    """
    return _StdPrs.StdPrs_Isolines_Add(*args)

def StdPrs_Isolines_AddOnTriangulation(*args):
    """
    AddOnTriangulation(Handle_Prs3d_Presentation thePresentation, TopoDS_Face theFace, Handle_Prs3d_Drawer theDrawer)
    AddOnTriangulation(TopoDS_Face theFace, Handle_Prs3d_Drawer theDrawer, NCollection_List_Handle_TColgp_HSequenceOfPnt theUPolylines, NCollection_List_Handle_TColgp_HSequenceOfPnt theVPolylines)
    StdPrs_Isolines_AddOnTriangulation(Handle_Prs3d_Presentation thePresentation, Handle_Poly_Triangulation theTriangulation, Handle_Geom_Surface theSurface, TopLoc_Location theLocation, Handle_Prs3d_Drawer theDrawer, NCollection_Sequence_Standard_Real theUIsoParams, NCollection_Sequence_Standard_Real theVIsoParams)

    Computes isolines on triangulation and adds them to a presentation.
    @param thePresentation [in] the presentation.
    @param theTriangulation [in] the triangulation.
    @param theSurface [in] the definition of triangulated surface. The surface
    adapter is used to precisely evaluate isoline points using surface
    law and fit them on triangulation. If NULL is passed, the method will
    use linear interpolation of triangle node's UV coordinates to evaluate
    isoline points.
    @param theLocation [in] the location transformation defined for triangulation (surface).
    @param theDrawer [in] the display settings.
    @param theUIsoParams [in] the parameters of u isolines to compute.
    @param theVIsoParams [in] the parameters of v isolines to compute.

    :type thePresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
    :type theTriangulation: OCC.wrapper.Poly.Handle_Poly_Triangulation
    :type theSurface: OCC.wrapper.Geom.Handle_Geom_Surface
    :type theLocation: OCC.wrapper.TopLoc.TopLoc_Location
    :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
    :type theUIsoParams: OCC.wrapper.TColStd.TColStd_SequenceOfReal
    :type theVIsoParams: OCC.wrapper.TColStd.TColStd_SequenceOfReal

    """
    return _StdPrs.StdPrs_Isolines_AddOnTriangulation(*args)

def StdPrs_Isolines_AddOnSurface(*args):
    """
    AddOnSurface(Handle_Prs3d_Presentation thePresentation, TopoDS_Face theFace, Handle_Prs3d_Drawer theDrawer, Standard_Real const theDeflection)
    AddOnSurface(TopoDS_Face theFace, Handle_Prs3d_Drawer theDrawer, Standard_Real const theDeflection, NCollection_List_Handle_TColgp_HSequenceOfPnt theUPolylines, NCollection_List_Handle_TColgp_HSequenceOfPnt theVPolylines)
    StdPrs_Isolines_AddOnSurface(Handle_Prs3d_Presentation thePresentation, Handle_BRepAdaptor_HSurface theSurface, Handle_Prs3d_Drawer theDrawer, Standard_Real const theDeflection, NCollection_Sequence_Standard_Real theUIsoParams, NCollection_Sequence_Standard_Real theVIsoParams)

    Computes isolines on surface and adds them to presentation.
    @param thePresentation [in] the presentation.
    @param theSurface [in] the surface.
    @param theDrawer [in] the display settings.
    @param theDeflection [in] the deflection value.
    @param theUIsoParams [in] the parameters of u isolines to compute.
    @param theVIsoParams [in] the parameters of v isolines to compute.

    :type thePresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
    :type theSurface: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
    :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
    :type theDeflection: float
    :type theUIsoParams: OCC.wrapper.TColStd.TColStd_SequenceOfReal
    :type theVIsoParams: OCC.wrapper.TColStd.TColStd_SequenceOfReal

    """
    return _StdPrs.StdPrs_Isolines_AddOnSurface(*args)

def StdPrs_Isolines_UVIsoParameters(*args):
    """
    StdPrs_Isolines_UVIsoParameters(TopoDS_Face theFace, Standard_Integer const theNbIsoU, Standard_Integer const theNbIsoV, Standard_Real const theUVLimit, NCollection_Sequence_Standard_Real theUIsoParams, NCollection_Sequence_Standard_Real theVIsoParams)

    Evalute sequence of parameters for drawing uv isolines for a given face.
    @param theFace [in] the face.
    @param theNbIsoU [in] the number of u isolines.
    @param theNbIsoV [in] the number of v isolines.
    @param theUVLimit [in] the u, v parameter value limit.
    @param theUIsoParams [out] the sequence of u isoline parameters.
    @param theVIsoParams [out] the sequence of v isoline parameters.

    :type theFace: OCC.wrapper.TopoDS.TopoDS_Face
    :type theNbIsoU: int
    :type theNbIsoV: int
    :type theUVLimit: float
    :type theUIsoParams: OCC.wrapper.TColStd.TColStd_SequenceOfReal
    :type theVIsoParams: OCC.wrapper.TColStd.TColStd_SequenceOfReal

    """
    return _StdPrs.StdPrs_Isolines_UVIsoParameters(*args)

class StdPrs_HLRPolyShape(Prs3d.Prs3d_Root):
    """
    Instantiates Prs3d_PolyHLRShape to define a
    display of a shape where hidden and visible lines are
    identified with respect to a given projection.
    StdPrs_HLRPolyShape works with a polyhedral
    simplification of the shape whereas
    StdPrs_HLRShape takes the shape itself into
    account. When you use StdPrs_HLRShape, you
    obtain an exact result, whereas, when you use
    StdPrs_HLRPolyShape, you reduce computation
    time but obtain polygonal segments.
    The polygonal algorithm is used.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args):
        """
        Add(Handle_Prs3d_Presentation aPresentation, TopoDS_Shape aShape, Handle_Prs3d_Drawer aDrawer, Handle_Prs3d_Projector aProjector)

        Defines the hidden line removal display of the
        topology aShape in the projection defined by
        aProjector. The shape and the projection are added
        to the display aPresentation, and the attributes of the
        elements present in the aPresentation are defined by
        the attribute manager aDrawer.

        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector

        """
        return _StdPrs.StdPrs_HLRPolyShape_Add(*args)

    Add = staticmethod(Add)

    def __init__(self):
        """
        Instantiates Prs3d_PolyHLRShape to define a
        display of a shape where hidden and visible lines are
        identified with respect to a given projection.
        StdPrs_HLRPolyShape works with a polyhedral
        simplification of the shape whereas
        StdPrs_HLRShape takes the shape itself into
        account. When you use StdPrs_HLRShape, you
        obtain an exact result, whereas, when you use
        StdPrs_HLRPolyShape, you reduce computation
        time but obtain polygonal segments.
        The polygonal algorithm is used.
        """
        this = _StdPrs.new_StdPrs_HLRPolyShape()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StdPrs.delete_StdPrs_HLRPolyShape
StdPrs_HLRPolyShape_swigregister = _StdPrs.StdPrs_HLRPolyShape_swigregister
StdPrs_HLRPolyShape_swigregister(StdPrs_HLRPolyShape)

def StdPrs_HLRPolyShape_Add(*args):
    """
    StdPrs_HLRPolyShape_Add(Handle_Prs3d_Presentation aPresentation, TopoDS_Shape aShape, Handle_Prs3d_Drawer aDrawer, Handle_Prs3d_Projector aProjector)

    Defines the hidden line removal display of the
    topology aShape in the projection defined by
    aProjector. The shape and the projection are added
    to the display aPresentation, and the attributes of the
    elements present in the aPresentation are defined by
    the attribute manager aDrawer.

    :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
    :type aShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
    :type aProjector: OCC.wrapper.Prs3d.Handle_Prs3d_Projector

    """
    return _StdPrs.StdPrs_HLRPolyShape_Add(*args)

class Prs3d_Point_TopoDS_Vertex_StdPrs_ToolVertex(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args):
        """
        Add(Handle_Prs3d_Presentation thePresentation, TopoDS_Vertex thePoint, Handle_Prs3d_Drawer theDrawer)

        :type thePresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type thePoint: const AnyPoint &
        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _StdPrs.Prs3d_Point_TopoDS_Vertex_StdPrs_ToolVertex_Add(*args)

    Add = staticmethod(Add)

    def Match(*args):
        """
        Match(TopoDS_Vertex thePoint, Standard_Real const theX, Standard_Real const theY, Standard_Real const theZ, Standard_Real const theDistance) -> Standard_Boolean

        :type thePoint: const AnyPoint &
        :type theX: float
        :type theY: float
        :type theZ: float
        :type theDistance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StdPrs.Prs3d_Point_TopoDS_Vertex_StdPrs_ToolVertex_Match(*args)

    Match = staticmethod(Match)

    def __init__(self):
        this = _StdPrs.new_Prs3d_Point_TopoDS_Vertex_StdPrs_ToolVertex()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StdPrs.delete_Prs3d_Point_TopoDS_Vertex_StdPrs_ToolVertex
Prs3d_Point_TopoDS_Vertex_StdPrs_ToolVertex_swigregister = _StdPrs.Prs3d_Point_TopoDS_Vertex_StdPrs_ToolVertex_swigregister
Prs3d_Point_TopoDS_Vertex_StdPrs_ToolVertex_swigregister(Prs3d_Point_TopoDS_Vertex_StdPrs_ToolVertex)

def Prs3d_Point_TopoDS_Vertex_StdPrs_ToolVertex_Add(*args):
    """
    Prs3d_Point_TopoDS_Vertex_StdPrs_ToolVertex_Add(Handle_Prs3d_Presentation thePresentation, TopoDS_Vertex thePoint, Handle_Prs3d_Drawer theDrawer)

    :type thePresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
    :type thePoint: const AnyPoint &
    :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

    """
    return _StdPrs.Prs3d_Point_TopoDS_Vertex_StdPrs_ToolVertex_Add(*args)

def Prs3d_Point_TopoDS_Vertex_StdPrs_ToolVertex_Match(*args):
    """
    Prs3d_Point_TopoDS_Vertex_StdPrs_ToolVertex_Match(TopoDS_Vertex thePoint, Standard_Real const theX, Standard_Real const theY, Standard_Real const theZ, Standard_Real const theDistance) -> Standard_Boolean

    :type thePoint: const AnyPoint &
    :type theX: float
    :type theY: float
    :type theZ: float
    :type theDistance: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _StdPrs.Prs3d_Point_TopoDS_Vertex_StdPrs_ToolVertex_Match(*args)


try:
	StdPrs_Vertex = Prs3d_Point_TopoDS_Vertex_StdPrs_ToolVertex
except NameError:
	pass # does not exist, probably ignored

class StdPrs_WFDeflectionRestrictedFace(Prs3d.Prs3d_Root):
    """
    A framework to provide display of U and V
    isoparameters of faces, while allowing you to impose
    a deflection on them.
    Computes the wireframe presentation of faces with
    restrictions by displaying a given number of U and/or
    V isoparametric curves. The isoparametric curves are
    drawn with respect to a maximal chordial deviation.
    The presentation includes the restriction curves.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def AddUIso(*args):
        """
        AddUIso(Handle_Prs3d_Presentation aPresentation, Handle_BRepAdaptor_HSurface aFace, Handle_Prs3d_Drawer aDrawer)

        Defines a display featuring U isoparameters
        respectively. Add the surface aFace to the
        StdPrs_WFRestrictedFace algorithm. This face
        is found in a shape in the presentation object
        aPresentation, and its display attributes - in
        particular, the number of U isoparameters -
        are set in the attribute manager aDrawer.
        aFace is BRepAdaptor_HSurface surface
        created from a face in a topological shape.   which
        is passed to the function as an argument through
        the BRepAdaptor_HSurface surface created from
        it. This is what allows the topological face to be
        treated as a geometric surface.

        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type aFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
        :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _StdPrs.StdPrs_WFDeflectionRestrictedFace_AddUIso(*args)

    AddUIso = staticmethod(AddUIso)

    def AddVIso(*args):
        """
        AddVIso(Handle_Prs3d_Presentation aPresentation, Handle_BRepAdaptor_HSurface aFace, Handle_Prs3d_Drawer aDrawer)

        Defines a display featuring V isoparameters
        respectively. Add the surface aFace to the
        StdPrs_WFRestrictedFace algorithm. This face
        is found in a shape in the presentation object
        aPresentation, and its display attributes - in
        particular, the number of V isoparameters -
        are set in the attribute manager aDrawer.
        aFace is BRepAdaptor_HSurface surface
        created from a face in a topological shape.   which
        is passed to the function as an argument through
        the BRepAdaptor_HSurface surface created from
        it. This is what allows the topological face to be
        treated as a geometric surface.

        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type aFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
        :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _StdPrs.StdPrs_WFDeflectionRestrictedFace_AddVIso(*args)

    AddVIso = staticmethod(AddVIso)

    def Add(*args):
        """
        Add(Handle_Prs3d_Presentation aPresentation, Handle_BRepAdaptor_HSurface aFace, Handle_Prs3d_Drawer aDrawer)
        Add(Handle_Prs3d_Presentation aPresentation, Handle_BRepAdaptor_HSurface aFace, Standard_Boolean const DrawUIso, Standard_Boolean const DrawVIso, Standard_Real const Deflection, Standard_Integer const NBUiso, Standard_Integer const NBViso, Handle_Prs3d_Drawer aDrawer, NCollection_List_Handle_TColgp_HSequenceOfPnt Curves)

        Defines a display of a delection-specified face. The
        display will feature U and V isoparameters.
        Adds the topology aShape to the
        StdPrs_WFRestrictedFace algorithm. This shape is
        found in the presentation object aPresentation, and
        its display attributes - except the number of U and V
        isoparameters - are set in the attribute manager aDrawer.
        The function sets the number of U and V
        isoparameters, NBUiso and NBViso, in the shape. To
        do this, the arguments DrawUIso and DrawVIso must be true.
        aFace is BRepAdaptor_HSurface surface created
        from a face in a topological shape.   which is passed
        as an argument through the
        BRepAdaptor_HSurface surface created from it.
        This is what allows the topological face to be treated
        as a geometric surface.
        Curves give a sequence of face curves, it is used if the PrimitiveArray
        visualization approach is activated (it is activated by default).

        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type aFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
        :type DrawUIso: bool
        :type DrawVIso: bool
        :type Deflection: float
        :type NBUiso: int
        :type NBViso: int
        :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type Curves: OCC.wrapper.Prs3d.Prs3d_NListOfSequenceOfPnt

        """
        return _StdPrs.StdPrs_WFDeflectionRestrictedFace_Add(*args)

    Add = staticmethod(Add)

    def MatchUIso(*args):
        """
        MatchUIso(Standard_Real const X, Standard_Real const Y, Standard_Real const Z, Standard_Real const aDistance, Handle_BRepAdaptor_HSurface aFace, Handle_Prs3d_Drawer aDrawer) -> Standard_Boolean

        :type X: float
        :type Y: float
        :type Z: float
        :type aDistance: float
        :type aFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
        :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StdPrs.StdPrs_WFDeflectionRestrictedFace_MatchUIso(*args)

    MatchUIso = staticmethod(MatchUIso)

    def MatchVIso(*args):
        """
        MatchVIso(Standard_Real const X, Standard_Real const Y, Standard_Real const Z, Standard_Real const aDistance, Handle_BRepAdaptor_HSurface aFace, Handle_Prs3d_Drawer aDrawer) -> Standard_Boolean

        :type X: float
        :type Y: float
        :type Z: float
        :type aDistance: float
        :type aFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
        :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StdPrs.StdPrs_WFDeflectionRestrictedFace_MatchVIso(*args)

    MatchVIso = staticmethod(MatchVIso)

    def Match(*args):
        """
        Match(Standard_Real const X, Standard_Real const Y, Standard_Real const Z, Standard_Real const aDistance, Handle_BRepAdaptor_HSurface aFace, Handle_Prs3d_Drawer aDrawer) -> Standard_Boolean
        Match(Standard_Real const X, Standard_Real const Y, Standard_Real const Z, Standard_Real const aDistance, Handle_BRepAdaptor_HSurface aFace, Handle_Prs3d_Drawer aDrawer, Standard_Boolean const DrawUIso, Standard_Boolean const DrawVIso, Standard_Real const aDeflection, Standard_Integer const NBUiso, Standard_Integer const NBViso) -> Standard_Boolean

        :type X: float
        :type Y: float
        :type Z: float
        :type aDistance: float
        :type aFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
        :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type DrawUIso: bool
        :type DrawVIso: bool
        :type aDeflection: float
        :type NBUiso: int
        :type NBViso: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StdPrs.StdPrs_WFDeflectionRestrictedFace_Match(*args)

    Match = staticmethod(Match)

    def __init__(self):
        """
        A framework to provide display of U and V
        isoparameters of faces, while allowing you to impose
        a deflection on them.
        Computes the wireframe presentation of faces with
        restrictions by displaying a given number of U and/or
        V isoparametric curves. The isoparametric curves are
        drawn with respect to a maximal chordial deviation.
        The presentation includes the restriction curves.
        """
        this = _StdPrs.new_StdPrs_WFDeflectionRestrictedFace()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StdPrs.delete_StdPrs_WFDeflectionRestrictedFace
StdPrs_WFDeflectionRestrictedFace_swigregister = _StdPrs.StdPrs_WFDeflectionRestrictedFace_swigregister
StdPrs_WFDeflectionRestrictedFace_swigregister(StdPrs_WFDeflectionRestrictedFace)

def StdPrs_WFDeflectionRestrictedFace_AddUIso(*args):
    """
    StdPrs_WFDeflectionRestrictedFace_AddUIso(Handle_Prs3d_Presentation aPresentation, Handle_BRepAdaptor_HSurface aFace, Handle_Prs3d_Drawer aDrawer)

    Defines a display featuring U isoparameters
    respectively. Add the surface aFace to the
    StdPrs_WFRestrictedFace algorithm. This face
    is found in a shape in the presentation object
    aPresentation, and its display attributes - in
    particular, the number of U isoparameters -
    are set in the attribute manager aDrawer.
    aFace is BRepAdaptor_HSurface surface
    created from a face in a topological shape.   which
    is passed to the function as an argument through
    the BRepAdaptor_HSurface surface created from
    it. This is what allows the topological face to be
    treated as a geometric surface.

    :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
    :type aFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
    :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

    """
    return _StdPrs.StdPrs_WFDeflectionRestrictedFace_AddUIso(*args)

def StdPrs_WFDeflectionRestrictedFace_AddVIso(*args):
    """
    StdPrs_WFDeflectionRestrictedFace_AddVIso(Handle_Prs3d_Presentation aPresentation, Handle_BRepAdaptor_HSurface aFace, Handle_Prs3d_Drawer aDrawer)

    Defines a display featuring V isoparameters
    respectively. Add the surface aFace to the
    StdPrs_WFRestrictedFace algorithm. This face
    is found in a shape in the presentation object
    aPresentation, and its display attributes - in
    particular, the number of V isoparameters -
    are set in the attribute manager aDrawer.
    aFace is BRepAdaptor_HSurface surface
    created from a face in a topological shape.   which
    is passed to the function as an argument through
    the BRepAdaptor_HSurface surface created from
    it. This is what allows the topological face to be
    treated as a geometric surface.

    :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
    :type aFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
    :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

    """
    return _StdPrs.StdPrs_WFDeflectionRestrictedFace_AddVIso(*args)

def StdPrs_WFDeflectionRestrictedFace_Add(*args):
    """
    Add(Handle_Prs3d_Presentation aPresentation, Handle_BRepAdaptor_HSurface aFace, Handle_Prs3d_Drawer aDrawer)
    StdPrs_WFDeflectionRestrictedFace_Add(Handle_Prs3d_Presentation aPresentation, Handle_BRepAdaptor_HSurface aFace, Standard_Boolean const DrawUIso, Standard_Boolean const DrawVIso, Standard_Real const Deflection, Standard_Integer const NBUiso, Standard_Integer const NBViso, Handle_Prs3d_Drawer aDrawer, NCollection_List_Handle_TColgp_HSequenceOfPnt Curves)

    Defines a display of a delection-specified face. The
    display will feature U and V isoparameters.
    Adds the topology aShape to the
    StdPrs_WFRestrictedFace algorithm. This shape is
    found in the presentation object aPresentation, and
    its display attributes - except the number of U and V
    isoparameters - are set in the attribute manager aDrawer.
    The function sets the number of U and V
    isoparameters, NBUiso and NBViso, in the shape. To
    do this, the arguments DrawUIso and DrawVIso must be true.
    aFace is BRepAdaptor_HSurface surface created
    from a face in a topological shape.   which is passed
    as an argument through the
    BRepAdaptor_HSurface surface created from it.
    This is what allows the topological face to be treated
    as a geometric surface.
    Curves give a sequence of face curves, it is used if the PrimitiveArray
    visualization approach is activated (it is activated by default).

    :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
    :type aFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
    :type DrawUIso: bool
    :type DrawVIso: bool
    :type Deflection: float
    :type NBUiso: int
    :type NBViso: int
    :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
    :type Curves: OCC.wrapper.Prs3d.Prs3d_NListOfSequenceOfPnt

    """
    return _StdPrs.StdPrs_WFDeflectionRestrictedFace_Add(*args)

def StdPrs_WFDeflectionRestrictedFace_MatchUIso(*args):
    """
    StdPrs_WFDeflectionRestrictedFace_MatchUIso(Standard_Real const X, Standard_Real const Y, Standard_Real const Z, Standard_Real const aDistance, Handle_BRepAdaptor_HSurface aFace, Handle_Prs3d_Drawer aDrawer) -> Standard_Boolean

    :type X: float
    :type Y: float
    :type Z: float
    :type aDistance: float
    :type aFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
    :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _StdPrs.StdPrs_WFDeflectionRestrictedFace_MatchUIso(*args)

def StdPrs_WFDeflectionRestrictedFace_MatchVIso(*args):
    """
    StdPrs_WFDeflectionRestrictedFace_MatchVIso(Standard_Real const X, Standard_Real const Y, Standard_Real const Z, Standard_Real const aDistance, Handle_BRepAdaptor_HSurface aFace, Handle_Prs3d_Drawer aDrawer) -> Standard_Boolean

    :type X: float
    :type Y: float
    :type Z: float
    :type aDistance: float
    :type aFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
    :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _StdPrs.StdPrs_WFDeflectionRestrictedFace_MatchVIso(*args)

def StdPrs_WFDeflectionRestrictedFace_Match(*args):
    """
    Match(Standard_Real const X, Standard_Real const Y, Standard_Real const Z, Standard_Real const aDistance, Handle_BRepAdaptor_HSurface aFace, Handle_Prs3d_Drawer aDrawer) -> Standard_Boolean
    StdPrs_WFDeflectionRestrictedFace_Match(Standard_Real const X, Standard_Real const Y, Standard_Real const Z, Standard_Real const aDistance, Handle_BRepAdaptor_HSurface aFace, Handle_Prs3d_Drawer aDrawer, Standard_Boolean const DrawUIso, Standard_Boolean const DrawVIso, Standard_Real const aDeflection, Standard_Integer const NBUiso, Standard_Integer const NBViso) -> Standard_Boolean

    :type X: float
    :type Y: float
    :type Z: float
    :type aDistance: float
    :type aFace: OCC.wrapper.BRepAdaptor.Handle_BRepAdaptor_HSurface
    :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
    :type DrawUIso: bool
    :type DrawVIso: bool
    :type aDeflection: float
    :type NBUiso: int
    :type NBViso: int
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _StdPrs.StdPrs_WFDeflectionRestrictedFace_Match(*args)

class StdPrs_BndBox(Prs3d.Prs3d_Root):
    """Tool for computing bounding box presentation."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args):
        """
        Add(Handle_Prs3d_Presentation thePresentation, Bnd_Box theBndBox, Handle_Prs3d_Drawer theDrawer)

        Computes presentation of a bounding box.
        @param thePresentation [in] the presentation.
        @param theBndBox [in] the bounding box.
        @param theDrawer [in] the drawer.

        :type thePresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type theBndBox: OCC.wrapper.Bnd.Bnd_Box
        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _StdPrs.StdPrs_BndBox_Add(*args)

    Add = staticmethod(Add)

    def __init__(self):
        """Tool for computing bounding box presentation."""
        this = _StdPrs.new_StdPrs_BndBox()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StdPrs.delete_StdPrs_BndBox
StdPrs_BndBox_swigregister = _StdPrs.StdPrs_BndBox_swigregister
StdPrs_BndBox_swigregister(StdPrs_BndBox)

def StdPrs_BndBox_Add(*args):
    """
    StdPrs_BndBox_Add(Handle_Prs3d_Presentation thePresentation, Bnd_Box theBndBox, Handle_Prs3d_Drawer theDrawer)

    Computes presentation of a bounding box.
    @param thePresentation [in] the presentation.
    @param theBndBox [in] the bounding box.
    @param theDrawer [in] the drawer.

    :type thePresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
    :type theBndBox: OCC.wrapper.Bnd.Bnd_Box
    :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

    """
    return _StdPrs.StdPrs_BndBox_Add(*args)

class Prs3d_Point_Handle_Geom_Point_StdPrs_ToolPoint(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args):
        """
        Add(Handle_Prs3d_Presentation thePresentation, Handle_Geom_Point thePoint, Handle_Prs3d_Drawer theDrawer)

        :type thePresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type thePoint: const AnyPoint &
        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _StdPrs.Prs3d_Point_Handle_Geom_Point_StdPrs_ToolPoint_Add(*args)

    Add = staticmethod(Add)

    def Match(*args):
        """
        Match(Handle_Geom_Point thePoint, Standard_Real const theX, Standard_Real const theY, Standard_Real const theZ, Standard_Real const theDistance) -> Standard_Boolean

        :type thePoint: const AnyPoint &
        :type theX: float
        :type theY: float
        :type theZ: float
        :type theDistance: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _StdPrs.Prs3d_Point_Handle_Geom_Point_StdPrs_ToolPoint_Match(*args)

    Match = staticmethod(Match)

    def __init__(self):
        this = _StdPrs.new_Prs3d_Point_Handle_Geom_Point_StdPrs_ToolPoint()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StdPrs.delete_Prs3d_Point_Handle_Geom_Point_StdPrs_ToolPoint
Prs3d_Point_Handle_Geom_Point_StdPrs_ToolPoint_swigregister = _StdPrs.Prs3d_Point_Handle_Geom_Point_StdPrs_ToolPoint_swigregister
Prs3d_Point_Handle_Geom_Point_StdPrs_ToolPoint_swigregister(Prs3d_Point_Handle_Geom_Point_StdPrs_ToolPoint)

def Prs3d_Point_Handle_Geom_Point_StdPrs_ToolPoint_Add(*args):
    """
    Prs3d_Point_Handle_Geom_Point_StdPrs_ToolPoint_Add(Handle_Prs3d_Presentation thePresentation, Handle_Geom_Point thePoint, Handle_Prs3d_Drawer theDrawer)

    :type thePresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
    :type thePoint: const AnyPoint &
    :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

    """
    return _StdPrs.Prs3d_Point_Handle_Geom_Point_StdPrs_ToolPoint_Add(*args)

def Prs3d_Point_Handle_Geom_Point_StdPrs_ToolPoint_Match(*args):
    """
    Prs3d_Point_Handle_Geom_Point_StdPrs_ToolPoint_Match(Handle_Geom_Point thePoint, Standard_Real const theX, Standard_Real const theY, Standard_Real const theZ, Standard_Real const theDistance) -> Standard_Boolean

    :type thePoint: const AnyPoint &
    :type theX: float
    :type theY: float
    :type theZ: float
    :type theDistance: float
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _StdPrs.Prs3d_Point_Handle_Geom_Point_StdPrs_ToolPoint_Match(*args)


try:
	StdPrs_Point = Prs3d_Point_Handle_Geom_Point_StdPrs_ToolPoint
except NameError:
	pass # does not exist, probably ignored

class StdPrs_ShadedSurface(Prs3d.Prs3d_Root):
    """
    Computes the shading presentation of surfaces.
    Draws a surface by drawing the isoparametric curves with respect to
    a maximal chordial deviation.
    The number of isoparametric curves to be drawn and their color are
    controlled by the furnished Drawer.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args):
        """
        Add(Handle_Prs3d_Presentation aPresentation, Adaptor3d_Surface aSurface, Handle_Prs3d_Drawer aDrawer)

        Adds the surface aSurface to the presentation object aPresentation.
        The surface's display attributes are set in the attribute manager aDrawer.
        The surface object from Adaptor3d provides data
        from a Geom surface in order to use the surface in an algorithm.

        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type aSurface: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
        :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _StdPrs.StdPrs_ShadedSurface_Add(*args)

    Add = staticmethod(Add)

    def __init__(self):
        """
        Computes the shading presentation of surfaces.
        Draws a surface by drawing the isoparametric curves with respect to
        a maximal chordial deviation.
        The number of isoparametric curves to be drawn and their color are
        controlled by the furnished Drawer.
        """
        this = _StdPrs.new_StdPrs_ShadedSurface()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StdPrs.delete_StdPrs_ShadedSurface
StdPrs_ShadedSurface_swigregister = _StdPrs.StdPrs_ShadedSurface_swigregister
StdPrs_ShadedSurface_swigregister(StdPrs_ShadedSurface)

def StdPrs_ShadedSurface_Add(*args):
    """
    StdPrs_ShadedSurface_Add(Handle_Prs3d_Presentation aPresentation, Adaptor3d_Surface aSurface, Handle_Prs3d_Drawer aDrawer)

    Adds the surface aSurface to the presentation object aPresentation.
    The surface's display attributes are set in the attribute manager aDrawer.
    The surface object from Adaptor3d provides data
    from a Geom surface in order to use the surface in an algorithm.

    :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
    :type aSurface: OCC.wrapper.Adaptor3d.Adaptor3d_Surface
    :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

    """
    return _StdPrs.StdPrs_ShadedSurface_Add(*args)

class StdPrs_WFSurface(Prs3d.Prs3d_Root):
    """
    Computes the wireframe presentation of surfaces
    by displaying a given number of U and/or V isoparametric
    curves. The isoparametric curves are drawn with respect
    to a given number of points.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args):
        """
        Add(Handle_Prs3d_Presentation aPresentation, Handle_Adaptor3d_HSurface aSurface, Handle_Prs3d_Drawer aDrawer)

        Draws a surface by drawing the isoparametric curves with respect to
        a fixed number of points given by the Drawer.
        The number of isoparametric curves to be drawn and their color are
        controlled by the furnished Drawer.

        :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type aSurface: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

        """
        return _StdPrs.StdPrs_WFSurface_Add(*args)

    Add = staticmethod(Add)

    def __init__(self):
        """
        Computes the wireframe presentation of surfaces
        by displaying a given number of U and/or V isoparametric
        curves. The isoparametric curves are drawn with respect
        to a given number of points.
        """
        this = _StdPrs.new_StdPrs_WFSurface()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StdPrs.delete_StdPrs_WFSurface
StdPrs_WFSurface_swigregister = _StdPrs.StdPrs_WFSurface_swigregister
StdPrs_WFSurface_swigregister(StdPrs_WFSurface)

def StdPrs_WFSurface_Add(*args):
    """
    StdPrs_WFSurface_Add(Handle_Prs3d_Presentation aPresentation, Handle_Adaptor3d_HSurface aSurface, Handle_Prs3d_Drawer aDrawer)

    Draws a surface by drawing the isoparametric curves with respect to
    a fixed number of points given by the Drawer.
    The number of isoparametric curves to be drawn and their color are
    controlled by the furnished Drawer.

    :type aPresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
    :type aSurface: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
    :type aDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer

    """
    return _StdPrs.StdPrs_WFSurface_Add(*args)

class StdPrs_WFShape(Prs3d.Prs3d_Root):
    """Tool for computing wireframe presentation of a TopoDS_Shape."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Add(*args):
        """
        Add(Handle_Prs3d_Presentation thePresentation, TopoDS_Shape theShape, Handle_Prs3d_Drawer theDrawer, Standard_Boolean theIsParallel)

        Computes wireframe presentation of a shape.
        @param thePresentation [in] the presentation.
        @param theShape [in] the shape.
        @param theDrawer [in] the draw settings.
        @param theIsParallel [in] perform algorithm using multiple threads

        :type thePresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
        :type theIsParallel: bool

        """
        return _StdPrs.StdPrs_WFShape_Add(*args)

    Add = staticmethod(Add)

    def AddEdgesOnTriangulation(*args):
        """
        AddEdgesOnTriangulation(TopoDS_Shape theShape, Standard_Boolean const theToExcludeGeometric) -> Handle_Graphic3d_ArrayOfPrimitives
        AddEdgesOnTriangulation(NCollection_Sequence_gp_Pnt theSegments, TopoDS_Shape theShape, Standard_Boolean const theToExcludeGeometric)

        Compute free and boundary edges on a triangulation of each face in the given shape.
        @param theSegments           [in] the sequence of points defining segments
        @param theShape              [in] the list of triangulated faces
        @param theToExcludeGeometric [in] flag indicating that Faces with defined Surface should be skipped

        :type theSegments: OCC.wrapper.TColgp.TColgp_SequenceOfPnt
        :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type theToExcludeGeometric: bool

        """
        return _StdPrs.StdPrs_WFShape_AddEdgesOnTriangulation(*args)

    AddEdgesOnTriangulation = staticmethod(AddEdgesOnTriangulation)

    def __init__(self):
        """Tool for computing wireframe presentation of a TopoDS_Shape."""
        this = _StdPrs.new_StdPrs_WFShape()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _StdPrs.delete_StdPrs_WFShape
StdPrs_WFShape_swigregister = _StdPrs.StdPrs_WFShape_swigregister
StdPrs_WFShape_swigregister(StdPrs_WFShape)

def StdPrs_WFShape_Add(*args):
    """
    StdPrs_WFShape_Add(Handle_Prs3d_Presentation thePresentation, TopoDS_Shape theShape, Handle_Prs3d_Drawer theDrawer, Standard_Boolean theIsParallel)

    Computes wireframe presentation of a shape.
    @param thePresentation [in] the presentation.
    @param theShape [in] the shape.
    @param theDrawer [in] the draw settings.
    @param theIsParallel [in] perform algorithm using multiple threads

    :type thePresentation: OCC.wrapper.Prs3d.Handle_Prs3d_Presentation
    :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theDrawer: OCC.wrapper.Prs3d.Handle_Prs3d_Drawer
    :type theIsParallel: bool

    """
    return _StdPrs.StdPrs_WFShape_Add(*args)

def StdPrs_WFShape_AddEdgesOnTriangulation(*args):
    """
    AddEdgesOnTriangulation(TopoDS_Shape theShape, Standard_Boolean const theToExcludeGeometric) -> Handle_Graphic3d_ArrayOfPrimitives
    StdPrs_WFShape_AddEdgesOnTriangulation(NCollection_Sequence_gp_Pnt theSegments, TopoDS_Shape theShape, Standard_Boolean const theToExcludeGeometric)

    Compute free and boundary edges on a triangulation of each face in the given shape.
    @param theSegments           [in] the sequence of points defining segments
    @param theShape              [in] the list of triangulated faces
    @param theToExcludeGeometric [in] flag indicating that Faces with defined Surface should be skipped

    :type theSegments: OCC.wrapper.TColgp.TColgp_SequenceOfPnt
    :type theShape: OCC.wrapper.TopoDS.TopoDS_Shape
    :type theToExcludeGeometric: bool

    """
    return _StdPrs.StdPrs_WFShape_AddEdgesOnTriangulation(*args)




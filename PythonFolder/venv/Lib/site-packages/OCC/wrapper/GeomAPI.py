# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_GeomAPI')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_GeomAPI')
    _GeomAPI = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_GeomAPI', [dirname(__file__)])
        except ImportError:
            import _GeomAPI
            return _GeomAPI
        try:
            _mod = imp.load_module('_GeomAPI', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _GeomAPI = swig_import_helper()
    del swig_import_helper
else:
    import _GeomAPI
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _GeomAPI.delete_SwigPyIterator

    def value(self):
        return _GeomAPI.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _GeomAPI.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _GeomAPI.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _GeomAPI.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _GeomAPI.SwigPyIterator_equal(self, x)

    def copy(self):
        return _GeomAPI.SwigPyIterator_copy(self)

    def next(self):
        return _GeomAPI.SwigPyIterator_next(self)

    def __next__(self):
        return _GeomAPI.SwigPyIterator___next__(self)

    def previous(self):
        return _GeomAPI.SwigPyIterator_previous(self)

    def advance(self, n):
        return _GeomAPI.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _GeomAPI.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _GeomAPI.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _GeomAPI.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _GeomAPI.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _GeomAPI.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _GeomAPI.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _GeomAPI.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _GeomAPI.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_GeomAPI.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _GeomAPI.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _GeomAPI.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GeomAPI.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _GeomAPI.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _GeomAPI.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _GeomAPI.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _GeomAPI.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_GeomAPI.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _GeomAPI.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _GeomAPI.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GeomAPI.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _GeomAPI.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _GeomAPI.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _GeomAPI.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _GeomAPI.ptr_to_number(item)
ptr_to_number = _GeomAPI.ptr_to_number

def HashCode(*args):
    return _GeomAPI.HashCode(*args)
HashCode = _GeomAPI.HashCode

def ptr_equal(a, b):
    return _GeomAPI.ptr_equal(a, b)
ptr_equal = _GeomAPI.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Approx
else:
    import Approx
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppCont
else:
    import AppCont
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AppParCurves
else:
    import AppParCurves
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import AdvApprox
else:
    import AdvApprox
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import PLib
else:
    import PLib
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Extrema
else:
    import Extrema
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
class GeomAPI_PointsToBSpline(object):
    """
    This  class  is  used  to  approximate a  BsplineCurve
    passing  through an  array  of points,  with  a  given Continuity.
    Describes functions for building a 3D BSpline
    curve which approximates a set of points.
    A PointsToBSpline object provides a framework for:
    -   defining the data of the BSpline curve to be built,
    -   implementing the approximation algorithm, and consulting the results.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomAPI_PointsToBSpline self) -> GeomAPI_PointsToBSpline
        __init__(GeomAPI_PointsToBSpline self, NCollection_Array1_gp_Pnt Points, Standard_Integer const DegMin=3, Standard_Integer const DegMax=8, GeomAbs_Shape const Continuity=GeomAbs_C2, Standard_Real const Tol3D=1.0e-3) -> GeomAPI_PointsToBSpline
        __init__(GeomAPI_PointsToBSpline self, NCollection_Array1_gp_Pnt Points, Approx_ParametrizationType const ParType, Standard_Integer const DegMin=3, Standard_Integer const DegMax=8, GeomAbs_Shape const Continuity=GeomAbs_C2, Standard_Real const Tol3D=1.0e-3) -> GeomAPI_PointsToBSpline
        __init__(GeomAPI_PointsToBSpline self, NCollection_Array1_gp_Pnt Points, NCollection_Array1_Standard_Real Parameters, Standard_Integer const DegMin=3, Standard_Integer const DegMax=8, GeomAbs_Shape const Continuity=GeomAbs_C2, Standard_Real const Tol3D=1.0e-3) -> GeomAPI_PointsToBSpline
        __init__(GeomAPI_PointsToBSpline self, NCollection_Array1_gp_Pnt Points, Standard_Real const Weight1, Standard_Real const Weight2, Standard_Real const Weight3, Standard_Integer const DegMax=8, GeomAbs_Shape const Continuity=GeomAbs_C2, Standard_Real const Tol3D=1.0e-3) -> GeomAPI_PointsToBSpline

        Approximate a BSpline Curve  passing through an
        array of Point using variational smoothing algorithm,
        which tries to minimize additional criterium:
        Weight1*CurveLength + Weight2*Curvature + Weight3*Torsion

        :type Points: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Weight1: float
        :type Weight2: float
        :type Weight3: float
        :type DegMax: int
        :type Continuity: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type Tol3D: float

        """
        this = _GeomAPI.new_GeomAPI_PointsToBSpline(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(GeomAPI_PointsToBSpline self, NCollection_Array1_gp_Pnt Points, Standard_Integer const DegMin=3, Standard_Integer const DegMax=8, GeomAbs_Shape const Continuity=GeomAbs_C2, Standard_Real const Tol3D=1.0e-3)
        Init(GeomAPI_PointsToBSpline self, NCollection_Array1_gp_Pnt Points, Approx_ParametrizationType const ParType, Standard_Integer const DegMin=3, Standard_Integer const DegMax=8, GeomAbs_Shape const Continuity=GeomAbs_C2, Standard_Real const Tol3D=1.0e-3)
        Init(GeomAPI_PointsToBSpline self, NCollection_Array1_gp_Pnt Points, NCollection_Array1_Standard_Real Parameters, Standard_Integer const DegMin=3, Standard_Integer const DegMax=8, GeomAbs_Shape const Continuity=GeomAbs_C2, Standard_Real const Tol3D=1.0e-3)
        Init(GeomAPI_PointsToBSpline self, NCollection_Array1_gp_Pnt Points, Standard_Real const Weight1, Standard_Real const Weight2, Standard_Real const Weight3, Standard_Integer const DegMax=8, GeomAbs_Shape const Continuity=GeomAbs_C2, Standard_Real const Tol3D=1.0e-3)

        Approximate a BSpline Curve  passing through an
        array of Point using variational smoothing algorithm,
        which tries to minimize additional criterium:
        Weight1*CurveLength + Weight2*Curvature + Weight3*Torsion

        :type Points: OCC.wrapper.TColgp.TColgp_Array1OfPnt
        :type Weight1: float
        :type Weight2: float
        :type Weight3: float
        :type DegMax: int
        :type Continuity: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type Tol3D: float

        """
        return _GeomAPI.GeomAPI_PointsToBSpline_Init(self, *args)


    def Curve(self, *args):
        """
        Returns the computed BSpline curve.
        Raises StdFail_NotDone if the curve is not built.

        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineCurve

        """
        res = _GeomAPI.GeomAPI_PointsToBSpline_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDone(self, *args):
        """
        IsDone(GeomAPI_PointsToBSpline self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomAPI.GeomAPI_PointsToBSpline_IsDone(self, *args)

    __swig_destroy__ = _GeomAPI.delete_GeomAPI_PointsToBSpline
GeomAPI_PointsToBSpline_swigregister = _GeomAPI.GeomAPI_PointsToBSpline_swigregister
GeomAPI_PointsToBSpline_swigregister(GeomAPI_PointsToBSpline)

class GeomAPI_ExtremaSurfaceSurface(object):
    """
    Describes functions for computing all the extrema
    between two surfaces.
    An ExtremaSurfaceSurface algorithm minimizes or
    maximizes the distance between a point on the first
    surface and a point on the second surface. Results
    are start and end points of perpendiculars common to the two surfaces.
    Solutions consist of pairs of points, and an extremum
    is considered to be a segment joining the two points of a solution.
    An ExtremaSurfaceSurface object provides a framework for:
    -   defining the construction of the extrema,
    -   implementing the construction algorithm, and
    -   consulting the results.
    Warning
    In some cases, the nearest points between the two
    surfaces do not correspond to one of the computed
    extrema. Instead, they may be given by:
    -   a point of a bounding curve of one surface and one of the following:
    -   its orthogonal projection on the other surface,
    -   a point of a bounding curve of the other surface; or
    -   any point on intersection curves between the two surfaces.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomAPI_ExtremaSurfaceSurface self) -> GeomAPI_ExtremaSurfaceSurface
        __init__(GeomAPI_ExtremaSurfaceSurface self, Handle_Geom_Surface S1, Handle_Geom_Surface S2) -> GeomAPI_ExtremaSurfaceSurface
        __init__(GeomAPI_ExtremaSurfaceSurface self, Handle_Geom_Surface S1, Handle_Geom_Surface S2, Standard_Real const U1min, Standard_Real const U1max, Standard_Real const V1min, Standard_Real const V1max, Standard_Real const U2min, Standard_Real const U2max, Standard_Real const V2min, Standard_Real const V2max) -> GeomAPI_ExtremaSurfaceSurface

        Computes  the  extrema  distances  between
        the portion of the surface S1 limited by the
        two values of parameter (U1min,U1max) in
        the u parametric direction, and by the two
        values of parameter (V1min,V1max) in the v
        parametric direction, and
        -   the portion of the surface S2 limited by the
        two values of parameter (U2min,U2max) in
        the u parametric direction, and by the two
        values of parameter (V2min,V2max) in the v
        parametric direction.

        :type S1: OCC.wrapper.Geom.Handle_Geom_Surface
        :type S2: OCC.wrapper.Geom.Handle_Geom_Surface
        :type U1min: float
        :type U1max: float
        :type V1min: float
        :type V1max: float
        :type U2min: float
        :type U2max: float
        :type V2min: float
        :type V2max: float

        """
        this = _GeomAPI.new_GeomAPI_ExtremaSurfaceSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(GeomAPI_ExtremaSurfaceSurface self, Handle_Geom_Surface S1, Handle_Geom_Surface S2)
        Init(GeomAPI_ExtremaSurfaceSurface self, Handle_Geom_Surface S1, Handle_Geom_Surface S2, Standard_Real const U1min, Standard_Real const U1max, Standard_Real const V1min, Standard_Real const V1max, Standard_Real const U2min, Standard_Real const U2max, Standard_Real const V2min, Standard_Real const V2max)

        Initializes this algorithm with the given arguments
        and computes  the  extrema  distances  between -
        the portion of the surface S1 limited by the two
        values of parameter (U1min,U1max) in the u
        parametric direction, and by the two values of
        parameter (V1min,V1max) in the v parametric direction, and
        -   the portion of the surface S2 limited by the two
        values of parameter (U2min,U2max) in the u
        parametric direction, and by the two values of
        parameter (V2min,V2max) in the v parametric direction.

        :type S1: OCC.wrapper.Geom.Handle_Geom_Surface
        :type S2: OCC.wrapper.Geom.Handle_Geom_Surface
        :type U1min: float
        :type U1max: float
        :type V1min: float
        :type V1max: float
        :type U2min: float
        :type U2max: float
        :type V2min: float
        :type V2max: float

        """
        return _GeomAPI.GeomAPI_ExtremaSurfaceSurface_Init(self, *args)


    def NbExtrema(self, *args):
        """
        NbExtrema(GeomAPI_ExtremaSurfaceSurface self) -> Standard_Integer

        Returns the number of extrema computed by this algorithm.
        Note: if this algorithm fails, NbExtrema returns 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomAPI.GeomAPI_ExtremaSurfaceSurface_NbExtrema(self, *args)


    def Points(self, *args):
        """
        Points(GeomAPI_ExtremaSurfaceSurface self, Standard_Integer const Index, gp_Pnt P1, gp_Pnt P2)

        Returns the points P1 on the first surface and P2 on
        the second surface, which are the ends of the
        extremum of index Index computed by this algorithm.
        Exceptions
        Standard_OutOfRange if Index is not in the range [
        1,NbExtrema ], where NbExtrema is the
        number of extrema computed by this algorithm.

        :type Index: int
        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomAPI.GeomAPI_ExtremaSurfaceSurface_Points(self, *args)


    def Parameters(self, *args):
        """
        Parameters(GeomAPI_ExtremaSurfaceSurface self, Standard_Integer const Index)

        Returns the parameters (U1,V1) of the point on the
        first surface, and (U2,V2) of the point on the second
        surface, which are the ends of the extremum of index
        Index computed by this algorithm.
        Exceptions
        Standard_OutOfRange if Index is not in the range [
        1,NbExtrema ], where NbExtrema is the
        number of extrema computed by this algorithm.

        :type Index: int
        :type U1: float
        :type V1: float
        :type U2: float
        :type V2: float

        """
        return _GeomAPI.GeomAPI_ExtremaSurfaceSurface_Parameters(self, *args)


    def Distance(self, *args):
        """
        Distance(GeomAPI_ExtremaSurfaceSurface self, Standard_Integer const Index) -> Standard_Real

        Computes the distance between the end points of the
        extremum of index Index computed by this algorithm.
        Exceptions
        Standard_OutOfRange if Index is not in the range [
        1,NbExtrema ], where NbExtrema is the
        number of extrema computed by this algorithm.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomAPI.GeomAPI_ExtremaSurfaceSurface_Distance(self, *args)


    def NearestPoints(self, *args):
        """
        NearestPoints(GeomAPI_ExtremaSurfaceSurface self, gp_Pnt P1, gp_Pnt P2)

        Returns the points P1 on the first surface and P2 on
        the second surface, which are the ends of the
        shortest extremum computed by this algorithm.
        Exceptions StdFail_NotDone if this algorithm fails.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomAPI.GeomAPI_ExtremaSurfaceSurface_NearestPoints(self, *args)


    def LowerDistanceParameters(self, *args):
        """
        LowerDistanceParameters(GeomAPI_ExtremaSurfaceSurface self)

        Returns the parameters (U1,V1) of the point on the
        first surface and (U2,V2) of the point on the second
        surface, which are the ends of the shortest extremum
        computed by this algorithm.
        Exceptions - StdFail_NotDone if this algorithm fails.

        :type U1: float
        :type V1: float
        :type U2: float
        :type V2: float

        """
        return _GeomAPI.GeomAPI_ExtremaSurfaceSurface_LowerDistanceParameters(self, *args)


    def LowerDistance(self, *args):
        """
        LowerDistance(GeomAPI_ExtremaSurfaceSurface self) -> Standard_Real

        Computes the distance between the end points of the
        shortest extremum computed by this algorithm.
        Exceptions StdFail_NotDone if this algorithm fails.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomAPI.GeomAPI_ExtremaSurfaceSurface_LowerDistance(self, *args)


    def Extrema(self, *args):
        """
        return the algorithmic object from Extrema

        :rtype: OCC.wrapper.Extrema.Extrema_ExtSS

        """
        res = _GeomAPI.GeomAPI_ExtremaSurfaceSurface_Extrema(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomAPI.delete_GeomAPI_ExtremaSurfaceSurface
GeomAPI_ExtremaSurfaceSurface_swigregister = _GeomAPI.GeomAPI_ExtremaSurfaceSurface_swigregister
GeomAPI_ExtremaSurfaceSurface_swigregister(GeomAPI_ExtremaSurfaceSurface)

class GeomAPI_PointsToBSplineSurface(object):
    """
    This class is used to approximate or interpolate
    a BSplineSurface passing through an  Array2 of
    points, with a given continuity.
    Describes functions for building a BSpline
    surface which approximates or interpolates a set of points.
    A PointsToBSplineSurface object provides a framework for:
    -   defining the data of the BSpline surface to be built,
    -   implementing the approximation algorithm
    or the interpolation algorithm, and consulting the results.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomAPI_PointsToBSplineSurface self) -> GeomAPI_PointsToBSplineSurface
        __init__(GeomAPI_PointsToBSplineSurface self, NCollection_Array2_gp_Pnt Points, Standard_Integer const DegMin=3, Standard_Integer const DegMax=8, GeomAbs_Shape const Continuity=GeomAbs_C2, Standard_Real const Tol3D=1.0e-3) -> GeomAPI_PointsToBSplineSurface
        __init__(GeomAPI_PointsToBSplineSurface self, NCollection_Array2_gp_Pnt Points, Approx_ParametrizationType const ParType, Standard_Integer const DegMin=3, Standard_Integer const DegMax=8, GeomAbs_Shape const Continuity=GeomAbs_C2, Standard_Real const Tol3D=1.0e-3) -> GeomAPI_PointsToBSplineSurface
        __init__(GeomAPI_PointsToBSplineSurface self, NCollection_Array2_gp_Pnt Points, Standard_Real const Weight1, Standard_Real const Weight2, Standard_Real const Weight3, Standard_Integer const DegMax=8, GeomAbs_Shape const Continuity=GeomAbs_C2, Standard_Real const Tol3D=1.0e-3) -> GeomAPI_PointsToBSplineSurface
        __init__(GeomAPI_PointsToBSplineSurface self, NCollection_Array2_Standard_Real ZPoints, Standard_Real const X0, Standard_Real const dX, Standard_Real const Y0, Standard_Real const dY, Standard_Integer const DegMin=3, Standard_Integer const DegMax=8, GeomAbs_Shape const Continuity=GeomAbs_C2, Standard_Real const Tol3D=1.0e-3) -> GeomAPI_PointsToBSplineSurface

        Approximates  a BSpline  Surface passing  through  an
        array of  Points.

        The points will be constructed as follow:
        P(i,j) = gp_Pnt( X0 + (i-1)*dX ,
        Y0 + (j-1)*dY ,
        ZPoints(i,j)   )

        The resulting BSpline will  have the following
        properties:
        1- his degree will be in the range [Degmin,Degmax]
        2- his  continuity will be  at  least <Continuity>
        3- the distance from the point <Points> to the
        BSpline will be lower to Tol3D
        4- the parametrization of the surface will verify:
        S->Value( U, V) = gp_Pnt( U, V, Z(U,V) );

        :type ZPoints: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type X0: float
        :type dX: float
        :type Y0: float
        :type dY: float
        :type DegMin: int
        :type DegMax: int
        :type Continuity: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type Tol3D: float

        """
        this = _GeomAPI.new_GeomAPI_PointsToBSplineSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Interpolate(self, *args):
        """
        Interpolate(GeomAPI_PointsToBSplineSurface self, NCollection_Array2_gp_Pnt Points)
        Interpolate(GeomAPI_PointsToBSplineSurface self, NCollection_Array2_gp_Pnt Points, Approx_ParametrizationType const ParType)
        Interpolate(GeomAPI_PointsToBSplineSurface self, NCollection_Array2_Standard_Real ZPoints, Standard_Real const X0, Standard_Real const dX, Standard_Real const Y0, Standard_Real const dY)

        Interpolates  a BSpline  Surface passing  through  an
        array of  Points.

        The points will be constructed as follow:
        P(i,j) = gp_Pnt( X0 + (i-1)*dX ,
        Y0 + (j-1)*dY ,
        ZPoints(i,j)   )

        The resulting BSpline will  have the following
        properties:
        1- his degree will be 3
        2- his  continuity will be  C2.
        4- the parametrization of the surface will verify:
        S->Value( U, V) = gp_Pnt( U, V, Z(U,V) );

        :type ZPoints: OCC.wrapper.TColStd.TColStd_Array2OfReal
        :type X0: float
        :type dX: float
        :type Y0: float
        :type dY: float

        """
        return _GeomAPI.GeomAPI_PointsToBSplineSurface_Interpolate(self, *args)


    def Init(self, *args):
        """
        Init(GeomAPI_PointsToBSplineSurface self, NCollection_Array2_gp_Pnt Points, Standard_Integer const DegMin=3, Standard_Integer const DegMax=8, GeomAbs_Shape const Continuity=GeomAbs_C2, Standard_Real const Tol3D=1.0e-3)
        Init(GeomAPI_PointsToBSplineSurface self, NCollection_Array2_Standard_Real ZPoints, Standard_Real const X0, Standard_Real const dX, Standard_Real const Y0, Standard_Real const dY, Standard_Integer const DegMin=3, Standard_Integer const DegMax=8, GeomAbs_Shape const Continuity=GeomAbs_C2, Standard_Real const Tol3D=1.0e-3)
        Init(GeomAPI_PointsToBSplineSurface self, NCollection_Array2_gp_Pnt Points, Approx_ParametrizationType const ParType, Standard_Integer const DegMin=3, Standard_Integer const DegMax=8, GeomAbs_Shape const Continuity=GeomAbs_C2, Standard_Real const Tol3D=1.0e-3)
        Init(GeomAPI_PointsToBSplineSurface self, NCollection_Array2_gp_Pnt Points, Standard_Real const Weight1, Standard_Real const Weight2, Standard_Real const Weight3, Standard_Integer const DegMax=8, GeomAbs_Shape const Continuity=GeomAbs_C2, Standard_Real const Tol3D=1.0e-3)

        Approximates  a BSpline Surface passing  through  an
        array of  point using variational smoothing algorithm,
        which tries to minimize additional criterium:
        Weight1*CurveLength + Weight2*Curvature + Weight3*Torsion

        :type Points: OCC.wrapper.TColgp.TColgp_Array2OfPnt
        :type Weight1: float
        :type Weight2: float
        :type Weight3: float
        :type DegMax: int
        :type Continuity: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type Tol3D: float

        """
        return _GeomAPI.GeomAPI_PointsToBSplineSurface_Init(self, *args)


    def Surface(self, *args):
        """
        Returns the approximate BSpline Surface

        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineSurface

        """
        res = _GeomAPI.GeomAPI_PointsToBSplineSurface_Surface(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDone(self, *args):
        """
        IsDone(GeomAPI_PointsToBSplineSurface self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomAPI.GeomAPI_PointsToBSplineSurface_IsDone(self, *args)

    __swig_destroy__ = _GeomAPI.delete_GeomAPI_PointsToBSplineSurface
GeomAPI_PointsToBSplineSurface_swigregister = _GeomAPI.GeomAPI_PointsToBSplineSurface_swigregister
GeomAPI_PointsToBSplineSurface_swigregister(GeomAPI_PointsToBSplineSurface)

class GeomAPI_ExtremaCurveSurface(object):
    """
    Describes functions for computing all the extrema
    between a curve and a surface.
    An ExtremaCurveSurface algorithm minimizes or
    maximizes the distance between a point on the curve
    and a point on the surface. Thus, it computes start
    and end points of perpendiculars common to the
    curve and the surface (an intersection point is not an
    extremum except where the curve and the surface
    are tangential at this point).
    Solutions consist of pairs of points, and an extremum
    is considered to be a segment joining the two points of a solution.
    An ExtremaCurveSurface object provides a framework for:
    -   defining the construction of the extrema,
    -   implementing the construction algorithm, and
    -   consulting the results.
    Warning
    In some cases, the nearest points between a curve
    and a surface do not correspond to one of the
    computed extrema. Instead, they may be given by:
    -   a point of a bounding curve of the surface and one of the following:
    -   its orthogonal projection on the curve,
    -   a limit point of the curve; or
    -   a limit point of the curve and its projection on the surface; or
    -   an intersection point between the curve and the surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomAPI_ExtremaCurveSurface self) -> GeomAPI_ExtremaCurveSurface
        __init__(GeomAPI_ExtremaCurveSurface self, Handle_Geom_Curve Curve, Handle_Geom_Surface Surface) -> GeomAPI_ExtremaCurveSurface
        __init__(GeomAPI_ExtremaCurveSurface self, Handle_Geom_Curve Curve, Handle_Geom_Surface Surface, Standard_Real const Wmin, Standard_Real const Wmax, Standard_Real const Umin, Standard_Real const Umax, Standard_Real const Vmin, Standard_Real const Vmax) -> GeomAPI_ExtremaCurveSurface

        Computes  the  extrema  distances  between  the
        curve <C>  and the  surface  <S>.  The solution
        point are computed in the domain [Wmin,Wmax] of
        the  curve   and  in  the  domain   [Umin,Umax]
        [Vmin,Vmax] of the surface.
        Warning
        Use the function NbExtrema to obtain the number
        of solutions. If this algorithm fails, NbExtrema returns 0.

        :type Curve: OCC.wrapper.Geom.Handle_Geom_Curve
        :type Surface: OCC.wrapper.Geom.Handle_Geom_Surface
        :type Wmin: float
        :type Wmax: float
        :type Umin: float
        :type Umax: float
        :type Vmin: float
        :type Vmax: float

        """
        this = _GeomAPI.new_GeomAPI_ExtremaCurveSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(GeomAPI_ExtremaCurveSurface self, Handle_Geom_Curve Curve, Handle_Geom_Surface Surface)
        Init(GeomAPI_ExtremaCurveSurface self, Handle_Geom_Curve Curve, Handle_Geom_Surface Surface, Standard_Real const Wmin, Standard_Real const Wmax, Standard_Real const Umin, Standard_Real const Umax, Standard_Real const Vmin, Standard_Real const Vmax)

        Computes  the  extrema  distances  between  the
        curve <C>  and the  surface  <S>.  The solution
        point are computed in the domain [Wmin,Wmax] of
        the  curve   and  in  the  domain   [Umin,Umax]
        [Vmin,Vmax] of the surface.
        Warning
        Use the function NbExtrema to obtain the number
        of solutions. If this algorithm fails, NbExtrema returns 0.

        :type Curve: OCC.wrapper.Geom.Handle_Geom_Curve
        :type Surface: OCC.wrapper.Geom.Handle_Geom_Surface
        :type Wmin: float
        :type Wmax: float
        :type Umin: float
        :type Umax: float
        :type Vmin: float
        :type Vmax: float

        """
        return _GeomAPI.GeomAPI_ExtremaCurveSurface_Init(self, *args)


    def NbExtrema(self, *args):
        """
        NbExtrema(GeomAPI_ExtremaCurveSurface self) -> Standard_Integer

        Returns the number of extrema computed by this algorithm.
        Note: if this algorithm fails, NbExtrema returns 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomAPI.GeomAPI_ExtremaCurveSurface_NbExtrema(self, *args)


    def Points(self, *args):
        """
        Points(GeomAPI_ExtremaCurveSurface self, Standard_Integer const Index, gp_Pnt P1, gp_Pnt P2)

        Returns the points P1 on the curve and P2 on the
        surface, which are the ends of the extremum of index
        Index computed by this algorithm.
        Exceptions
        Standard_OutOfRange if Index is not in the range [
        1,NbExtrema ], where NbExtrema is the
        number of extrema computed by this algorithm.

        :type Index: int
        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomAPI.GeomAPI_ExtremaCurveSurface_Points(self, *args)


    def Parameters(self, *args):
        """
        Parameters(GeomAPI_ExtremaCurveSurface self, Standard_Integer const Index)

        Returns the parameters W of the point on the curve,
        and (U,V) of the point on the surface, which are the
        ends of the extremum of index Index computed by this algorithm.
        Exceptions
        Standard_OutOfRange if Index is not in the range [
        1,NbExtrema ], where NbExtrema is the
        number of extrema computed by this algorithm.

        :type Index: int
        :type W: float
        :type U: float
        :type V: float

        """
        return _GeomAPI.GeomAPI_ExtremaCurveSurface_Parameters(self, *args)


    def Distance(self, *args):
        """
        Distance(GeomAPI_ExtremaCurveSurface self, Standard_Integer const Index) -> Standard_Real

        Computes the distance between the end points of the
        extremum of index Index computed by this algorithm.
        Exceptions
        Standard_OutOfRange if index is not in the range [
        1,NbExtrema ], where NbExtrema is the
        number of extrema computed by this algorithm.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomAPI.GeomAPI_ExtremaCurveSurface_Distance(self, *args)


    def NearestPoints(self, *args):
        """
        NearestPoints(GeomAPI_ExtremaCurveSurface self, gp_Pnt PC, gp_Pnt PS)

        Returns the points PC on the curve and PS on the
        surface, which are the ends of the shortest extremum computed by this algorithm.
        Exceptions - StdFail_NotDone if this algorithm fails.

        :type PC: OCC.wrapper.gp.gp_Pnt
        :type PS: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomAPI.GeomAPI_ExtremaCurveSurface_NearestPoints(self, *args)


    def LowerDistanceParameters(self, *args):
        """
        LowerDistanceParameters(GeomAPI_ExtremaCurveSurface self)

        Returns the parameters W of the point on the curve
        and (U,V) of the point on the surface, which are the
        ends of the shortest extremum computed by this algorithm.
        Exceptions - StdFail_NotDone if this algorithm fails.

        :type W: float
        :type U: float
        :type V: float

        """
        return _GeomAPI.GeomAPI_ExtremaCurveSurface_LowerDistanceParameters(self, *args)


    def LowerDistance(self, *args):
        """
        LowerDistance(GeomAPI_ExtremaCurveSurface self) -> Standard_Real

        Computes the distance between the end points of the
        shortest extremum computed by this algorithm.
        Exceptions - StdFail_NotDone if this algorithm fails.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomAPI.GeomAPI_ExtremaCurveSurface_LowerDistance(self, *args)


    def Extrema(self, *args):
        """
        Returns the algorithmic object from Extrema

        :rtype: OCC.wrapper.Extrema.Extrema_ExtCS

        """
        res = _GeomAPI.GeomAPI_ExtremaCurveSurface_Extrema(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomAPI.delete_GeomAPI_ExtremaCurveSurface
GeomAPI_ExtremaCurveSurface_swigregister = _GeomAPI.GeomAPI_ExtremaCurveSurface_swigregister
GeomAPI_ExtremaCurveSurface_swigregister(GeomAPI_ExtremaCurveSurface)

class GeomAPI_IntSS(object):
    """
    This class implements methods for
    computing the intersection curves   between two surfaces.
    The result is curves from Geom.  The "domain" used for
    a surface   is the natural  parametric domain
    unless the surface is a  RectangularTrimmedSurface
    from Geom.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomAPI_IntSS self) -> GeomAPI_IntSS
        __init__(GeomAPI_IntSS self, Handle_Geom_Surface S1, Handle_Geom_Surface S2, Standard_Real const Tol) -> GeomAPI_IntSS

        Computes the intersection curves
        between the two surfaces S1 and S2. Parameter Tol defines the precision
        of curves computation. For most cases the value 1.0e-7 is recommended to use.
        Warning
        Use the function IsDone to verify that the intersections are successfully computed.I

        :type S1: OCC.wrapper.Geom.Handle_Geom_Surface
        :type S2: OCC.wrapper.Geom.Handle_Geom_Surface
        :type Tol: float

        """
        this = _GeomAPI.new_GeomAPI_IntSS(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(GeomAPI_IntSS self, Handle_Geom_Surface S1, Handle_Geom_Surface S2, Standard_Real const Tol)

        Initializes an algorithm with the
        given arguments and computes the intersection curves between the two surfaces S1 and S2.
        Parameter Tol defines the precision of curves computation. For most
        cases the value 1.0e-7 is recommended to use.
        Warning
        Use function IsDone to verify that the intersections are successfully computed.

        :type S1: OCC.wrapper.Geom.Handle_Geom_Surface
        :type S2: OCC.wrapper.Geom.Handle_Geom_Surface
        :type Tol: float

        """
        return _GeomAPI.GeomAPI_IntSS_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(GeomAPI_IntSS self) -> Standard_Boolean

        Returns True if the intersection was successful.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomAPI.GeomAPI_IntSS_IsDone(self, *args)


    def NbLines(self, *args):
        """
        NbLines(GeomAPI_IntSS self) -> Standard_Integer

        Returns the number of computed intersection curves.
        Exceptions
        StdFail_NotDone if the computation fails.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomAPI.GeomAPI_IntSS_NbLines(self, *args)


    def Line(self, *args):
        """
        Returns the computed intersection curve of index Index.
        Exceptions
        StdFail_NotDone if the computation fails.
        Standard_OutOfRange if Index is out of range [1, NbLines] where NbLines
        is the number of computed intersection curves.

        :type Index: int
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        res = _GeomAPI.GeomAPI_IntSS_Line(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomAPI.delete_GeomAPI_IntSS
GeomAPI_IntSS_swigregister = _GeomAPI.GeomAPI_IntSS_swigregister
GeomAPI_IntSS_swigregister(GeomAPI_IntSS)

class GeomAPI_ProjectPointOnSurf(object):
    """
    This class implements methods for  computing all the orthogonal
    projections of a point onto a  surface.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomAPI_ProjectPointOnSurf self) -> GeomAPI_ProjectPointOnSurf
        __init__(GeomAPI_ProjectPointOnSurf self, gp_Pnt P, Handle_Geom_Surface Surface, Extrema_ExtAlgo const Algo=Extrema_ExtAlgo_Grad) -> GeomAPI_ProjectPointOnSurf
        __init__(GeomAPI_ProjectPointOnSurf self, gp_Pnt P, Handle_Geom_Surface Surface, Standard_Real const Tolerance, Extrema_ExtAlgo const Algo=Extrema_ExtAlgo_Grad) -> GeomAPI_ProjectPointOnSurf
        __init__(GeomAPI_ProjectPointOnSurf self, gp_Pnt P, Handle_Geom_Surface Surface, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const Vmin, Standard_Real const Vsup, Standard_Real const Tolerance, Extrema_ExtAlgo const Algo=Extrema_ExtAlgo_Grad) -> GeomAPI_ProjectPointOnSurf
        __init__(GeomAPI_ProjectPointOnSurf self, gp_Pnt P, Handle_Geom_Surface Surface, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const Vmin, Standard_Real const Vsup, Extrema_ExtAlgo const Algo=Extrema_ExtAlgo_Grad) -> GeomAPI_ProjectPointOnSurf

        Init the projection  of a point <P> on a surface
        <Surface>

        :type P: OCC.wrapper.gp.gp_Pnt
        :type Surface: OCC.wrapper.Geom.Handle_Geom_Surface
        :type Umin: float
        :type Usup: float
        :type Vmin: float
        :type Vsup: float
        :type Algo: OCC.wrapper.Extrema.Extrema_ExtAlgo

        """
        this = _GeomAPI.new_GeomAPI_ProjectPointOnSurf(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(GeomAPI_ProjectPointOnSurf self, gp_Pnt P, Handle_Geom_Surface Surface, Standard_Real const Tolerance, Extrema_ExtAlgo const Algo=Extrema_ExtAlgo_Grad)
        Init(GeomAPI_ProjectPointOnSurf self, gp_Pnt P, Handle_Geom_Surface Surface, Extrema_ExtAlgo const Algo=Extrema_ExtAlgo_Grad)
        Init(GeomAPI_ProjectPointOnSurf self, gp_Pnt P, Handle_Geom_Surface Surface, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const Vmin, Standard_Real const Vsup, Standard_Real const Tolerance, Extrema_ExtAlgo const Algo=Extrema_ExtAlgo_Grad)
        Init(GeomAPI_ProjectPointOnSurf self, gp_Pnt P, Handle_Geom_Surface Surface, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const Vmin, Standard_Real const Vsup, Extrema_ExtAlgo const Algo=Extrema_ExtAlgo_Grad)
        Init(GeomAPI_ProjectPointOnSurf self, Handle_Geom_Surface Surface, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const Vmin, Standard_Real const Vsup, Standard_Real const Tolerance, Extrema_ExtAlgo const Algo=Extrema_ExtAlgo_Grad)
        Init(GeomAPI_ProjectPointOnSurf self, Handle_Geom_Surface Surface, Standard_Real const Umin, Standard_Real const Usup, Standard_Real const Vmin, Standard_Real const Vsup, Extrema_ExtAlgo const Algo=Extrema_ExtAlgo_Grad)

        :type Surface: OCC.wrapper.Geom.Handle_Geom_Surface
        :type Umin: float
        :type Usup: float
        :type Vmin: float
        :type Vsup: float
        :type Algo: OCC.wrapper.Extrema.Extrema_ExtAlgo

        """
        return _GeomAPI.GeomAPI_ProjectPointOnSurf_Init(self, *args)


    def SetExtremaAlgo(self, *args):
        """
        SetExtremaAlgo(GeomAPI_ProjectPointOnSurf self, Extrema_ExtAlgo const theAlgo)

        Sets the Extrema search algorithm - Grad or Tree. <br>
        By default the Extrema is initialized with Grad algorithm.

        :type theAlgo: OCC.wrapper.Extrema.Extrema_ExtAlgo

        """
        return _GeomAPI.GeomAPI_ProjectPointOnSurf_SetExtremaAlgo(self, *args)


    def SetExtremaFlag(self, *args):
        """
        SetExtremaFlag(GeomAPI_ProjectPointOnSurf self, Extrema_ExtFlag const theExtFlag)

        Sets the Extrema search flag - MIN or MAX or MINMAX.<br>
        By default the Extrema is set to search the MinMax solutions.

        :type theExtFlag: OCC.wrapper.Extrema.Extrema_ExtFlag

        """
        return _GeomAPI.GeomAPI_ProjectPointOnSurf_SetExtremaFlag(self, *args)


    def Perform(self, *args):
        """
        Perform(GeomAPI_ProjectPointOnSurf self, gp_Pnt P)

        Performs the projection of a point on the current surface.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomAPI.GeomAPI_ProjectPointOnSurf_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(GeomAPI_ProjectPointOnSurf self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomAPI.GeomAPI_ProjectPointOnSurf_IsDone(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(GeomAPI_ProjectPointOnSurf self) -> Standard_Integer

        Returns the number of computed orthogonal projection points.
        Note: if projection fails, NbPoints returns 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomAPI.GeomAPI_ProjectPointOnSurf_NbPoints(self, *args)


    def Point(self, *args):
        """
        Point(GeomAPI_ProjectPointOnSurf self, Standard_Integer const Index) -> gp_Pnt

        Returns the orthogonal projection
        on the surface. Index is a number of a computed point.
        Exceptions
        Standard_OutOfRange if Index is not in the range [ 1,NbPoints ], where
        NbPoints is the number of solution points.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomAPI.GeomAPI_ProjectPointOnSurf_Point(self, *args)


    def Parameters(self, *args):
        """
        Parameters(GeomAPI_ProjectPointOnSurf self, Standard_Integer const Index)

        Returns the parameters (U,V) on the
        surface of the orthogonal projection. Index is a number of a
        computed point.
        Exceptions
        Standard_OutOfRange if Index is not in the range [ 1,NbPoints ], where
        NbPoints is the number of solution points.

        :type Index: int
        :type U: float
        :type V: float

        """
        return _GeomAPI.GeomAPI_ProjectPointOnSurf_Parameters(self, *args)


    def Distance(self, *args):
        """
        Distance(GeomAPI_ProjectPointOnSurf self, Standard_Integer const Index) -> Standard_Real

        Computes the distance between the
        point and its orthogonal projection on the surface. Index is a number
        of a computed point.
        Exceptions
        Standard_OutOfRange if Index is not in the range [ 1,NbPoints ], where
        NbPoints is the number of solution points.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomAPI.GeomAPI_ProjectPointOnSurf_Distance(self, *args)


    def NearestPoint(self, *args):
        """
        NearestPoint(GeomAPI_ProjectPointOnSurf self) -> gp_Pnt

        Returns the nearest orthogonal projection of the point
        on the surface.
        Exceptions
        StdFail_NotDone if projection fails.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomAPI.GeomAPI_ProjectPointOnSurf_NearestPoint(self, *args)


    def LowerDistanceParameters(self, *args):
        """
        LowerDistanceParameters(GeomAPI_ProjectPointOnSurf self)

        Returns the parameters (U,V) on the
        surface of the nearest computed orthogonal projection of the point.
        Exceptions
        StdFail_NotDone if projection fails.

        :type U: float
        :type V: float

        """
        return _GeomAPI.GeomAPI_ProjectPointOnSurf_LowerDistanceParameters(self, *args)


    def LowerDistance(self, *args):
        """
        LowerDistance(GeomAPI_ProjectPointOnSurf self) -> Standard_Real

        Computes the distance between the
        point and its nearest orthogonal projection on the surface.
        Exceptions
        StdFail_NotDone if projection fails.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomAPI.GeomAPI_ProjectPointOnSurf_LowerDistance(self, *args)


    def Extrema(self, *args):
        """
        return the algorithmic object from Extrema

        :rtype: OCC.wrapper.Extrema.Extrema_ExtPS

        """
        res = _GeomAPI.GeomAPI_ProjectPointOnSurf_Extrema(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomAPI.delete_GeomAPI_ProjectPointOnSurf
GeomAPI_ProjectPointOnSurf_swigregister = _GeomAPI.GeomAPI_ProjectPointOnSurf_swigregister
GeomAPI_ProjectPointOnSurf_swigregister(GeomAPI_ProjectPointOnSurf)

class GeomAPI_ProjectPointOnCurve(object):
    """
    This class implements methods for  computing all the orthogonal
    projections of a 3D point onto a  3D curve.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomAPI_ProjectPointOnCurve self) -> GeomAPI_ProjectPointOnCurve
        __init__(GeomAPI_ProjectPointOnCurve self, gp_Pnt P, Handle_Geom_Curve Curve) -> GeomAPI_ProjectPointOnCurve
        __init__(GeomAPI_ProjectPointOnCurve self, gp_Pnt P, Handle_Geom_Curve Curve, Standard_Real const Umin, Standard_Real const Usup) -> GeomAPI_ProjectPointOnCurve

        Create  the projection  of a point <P>  on a curve
        <Curve> limited by the two points of parameter Umin and Usup.

        :type P: OCC.wrapper.gp.gp_Pnt
        :type Curve: OCC.wrapper.Geom.Handle_Geom_Curve
        :type Umin: float
        :type Usup: float

        """
        this = _GeomAPI.new_GeomAPI_ProjectPointOnCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(GeomAPI_ProjectPointOnCurve self, gp_Pnt P, Handle_Geom_Curve Curve)
        Init(GeomAPI_ProjectPointOnCurve self, gp_Pnt P, Handle_Geom_Curve Curve, Standard_Real const Umin, Standard_Real const Usup)
        Init(GeomAPI_ProjectPointOnCurve self, Handle_Geom_Curve Curve, Standard_Real const Umin, Standard_Real const Usup)

        Init  the  projection  of a  point <P>  on a curve
        <Curve> limited by the two points of parameter Umin and Usup.

        :type Curve: OCC.wrapper.Geom.Handle_Geom_Curve
        :type Umin: float
        :type Usup: float

        """
        return _GeomAPI.GeomAPI_ProjectPointOnCurve_Init(self, *args)


    def Perform(self, *args):
        """
        Perform(GeomAPI_ProjectPointOnCurve self, gp_Pnt P)

        Performs the projection of a point on the current curve.

        :type P: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomAPI.GeomAPI_ProjectPointOnCurve_Perform(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(GeomAPI_ProjectPointOnCurve self) -> Standard_Integer

        Returns the number of computed
        orthogonal projection points.
        Note: if this algorithm fails, NbPoints returns 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomAPI.GeomAPI_ProjectPointOnCurve_NbPoints(self, *args)


    def Point(self, *args):
        """
        Point(GeomAPI_ProjectPointOnCurve self, Standard_Integer const Index) -> gp_Pnt

        Returns the orthogonal projection
        on the curve. Index is a number of a computed point.
        Exceptions
        Standard_OutOfRange if Index is not in the range [ 1,NbPoints ], where
        NbPoints is the number of solution points.

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomAPI.GeomAPI_ProjectPointOnCurve_Point(self, *args)


    def Parameter(self, *args):
        """
        Parameter(GeomAPI_ProjectPointOnCurve self, Standard_Integer const Index) -> Standard_Real
        Parameter(GeomAPI_ProjectPointOnCurve self, Standard_Integer const Index)

        Returns the parameter on the curve
        of the point, which is the orthogonal projection. Index is a
        number of a computed point.
        Exceptions
        Standard_OutOfRange if Index is not in the range [ 1,NbPoints ], where
        NbPoints is the number of solution points.-

        :type Index: int
        :type U: float

        """
        return _GeomAPI.GeomAPI_ProjectPointOnCurve_Parameter(self, *args)


    def Distance(self, *args):
        """
        Distance(GeomAPI_ProjectPointOnCurve self, Standard_Integer const Index) -> Standard_Real

        Computes the distance between the
        point and its orthogonal projection on the curve. Index is a number of a computed point.
        Exceptions
        Standard_OutOfRange if Index is not in the range [ 1,NbPoints ], where
        NbPoints is the number of solution points.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomAPI.GeomAPI_ProjectPointOnCurve_Distance(self, *args)


    def NearestPoint(self, *args):
        """
        NearestPoint(GeomAPI_ProjectPointOnCurve self) -> gp_Pnt

        Returns the nearest orthogonal
        projection of the point on the curve.
        Exceptions: StdFail_NotDone if this algorithm fails.

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomAPI.GeomAPI_ProjectPointOnCurve_NearestPoint(self, *args)


    def LowerDistanceParameter(self, *args):
        """
        LowerDistanceParameter(GeomAPI_ProjectPointOnCurve self) -> Standard_Real

        Returns the parameter on the curve
        of the nearest orthogonal projection of the point.
        Exceptions: StdFail_NotDone if this algorithm fails.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomAPI.GeomAPI_ProjectPointOnCurve_LowerDistanceParameter(self, *args)


    def LowerDistance(self, *args):
        """
        LowerDistance(GeomAPI_ProjectPointOnCurve self) -> Standard_Real

        Computes the distance between the
        point and its nearest orthogonal projection on the curve.
        Exceptions: StdFail_NotDone if this algorithm fails.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomAPI.GeomAPI_ProjectPointOnCurve_LowerDistance(self, *args)


    def Extrema(self, *args):
        """
        return the algorithmic object from Extrema

        :rtype: OCC.wrapper.Extrema.Extrema_ExtPC

        """
        res = _GeomAPI.GeomAPI_ProjectPointOnCurve_Extrema(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _GeomAPI.delete_GeomAPI_ProjectPointOnCurve
GeomAPI_ProjectPointOnCurve_swigregister = _GeomAPI.GeomAPI_ProjectPointOnCurve_swigregister
GeomAPI_ProjectPointOnCurve_swigregister(GeomAPI_ProjectPointOnCurve)

class GeomAPI_Interpolate(object):
    """
    This  class  is  used  to  interpolate a  BsplineCurve
    passing   through  an  array  of  points,  with  a  C2
    Continuity if tangency is not requested at the point.
    If tangency is requested at the point the continuity will
    be C1.  If Perodicity is requested the curve will be closed
    and the junction will be the first point given. The curve
    will than be only C1
    Describes functions for building a constrained 3D BSpline curve.
    The curve is defined by a table of points
    through which it passes, and if required:
    -   by a parallel table of reals which gives the
    value of the parameter of each point through
    which the resulting BSpline curve passes, and
    -   by vectors tangential to these points.
    An Interpolate object provides a framework for:
    -   defining the constraints of the BSpline curve,
    -   implementing the interpolation algorithm, and
    -   consulting the results.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomAPI_Interpolate self, Handle_TColgp_HArray1OfPnt Points, Standard_Boolean const PeriodicFlag, Standard_Real const Tolerance) -> GeomAPI_Interpolate
        __init__(GeomAPI_Interpolate self, Handle_TColgp_HArray1OfPnt Points, Handle_TColStd_HArray1OfReal Parameters, Standard_Boolean const PeriodicFlag, Standard_Real const Tolerance) -> GeomAPI_Interpolate

        Initializes an algorithm for constructing a
        constrained BSpline curve passing through the points of the table
        Points, where the parameters of each of its
        points are given by the parallel table Parameters.
        Tangential vectors can then be assigned, using the function Load.
        If PeriodicFlag is true, the constrained BSpline
        curve will be periodic and closed. In this case,
        the junction point is the first point of the table Points.
        The tolerance value Tolerance is used to check that:
        -   points are not too close to each other, or
        -   tangential vectors (defined using the
        function Load) are not too small.
        The resulting BSpline curve will be "C2"
        continuous, except where a tangency
        constraint is defined on a point through which
        the curve passes (by using the Load function).
        In this case, it will be only "C1" continuous.
        Once all the constraints are defined, use the
        function Perform to compute the curve.
        Warning
        -   There must be at least 2 points in the table Points.
        -   If PeriodicFlag is false, there must be as
        many parameters in the array Parameters as
        there are points in the array Points.
        -   If PeriodicFlag is true, there must be one
        more parameter in the table Parameters: this
        is used to give the parameter on the
        resulting BSpline curve of the junction point
        of the curve (which is also the first point of the table Points).
        Exceptions
        -   Standard_ConstructionError if the
        distance between two consecutive points in
        the table Points is less than or equal to Tolerance.
        -   Standard_OutOfRange if:
        -   there are less than two points in the table Points, or
        -   conditions relating to the respective
        number of elements in the parallel tables
        Points and Parameters are not respected.

        :type Points: OCC.wrapper.TColgp.Handle_TColgp_HArray1OfPnt
        :type Parameters: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal
        :type PeriodicFlag: bool
        :type Tolerance: float

        """
        this = _GeomAPI.new_GeomAPI_Interpolate(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Load(self, *args):
        """
        Load(GeomAPI_Interpolate self, gp_Vec InitialTangent, gp_Vec FinalTangent, Standard_Boolean const Scale)
        Load(GeomAPI_Interpolate self, NCollection_Array1_gp_Vec Tangents, Handle_TColStd_HArray1OfBoolean TangentFlags, Standard_Boolean const Scale)

        Assigns this constrained BSpline curve to be
        tangential to vectors defined in the table Tangents,
        which is parallel to the table of points
        through which the curve passes, as
        defined at the time of initialization. Vectors
        in the table Tangents are defined only if
        the flag given in the parallel table
        TangentFlags is true: only these vectors
        are set as tangency constraints.

        :type Tangents: OCC.wrapper.TColgp.TColgp_Array1OfVec
        :type TangentFlags: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfBoolean
        :type Scale: bool

        """
        return _GeomAPI.GeomAPI_Interpolate_Load(self, *args)


    def Perform(self, *args):
        """
        Perform(GeomAPI_Interpolate self)

        Computes the constrained BSpline curve.
        Use the function IsDone to verify that the
        computation is successful, and then the function Curve to obtain the result.


        """
        return _GeomAPI.GeomAPI_Interpolate_Perform(self, *args)


    def Curve(self, *args):
        """
        Returns the computed BSpline curve.
        Raises StdFail_NotDone if the interpolation fails.

        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineCurve

        """
        res = _GeomAPI.GeomAPI_Interpolate_Curve(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDone(self, *args):
        """
        IsDone(GeomAPI_Interpolate self) -> Standard_Boolean

        Returns true if the constrained BSpline curve is successfully constructed.
        Note: in this case, the result is given by the function Curve.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomAPI.GeomAPI_Interpolate_IsDone(self, *args)

    __swig_destroy__ = _GeomAPI.delete_GeomAPI_Interpolate
GeomAPI_Interpolate_swigregister = _GeomAPI.GeomAPI_Interpolate_swigregister
GeomAPI_Interpolate_swigregister(GeomAPI_Interpolate)

class GeomAPI_IntCS(object):
    """
    This class implements methods for
    computing intersection points and  segments between a
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomAPI_IntCS self) -> GeomAPI_IntCS
        __init__(GeomAPI_IntCS self, Handle_Geom_Curve C, Handle_Geom_Surface S) -> GeomAPI_IntCS

        Computes the intersections between
        the curve C and the surface S.
        Warning
        Use function IsDone to verify that the intersections are computed successfully.

        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        this = _GeomAPI.new_GeomAPI_IntCS(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(GeomAPI_IntCS self, Handle_Geom_Curve C, Handle_Geom_Surface S)

        This function Initializes an algorithm with the curve C and the
        surface S and computes the intersections between C and S.
        Warning
        Use function IsDone to verify that the intersections are computed successfully.

        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type S: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _GeomAPI.GeomAPI_IntCS_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(GeomAPI_IntCS self) -> Standard_Boolean

        Returns true if the intersections are successfully computed.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomAPI.GeomAPI_IntCS_IsDone(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(GeomAPI_IntCS self) -> Standard_Integer

        Returns the number of Intersection Points
        if IsDone returns True.
        else NotDone is raised.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomAPI.GeomAPI_IntCS_NbPoints(self, *args)


    def Point(self, *args):
        """
        Returns the Intersection Point of range <Index>in case of cross intersection.
        Raises NotDone if the computation has failed or if
        the computation has not been done
        raises OutOfRange if Index is not in the range <1..NbPoints>

        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        res = _GeomAPI.GeomAPI_IntCS_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NbSegments(self, *args):
        """
        NbSegments(GeomAPI_IntCS self) -> Standard_Integer

        Returns the number of computed
        intersection segments in case of tangential intersection.
        Exceptions
        StdFail_NotDone if the intersection algorithm fails or is not initialized.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomAPI.GeomAPI_IntCS_NbSegments(self, *args)


    def Segment(self, *args):
        """
        Segment(GeomAPI_IntCS self, Standard_Integer const Index) -> Handle_Geom_Curve

        Returns the computed intersection
        segment of index Index in case of tangential intersection.
        Intersection segment is a portion of the initial curve tangent to surface.
        Exceptions
        StdFail_NotDone if intersection algorithm fails or is not initialized.
        Standard_OutOfRange if Index is not in the range [ 1,NbSegments ],
        where NbSegments is the number of computed intersection segments.

        :type Index: int
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _GeomAPI.GeomAPI_IntCS_Segment(self, *args)


    def Parameters(self, *args):
        """
        Parameters(GeomAPI_IntCS self, Standard_Integer const Index)
        Parameters(GeomAPI_IntCS self, Standard_Integer const Index)

        Returns the parameters of the first (U1,V1) and the last (U2,V2) points
        of curve's segment on the surface in case of tangential intersection.
        Index is the number of computed intersection segments.
        Exceptions
        StdFail_NotDone if intersection algorithm fails or is not initialized.
        Standard_OutOfRange if Index is not in the range [ 1,NbSegments ],
        where NbSegments is the number of computed intersection segments.

        :type Index: int
        :type U1: float
        :type V1: float
        :type U2: float
        :type V2: float

        """
        return _GeomAPI.GeomAPI_IntCS_Parameters(self, *args)

    __swig_destroy__ = _GeomAPI.delete_GeomAPI_IntCS
GeomAPI_IntCS_swigregister = _GeomAPI.GeomAPI_IntCS_swigregister
GeomAPI_IntCS_swigregister(GeomAPI_IntCS)

class GeomAPI_(object):
    """
    The   GeomAPI   package  provides  an  Application
    Programming Interface for the Geometry.

    The API is a set of  classes and methods aiming to
    provide :

    * High level and simple calls  for the most common
    operations.

    *    Keeping   an   access  on    the    low-level
    implementation of high-level calls.

    The API  provides classes to  call the algorithmes
    of the Geometry

    * The  constructors  of the classes  provides  the
    different constructions methods.

    * The  class keeps as fields the   different tools
    used by the algorithmes

    *   The class  provides  a  casting  method to get
    automatically the  result  with  a   function-like
    call.

    For example to evaluate the distance <D> between a
    point <P> and a curve <C>, one can writes :

    D = GeomAPI_ProjectPointOnCurve(P,C);

    or

    GeomAPI_ProjectPointOnCurve PonC(P,C);
    D = PonC.LowerDistance();
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def To2d(*args):
        """
        To2d(Handle_Geom_Curve C, gp_Pln P) -> Handle_Geom2d_Curve

        This function builds (in the
        parametric space of the plane P) a 2D curve equivalent to the 3D curve
        C. The 3D curve C is considered to be located in the plane P.
        Warning
        The 3D curve C must be of one of the following types:
        -      a line
        -      a circle
        -      an ellipse
        -      a hyperbola
        -      a parabola
        -      a Bezier curve
        -      a BSpline curve
        Exceptions Standard_NoSuchObject if C is not a defined type curve.

        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type P: OCC.wrapper.gp.gp_Pln
        :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

        """
        return _GeomAPI.GeomAPI__To2d(*args)

    To2d = staticmethod(To2d)

    def To3d(*args):
        """
        To3d(Handle_Geom2d_Curve C, gp_Pln P) -> Handle_Geom_Curve

        Builds a 3D curve equivalent to the 2D curve C
        described in the parametric space defined by the local
        coordinate system of plane P.
        The resulting 3D curve is of the same nature as that of the curve C.

        :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
        :type P: OCC.wrapper.gp.gp_Pln
        :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

        """
        return _GeomAPI.GeomAPI__To3d(*args)

    To3d = staticmethod(To3d)

    def __init__(self):
        """
        The   GeomAPI   package  provides  an  Application
        Programming Interface for the Geometry.

        The API is a set of  classes and methods aiming to
        provide :

        * High level and simple calls  for the most common
        operations.

        *    Keeping   an   access  on    the    low-level
        implementation of high-level calls.

        The API  provides classes to  call the algorithmes
        of the Geometry

        * The  constructors  of the classes  provides  the
        different constructions methods.

        * The  class keeps as fields the   different tools
        used by the algorithmes

        *   The class  provides  a  casting  method to get
        automatically the  result  with  a   function-like
        call.

        For example to evaluate the distance <D> between a
        point <P> and a curve <C>, one can writes :

        D = GeomAPI_ProjectPointOnCurve(P,C);

        or

        GeomAPI_ProjectPointOnCurve PonC(P,C);
        D = PonC.LowerDistance();
        """
        this = _GeomAPI.new_GeomAPI_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GeomAPI.delete_GeomAPI_
GeomAPI__swigregister = _GeomAPI.GeomAPI__swigregister
GeomAPI__swigregister(GeomAPI_)

def GeomAPI__To2d(*args):
    """
    GeomAPI__To2d(Handle_Geom_Curve C, gp_Pln P) -> Handle_Geom2d_Curve

    This function builds (in the
    parametric space of the plane P) a 2D curve equivalent to the 3D curve
    C. The 3D curve C is considered to be located in the plane P.
    Warning
    The 3D curve C must be of one of the following types:
    -      a line
    -      a circle
    -      an ellipse
    -      a hyperbola
    -      a parabola
    -      a Bezier curve
    -      a BSpline curve
    Exceptions Standard_NoSuchObject if C is not a defined type curve.

    :type C: OCC.wrapper.Geom.Handle_Geom_Curve
    :type P: OCC.wrapper.gp.gp_Pln
    :rtype: OCC.wrapper.Geom2d.Handle_Geom2d_Curve

    """
    return _GeomAPI.GeomAPI__To2d(*args)

def GeomAPI__To3d(*args):
    """
    GeomAPI__To3d(Handle_Geom2d_Curve C, gp_Pln P) -> Handle_Geom_Curve

    Builds a 3D curve equivalent to the 2D curve C
    described in the parametric space defined by the local
    coordinate system of plane P.
    The resulting 3D curve is of the same nature as that of the curve C.

    :type C: OCC.wrapper.Geom2d.Handle_Geom2d_Curve
    :type P: OCC.wrapper.gp.gp_Pln
    :rtype: OCC.wrapper.Geom.Handle_Geom_Curve

    """
    return _GeomAPI.GeomAPI__To3d(*args)

class GeomAPI_ExtremaCurveCurve(object):
    """
    Describes functions for computing all the extrema
    between two 3D curves.
    An ExtremaCurveCurve algorithm minimizes or
    maximizes the distance between a point on the first
    curve and a point on the second curve. Thus, it
    computes start and end points of perpendiculars
    common to the two curves (an intersection point is
    not an extremum unless the two curves are tangential at this point).
    Solutions consist of pairs of points, and an extremum
    is considered to be a segment joining the two points of a solution.
    An ExtremaCurveCurve object provides a framework for:
    -   defining the construction of the extrema,
    -   implementing the construction algorithm, and
    -   consulting the results.
    Warning
    In some cases, the nearest points between two
    curves do not correspond to one of the computed
    extrema. Instead, they may be given by:
    -   a limit point of one curve and one of the following:
    -   its orthogonal projection on the other curve,
    -   a limit point of the other curve; or
    -   an intersection point between the two curves.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomAPI_ExtremaCurveCurve self) -> GeomAPI_ExtremaCurveCurve
        __init__(GeomAPI_ExtremaCurveCurve self, Handle_Geom_Curve C1, Handle_Geom_Curve C2) -> GeomAPI_ExtremaCurveCurve
        __init__(GeomAPI_ExtremaCurveCurve self, Handle_Geom_Curve C1, Handle_Geom_Curve C2, Standard_Real const U1min, Standard_Real const U1max, Standard_Real const U2min, Standard_Real const U2max) -> GeomAPI_ExtremaCurveCurve

        Computes   the portion of the curve C1 limited by the two
        points of parameter (U1min,U1max), and
        -   the portion of the curve C2 limited by the two
        points of parameter (U2min,U2max).
        Warning
        Use the function NbExtrema to obtain the number
        of solutions. If this algorithm fails, NbExtrema returns 0.

        :type C1: OCC.wrapper.Geom.Handle_Geom_Curve
        :type C2: OCC.wrapper.Geom.Handle_Geom_Curve
        :type U1min: float
        :type U1max: float
        :type U2min: float
        :type U2max: float

        """
        this = _GeomAPI.new_GeomAPI_ExtremaCurveCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(GeomAPI_ExtremaCurveCurve self, Handle_Geom_Curve C1, Handle_Geom_Curve C2)
        Init(GeomAPI_ExtremaCurveCurve self, Handle_Geom_Curve C1, Handle_Geom_Curve C2, Standard_Real const U1min, Standard_Real const U1max, Standard_Real const U2min, Standard_Real const U2max)

        Initializes this algorithm with the given arguments
        and computes the extrema between :
        -   the portion of the curve C1 limited by the two
        points of parameter (U1min,U1max), and
        -   the portion of the curve C2 limited by the two
        points of parameter (U2min,U2max).
        Warning
        Use the function NbExtrema to obtain the number
        of solutions. If this algorithm fails, NbExtrema returns 0.

        :type C1: OCC.wrapper.Geom.Handle_Geom_Curve
        :type C2: OCC.wrapper.Geom.Handle_Geom_Curve
        :type U1min: float
        :type U1max: float
        :type U2min: float
        :type U2max: float

        """
        return _GeomAPI.GeomAPI_ExtremaCurveCurve_Init(self, *args)


    def NbExtrema(self, *args):
        """
        NbExtrema(GeomAPI_ExtremaCurveCurve self) -> Standard_Integer

        Returns the number of extrema computed by this algorithm.
        Note: if this algorithm fails, NbExtrema returns 0.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomAPI.GeomAPI_ExtremaCurveCurve_NbExtrema(self, *args)


    def Points(self, *args):
        """
        Points(GeomAPI_ExtremaCurveCurve self, Standard_Integer const Index, gp_Pnt P1, gp_Pnt P2)

        Returns the points P1 on the first curve and P2 on
        the second curve, which are the ends of the
        extremum of index Index computed by this algorithm.
        Exceptions
        Standard_OutOfRange if Index is not in the range [
        1,NbExtrema ], where NbExtrema is the
        number of extrema computed by this algorithm.

        :type Index: int
        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomAPI.GeomAPI_ExtremaCurveCurve_Points(self, *args)


    def Parameters(self, *args):
        """
        Parameters(GeomAPI_ExtremaCurveCurve self, Standard_Integer const Index)

        Returns the parameters U1 of the point on the first
        curve and U2 of the point on the second curve, which
        are the ends of the extremum of index Index computed by this algorithm.
        Exceptions
        Standard_OutOfRange if Index is not in the range [
        1,NbExtrema ], where NbExtrema is the
        number of extrema computed by this algorithm.

        :type Index: int
        :type U1: float
        :type U2: float

        """
        return _GeomAPI.GeomAPI_ExtremaCurveCurve_Parameters(self, *args)


    def Distance(self, *args):
        """
        Distance(GeomAPI_ExtremaCurveCurve self, Standard_Integer const Index) -> Standard_Real

        Computes the distance between the end points of the
        extremum of index Index computed by this algorithm.
        Exceptions
        Standard_OutOfRange if Index is not in the range [
        1,NbExtrema ], where NbExtrema is the
        number of extrema computed by this algorithm.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomAPI.GeomAPI_ExtremaCurveCurve_Distance(self, *args)


    def NearestPoints(self, *args):
        """
        NearestPoints(GeomAPI_ExtremaCurveCurve self, gp_Pnt P1, gp_Pnt P2)

        Returns the points P1 on the first curve and P2 on
        the second curve, which are the ends of the shortest
        extremum computed by this algorithm.
        Exceptions StdFail_NotDone if this algorithm fails.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt

        """
        return _GeomAPI.GeomAPI_ExtremaCurveCurve_NearestPoints(self, *args)


    def LowerDistanceParameters(self, *args):
        """
        LowerDistanceParameters(GeomAPI_ExtremaCurveCurve self)

        Returns the parameters U1 of the point on the first
        curve and U2 of the point on the second curve, which
        are the ends of the shortest extremum computed by this algorithm.
        Exceptions StdFail_NotDone if this algorithm fails.

        :type U1: float
        :type U2: float

        """
        return _GeomAPI.GeomAPI_ExtremaCurveCurve_LowerDistanceParameters(self, *args)


    def LowerDistance(self, *args):
        """
        LowerDistance(GeomAPI_ExtremaCurveCurve self) -> Standard_Real

        Computes the distance between the end points of the
        shortest extremum computed by this algorithm.
        Exceptions StdFail_NotDone if this algorithm fails.

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomAPI.GeomAPI_ExtremaCurveCurve_LowerDistance(self, *args)


    def Extrema(self, *args):
        """
        return the algorithmic object from Extrema

        :rtype: OCC.wrapper.Extrema.Extrema_ExtCC

        """
        res = _GeomAPI.GeomAPI_ExtremaCurveCurve_Extrema(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TotalNearestPoints(self, *args):
        """
        TotalNearestPoints(GeomAPI_ExtremaCurveCurve self, gp_Pnt P1, gp_Pnt P2) -> Standard_Boolean

        set  in  <P1>  and <P2> the couple solution points
        such a the distance [P1,P2] is the minimum. taking  in  account
        extremity  points  of  curves.

        :type P1: OCC.wrapper.gp.gp_Pnt
        :type P2: OCC.wrapper.gp.gp_Pnt
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomAPI.GeomAPI_ExtremaCurveCurve_TotalNearestPoints(self, *args)


    def TotalLowerDistanceParameters(self, *args):
        """
        TotalLowerDistanceParameters(GeomAPI_ExtremaCurveCurve self) -> Standard_Boolean

        set  in <U1> and <U2> the parameters of the couple
        solution   points  which  represents  the  total  nearest
        solution.

        :type U1: float
        :type U2: float
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomAPI.GeomAPI_ExtremaCurveCurve_TotalLowerDistanceParameters(self, *args)


    def TotalLowerDistance(self, *args):
        """
        TotalLowerDistance(GeomAPI_ExtremaCurveCurve self) -> Standard_Real

        return the distance of the total  nearest couple solution
        point.
        if <myExtCC> is not done

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomAPI.GeomAPI_ExtremaCurveCurve_TotalLowerDistance(self, *args)

    __swig_destroy__ = _GeomAPI.delete_GeomAPI_ExtremaCurveCurve
GeomAPI_ExtremaCurveCurve_swigregister = _GeomAPI.GeomAPI_ExtremaCurveCurve_swigregister
GeomAPI_ExtremaCurveCurve_swigregister(GeomAPI_ExtremaCurveCurve)




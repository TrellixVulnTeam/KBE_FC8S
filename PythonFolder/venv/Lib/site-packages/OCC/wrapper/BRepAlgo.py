# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_BRepAlgo')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_BRepAlgo')
    _BRepAlgo = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_BRepAlgo', [dirname(__file__)])
        except ImportError:
            import _BRepAlgo
            return _BRepAlgo
        try:
            _mod = imp.load_module('_BRepAlgo', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _BRepAlgo = swig_import_helper()
    del swig_import_helper
else:
    import _BRepAlgo
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _BRepAlgo.delete_SwigPyIterator

    def value(self):
        return _BRepAlgo.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _BRepAlgo.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _BRepAlgo.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _BRepAlgo.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _BRepAlgo.SwigPyIterator_equal(self, x)

    def copy(self):
        return _BRepAlgo.SwigPyIterator_copy(self)

    def next(self):
        return _BRepAlgo.SwigPyIterator_next(self)

    def __next__(self):
        return _BRepAlgo.SwigPyIterator___next__(self)

    def previous(self):
        return _BRepAlgo.SwigPyIterator_previous(self)

    def advance(self, n):
        return _BRepAlgo.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _BRepAlgo.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _BRepAlgo.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _BRepAlgo.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _BRepAlgo.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _BRepAlgo.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _BRepAlgo.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _BRepAlgo.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepAlgo.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_BRepAlgo.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepAlgo.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepAlgo.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepAlgo.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _BRepAlgo.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _BRepAlgo.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _BRepAlgo.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _BRepAlgo.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_BRepAlgo.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _BRepAlgo.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _BRepAlgo.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepAlgo.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _BRepAlgo.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _BRepAlgo.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _BRepAlgo.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _BRepAlgo.ptr_to_number(item)
ptr_to_number = _BRepAlgo.ptr_to_number

def HashCode(*args):
    return _BRepAlgo.HashCode(*args)
HashCode = _BRepAlgo.HashCode

def ptr_equal(a, b):
    return _BRepAlgo.ptr_equal(a, b)
ptr_equal = _BRepAlgo.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopOpeBRepDS
else:
    import TopOpeBRepDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopTools
else:
    import TopTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Message
else:
    import Message
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopLoc
else:
    import TopLoc
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopoDS
else:
    import TopoDS
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Bnd
else:
    import Bnd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopOpeBRepTool
else:
    import TopOpeBRepTool
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopExp
else:
    import TopExp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepClass3d
else:
    import BRepClass3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurveSurface
else:
    import IntCurveSurface
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Intf
else:
    import Intf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntAna
else:
    import IntAna
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntSurf
else:
    import IntSurf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntCurvesFace
else:
    import IntCurvesFace
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepAdaptor
else:
    import BRepAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2dAdaptor
else:
    import Geom2dAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAdaptor
else:
    import GeomAdaptor
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepBuilderAPI
else:
    import BRepBuilderAPI
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRepTools
else:
    import BRepTools
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Poly
else:
    import Poly
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TShort
else:
    import TShort
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import BRep
else:
    import BRep
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopOpeBRepBuild
else:
    import TopOpeBRepBuild
del _swig_python_version_info
BRepAlgo_OK = _BRepAlgo.BRepAlgo_OK
BRepAlgo_NOK = _BRepAlgo.BRepAlgo_NOK
class BRepAlgo_EdgeConnector(Standard.Standard_Transient):
    """
    Used by DSAccess to reconstruct an EdgeSet of connected edges. The result produced by
    MakeBlock is a list of non-standard TopoDS_wire,
    which  can present connexions of edge  of  order > 2
    in certain  vertex. The method  IsWire
    indicates standard/non-standard character of  all wire produced.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepAlgo_EdgeConnector
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepAlgo_EdgeConnector(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRepAlgo_EdgeConnector self) -> BRepAlgo_EdgeConnector

        Used by DSAccess to reconstruct an EdgeSet of connected edges. The result produced by
        MakeBlock is a list of non-standard TopoDS_wire,
        which  can present connexions of edge  of  order > 2
        in certain  vertex. The method  IsWire
        indicates standard/non-standard character of  all wire produced.
        """
        this = _BRepAlgo.new_BRepAlgo_EdgeConnector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Add(self, *args):
        """
        Add(BRepAlgo_EdgeConnector self, TopoDS_Edge e)
        Add(BRepAlgo_EdgeConnector self, NCollection_List_TopoDS_Shape LOEdge)

        :type LOEdge: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepAlgo.BRepAlgo_EdgeConnector_Add(self, *args)


    def AddStart(self, *args):
        """
        AddStart(BRepAlgo_EdgeConnector self, TopoDS_Shape e)
        AddStart(BRepAlgo_EdgeConnector self, NCollection_List_TopoDS_Shape LOEdge)

        :type LOEdge: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepAlgo.BRepAlgo_EdgeConnector_AddStart(self, *args)


    def ClearStartElement(self, *args):
        """ClearStartElement(BRepAlgo_EdgeConnector self)"""
        return _BRepAlgo.BRepAlgo_EdgeConnector_ClearStartElement(self, *args)


    def MakeBlock(self, *args):
        """
        MakeBlock(BRepAlgo_EdgeConnector self) -> NCollection_List_TopoDS_Shape

        returns a list of wire non standard

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepAlgo.BRepAlgo_EdgeConnector_MakeBlock(self, *args)


    def Done(self, *args):
        """Done(BRepAlgo_EdgeConnector self)"""
        return _BRepAlgo.BRepAlgo_EdgeConnector_Done(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepAlgo_EdgeConnector self) -> Standard_Boolean

        NYI
        returns true if proceeded  to MakeBlock()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.BRepAlgo_EdgeConnector_IsDone(self, *args)


    def IsWire(self, *args):
        """
        IsWire(BRepAlgo_EdgeConnector self, TopoDS_Shape W) -> Standard_Boolean

        NYI
        returns true if W is  a Wire standard.
        W must belong  to the list returned  by MakeBlock.

        :type W: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.BRepAlgo_EdgeConnector_IsWire(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepAlgo.BRepAlgo_EdgeConnector_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepAlgo.BRepAlgo_EdgeConnector_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepAlgo.BRepAlgo_EdgeConnector_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_EdgeConnector
BRepAlgo_EdgeConnector_swigregister = _BRepAlgo.BRepAlgo_EdgeConnector_swigregister
BRepAlgo_EdgeConnector_swigregister(BRepAlgo_EdgeConnector)

def BRepAlgo_EdgeConnector_get_type_name(*args):
    """
    BRepAlgo_EdgeConnector_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepAlgo.BRepAlgo_EdgeConnector_get_type_name(*args)

def BRepAlgo_EdgeConnector_get_type_descriptor(*args):
    """
    BRepAlgo_EdgeConnector_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepAlgo.BRepAlgo_EdgeConnector_get_type_descriptor(*args)

class BRepAlgo_BooleanOperation(BRepBuilderAPI.BRepBuilderAPI_MakeShape):
    """
    The abstract class BooleanOperation is the root
    class of Boolean operations.
    A BooleanOperation object stores the two shapes in
    preparation for the Boolean operation specified in
    one of the classes inheriting from this one. These include:
    - Common
    - Cut
    - Fuse
    - Section.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def PerformDS(self, *args):
        """PerformDS(BRepAlgo_BooleanOperation self)"""
        return _BRepAlgo.BRepAlgo_BooleanOperation_PerformDS(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepAlgo_BooleanOperation self, TopAbs_State const St1, TopAbs_State const St2)

        :type St1: OCC.wrapper.TopAbs.TopAbs_State
        :type St2: OCC.wrapper.TopAbs.TopAbs_State

        """
        return _BRepAlgo.BRepAlgo_BooleanOperation_Perform(self, *args)


    def Builder(self, *args):
        """
        Builder(BRepAlgo_BooleanOperation self) -> Handle_TopOpeBRepBuild_HBuilder

        :rtype: OCC.wrapper.TopOpeBRepBuild.Handle_TopOpeBRepBuild_HBuilder

        """
        return _BRepAlgo.BRepAlgo_BooleanOperation_Builder(self, *args)


    def Shape1(self, *args):
        """
        Returns the first shape involved in this Boolean operation.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepAlgo.BRepAlgo_BooleanOperation_Shape1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Shape2(self, *args):
        """
        Returns the second shape involved in this Boolean operation.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepAlgo.BRepAlgo_BooleanOperation_Shape2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Modified(self, *args):
        """
        Returns the list  of shapes modified from the shape
        <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepAlgo.BRepAlgo_BooleanOperation_Modified(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDeleted(self, *args):
        """
        IsDeleted(BRepAlgo_BooleanOperation self, TopoDS_Shape S) -> Standard_Boolean

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.BRepAlgo_BooleanOperation_IsDeleted(self, *args)

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_BooleanOperation
BRepAlgo_BooleanOperation_swigregister = _BRepAlgo.BRepAlgo_BooleanOperation_swigregister
BRepAlgo_BooleanOperation_swigregister(BRepAlgo_BooleanOperation)

class NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,Standard_Boolean,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,Standard_Boolean,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,Standard_Boolean,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,Standard_Boolean,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _BRepAlgo.new_NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, bool const & theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, bool const & theItem) -> bool *

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> bool const *

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> bool *

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> bool &

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _BRepAlgo.delete_NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher_swigregister = _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BRepAlgo.new_NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepAlgo.delete_NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher_IteratorHelper)


try:
	BRepAlgo_DataMapOfShapeBoolean = NCollection_DataMap_TopoDS_Shape_Standard_Boolean_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class BRepAlgo_AsDes(Standard.Standard_Transient):
    """SD to store descendants and ascendants of Shapes."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_BRepAlgo_AsDes
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_BRepAlgo_AsDes(self) 
            return h


    def __init__(self, *args):
        """
        __init__(BRepAlgo_AsDes self) -> BRepAlgo_AsDes

        Creates an empty AsDes.


        """
        this = _BRepAlgo.new_BRepAlgo_AsDes(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Clear(self, *args):
        """Clear(BRepAlgo_AsDes self)"""
        return _BRepAlgo.BRepAlgo_AsDes_Clear(self, *args)


    def Add(self, *args):
        """
        Add(BRepAlgo_AsDes self, TopoDS_Shape S, TopoDS_Shape SS)
        Add(BRepAlgo_AsDes self, TopoDS_Shape S, NCollection_List_TopoDS_Shape SS)

        Stores <SS> as futurs SubShapes of <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type SS: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepAlgo.BRepAlgo_AsDes_Add(self, *args)


    def HasAscendant(self, *args):
        """
        HasAscendant(BRepAlgo_AsDes self, TopoDS_Shape S) -> Standard_Boolean

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.BRepAlgo_AsDes_HasAscendant(self, *args)


    def HasDescendant(self, *args):
        """
        HasDescendant(BRepAlgo_AsDes self, TopoDS_Shape S) -> Standard_Boolean

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.BRepAlgo_AsDes_HasDescendant(self, *args)


    def Ascendant(self, *args):
        """
        Returns the Shape containing <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepAlgo.BRepAlgo_AsDes_Ascendant(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Descendant(self, *args):
        """
        Returns futur subhapes of <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepAlgo.BRepAlgo_AsDes_Descendant(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeDescendant(self, *args):
        """
        ChangeDescendant(BRepAlgo_AsDes self, TopoDS_Shape S) -> NCollection_List_TopoDS_Shape

        Returns futur subhapes of <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepAlgo.BRepAlgo_AsDes_ChangeDescendant(self, *args)


    def Replace(self, *args):
        """
        Replace(BRepAlgo_AsDes self, TopoDS_Shape OldS, TopoDS_Shape NewS)

        Replace <OldS> by <NewS>.
        <OldS> disapear from <me>.

        :type OldS: OCC.wrapper.TopoDS.TopoDS_Shape
        :type NewS: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_AsDes_Replace(self, *args)


    def Remove(self, *args):
        """
        Remove(BRepAlgo_AsDes self, TopoDS_Shape S)

        Remove <S> from me.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_AsDes_Remove(self, *args)


    def HasCommonDescendant(self, *args):
        """
        HasCommonDescendant(BRepAlgo_AsDes self, TopoDS_Shape S1, TopoDS_Shape S2, NCollection_List_TopoDS_Shape LC) -> Standard_Boolean

        Returns  True if (S1> and <S2>  has  common
        Descendants.  Stores in <LC> the Commons Descendants.

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type LC: OCC.wrapper.TopTools.TopTools_ListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.BRepAlgo_AsDes_HasCommonDescendant(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _BRepAlgo.BRepAlgo_AsDes_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _BRepAlgo.BRepAlgo_AsDes_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepAlgo.BRepAlgo_AsDes_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_AsDes
BRepAlgo_AsDes_swigregister = _BRepAlgo.BRepAlgo_AsDes_swigregister
BRepAlgo_AsDes_swigregister(BRepAlgo_AsDes)

def BRepAlgo_AsDes_get_type_name(*args):
    """
    BRepAlgo_AsDes_get_type_name() -> char const *

    :rtype: const char *

    """
    return _BRepAlgo.BRepAlgo_AsDes_get_type_name(*args)

def BRepAlgo_AsDes_get_type_descriptor(*args):
    """
    BRepAlgo_AsDes_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _BRepAlgo.BRepAlgo_AsDes_get_type_descriptor(*args)

class BRepAlgo_NormalProjection(object):
    """
    This class makes the projection  of a wire on a
    shape.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepAlgo_NormalProjection self) -> BRepAlgo_NormalProjection
        __init__(BRepAlgo_NormalProjection self, TopoDS_Shape S) -> BRepAlgo_NormalProjection

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _BRepAlgo.new_BRepAlgo_NormalProjection(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepAlgo_NormalProjection self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_NormalProjection_Init(self, *args)


    def Add(self, *args):
        """
        Add(BRepAlgo_NormalProjection self, TopoDS_Shape ToProj)

        Add an edge or a wire to the list of shape to project

        :type ToProj: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_NormalProjection_Add(self, *args)


    def SetParams(self, *args):
        """
        SetParams(BRepAlgo_NormalProjection self, Standard_Real const Tol3D, Standard_Real const Tol2D, GeomAbs_Shape const InternalContinuity, Standard_Integer const MaxDegree, Standard_Integer const MaxSeg)

        Set the parameters  used  for computation
        Tol3d is the requiered  tolerance between the  3d projected
        curve  and its 2d representation
        InternalContinuity  is the order of constraints
        used for  approximation.
        MaxDeg and MaxSeg are the maximum degree and the maximum
        number of segment for BSpline resulting of an approximation.

        :type Tol3D: float
        :type Tol2D: float
        :type InternalContinuity: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type MaxDegree: int
        :type MaxSeg: int

        """
        return _BRepAlgo.BRepAlgo_NormalProjection_SetParams(self, *args)


    def SetDefaultParams(self, *args):
        """
        SetDefaultParams(BRepAlgo_NormalProjection self)

        Set the parameters  used  for computation
        in their default values


        """
        return _BRepAlgo.BRepAlgo_NormalProjection_SetDefaultParams(self, *args)


    def SetMaxDistance(self, *args):
        """
        SetMaxDistance(BRepAlgo_NormalProjection self, Standard_Real const MaxDist)

        Sets the maximum distance between target shape and
        shape to project. If this condition is not satisfied then
        corresponding part of solution is discarded.
        if MaxDist < 0 then this method does not affect the algorithm

        :type MaxDist: float

        """
        return _BRepAlgo.BRepAlgo_NormalProjection_SetMaxDistance(self, *args)


    def Compute3d(self, *args):
        """
        Compute3d(BRepAlgo_NormalProjection self, Standard_Boolean const With3d)

        if  With3d = Standard_False the 3dcurve is not computed
        the  initial 3dcurve is kept  to  build the  resulting edges.

        :type With3d: bool

        """
        return _BRepAlgo.BRepAlgo_NormalProjection_Compute3d(self, *args)


    def SetLimit(self, *args):
        """
        SetLimit(BRepAlgo_NormalProjection self, Standard_Boolean const FaceBoundaries)

        Manage  limitation  of  projected  edges.

        :type FaceBoundaries: bool

        """
        return _BRepAlgo.BRepAlgo_NormalProjection_SetLimit(self, *args)


    def Build(self, *args):
        """
        Build(BRepAlgo_NormalProjection self)

        Builds the result as a  compound.


        """
        return _BRepAlgo.BRepAlgo_NormalProjection_Build(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepAlgo_NormalProjection self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.BRepAlgo_NormalProjection_IsDone(self, *args)


    def Projection(self, *args):
        """
        returns the result

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepAlgo.BRepAlgo_NormalProjection_Projection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Ancestor(self, *args):
        """
        For a resulting edge, returns the corresponding initial edge.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepAlgo.BRepAlgo_NormalProjection_Ancestor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Couple(self, *args):
        """
        For a projected edge, returns the corresponding initial face.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepAlgo.BRepAlgo_NormalProjection_Couple(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Generated(self, *args):
        """
        Returns the  list   of shapes generated   from the
        shape <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepAlgo.BRepAlgo_NormalProjection_Generated(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsElementary(self, *args):
        """
        IsElementary(BRepAlgo_NormalProjection self, Adaptor3d_Curve C) -> Standard_Boolean

        :type C: OCC.wrapper.Adaptor3d.Adaptor3d_Curve
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.BRepAlgo_NormalProjection_IsElementary(self, *args)


    def BuildWire(self, *args):
        """
        BuildWire(BRepAlgo_NormalProjection self, NCollection_List_TopoDS_Shape Liste) -> Standard_Boolean

        build the result as a list of wire if possible in --
        a first returns a wire only if there is only a wire.

        :type Liste: OCC.wrapper.TopTools.TopTools_ListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.BRepAlgo_NormalProjection_BuildWire(self, *args)

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_NormalProjection
BRepAlgo_NormalProjection_swigregister = _BRepAlgo.BRepAlgo_NormalProjection_swigregister
BRepAlgo_NormalProjection_swigregister(BRepAlgo_NormalProjection)

class BRepAlgo_Common(BRepAlgo_BooleanOperation):
    """
    Describes functions for performing a topological
    common operation (Boolean intersection).
    A Common object provides the framework for:
    - defining the construction of a common shape,
    - implementing the construction algorithm, and
    - consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepAlgo_Common self, TopoDS_Shape S1, TopoDS_Shape S2) -> BRepAlgo_Common

        Constructs the common part of shapes S1 and S2.

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _BRepAlgo.new_BRepAlgo_Common(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_Common
BRepAlgo_Common_swigregister = _BRepAlgo.BRepAlgo_Common_swigregister
BRepAlgo_Common_swigregister(BRepAlgo_Common)

class BRepAlgo_FaceRestrictor(object):
    """
    Builds all  the faces  limited  with a set of non
    jointing   and     planars     wires.    if
    <ControlOrientation> is false  The Wires must have
    correct orientations.  Sinon orientation des wires
    de telle sorte que les faces ne soient pas infinies
    et qu'elles soient disjointes.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepAlgo_FaceRestrictor self) -> BRepAlgo_FaceRestrictor

        Builds all  the faces  limited  with a set of non
        jointing   and     planars     wires.    if
        <ControlOrientation> is false  The Wires must have
        correct orientations.  Sinon orientation des wires
        de telle sorte que les faces ne soient pas infinies
        et qu'elles soient disjointes.
        """
        this = _BRepAlgo.new_BRepAlgo_FaceRestrictor(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepAlgo_FaceRestrictor self, TopoDS_Face F, Standard_Boolean const Proj, Standard_Boolean const ControlOrientation)

        the surface of <F> will be the the surface of each new
        faces built.
        <Proj> is used to update pcurves on edges if necessary.
        See Add().

        :type F: OCC.wrapper.TopoDS.TopoDS_Face
        :type Proj: bool
        :type ControlOrientation: bool

        """
        return _BRepAlgo.BRepAlgo_FaceRestrictor_Init(self, *args)


    def Add(self, *args):
        """
        Add(BRepAlgo_FaceRestrictor self, TopoDS_Wire W)

        Add the wire <W> to the set of wires.

        Warning:
        The Wires must be closed.

        The edges of <W> can be modified if they  have not pcurves
        on the surface <S>  of <F>. In this  case
        if <Proj> is false the first pcurve of  the edge
        is positionned on <S>.
        if <Proj> is True ,the Pcurve On <S> is the
        projection of the  curve 3d on <F>.

        :type W: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _BRepAlgo.BRepAlgo_FaceRestrictor_Add(self, *args)


    def Clear(self, *args):
        """
        Clear(BRepAlgo_FaceRestrictor self)

        Removes all the Wires


        """
        return _BRepAlgo.BRepAlgo_FaceRestrictor_Clear(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepAlgo_FaceRestrictor self)

        Evaluate all the faces limited by the set of Wires.


        """
        return _BRepAlgo.BRepAlgo_FaceRestrictor_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(BRepAlgo_FaceRestrictor self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.BRepAlgo_FaceRestrictor_IsDone(self, *args)


    def More(self, *args):
        """
        More(BRepAlgo_FaceRestrictor self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.BRepAlgo_FaceRestrictor_More(self, *args)


    def Next(self, *args):
        """Next(BRepAlgo_FaceRestrictor self)"""
        return _BRepAlgo.BRepAlgo_FaceRestrictor_Next(self, *args)


    def Current(self, *args):
        """
        Current(BRepAlgo_FaceRestrictor self) -> TopoDS_Face

        :rtype: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepAlgo.BRepAlgo_FaceRestrictor_Current(self, *args)

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_FaceRestrictor
BRepAlgo_FaceRestrictor_swigregister = _BRepAlgo.BRepAlgo_FaceRestrictor_swigregister
BRepAlgo_FaceRestrictor_swigregister(BRepAlgo_FaceRestrictor)

class BRepAlgo_Cut(BRepAlgo_BooleanOperation):
    """
    Describes functions for performing a topological cut
    operation (Boolean subtraction).
    A Cut object provides the framework for:
    - defining the construction of a cut shape,
    - implementing the construction algorithm, and
    - consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepAlgo_Cut self, TopoDS_Shape S1, TopoDS_Shape S2) -> BRepAlgo_Cut

        Cuts the shape S2 from the shape S1.

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _BRepAlgo.new_BRepAlgo_Cut(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_Cut
BRepAlgo_Cut_swigregister = _BRepAlgo.BRepAlgo_Cut_swigregister
BRepAlgo_Cut_swigregister(BRepAlgo_Cut)

class BRepAlgo_(object):
    """
    The BRepAlgo package provides a full range of
    services to perform Old Boolean Operations in Open CASCADE.
    Attention:
    The New Boolean Operation has replaced the Old
    Boolean Operations algorithm in the BrepAlgoAPI
    package in Open CASCADE.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def ConcatenateWire(*args):
        """
        ConcatenateWire(TopoDS_Wire Wire, GeomAbs_Shape const Option, Standard_Real const AngularTolerance=1.0e-4) -> TopoDS_Wire

        this method makes a wire whose edges are C1 from
        a Wire whose edges could be G1. It removes a vertex
        between G1 edges.
        Option can be G1 or C1.

        :type Wire: OCC.wrapper.TopoDS.TopoDS_Wire
        :type Option: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type AngularTolerance: float
        :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

        """
        return _BRepAlgo.BRepAlgo__ConcatenateWire(*args)

    ConcatenateWire = staticmethod(ConcatenateWire)

    def ConcatenateWireC0(*args):
        """
        ConcatenateWireC0(TopoDS_Wire Wire) -> TopoDS_Edge

        this method makes an edge from a wire.
        Junction points between edges of wire may be sharp,
        resulting curve of the resulting edge may be C0.

        :type Wire: OCC.wrapper.TopoDS.TopoDS_Wire
        :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _BRepAlgo.BRepAlgo__ConcatenateWireC0(*args)

    ConcatenateWireC0 = staticmethod(ConcatenateWireC0)

    def IsValid(*args):
        """
        IsValid(TopoDS_Shape S) -> Standard_Boolean
        IsValid(NCollection_List_TopoDS_Shape theArgs, TopoDS_Shape theResult, Standard_Boolean const closedSolid, Standard_Boolean const GeomCtrl) -> Standard_Boolean

        Checks if  the  Generated and Modified Faces  from
        the shapes <arguments> in  the shape <result>  are
        "correct". The args   may be empty, then all faces
        will be checked.
        If <Closed> is True,  only  closed shape are valid.
        If <GeomCtrl>  is    False the geometry  of   new
        vertices and edges   are   not verified and  the
        auto-intersection of new wires are not searched.

        :type theArgs: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type theResult: OCC.wrapper.TopoDS.TopoDS_Shape
        :type closedSolid: bool
        :type GeomCtrl: bool
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.BRepAlgo__IsValid(*args)

    IsValid = staticmethod(IsValid)

    def IsTopologicallyValid(*args):
        """
        IsTopologicallyValid(TopoDS_Shape S) -> Standard_Boolean

        Checks if the shape is  "correct". If not, returns
        <Standard_False>,  else   returns <Standard_True>.
        This method differs from  the previous one in  the
        fact that no   geometric contols (intersection  of
        wires, pcurve validity) are performed.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.BRepAlgo__IsTopologicallyValid(*args)

    IsTopologicallyValid = staticmethod(IsTopologicallyValid)

    def __init__(self):
        """
        The BRepAlgo package provides a full range of
        services to perform Old Boolean Operations in Open CASCADE.
        Attention:
        The New Boolean Operation has replaced the Old
        Boolean Operations algorithm in the BrepAlgoAPI
        package in Open CASCADE.
        """
        this = _BRepAlgo.new_BRepAlgo_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_
BRepAlgo__swigregister = _BRepAlgo.BRepAlgo__swigregister
BRepAlgo__swigregister(BRepAlgo_)

def BRepAlgo__ConcatenateWire(*args):
    """
    BRepAlgo__ConcatenateWire(TopoDS_Wire Wire, GeomAbs_Shape const Option, Standard_Real const AngularTolerance=1.0e-4) -> TopoDS_Wire

    this method makes a wire whose edges are C1 from
    a Wire whose edges could be G1. It removes a vertex
    between G1 edges.
    Option can be G1 or C1.

    :type Wire: OCC.wrapper.TopoDS.TopoDS_Wire
    :type Option: OCC.wrapper.GeomAbs.GeomAbs_Shape
    :type AngularTolerance: float
    :rtype: OCC.wrapper.TopoDS.TopoDS_Wire

    """
    return _BRepAlgo.BRepAlgo__ConcatenateWire(*args)

def BRepAlgo__ConcatenateWireC0(*args):
    """
    BRepAlgo__ConcatenateWireC0(TopoDS_Wire Wire) -> TopoDS_Edge

    this method makes an edge from a wire.
    Junction points between edges of wire may be sharp,
    resulting curve of the resulting edge may be C0.

    :type Wire: OCC.wrapper.TopoDS.TopoDS_Wire
    :rtype: OCC.wrapper.TopoDS.TopoDS_Edge

    """
    return _BRepAlgo.BRepAlgo__ConcatenateWireC0(*args)

def BRepAlgo__IsValid(*args):
    """
    IsValid(TopoDS_Shape S) -> Standard_Boolean
    BRepAlgo__IsValid(NCollection_List_TopoDS_Shape theArgs, TopoDS_Shape theResult, Standard_Boolean const closedSolid, Standard_Boolean const GeomCtrl) -> Standard_Boolean

    Checks if  the  Generated and Modified Faces  from
    the shapes <arguments> in  the shape <result>  are
    "correct". The args   may be empty, then all faces
    will be checked.
    If <Closed> is True,  only  closed shape are valid.
    If <GeomCtrl>  is    False the geometry  of   new
    vertices and edges   are   not verified and  the
    auto-intersection of new wires are not searched.

    :type theArgs: OCC.wrapper.TopTools.TopTools_ListOfShape
    :type theResult: OCC.wrapper.TopoDS.TopoDS_Shape
    :type closedSolid: bool
    :type GeomCtrl: bool
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepAlgo.BRepAlgo__IsValid(*args)

def BRepAlgo__IsTopologicallyValid(*args):
    """
    BRepAlgo__IsTopologicallyValid(TopoDS_Shape S) -> Standard_Boolean

    Checks if the shape is  "correct". If not, returns
    <Standard_False>,  else   returns <Standard_True>.
    This method differs from  the previous one in  the
    fact that no   geometric contols (intersection  of
    wires, pcurve validity) are performed.

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _BRepAlgo.BRepAlgo__IsTopologicallyValid(*args)

class BRepAlgo_Fuse(BRepAlgo_BooleanOperation):
    """
    Describes functions for performing a topological
    fusion operation (Boolean union).
    A Fuse object provides the framework for:
    - defining the construction of a fused shape,
    - implementing the construction algorithm, and
    - consulting the result.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepAlgo_Fuse self, TopoDS_Shape S1, TopoDS_Shape S2) -> BRepAlgo_Fuse

        Fuse S1 and S2.

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        this = _BRepAlgo.new_BRepAlgo_Fuse(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_Fuse
BRepAlgo_Fuse_swigregister = _BRepAlgo.BRepAlgo_Fuse_swigregister
BRepAlgo_Fuse_swigregister(BRepAlgo_Fuse)

class NCollection_Sequence_TColStd_SequenceOfInteger(NCollection.NCollection_BaseSequence):
    """
    Purpose:     Definition of a sequence of elements indexed by
    an Integer in range of 1..n
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_Sequence_TColStd_SequenceOfInteger self) -> NCollection_Sequence< TColStd_SequenceOfInteger >::iterator

        Returns an iterator pointing to the first element in the sequence.

        :rtype: iterator

        """
        return _BRepAlgo.NCollection_Sequence_TColStd_SequenceOfInteger_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_Sequence_TColStd_SequenceOfInteger self) -> NCollection_Sequence< TColStd_SequenceOfInteger >::iterator

        Returns an iterator referring to the past-the-end element in the sequence.

        :rtype: iterator

        """
        return _BRepAlgo.NCollection_Sequence_TColStd_SequenceOfInteger_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_Sequence_TColStd_SequenceOfInteger self) -> NCollection_Sequence< TColStd_SequenceOfInteger >::const_iterator

        Returns a const iterator pointing to the first element in the sequence.

        :rtype: const_iterator

        """
        return _BRepAlgo.NCollection_Sequence_TColStd_SequenceOfInteger_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Sequence_TColStd_SequenceOfInteger self) -> NCollection_Sequence< TColStd_SequenceOfInteger >::const_iterator

        Returns a const iterator referring to the past-the-end element in the sequence.

        :rtype: const_iterator

        """
        return _BRepAlgo.NCollection_Sequence_TColStd_SequenceOfInteger_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Definition of a sequence of elements indexed by
        an Integer in range of 1..n
        """
        this = _BRepAlgo.new_NCollection_Sequence_TColStd_SequenceOfInteger(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Size(self, *args):
        """
        Size(NCollection_Sequence_TColStd_SequenceOfInteger self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepAlgo.NCollection_Sequence_TColStd_SequenceOfInteger_Size(self, *args)


    def Length(self, *args):
        """
        Length(NCollection_Sequence_TColStd_SequenceOfInteger self) -> Standard_Integer

        Number of items

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepAlgo.NCollection_Sequence_TColStd_SequenceOfInteger_Length(self, *args)


    def Lower(self, *args):
        """
        Lower(NCollection_Sequence_TColStd_SequenceOfInteger self) -> Standard_Integer

        Method for consistency with other collections.
        @return Lower bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepAlgo.NCollection_Sequence_TColStd_SequenceOfInteger_Lower(self, *args)


    def Upper(self, *args):
        """
        Upper(NCollection_Sequence_TColStd_SequenceOfInteger self) -> Standard_Integer

        Method for consistency with other collections.
        @return Upper bound (inclusive) for iteration.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepAlgo.NCollection_Sequence_TColStd_SequenceOfInteger_Upper(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(NCollection_Sequence_TColStd_SequenceOfInteger self) -> Standard_Boolean

        Empty query

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.NCollection_Sequence_TColStd_SequenceOfInteger_IsEmpty(self, *args)


    def Reverse(self, *args):
        """
        Reverse(NCollection_Sequence_TColStd_SequenceOfInteger self)

        Reverse sequence


        """
        return _BRepAlgo.NCollection_Sequence_TColStd_SequenceOfInteger_Reverse(self, *args)


    def Exchange(self, *args):
        """
        Exchange(NCollection_Sequence_TColStd_SequenceOfInteger self, Standard_Integer const I, Standard_Integer const J)

        Exchange two members

        :type I: int
        :type J: int

        """
        return _BRepAlgo.NCollection_Sequence_TColStd_SequenceOfInteger_Exchange(self, *args)


    def delNode(*args):
        """
        delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

        Static deleter to be passed to BaseSequence

        :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
        :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepAlgo.NCollection_Sequence_TColStd_SequenceOfInteger_delNode(*args)

    delNode = staticmethod(delNode)

    def Clear(self, *args):
        """
        Clear(NCollection_Sequence_TColStd_SequenceOfInteger self, Handle_NCollection_BaseAllocator theAllocator=0)

        Clear the items out, take a new allocator if non null

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepAlgo.NCollection_Sequence_TColStd_SequenceOfInteger_Clear(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Sequence_TColStd_SequenceOfInteger self, NCollection_Sequence_TColStd_SequenceOfInteger theOther) -> NCollection_Sequence_TColStd_SequenceOfInteger

        Replace this sequence by the items of theOther.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepAlgo.NCollection_Sequence_TColStd_SequenceOfInteger_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Sequence_TColStd_SequenceOfInteger self, NCollection_Sequence_TColStd_SequenceOfInteger theOther) -> NCollection_Sequence_TColStd_SequenceOfInteger

        Replacement operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Sequence
        :rtype: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepAlgo.NCollection_Sequence_TColStd_SequenceOfInteger_assign(self, *args)


    def Remove(self, *args):
        """
        Remove(NCollection_Sequence_TColStd_SequenceOfInteger self, NCollection_Sequence< TColStd_SequenceOfInteger >::Iterator & thePosition)
        Remove(NCollection_Sequence_TColStd_SequenceOfInteger self, Standard_Integer const theIndex)
        Remove(NCollection_Sequence_TColStd_SequenceOfInteger self, Standard_Integer const theFromIndex, Standard_Integer const theToIndex)

        Remove range of items

        :type theFromIndex: int
        :type theToIndex: int

        """
        return _BRepAlgo.NCollection_Sequence_TColStd_SequenceOfInteger_Remove(self, *args)


    def Append(self, *args):
        """
        Append(NCollection_Sequence_TColStd_SequenceOfInteger self, NCollection_Sequence_Standard_Integer theItem)
        Append(NCollection_Sequence_TColStd_SequenceOfInteger self, NCollection_Sequence_TColStd_SequenceOfInteger theSeq)

        Append another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepAlgo.NCollection_Sequence_TColStd_SequenceOfInteger_Append(self, *args)


    def Prepend(self, *args):
        """
        Prepend(NCollection_Sequence_TColStd_SequenceOfInteger self, NCollection_Sequence_Standard_Integer theItem)
        Prepend(NCollection_Sequence_TColStd_SequenceOfInteger self, NCollection_Sequence_TColStd_SequenceOfInteger theSeq)

        Prepend another sequence (making it empty)

        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepAlgo.NCollection_Sequence_TColStd_SequenceOfInteger_Prepend(self, *args)


    def InsertBefore(self, *args):
        """
        InsertBefore(NCollection_Sequence_TColStd_SequenceOfInteger self, Standard_Integer const theIndex, NCollection_Sequence_Standard_Integer theItem)
        InsertBefore(NCollection_Sequence_TColStd_SequenceOfInteger self, Standard_Integer const theIndex, NCollection_Sequence_TColStd_SequenceOfInteger theSeq)

        InsertBefore theIndex another sequence

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepAlgo.NCollection_Sequence_TColStd_SequenceOfInteger_InsertBefore(self, *args)


    def InsertAfter(self, *args):
        """
        InsertAfter(NCollection_Sequence_TColStd_SequenceOfInteger self, NCollection_Sequence< TColStd_SequenceOfInteger >::Iterator & thePosition, NCollection_Sequence_Standard_Integer theItem)
        InsertAfter(NCollection_Sequence_TColStd_SequenceOfInteger self, Standard_Integer const theIndex, NCollection_Sequence_TColStd_SequenceOfInteger theSeq)
        InsertAfter(NCollection_Sequence_TColStd_SequenceOfInteger self, Standard_Integer const theIndex, NCollection_Sequence_Standard_Integer theItem)

        InsertAfter theIndex another sequence

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _BRepAlgo.NCollection_Sequence_TColStd_SequenceOfInteger_InsertAfter(self, *args)


    def Split(self, *args):
        """
        Split(NCollection_Sequence_TColStd_SequenceOfInteger self, Standard_Integer const theIndex, NCollection_Sequence_TColStd_SequenceOfInteger theSeq)

        Split in two sequences

        :type theIndex: int
        :type theSeq: OCC.wrapper.NCollection.NCollection_Sequence

        """
        return _BRepAlgo.NCollection_Sequence_TColStd_SequenceOfInteger_Split(self, *args)


    def First(self, *args):
        """
        First item access

        :rtype: const TheItemType &

        """
        res = _BRepAlgo.NCollection_Sequence_TColStd_SequenceOfInteger_First(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeFirst(self, *args):
        """
        ChangeFirst(NCollection_Sequence_TColStd_SequenceOfInteger self) -> NCollection_Sequence_Standard_Integer

        First item access

        :rtype: TheItemType &

        """
        return _BRepAlgo.NCollection_Sequence_TColStd_SequenceOfInteger_ChangeFirst(self, *args)


    def Last(self, *args):
        """
        Last item access

        :rtype: const TheItemType &

        """
        res = _BRepAlgo.NCollection_Sequence_TColStd_SequenceOfInteger_Last(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeLast(self, *args):
        """
        ChangeLast(NCollection_Sequence_TColStd_SequenceOfInteger self) -> NCollection_Sequence_Standard_Integer

        Last item access

        :rtype: TheItemType &

        """
        return _BRepAlgo.NCollection_Sequence_TColStd_SequenceOfInteger_ChangeLast(self, *args)


    def Value(self, *args):
        """
        Constant item access by theIndex

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BRepAlgo.NCollection_Sequence_TColStd_SequenceOfInteger_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeValue(self, *args):
        """
        ChangeValue(NCollection_Sequence_TColStd_SequenceOfInteger self, Standard_Integer const theIndex) -> NCollection_Sequence_Standard_Integer

        Variable item access by theIndex

        :type theIndex: int
        :rtype: TheItemType &

        """
        return _BRepAlgo.NCollection_Sequence_TColStd_SequenceOfInteger_ChangeValue(self, *args)


    def __call__(self, *args):
        """
        Constant operator()

        :type theIndex: int
        :rtype: const TheItemType &

        """
        res = _BRepAlgo.NCollection_Sequence_TColStd_SequenceOfInteger___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SetValue(self, *args):
        """
        SetValue(NCollection_Sequence_TColStd_SequenceOfInteger self, Standard_Integer const theIndex, NCollection_Sequence_Standard_Integer theItem)

        Set item value by theIndex

        :type theIndex: int
        :type theItem: const TheItemType &

        """
        return _BRepAlgo.NCollection_Sequence_TColStd_SequenceOfInteger_SetValue(self, *args)


    def __iter__(self):
        return _BRepAlgo.NCollection_Sequence_TColStd_SequenceOfInteger___iter__(self)
    __swig_destroy__ = _BRepAlgo.delete_NCollection_Sequence_TColStd_SequenceOfInteger
NCollection_Sequence_TColStd_SequenceOfInteger_swigregister = _BRepAlgo.NCollection_Sequence_TColStd_SequenceOfInteger_swigregister
NCollection_Sequence_TColStd_SequenceOfInteger_swigregister(NCollection_Sequence_TColStd_SequenceOfInteger)

def NCollection_Sequence_TColStd_SequenceOfInteger_delNode(*args):
    """
    NCollection_Sequence_TColStd_SequenceOfInteger_delNode(NCollection_SeqNode theNode, Handle_NCollection_BaseAllocator theAl)

    Static deleter to be passed to BaseSequence

    :type theNode: OCC.wrapper.NCollection.NCollection_SeqNode
    :type theAl: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

    """
    return _BRepAlgo.NCollection_Sequence_TColStd_SequenceOfInteger_delNode(*args)

class NCollection_Sequence_TColStd_SequenceOfInteger_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BRepAlgo.new_NCollection_Sequence_TColStd_SequenceOfInteger_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepAlgo.delete_NCollection_Sequence_TColStd_SequenceOfInteger_IteratorHelper

    def __next__(self):
        return _BRepAlgo.NCollection_Sequence_TColStd_SequenceOfInteger_IteratorHelper___next__(self)
NCollection_Sequence_TColStd_SequenceOfInteger_IteratorHelper_swigregister = _BRepAlgo.NCollection_Sequence_TColStd_SequenceOfInteger_IteratorHelper_swigregister
NCollection_Sequence_TColStd_SequenceOfInteger_IteratorHelper_swigregister(NCollection_Sequence_TColStd_SequenceOfInteger_IteratorHelper)


try:
	BRepAlgo_SequenceOfSequenceOfInteger = NCollection_Sequence_TColStd_SequenceOfInteger
except NameError:
	pass # does not exist, probably ignored

class BRepAlgo_Tool(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Deboucle3D(*args):
        """
        Deboucle3D(TopoDS_Shape S, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher Boundary) -> TopoDS_Shape

        Remove the non valid   part of an offsetshape
        1 - Remove all the free boundary  and the faces
        connex to such edges.
        2 - Remove all the shapes not  valid in the result
        (according to the side of offseting)
        in this verion only the first point is implemented.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type Boundary: OCC.wrapper.TopTools.TopTools_MapOfShape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_Tool_Deboucle3D(*args)

    Deboucle3D = staticmethod(Deboucle3D)

    def __init__(self):
        this = _BRepAlgo.new_BRepAlgo_Tool()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_Tool
BRepAlgo_Tool_swigregister = _BRepAlgo.BRepAlgo_Tool_swigregister
BRepAlgo_Tool_swigregister(BRepAlgo_Tool)

def BRepAlgo_Tool_Deboucle3D(*args):
    """
    BRepAlgo_Tool_Deboucle3D(TopoDS_Shape S, NCollection_Map_TopoDS_Shape_TopTools_ShapeMapHasher Boundary) -> TopoDS_Shape

    Remove the non valid   part of an offsetshape
    1 - Remove all the free boundary  and the faces
    connex to such edges.
    2 - Remove all the shapes not  valid in the result
    (according to the side of offseting)
    in this verion only the first point is implemented.

    :type S: OCC.wrapper.TopoDS.TopoDS_Shape
    :type Boundary: OCC.wrapper.TopTools.TopTools_MapOfShape
    :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

    """
    return _BRepAlgo.BRepAlgo_Tool_Deboucle3D(*args)

class BRepAlgo_Image(object):
    """
    Stores link between a shape <S> and a shape <NewS>
    obtained from <S>. <NewS> is an image of <S>.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepAlgo_Image self) -> BRepAlgo_Image

        Stores link between a shape <S> and a shape <NewS>
        obtained from <S>. <NewS> is an image of <S>.
        """
        this = _BRepAlgo.new_BRepAlgo_Image(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetRoot(self, *args):
        """
        SetRoot(BRepAlgo_Image self, TopoDS_Shape S)

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_Image_SetRoot(self, *args)


    def Bind(self, *args):
        """
        Bind(BRepAlgo_Image self, TopoDS_Shape OldS, TopoDS_Shape NewS)
        Bind(BRepAlgo_Image self, TopoDS_Shape OldS, NCollection_List_TopoDS_Shape NewS)

        Links <NewS> as image of <OldS>.

        :type OldS: OCC.wrapper.TopoDS.TopoDS_Shape
        :type NewS: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepAlgo.BRepAlgo_Image_Bind(self, *args)


    def Add(self, *args):
        """
        Add(BRepAlgo_Image self, TopoDS_Shape OldS, TopoDS_Shape NewS)
        Add(BRepAlgo_Image self, TopoDS_Shape OldS, NCollection_List_TopoDS_Shape NewS)

        Add <NewS> to the image of <OldS>.

        :type OldS: OCC.wrapper.TopoDS.TopoDS_Shape
        :type NewS: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepAlgo.BRepAlgo_Image_Add(self, *args)


    def Clear(self, *args):
        """Clear(BRepAlgo_Image self)"""
        return _BRepAlgo.BRepAlgo_Image_Clear(self, *args)


    def Remove(self, *args):
        """
        Remove(BRepAlgo_Image self, TopoDS_Shape S)

        Remove <S> to set of images.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_Image_Remove(self, *args)


    def Roots(self, *args):
        """
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepAlgo.BRepAlgo_Image_Roots(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsImage(self, *args):
        """
        IsImage(BRepAlgo_Image self, TopoDS_Shape S) -> Standard_Boolean

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.BRepAlgo_Image_IsImage(self, *args)


    def ImageFrom(self, *args):
        """
        Returns the generator of <S>

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepAlgo.BRepAlgo_Image_ImageFrom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Root(self, *args):
        """
        Returns the upper generator of <S>

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepAlgo.BRepAlgo_Image_Root(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def HasImage(self, *args):
        """
        HasImage(BRepAlgo_Image self, TopoDS_Shape S) -> Standard_Boolean

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.BRepAlgo_Image_HasImage(self, *args)


    def Image(self, *args):
        """
        Returns the Image of <S>.
        Returns <S> in the list if HasImage(S) is false.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepAlgo.BRepAlgo_Image_Image(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def LastImage(self, *args):
        """
        LastImage(BRepAlgo_Image self, TopoDS_Shape S, NCollection_List_TopoDS_Shape L)

        Stores in <L> the images of images of...images of <S>.
        <L> contains only <S> if  HasImage(S) is false.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type L: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepAlgo.BRepAlgo_Image_LastImage(self, *args)


    def Compact(self, *args):
        """
        Compact(BRepAlgo_Image self)

        Keeps only the link between roots and lastimage.


        """
        return _BRepAlgo.BRepAlgo_Image_Compact(self, *args)


    def Filter(self, *args):
        """
        Filter(BRepAlgo_Image self, TopoDS_Shape S, TopAbs_ShapeEnum const ShapeType)

        Deletes in the images the shape of type <ShapeType>
        which are not in <S>.
        Warning:  Compact() must be call before.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type ShapeType: OCC.wrapper.TopAbs.TopAbs_ShapeEnum

        """
        return _BRepAlgo.BRepAlgo_Image_Filter(self, *args)

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_Image
BRepAlgo_Image_swigregister = _BRepAlgo.BRepAlgo_Image_swigregister
BRepAlgo_Image_swigregister(BRepAlgo_Image)

class Handle_BRepAlgo_EdgeConnector(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepAlgo_EdgeConnector self)

        Nullify the handle


        """
        return _BRepAlgo.Handle_BRepAlgo_EdgeConnector_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepAlgo_EdgeConnector self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepAlgo.Handle_BRepAlgo_EdgeConnector_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepAlgo_EdgeConnector self, BRepAlgo_EdgeConnector thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepAlgo.Handle_BRepAlgo_EdgeConnector_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepAlgo_EdgeConnector self, Handle_BRepAlgo_EdgeConnector theHandle) -> Handle_BRepAlgo_EdgeConnector
        assign(Handle_BRepAlgo_EdgeConnector self, BRepAlgo_EdgeConnector thePtr) -> Handle_BRepAlgo_EdgeConnector
        assign(Handle_BRepAlgo_EdgeConnector self, Handle_BRepAlgo_EdgeConnector theHandle) -> Handle_BRepAlgo_EdgeConnector

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepAlgo.Handle_BRepAlgo_EdgeConnector_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepAlgo_EdgeConnector self) -> BRepAlgo_EdgeConnector

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepAlgo.Handle_BRepAlgo_EdgeConnector_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepAlgo_EdgeConnector self) -> BRepAlgo_EdgeConnector

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepAlgo.Handle_BRepAlgo_EdgeConnector___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepAlgo_EdgeConnector self) -> BRepAlgo_EdgeConnector

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepAlgo.Handle_BRepAlgo_EdgeConnector___ref__(self, *args)


    def __hash__(self):
        return _BRepAlgo.Handle_BRepAlgo_EdgeConnector___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepAlgo.Handle_BRepAlgo_EdgeConnector___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepAlgo.new_Handle_BRepAlgo_EdgeConnector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepAlgo.Handle_BRepAlgo_EdgeConnector_DownCast)
    __swig_destroy__ = _BRepAlgo.delete_Handle_BRepAlgo_EdgeConnector

    def Add(self, *args):
        """
        Add(Handle_BRepAlgo_EdgeConnector self, TopoDS_Edge e)
        Add(Handle_BRepAlgo_EdgeConnector self, NCollection_List_TopoDS_Shape LOEdge)

        :type LOEdge: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepAlgo.Handle_BRepAlgo_EdgeConnector_Add(self, *args)


    def AddStart(self, *args):
        """
        AddStart(Handle_BRepAlgo_EdgeConnector self, TopoDS_Shape e)
        AddStart(Handle_BRepAlgo_EdgeConnector self, NCollection_List_TopoDS_Shape LOEdge)

        :type LOEdge: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepAlgo.Handle_BRepAlgo_EdgeConnector_AddStart(self, *args)


    def ClearStartElement(self, *args):
        """ClearStartElement(Handle_BRepAlgo_EdgeConnector self)"""
        return _BRepAlgo.Handle_BRepAlgo_EdgeConnector_ClearStartElement(self, *args)


    def MakeBlock(self, *args):
        """
        MakeBlock(Handle_BRepAlgo_EdgeConnector self) -> NCollection_List_TopoDS_Shape

        returns a list of wire non standard

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepAlgo.Handle_BRepAlgo_EdgeConnector_MakeBlock(self, *args)


    def Done(self, *args):
        """Done(Handle_BRepAlgo_EdgeConnector self)"""
        return _BRepAlgo.Handle_BRepAlgo_EdgeConnector_Done(self, *args)


    def IsDone(self, *args):
        """
        IsDone(Handle_BRepAlgo_EdgeConnector self) -> Standard_Boolean

        NYI
        returns true if proceeded  to MakeBlock()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.Handle_BRepAlgo_EdgeConnector_IsDone(self, *args)


    def IsWire(self, *args):
        """
        IsWire(Handle_BRepAlgo_EdgeConnector self, TopoDS_Shape W) -> Standard_Boolean

        NYI
        returns true if W is  a Wire standard.
        W must belong  to the list returned  by MakeBlock.

        :type W: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.Handle_BRepAlgo_EdgeConnector_IsWire(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepAlgo_EdgeConnector self) -> char const *

        :rtype: const char *

        """
        return _BRepAlgo.Handle_BRepAlgo_EdgeConnector_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepAlgo.Handle_BRepAlgo_EdgeConnector_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepAlgo.Handle_BRepAlgo_EdgeConnector_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRepAlgo_EdgeConnector self)

        Memory deallocator for transient classes


        """
        return _BRepAlgo.Handle_BRepAlgo_EdgeConnector_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepAlgo_EdgeConnector self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepAlgo_EdgeConnector self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.Handle_BRepAlgo_EdgeConnector_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepAlgo_EdgeConnector self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepAlgo_EdgeConnector self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.Handle_BRepAlgo_EdgeConnector_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepAlgo_EdgeConnector self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepAlgo.Handle_BRepAlgo_EdgeConnector_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepAlgo_EdgeConnector self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepAlgo.Handle_BRepAlgo_EdgeConnector_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepAlgo_EdgeConnector self)

        Increments the reference counter of this object


        """
        return _BRepAlgo.Handle_BRepAlgo_EdgeConnector_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepAlgo_EdgeConnector self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepAlgo.Handle_BRepAlgo_EdgeConnector_DecrementRefCounter(self, *args)

Handle_BRepAlgo_EdgeConnector_swigregister = _BRepAlgo.Handle_BRepAlgo_EdgeConnector_swigregister
Handle_BRepAlgo_EdgeConnector_swigregister(Handle_BRepAlgo_EdgeConnector)

def Handle_BRepAlgo_EdgeConnector_DownCast(thing):
    return _BRepAlgo.Handle_BRepAlgo_EdgeConnector_DownCast(thing)
Handle_BRepAlgo_EdgeConnector_DownCast = _BRepAlgo.Handle_BRepAlgo_EdgeConnector_DownCast

class NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     The DataMap is a Map to store keys with associated
    Items. See Map  from NCollection for  a discussion
    about the number of buckets.

    The DataMap can be seen as an extended array where
    the Keys  are the   indices.  For this reason  the
    operator () is defined on DataMap to fetch an Item
    from a Key. So the following syntax can be used :

    anItem = aMap(aKey);
    aMap(aKey) = anItem;

    This analogy has its  limit.   aMap(aKey) = anItem
    can  be done only  if aKey was previously bound to
    an item in the map.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def begin(self, *args):
        """
        begin(NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< TopOpeBRepDS_Interference >,TopTools_ShapeMapHasher >::iterator

        Returns an iterator pointing to the first element in the map.

        :rtype: iterator

        """
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher_begin(self, *args)


    def end(self, *args):
        """
        end(NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< TopOpeBRepDS_Interference >,TopTools_ShapeMapHasher >::iterator

        Returns an iterator referring to the past-the-end element in the map.

        :rtype: iterator

        """
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher_end(self, *args)


    def cbegin(self, *args):
        """
        cbegin(NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< TopOpeBRepDS_Interference >,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher self) -> NCollection_DataMap< TopoDS_Shape,opencascade::handle< TopOpeBRepDS_Interference >,TopTools_ShapeMapHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     The DataMap is a Map to store keys with associated
        Items. See Map  from NCollection for  a discussion
        about the number of buckets.

        The DataMap can be seen as an extended array where
        the Keys  are the   indices.  For this reason  the
        operator () is defined on DataMap to fetch an Item
        from a Key. So the following syntax can be used :

        anItem = aMap(aKey);
        aMap(aKey) = anItem;

        This analogy has its  limit.   aMap(aKey) = anItem
        can  be done only  if aKey was previously bound to
        an item in the map.
        """
        this = _BRepAlgo.new_NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher

        Assignment.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher self, NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher theOther) -> NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_DataMap
        :rtype: OCC.wrapper.NCollection.NCollection_DataMap

        """
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher_ReSize(self, *args)


    def Bind(self, *args):
        """
        Bind(NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, Handle_TopOpeBRepDS_Interference theItem) -> Standard_Boolean

        Bind binds Item to Key in map.
        @param theKey  key to add/update
        @param theItem new item; overrides value previously bound to the key, if any
        @return Standard_True if Key was not bound already

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher_Bind(self, *args)


    def Bound(self, *args):
        """
        Bound(NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher self, TopoDS_Shape theKey, Handle_TopOpeBRepDS_Interference theItem) -> Handle_TopOpeBRepDS_Interference

        Bound binds Item to Key in map. Returns modifiable Item 

        :type theKey: const TheKeyType &
        :type theItem: const TheItemType &
        :rtype: TheItemType *

        """
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher_Bound(self, *args)


    def IsBound(self, *args):
        """
        IsBound(NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        IsBound

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher_IsBound(self, *args)


    def UnBind(self, *args):
        """
        UnBind(NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Standard_Boolean

        UnBind removes Item Key pair from map

        :type theKey: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher_UnBind(self, *args)


    def Seek(self, *args):
        """
        Seek(NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Handle_TopOpeBRepDS_Interference

        Seek returns pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: const TheItemType *

        """
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher_Seek(self, *args)


    def Find(self, *args):
        """
        Find returns the Item for Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher_Find(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeSeek(self, *args):
        """
        ChangeSeek(NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Handle_TopOpeBRepDS_Interference

        ChangeSeek returns modifiable pointer to Item by Key. Returns
        NULL is Key was not bound.

        :type theKey: const TheKeyType &
        :rtype: TheItemType *

        """
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher_ChangeSeek(self, *args)


    def ChangeFind(self, *args):
        """
        ChangeFind(NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher self, TopoDS_Shape theKey) -> Handle_TopOpeBRepDS_Interference

        ChangeFind returns mofifiable Item by Key. Raises if Key was not bound

        :type theKey: const TheKeyType &
        :rtype: TheItemType &

        """
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher_ChangeFind(self, *args)


    def __call__(self, *args):
        """
        operator ()

        :type theKey: const TheKeyType &
        :rtype: const TheItemType &

        """
        res = _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Clear(self, *args):
        """
        Clear(NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher_Size(self, *args)


    def __iter__(self):
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher___iter__(self)
    __swig_destroy__ = _BRepAlgo.delete_NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher
NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher_swigregister = _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher_swigregister
NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher_swigregister(NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher)

class NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _BRepAlgo.new_NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _BRepAlgo.delete_NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher_IteratorHelper

    def __next__(self):
        return _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher_IteratorHelper___next__(self)
NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher_IteratorHelper_swigregister = _BRepAlgo.NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher_IteratorHelper_swigregister
NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher_IteratorHelper_swigregister(NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher_IteratorHelper)


try:
	BRepAlgo_DataMapOfShapeInterference = NCollection_DataMap_TopoDS_Shape_Handle_TopOpeBRepDS_Interference_TopTools_ShapeMapHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_BRepAlgo_AsDes(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_BRepAlgo_AsDes self)

        Nullify the handle


        """
        return _BRepAlgo.Handle_BRepAlgo_AsDes_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_BRepAlgo_AsDes self) -> bool

        Check for being null

        :rtype: bool

        """
        return _BRepAlgo.Handle_BRepAlgo_AsDes_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_BRepAlgo_AsDes self, BRepAlgo_AsDes thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _BRepAlgo.Handle_BRepAlgo_AsDes_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_BRepAlgo_AsDes self, Handle_BRepAlgo_AsDes theHandle) -> Handle_BRepAlgo_AsDes
        assign(Handle_BRepAlgo_AsDes self, BRepAlgo_AsDes thePtr) -> Handle_BRepAlgo_AsDes
        assign(Handle_BRepAlgo_AsDes self, Handle_BRepAlgo_AsDes theHandle) -> Handle_BRepAlgo_AsDes

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _BRepAlgo.Handle_BRepAlgo_AsDes_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_BRepAlgo_AsDes self) -> BRepAlgo_AsDes

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _BRepAlgo.Handle_BRepAlgo_AsDes_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_BRepAlgo_AsDes self) -> BRepAlgo_AsDes

        Member access operator (note non-const)

        :rtype: T *

        """
        return _BRepAlgo.Handle_BRepAlgo_AsDes___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_BRepAlgo_AsDes self) -> BRepAlgo_AsDes

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _BRepAlgo.Handle_BRepAlgo_AsDes___ref__(self, *args)


    def __hash__(self):
        return _BRepAlgo.Handle_BRepAlgo_AsDes___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _BRepAlgo.Handle_BRepAlgo_AsDes___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _BRepAlgo.new_Handle_BRepAlgo_AsDes(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_BRepAlgo.Handle_BRepAlgo_AsDes_DownCast)
    __swig_destroy__ = _BRepAlgo.delete_Handle_BRepAlgo_AsDes

    def Clear(self, *args):
        """Clear(Handle_BRepAlgo_AsDes self)"""
        return _BRepAlgo.Handle_BRepAlgo_AsDes_Clear(self, *args)


    def Add(self, *args):
        """
        Add(Handle_BRepAlgo_AsDes self, TopoDS_Shape S, TopoDS_Shape SS)
        Add(Handle_BRepAlgo_AsDes self, TopoDS_Shape S, NCollection_List_TopoDS_Shape SS)

        Stores <SS> as futurs SubShapes of <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :type SS: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepAlgo.Handle_BRepAlgo_AsDes_Add(self, *args)


    def HasAscendant(self, *args):
        """
        HasAscendant(Handle_BRepAlgo_AsDes self, TopoDS_Shape S) -> Standard_Boolean

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.Handle_BRepAlgo_AsDes_HasAscendant(self, *args)


    def HasDescendant(self, *args):
        """
        HasDescendant(Handle_BRepAlgo_AsDes self, TopoDS_Shape S) -> Standard_Boolean

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.Handle_BRepAlgo_AsDes_HasDescendant(self, *args)


    def Ascendant(self, *args):
        """
        Returns the Shape containing <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepAlgo.Handle_BRepAlgo_AsDes_Ascendant(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Descendant(self, *args):
        """
        Returns futur subhapes of <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepAlgo.Handle_BRepAlgo_AsDes_Descendant(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeDescendant(self, *args):
        """
        ChangeDescendant(Handle_BRepAlgo_AsDes self, TopoDS_Shape S) -> NCollection_List_TopoDS_Shape

        Returns futur subhapes of <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepAlgo.Handle_BRepAlgo_AsDes_ChangeDescendant(self, *args)


    def Replace(self, *args):
        """
        Replace(Handle_BRepAlgo_AsDes self, TopoDS_Shape OldS, TopoDS_Shape NewS)

        Replace <OldS> by <NewS>.
        <OldS> disapear from <me>.

        :type OldS: OCC.wrapper.TopoDS.TopoDS_Shape
        :type NewS: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepAlgo.Handle_BRepAlgo_AsDes_Replace(self, *args)


    def Remove(self, *args):
        """
        Remove(Handle_BRepAlgo_AsDes self, TopoDS_Shape S)

        Remove <S> from me.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepAlgo.Handle_BRepAlgo_AsDes_Remove(self, *args)


    def HasCommonDescendant(self, *args):
        """
        HasCommonDescendant(Handle_BRepAlgo_AsDes self, TopoDS_Shape S1, TopoDS_Shape S2, NCollection_List_TopoDS_Shape LC) -> Standard_Boolean

        Returns  True if (S1> and <S2>  has  common
        Descendants.  Stores in <LC> the Commons Descendants.

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type LC: OCC.wrapper.TopTools.TopTools_ListOfShape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.Handle_BRepAlgo_AsDes_HasCommonDescendant(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_BRepAlgo_AsDes self) -> char const *

        :rtype: const char *

        """
        return _BRepAlgo.Handle_BRepAlgo_AsDes_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepAlgo.Handle_BRepAlgo_AsDes_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _BRepAlgo.Handle_BRepAlgo_AsDes_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_BRepAlgo_AsDes self)

        Memory deallocator for transient classes


        """
        return _BRepAlgo.Handle_BRepAlgo_AsDes_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_BRepAlgo_AsDes self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_BRepAlgo_AsDes self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.Handle_BRepAlgo_AsDes_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_BRepAlgo_AsDes self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_BRepAlgo_AsDes self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.Handle_BRepAlgo_AsDes_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_BRepAlgo_AsDes self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _BRepAlgo.Handle_BRepAlgo_AsDes_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_BRepAlgo_AsDes self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepAlgo.Handle_BRepAlgo_AsDes_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_BRepAlgo_AsDes self)

        Increments the reference counter of this object


        """
        return _BRepAlgo.Handle_BRepAlgo_AsDes_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_BRepAlgo_AsDes self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _BRepAlgo.Handle_BRepAlgo_AsDes_DecrementRefCounter(self, *args)

Handle_BRepAlgo_AsDes_swigregister = _BRepAlgo.Handle_BRepAlgo_AsDes_swigregister
Handle_BRepAlgo_AsDes_swigregister(Handle_BRepAlgo_AsDes)

def Handle_BRepAlgo_AsDes_DownCast(thing):
    return _BRepAlgo.Handle_BRepAlgo_AsDes_DownCast(thing)
Handle_BRepAlgo_AsDes_DownCast = _BRepAlgo.Handle_BRepAlgo_AsDes_DownCast

class BRepAlgo_DSAccess(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(BRepAlgo_DSAccess self) -> BRepAlgo_DSAccess"""
        this = _BRepAlgo.new_BRepAlgo_DSAccess(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepAlgo_DSAccess self)

        Clears the internal data structure, including the


        """
        return _BRepAlgo.BRepAlgo_DSAccess_Init(self, *args)


    def Load(self, *args):
        """
        Load(BRepAlgo_DSAccess self, TopoDS_Shape S)
        Load(BRepAlgo_DSAccess self, TopoDS_Shape S1, TopoDS_Shape S2)

        Loads two shapes in the DS without intersecting them.

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_DSAccess_Load(self, *args)


    def Intersect(self, *args):
        """
        Intersect(BRepAlgo_DSAccess self)
        Intersect(BRepAlgo_DSAccess self, TopoDS_Shape S1, TopoDS_Shape S2)

        Intersects the faces contained in two given shapes
        and loads them in the DS. Clears the TopOpeBRepBuild_HBuilder
        if necessary

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_DSAccess_Intersect(self, *args)


    def SameDomain(self, *args):
        """
        SameDomain(BRepAlgo_DSAccess self, TopoDS_Shape S1, TopoDS_Shape S2)

        This method does the same thing as the previous,
        but faster. There is no intersection face/face 3D.
        The faces have the same support(surface). No test of
        tangency (that is why it is faster). Intersects in 2d
        the faces tangent F1 anf F2.

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_DSAccess_SameDomain(self, *args)


    def GetSectionEdgeSet(self, *args):
        """
        returns all compounds of edges connected with section
        contained in the DS

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepAlgo.BRepAlgo_DSAccess_GetSectionEdgeSet(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsWire(self, *args):
        """
        IsWire(BRepAlgo_DSAccess self, TopoDS_Shape Compound) -> Standard_Boolean

        NYI

        :type Compound: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.BRepAlgo_DSAccess_IsWire(self, *args)


    def Wire(self, *args):
        """
        NYI

        :type Compound: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepAlgo.BRepAlgo_DSAccess_Wire(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SectionVertex(self, *args):
        """
        NYI
        returns the vertex of section, which contains the section
        between face S1 and edge S2 (returns an empty Shape
        if S1 is not a face or if S2 is not an edge)

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepAlgo.BRepAlgo_DSAccess_SectionVertex(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def SuppressEdgeSet(self, *args):
        """
        SuppressEdgeSet(BRepAlgo_DSAccess self, TopoDS_Shape Compound)

        Invalidates a complete line of section. All
        Edges connected by Vertex or a Wire. Can be
        a group of connected Edges, which do not form a
        standard Wire.

        :type Compound: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_DSAccess_SuppressEdgeSet(self, *args)


    def ChangeEdgeSet(self, *args):
        """
        ChangeEdgeSet(BRepAlgo_DSAccess self, TopoDS_Shape Old, TopoDS_Shape New)

        Modifies a line of section.  <New> -- should be a
        Group of Edges connected by Vertex.  -- Can be a
        Wire.  Can be a group of connected Edges that do not
        form a standard Wire.   <New> should be sub-groupn of <Old>

        :type Old: OCC.wrapper.TopoDS.TopoDS_Shape
        :type New: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_DSAccess_ChangeEdgeSet(self, *args)


    def SuppressSectionVertex(self, *args):
        """
        SuppressSectionVertex(BRepAlgo_DSAccess self, TopoDS_Vertex V)

        NYI
        Make invalid a Vertex of section. The Vertex shoud be
        reconstructed from a point.

        :type V: OCC.wrapper.TopoDS.TopoDS_Vertex

        """
        return _BRepAlgo.BRepAlgo_DSAccess_SuppressSectionVertex(self, *args)


    def Merge(self, *args):
        """
        :type state1: OCC.wrapper.TopAbs.TopAbs_State
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepAlgo.BRepAlgo_DSAccess_Merge(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Propagate(self, *args):
        """
        NYI   Propagation  of a state starting from the shape
        FromShape = edge or vertex of section, face or
        Coumpound de section. LoadShape is either S1,
        or S2  (see the method Load).   Propagation   from
        FromShape, on the states <what> of LoadShape.
        Return a Wire in 2d, a Shell in 3d.
        Specifications are incomplete, to be redefined for the typologies
        correpsonding to  <FromShape> and the result :
        exemple :    FromShape        resultat
        vertex           wire (or edge)
        edge of section       face (or shell)
        compound of section   shell
        ...                  ...

        :type what: OCC.wrapper.TopAbs.TopAbs_State
        :type FromShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :type LoadShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepAlgo.BRepAlgo_DSAccess_Propagate(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def PropagateFromSection(self, *args):
        """
        SectionShape est soit un Vertex de section(NYI), soit
        une Edge de section. Propagation  des shapes
        de section en partant de SectionShape.
        return un Compound de section.

        :type SectionShape: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepAlgo.BRepAlgo_DSAccess_PropagateFromSection(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Modified(self, *args):
        """
        Returns the list of the descendant shapes of the shape <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepAlgo.BRepAlgo_DSAccess_Modified(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Check(self, *args):
        """
        Check(BRepAlgo_DSAccess self) -> BRepAlgo_CheckStatus

        NYI
        coherence of the internal Data Structure.

        :rtype: OCC.wrapper.BRepAlgo.BRepAlgo_CheckStatus

        """
        return _BRepAlgo.BRepAlgo_DSAccess_Check(self, *args)


    def DS(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure

        """
        res = _BRepAlgo.BRepAlgo_DSAccess_DS(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeDS(self, *args):
        """
        ChangeDS(BRepAlgo_DSAccess self) -> Handle_TopOpeBRepDS_HDataStructure

        :rtype: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure

        """
        return _BRepAlgo.BRepAlgo_DSAccess_ChangeDS(self, *args)


    def Builder(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRepBuild.Handle_TopOpeBRepBuild_HBuilder

        """
        res = _BRepAlgo.BRepAlgo_DSAccess_Builder(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeBuilder(self, *args):
        """
        ChangeBuilder(BRepAlgo_DSAccess self) -> Handle_TopOpeBRepBuild_HBuilder

        :rtype: OCC.wrapper.TopOpeBRepBuild.Handle_TopOpeBRepBuild_HBuilder

        """
        return _BRepAlgo.BRepAlgo_DSAccess_ChangeBuilder(self, *args)

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_DSAccess
BRepAlgo_DSAccess_swigregister = _BRepAlgo.BRepAlgo_DSAccess_swigregister
BRepAlgo_DSAccess_swigregister(BRepAlgo_DSAccess)

class BRepAlgo_Section(BRepAlgo_BooleanOperation):
    """
    Construction of the section lines between two shapes.
    For this Boolean operation, each face of the first
    shape is intersected by each face of the second
    shape. The resulting intersection edges are brought
    together into a compound object, but not chained or
    grouped into wires.
    Computation of the intersection of two Shapes or Surfaces
    The two parts involved in this Boolean operation may
    be defined from geometric surfaces: the most common
    use is the computation of the planar section of a shape.
    A Section object provides the framework for:
    - defining the shapes to be intersected, and the
    computation options,
    - implementing the construction algorithm, and
    - consulting the result.
    Example : giving two shapes S1,S2 accessing faces,
    let compute the section edges R on S1,S2,
    performing approximation on new curves,
    performing PCurve on part 1 but not on part 2 :
    Standard_Boolean PerformNow = Standard_False;
    BRepBoolAPI_Section S(S1,S2,PerformNow);
    S.ComputePCurveOn1(Standard_True);
    S.Approximation(Standard_True);
    S.Build();
    TopoDS_Shape R = S.Shape();
    On Null Shapes of geometries, NotDone() is called.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepAlgo_Section self, TopoDS_Shape Sh1, TopoDS_Shape Sh2, Standard_Boolean const PerformNow) -> BRepAlgo_Section
        __init__(BRepAlgo_Section self, TopoDS_Shape Sh, gp_Pln Pl, Standard_Boolean const PerformNow) -> BRepAlgo_Section
        __init__(BRepAlgo_Section self, TopoDS_Shape Sh, Handle_Geom_Surface Sf, Standard_Boolean const PerformNow) -> BRepAlgo_Section
        __init__(BRepAlgo_Section self, Handle_Geom_Surface Sf, TopoDS_Shape Sh, Standard_Boolean const PerformNow) -> BRepAlgo_Section
        __init__(BRepAlgo_Section self, Handle_Geom_Surface Sf1, Handle_Geom_Surface Sf2, Standard_Boolean const PerformNow) -> BRepAlgo_Section

        This and the above algorithms construct a framework for computing the section lines of
        - the two shapes Sh1 and Sh2, or
        - the shape Sh and the plane Pl, or
        - the shape Sh and the surface Sf, or
        - the surface Sf and the shape Sh, or
        - the two surfaces Sf1 and Sf2,
        and builds the result if PerformNow equals true, its
        default value. If PerformNow equals false, the
        intersection will be computed later by the function Build.
        The constructed shape will be returned by the
        function Shape. This is a compound object
        composed of edges. These intersection edges may be built:
        - on new intersection lines, or
        - on coincident portions of edges in the two intersected shapes.
        These intersection edges are independent: they
        are not chained or grouped in wires.
        If no intersection edge exists, the result is an empty compound object.
        Note that other objects than TopoDS_Shape
        shapes involved in these syntaxes are converted
        into faces or shells before performing the
        computation of the intersection. A shape resulting
        from this conversion can be retrieved with the
        function Shape1 or Shape2.
        Parametric 2D curves on intersection edges
        No parametric 2D curve (pcurve) is defined for
        each elementary edge of the result. To attach such
        parametric curves to the constructed edges you
        may use a constructor with the PerformNow flag
        equal to false; then you use:
        - the function ComputePCurveOn1 to ask for the
        additional computation of a pcurve in the
        parametric space of the first shape,
        - the function ComputePCurveOn2 to ask for the
        additional computation of a pcurve in the
        parametric space of the second shape,
        - in the end, the function Build to construct the result.
        Note that as a result, pcurves will only be added on
        edges built on new intersection lines.
        Approximation of intersection edges
        The underlying 3D geometry attached to each
        elementary edge of the result is:
        - analytic where possible, provided the
        corresponding geometry corresponds to a type
        of analytic curve defined in the Geom package;
        for example, the intersection of a cylindrical
        shape with a plane gives an ellipse or a circle;
        - or elsewhere, given as a succession of points
        grouped together in a BSpline curve of degree 1.
        If you prefer to have an attached 3D geometry
        which is a BSpline approximation of the computed
        set of points on computed elementary intersection
        edges whose underlying geometry is not analytic,
        you may use a constructor with the PerformNow
        flag equal to false. Then you use:
        - the function Approximation to ask for this
        computation option, and
        - the function Build to construct the result.
        Note that as a result, approximations will only be
        computed on edges built on new intersection lines.
        Example
        You may also combine these computation options.
        In the following example:
        - each elementary edge of the computed
        intersection, built on a new intersection line,
        which does not correspond to an analytic Geom
        curve, will be approximated by a BSpline curve
        whose degree is not greater than 8.
        - each elementary edge built on a new intersection line, will have:
        - a pcurve in the parametric space of the shape S1,
        - no pcurve in the parametric space of the shape S2.
        // TopoDS_Shape S1 = ... , S2 = ... ;
        Standard_Boolean PerformNow = Standard_False;
        BRepAlgo_Section S ( S1, S2, PerformNow );
        S.ComputePCurveOn1 (Standard_True);
        S.Approximation (Standard_True);
        S.Build();
        TopoDS_Shape R = S.Shape();

        :type Sf1: OCC.wrapper.Geom.Handle_Geom_Surface
        :type Sf2: OCC.wrapper.Geom.Handle_Geom_Surface
        :type PerformNow: bool

        """
        this = _BRepAlgo.new_BRepAlgo_Section(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init1(self, *args):
        """
        Init1(BRepAlgo_Section self, TopoDS_Shape S1)
        Init1(BRepAlgo_Section self, gp_Pln Pl)
        Init1(BRepAlgo_Section self, Handle_Geom_Surface Sf)

        Initializes the first part

        :type Sf: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _BRepAlgo.BRepAlgo_Section_Init1(self, *args)


    def Init2(self, *args):
        """
        Init2(BRepAlgo_Section self, TopoDS_Shape S2)
        Init2(BRepAlgo_Section self, gp_Pln Pl)
        Init2(BRepAlgo_Section self, Handle_Geom_Surface Sf)

        This and the above algorithms
        reinitialize the first and the second parts on which
        this algorithm is going to perform the intersection
        computation. This is done with either: the surface
        Sf, the plane Pl or the shape Sh.
        You use the function Build to construct the result.

        :type Sf: OCC.wrapper.Geom.Handle_Geom_Surface

        """
        return _BRepAlgo.BRepAlgo_Section_Init2(self, *args)


    def Approximation(self, *args):
        """
        Approximation(BRepAlgo_Section self, Standard_Boolean const B)

        Defines an option for computation of further
        intersections. This computation will be performed by
        the function Build in this framework.
        By default, the underlying 3D geometry attached to
        each elementary edge of the result of a computed intersection is:
        - analytic where possible, provided the
        corresponding geometry corresponds to a type of
        analytic curve defined in the Geom package; for
        example the intersection of a cylindrical shape with
        a plane gives an ellipse or a circle;
        - or elsewhere, given as a succession of points
        grouped together in a BSpline curve of degree 1. If
        Approx equals true, when further computations are
        performed in this framework with the function
        Build, these edges will have an attached 3D
        geometry which is a BSpline approximation of the
        computed set of points.
        Note that as a result, approximations will be computed
        on edges built only on new intersection lines.

        :type B: bool

        """
        return _BRepAlgo.BRepAlgo_Section_Approximation(self, *args)


    def ComputePCurveOn1(self, *args):
        """
        ComputePCurveOn1(BRepAlgo_Section self, Standard_Boolean const B)

        Indicates if the Pcurve must be (or not) performed on first part.

        :type B: bool

        """
        return _BRepAlgo.BRepAlgo_Section_ComputePCurveOn1(self, *args)


    def ComputePCurveOn2(self, *args):
        """
        ComputePCurveOn2(BRepAlgo_Section self, Standard_Boolean const B)

        Define options for the computation of further
        intersections which will be performed by the function
        Build in this framework.
        By default, no parametric 2D curve (pcurve) is defined
        for the elementary edges of the result.
        If ComputePCurve1 equals true, further computations
        performed in this framework with the function Build
        will attach an additional pcurve in the parametric
        space of the first shape to the constructed edges.
        If ComputePCurve2 equals true, the additional pcurve
        will be attached to the constructed edges in the
        parametric space of the second shape.
        These two functions may be used together.
        Note that as a result, pcurves will only be added onto
        edges built on new intersection lines.

        :type B: bool

        """
        return _BRepAlgo.BRepAlgo_Section_ComputePCurveOn2(self, *args)


    def Build(self, *args):
        """
        Build(BRepAlgo_Section self)

        Performs the computation of the section lines
        between the two parts defined at the time of
        construction of this framework or reinitialized with the
        Init1 and Init2 functions.
        The constructed shape will be returned by the function
        Shape. This is a compound object composed of
        edges. These intersection edges may be built:
        - on new intersection lines, or
        - on coincident portions of edges in the two intersected shapes.
        These intersection edges are independent: they are
        not chained or grouped into wires.
        If no intersection edge exists, the result is an empty compound object.
        The shapes involved in the construction of the section
        lines can be retrieved with the function Shape1 or
        Shape2. Note that other objects than
        TopoDS_Shape shapes given as arguments at the
        construction time of this framework, or to the Init1 or
        Init2 function, are converted into faces or shells
        before performing the computation of the intersection.
        Parametric 2D curves on intersection edges
        No parametric 2D curve (pcurve) is defined for the
        elementary edges of the result. To attach parametric
        curves like this to the constructed edges you have to use:
        - the function ComputePCurveOn1 to ask for the
        additional computation of a pcurve in the
        parametric space of the first shape,
        - the function ComputePCurveOn2 to ask for the
        additional computation of a pcurve in the
        parametric space of the second shape.
        This must be done before calling this function.
        Note that as a result, pcurves are added on edges
        built on new intersection lines only.
        Approximation of intersection edges
        The underlying 3D geometry attached to each
        elementary edge of the result is:
        - analytic where possible provided the corresponding
        geometry corresponds to a type of analytic curve
        defined in the Geom package; for example, the
        intersection of a cylindrical shape with a plane
        gives an ellipse or a circle; or
        - elsewhere, given as a succession of points grouped
        together in a BSpline curve of degree 1.
        If, on computed elementary intersection edges whose
        underlying geometry is not analytic, you prefer to
        have an attached 3D geometry which is a BSpline
        approximation of the computed set of points, you have
        to use the function Approximation to ask for this
        computation option before calling this function.
        You may also have combined these computation
        options: look at the example given above to illustrate
        the use of the constructors.


        """
        return _BRepAlgo.BRepAlgo_Section_Build(self, *args)


    def HasAncestorFaceOn1(self, *args):
        """
        HasAncestorFaceOn1(BRepAlgo_Section self, TopoDS_Shape E, TopoDS_Shape F) -> Standard_Boolean

        Identifies the ancestor faces of the new
        intersection edge E resulting from the last
        computation performed in this framework, that is,
        the faces of the two original shapes on which the edge E lies:
        - HasAncestorFaceOn1 gives the ancestor face
        in the first shape, and
        These functions return:
        - true if an ancestor face F is found, or
        - false if not.
        An ancestor face is identifiable for the edge E if the
        three following conditions are satisfied:
        - the first part on which this algorithm performed
        its last computation is a shape, that is, it was not
        given as a surface or a plane at the time of
        construction of this algorithm or at a later time by
        the Init1 function,
        - E is one of the elementary edges built by the last
        computation of this section algorithm,
        - the edge E is built on an intersection curve. In
        other words, E is a new edge built on the
        intersection curve, not on edges belonging to the
        intersecting shapes.
        To use these functions properly, you have to test
        the returned Boolean value before using the
        ancestor face: F is significant only if the returned
        Boolean value equals true.

        :type E: OCC.wrapper.TopoDS.TopoDS_Shape
        :type F: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.BRepAlgo_Section_HasAncestorFaceOn1(self, *args)


    def HasAncestorFaceOn2(self, *args):
        """
        HasAncestorFaceOn2(BRepAlgo_Section self, TopoDS_Shape E, TopoDS_Shape F) -> Standard_Boolean

        Identifies the ancestor faces of the new
        intersection edge E resulting from the last
        computation performed in this framework, that is,
        the faces of the two original shapes on which the edge E lies:
        - HasAncestorFaceOn2 gives the ancestor face in the second shape.
        These functions return:
        - true if an ancestor face F is found, or
        - false if not.
        An ancestor face is identifiable for the edge E if the
        three following conditions are satisfied:
        - the first part on which this algorithm performed
        its last computation is a shape, that is, it was not
        given as a surface or a plane at the time of
        construction of this algorithm or at a later time by
        the Init1 function,
        - E is one of the elementary edges built by the last
        computation of this section algorithm,
        - the edge E is built on an intersection curve. In
        other words, E is a new edge built on the
        intersection curve, not on edges belonging to the
        intersecting shapes.
        To use these functions properly, you have to test
        the returned Boolean value before using the
        ancestor face: F is significant only if the returned
        Boolean value equals true.

        :type E: OCC.wrapper.TopoDS.TopoDS_Shape
        :type F: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.BRepAlgo_Section_HasAncestorFaceOn2(self, *args)

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_Section
BRepAlgo_Section_swigregister = _BRepAlgo.BRepAlgo_Section_swigregister
BRepAlgo_Section_swigregister(BRepAlgo_Section)


try:
	TColStd_SequenceOfInteger = TColStd.NCollection_Sequence_Standard_Integer
except AttributeError:
	pass # does not exist, probably ignored

class BRepAlgo_BooleanOperations(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """__init__(BRepAlgo_BooleanOperations self) -> BRepAlgo_BooleanOperations"""
        this = _BRepAlgo.new_BRepAlgo_BooleanOperations(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Shapes2d(self, *args):
        """
        Shapes2d(BRepAlgo_BooleanOperations self, TopoDS_Shape S1, TopoDS_Shape S2)

        S1 is a Shell with ALL faces supported by the SAME S2 is
        an Edge INCLUDED in that surface with pcurve.
        this avoids a time-consuming 3D operation, compared to Shapes.

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_BooleanOperations_Shapes2d(self, *args)


    def Shapes(self, *args):
        """
        Shapes(BRepAlgo_BooleanOperations self, TopoDS_Shape S1, TopoDS_Shape S2)

        Defines the arguments.

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        return _BRepAlgo.BRepAlgo_BooleanOperations_Shapes(self, *args)


    def SetApproxParameters(self, *args):
        """
        SetApproxParameters(BRepAlgo_BooleanOperations self, Standard_Integer const NbPntMax, Standard_Real const Tol3D, Standard_Real const Tol2D)

        Sets different parameters for the curve approximations :
        NbPntMax : Maximum number of points to be approximated at
        the same time in one curve.
        Tol3D, Tol2D : Tolerances to be reached by the approximation.
        RelativeTol : The given tolerances are relative.

        :type NbPntMax: int
        :type Tol3D: float
        :type Tol2D: float

        """
        return _BRepAlgo.BRepAlgo_BooleanOperations_SetApproxParameters(self, *args)


    def Define(self, *args):
        """
        Define(BRepAlgo_BooleanOperations self, TopoDS_Shape S1, TopoDS_Shape S2, Handle_TopOpeBRepDS_HDataStructure HDS)

        :type S1: OCC.wrapper.TopoDS.TopoDS_Shape
        :type S2: OCC.wrapper.TopoDS.TopoDS_Shape
        :type HDS: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure

        """
        return _BRepAlgo.BRepAlgo_BooleanOperations_Define(self, *args)


    def Common(self, *args):
        """
        returns the common part of the shapes.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepAlgo.BRepAlgo_BooleanOperations_Common(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Fus(self, *args):
        """
        returns the fuse part of the shapes.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepAlgo.BRepAlgo_BooleanOperations_Fus(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Cut(self, *args):
        """
        returns the cut part of the shapes.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepAlgo.BRepAlgo_BooleanOperations_Cut(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Section(self, *args):
        """
        returns the intersection of the shapes.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepAlgo.BRepAlgo_BooleanOperations_Section(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Shape(self, *args):
        """
        returns the result of the boolean operation.

        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepAlgo.BRepAlgo_BooleanOperations_Shape(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ShapeFrom(self, *args):
        """
        Returns the shape(s) resulting of the boolean operation
        issued from the shape <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopoDS.TopoDS_Shape

        """
        res = _BRepAlgo.BRepAlgo_BooleanOperations_ShapeFrom(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Modified(self, *args):
        """
        Returns the list of the descendant shapes of the shape <S>.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepAlgo.BRepAlgo_BooleanOperations_Modified(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDeleted(self, *args):
        """
        IsDeleted(BRepAlgo_BooleanOperations self, TopoDS_Shape S) -> Standard_Boolean

        Returns the fact that the shape <S> has been deleted or not
        by the boolean operation.

        :type S: OCC.wrapper.TopoDS.TopoDS_Shape
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _BRepAlgo.BRepAlgo_BooleanOperations_IsDeleted(self, *args)


    def DataStructure(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure

        """
        res = _BRepAlgo.BRepAlgo_BooleanOperations_DataStructure(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeDataStructure(self, *args):
        """
        ChangeDataStructure(BRepAlgo_BooleanOperations self) -> Handle_TopOpeBRepDS_HDataStructure

        :rtype: OCC.wrapper.TopOpeBRepDS.Handle_TopOpeBRepDS_HDataStructure

        """
        return _BRepAlgo.BRepAlgo_BooleanOperations_ChangeDataStructure(self, *args)


    def Builder(self, *args):
        """
        :rtype: OCC.wrapper.TopOpeBRepBuild.Handle_TopOpeBRepBuild_HBuilder

        """
        res = _BRepAlgo.BRepAlgo_BooleanOperations_Builder(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ChangeBuilder(self, *args):
        """
        ChangeBuilder(BRepAlgo_BooleanOperations self) -> Handle_TopOpeBRepBuild_HBuilder

        :rtype: OCC.wrapper.TopOpeBRepBuild.Handle_TopOpeBRepBuild_HBuilder

        """
        return _BRepAlgo.BRepAlgo_BooleanOperations_ChangeBuilder(self, *args)


    def DataStructureAccess(self, *args):
        """
        DataStructureAccess(BRepAlgo_BooleanOperations self) -> BRepAlgo_DSAccess

        returns the member myDSA. It is useful to then access
        the method GetSectionEdgeSet (wich is a member of DSAccess)

        :rtype: OCC.wrapper.BRepAlgo.BRepAlgo_DSAccess

        """
        return _BRepAlgo.BRepAlgo_BooleanOperations_DataStructureAccess(self, *args)

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_BooleanOperations
BRepAlgo_BooleanOperations_swigregister = _BRepAlgo.BRepAlgo_BooleanOperations_swigregister
BRepAlgo_BooleanOperations_swigregister(BRepAlgo_BooleanOperations)

class BRepAlgo_Loop(object):
    """Builds the loops from a set of edges on a face."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(BRepAlgo_Loop self) -> BRepAlgo_Loop

        Builds the loops from a set of edges on a face.
        """
        this = _BRepAlgo.new_BRepAlgo_Loop(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Init(self, *args):
        """
        Init(BRepAlgo_Loop self, TopoDS_Face F)

        Init with <F> the set of edges must have
        pcurves on <F>.

        :type F: OCC.wrapper.TopoDS.TopoDS_Face

        """
        return _BRepAlgo.BRepAlgo_Loop_Init(self, *args)


    def AddEdge(self, *args):
        """
        AddEdge(BRepAlgo_Loop self, TopoDS_Edge E, NCollection_List_TopoDS_Shape LV)

        Add E with <LV>. <E> will be copied and trim
        by vertices in <LV>.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type LV: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepAlgo.BRepAlgo_Loop_AddEdge(self, *args)


    def AddConstEdge(self, *args):
        """
        AddConstEdge(BRepAlgo_Loop self, TopoDS_Edge E)

        Add <E> as const edge, E can be in the result.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge

        """
        return _BRepAlgo.BRepAlgo_Loop_AddConstEdge(self, *args)


    def AddConstEdges(self, *args):
        """
        AddConstEdges(BRepAlgo_Loop self, NCollection_List_TopoDS_Shape LE)

        Add <LE> as a set of const edges.

        :type LE: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepAlgo.BRepAlgo_Loop_AddConstEdges(self, *args)


    def Perform(self, *args):
        """
        Perform(BRepAlgo_Loop self)

        Make loops.


        """
        return _BRepAlgo.BRepAlgo_Loop_Perform(self, *args)


    def CutEdge(self, *args):
        """
        CutEdge(BRepAlgo_Loop self, TopoDS_Edge E, NCollection_List_TopoDS_Shape VonE, NCollection_List_TopoDS_Shape NE)

        Cut the  edge <E>  in  several edges  <NE> on the
        vertices<VonE>.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :type VonE: OCC.wrapper.TopTools.TopTools_ListOfShape
        :type NE: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        return _BRepAlgo.BRepAlgo_Loop_CutEdge(self, *args)


    def NewWires(self, *args):
        """
        Returns the list of wires performed.
        can be an empty list.

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepAlgo.BRepAlgo_Loop_NewWires(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def WiresToFaces(self, *args):
        """
        WiresToFaces(BRepAlgo_Loop self)

        Build faces from the wires result.


        """
        return _BRepAlgo.BRepAlgo_Loop_WiresToFaces(self, *args)


    def NewFaces(self, *args):
        """
        Returns the list of faces.
        Warning: The method <WiresToFaces> as to be called before.
        can be an empty list.

        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepAlgo.BRepAlgo_Loop_NewFaces(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def NewEdges(self, *args):
        """
        Returns the list of new edges built from an edge <E>
        it can be an empty list.

        :type E: OCC.wrapper.TopoDS.TopoDS_Edge
        :rtype: OCC.wrapper.TopTools.TopTools_ListOfShape

        """
        res = _BRepAlgo.BRepAlgo_Loop_NewEdges(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def GetVerticesForSubstitute(self, *args):
        """
        GetVerticesForSubstitute(BRepAlgo_Loop self, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher VerVerMap)

        Returns the datamap of vertices with their substitutes.

        :type VerVerMap: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape

        """
        return _BRepAlgo.BRepAlgo_Loop_GetVerticesForSubstitute(self, *args)


    def VerticesForSubstitute(self, *args):
        """
        VerticesForSubstitute(BRepAlgo_Loop self, NCollection_DataMap_TopoDS_Shape_TopoDS_Shape_TopTools_ShapeMapHasher VerVerMap)

        :type VerVerMap: OCC.wrapper.TopTools.TopTools_DataMapOfShapeShape

        """
        return _BRepAlgo.BRepAlgo_Loop_VerticesForSubstitute(self, *args)

    __swig_destroy__ = _BRepAlgo.delete_BRepAlgo_Loop
BRepAlgo_Loop_swigregister = _BRepAlgo.BRepAlgo_Loop_swigregister
BRepAlgo_Loop_swigregister(BRepAlgo_Loop)




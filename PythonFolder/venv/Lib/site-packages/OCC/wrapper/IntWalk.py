# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_IntWalk')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_IntWalk')
    _IntWalk = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_IntWalk', [dirname(__file__)])
        except ImportError:
            import _IntWalk
            return _IntWalk
        try:
            _mod = imp.load_module('_IntWalk', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _IntWalk = swig_import_helper()
    del swig_import_helper
else:
    import _IntWalk
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _IntWalk.delete_SwigPyIterator

    def value(self):
        return _IntWalk.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _IntWalk.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _IntWalk.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _IntWalk.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _IntWalk.SwigPyIterator_equal(self, x)

    def copy(self):
        return _IntWalk.SwigPyIterator_copy(self)

    def next(self):
        return _IntWalk.SwigPyIterator_next(self)

    def __next__(self):
        return _IntWalk.SwigPyIterator___next__(self)

    def previous(self):
        return _IntWalk.SwigPyIterator_previous(self)

    def advance(self, n):
        return _IntWalk.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _IntWalk.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _IntWalk.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _IntWalk.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _IntWalk.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _IntWalk.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _IntWalk.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _IntWalk.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _IntWalk.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_IntWalk.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _IntWalk.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _IntWalk.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntWalk.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _IntWalk.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _IntWalk.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _IntWalk.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _IntWalk.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_IntWalk.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _IntWalk.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _IntWalk.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _IntWalk.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _IntWalk.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _IntWalk.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _IntWalk.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _IntWalk.ptr_to_number(item)
ptr_to_number = _IntWalk.ptr_to_number

def HashCode(*args):
    return _IntWalk.HashCode(*args)
HashCode = _IntWalk.HashCode

def ptr_equal(a, b):
    return _IntWalk.ptr_equal(a, b)
ptr_equal = _IntWalk.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntImp
else:
    import IntImp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import IntSurf
else:
    import IntSurf
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
IntWalk_PasTropGrand = _IntWalk.IntWalk_PasTropGrand
IntWalk_StepTooSmall = _IntWalk.IntWalk_StepTooSmall
IntWalk_PointConfondu = _IntWalk.IntWalk_PointConfondu
IntWalk_ArretSurPointPrecedent = _IntWalk.IntWalk_ArretSurPointPrecedent
IntWalk_ArretSurPoint = _IntWalk.IntWalk_ArretSurPoint
IntWalk_OK = _IntWalk.IntWalk_OK
class IntWalk_TheFunctionOfTheInt2S(math.math_FunctionSetWithDerivatives):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntWalk_TheFunctionOfTheInt2S self, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_HSurface S2) -> IntWalk_TheFunctionOfTheInt2S

        :type S1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type S2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

        """
        this = _IntWalk.new_IntWalk_TheFunctionOfTheInt2S(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbVariables(self, *args):
        """
        NbVariables(IntWalk_TheFunctionOfTheInt2S self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntWalk.IntWalk_TheFunctionOfTheInt2S_NbVariables(self, *args)


    def NbEquations(self, *args):
        """
        NbEquations(IntWalk_TheFunctionOfTheInt2S self) -> Standard_Integer

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntWalk.IntWalk_TheFunctionOfTheInt2S_NbEquations(self, *args)


    def Value(self, *args):
        """
        Value(IntWalk_TheFunctionOfTheInt2S self, math_Vector X, math_Vector F) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntWalk.IntWalk_TheFunctionOfTheInt2S_Value(self, *args)


    def Derivatives(self, *args):
        """
        Derivatives(IntWalk_TheFunctionOfTheInt2S self, math_Vector X, math_Matrix D) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntWalk.IntWalk_TheFunctionOfTheInt2S_Derivatives(self, *args)


    def Values(self, *args):
        """
        Values(IntWalk_TheFunctionOfTheInt2S self, math_Vector X, math_Vector F, math_Matrix D) -> Standard_Boolean

        :type X: OCC.wrapper.math.math_Vector
        :type F: OCC.wrapper.math.math_Vector
        :type D: OCC.wrapper.math.math_Matrix
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntWalk.IntWalk_TheFunctionOfTheInt2S_Values(self, *args)


    def ComputeParameters(self, *args):
        """
        ComputeParameters(IntWalk_TheFunctionOfTheInt2S self, IntImp_ConstIsoparametric const ChoixIso, NCollection_Array1_Standard_Real Param, math_Vector UVap, math_Vector BornInf, math_Vector BornSup, math_Vector Tolerance)

        :type ChoixIso: OCC.wrapper.IntImp.IntImp_ConstIsoparametric
        :type Param: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type UVap: OCC.wrapper.math.math_Vector
        :type BornInf: OCC.wrapper.math.math_Vector
        :type BornSup: OCC.wrapper.math.math_Vector
        :type Tolerance: OCC.wrapper.math.math_Vector

        """
        return _IntWalk.IntWalk_TheFunctionOfTheInt2S_ComputeParameters(self, *args)


    def Root(self, *args):
        """
        Root(IntWalk_TheFunctionOfTheInt2S self) -> Standard_Real

        returns somme des fi*fi

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntWalk.IntWalk_TheFunctionOfTheInt2S_Root(self, *args)


    def Point(self, *args):
        """
        Point(IntWalk_TheFunctionOfTheInt2S self) -> gp_Pnt

        :rtype: OCC.wrapper.gp.gp_Pnt

        """
        return _IntWalk.IntWalk_TheFunctionOfTheInt2S_Point(self, *args)


    def IsTangent(self, *args):
        """
        IsTangent(IntWalk_TheFunctionOfTheInt2S self, math_Vector UVap, NCollection_Array1_Standard_Real Param) -> Standard_Boolean

        :type UVap: OCC.wrapper.math.math_Vector
        :type Param: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type BestChoix: OCC.wrapper.IntImp.IntImp_ConstIsoparametric
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntWalk.IntWalk_TheFunctionOfTheInt2S_IsTangent(self, *args)


    def Direction(self, *args):
        """
        Direction(IntWalk_TheFunctionOfTheInt2S self) -> gp_Dir

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        return _IntWalk.IntWalk_TheFunctionOfTheInt2S_Direction(self, *args)


    def DirectionOnS1(self, *args):
        """
        DirectionOnS1(IntWalk_TheFunctionOfTheInt2S self) -> gp_Dir2d

        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        return _IntWalk.IntWalk_TheFunctionOfTheInt2S_DirectionOnS1(self, *args)


    def DirectionOnS2(self, *args):
        """
        DirectionOnS2(IntWalk_TheFunctionOfTheInt2S self) -> gp_Dir2d

        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        return _IntWalk.IntWalk_TheFunctionOfTheInt2S_DirectionOnS2(self, *args)


    def AuxillarSurface1(self, *args):
        """
        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

        """
        res = _IntWalk.IntWalk_TheFunctionOfTheInt2S_AuxillarSurface1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def AuxillarSurface2(self, *args):
        """
        :rtype: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface

        """
        res = _IntWalk.IntWalk_TheFunctionOfTheInt2S_AuxillarSurface2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IntWalk.delete_IntWalk_TheFunctionOfTheInt2S
IntWalk_TheFunctionOfTheInt2S_swigregister = _IntWalk.IntWalk_TheFunctionOfTheInt2S_swigregister
IntWalk_TheFunctionOfTheInt2S_swigregister(IntWalk_TheFunctionOfTheInt2S)

class NCollection_StdAllocator_IntWalk_WalkingData(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(NCollection_StdAllocator<(IntWalk_WalkingData)> self) -> NCollection_StdAllocator_IntWalk_WalkingData
        __init__(NCollection_StdAllocator<(IntWalk_WalkingData)> self, Handle_NCollection_BaseAllocator theAlloc) -> NCollection_StdAllocator_IntWalk_WalkingData

        :type X: OCC.wrapper.NCollection.NCollection_StdAllocator

        """
        this = _IntWalk.new_NCollection_StdAllocator_IntWalk_WalkingData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def address(self, *args):
        """
        address(NCollection_StdAllocator_IntWalk_WalkingData self, NCollection_StdAllocator< IntWalk_WalkingData >::reference x) -> NCollection_StdAllocator< IntWalk_WalkingData >::pointer
        address(NCollection_StdAllocator_IntWalk_WalkingData self, NCollection_StdAllocator< IntWalk_WalkingData >::const_reference x) -> NCollection_StdAllocator< IntWalk_WalkingData >::const_pointer

        :type x: const_reference
        :rtype: const_pointer

        """
        return _IntWalk.NCollection_StdAllocator_IntWalk_WalkingData_address(self, *args)


    def allocate(self, *args):
        """
        allocate(NCollection_StdAllocator_IntWalk_WalkingData self, NCollection_StdAllocator< IntWalk_WalkingData >::size_type n, void const * arg3=None) -> NCollection_StdAllocator< IntWalk_WalkingData >::pointer

        :type n: size_type
        :type : const void *
        :rtype: pointer

        """
        return _IntWalk.NCollection_StdAllocator_IntWalk_WalkingData_allocate(self, *args)


    def deallocate(self, *args):
        """
        deallocate(NCollection_StdAllocator_IntWalk_WalkingData self, NCollection_StdAllocator< IntWalk_WalkingData >::pointer p, NCollection_StdAllocator< IntWalk_WalkingData >::size_type arg3)

        :type p: pointer
        :type : size_type

        """
        return _IntWalk.NCollection_StdAllocator_IntWalk_WalkingData_deallocate(self, *args)


    def max_size(self, *args):
        """
        max_size(NCollection_StdAllocator_IntWalk_WalkingData self) -> NCollection_StdAllocator< IntWalk_WalkingData >::size_type

        Returns the largest value for which method allocate might succeed.

        :rtype: size_type

        """
        return _IntWalk.NCollection_StdAllocator_IntWalk_WalkingData_max_size(self, *args)


    def construct(self, *args):
        """
        construct(NCollection_StdAllocator_IntWalk_WalkingData self, NCollection_StdAllocator< IntWalk_WalkingData >::pointer p, NCollection_StdAllocator< IntWalk_WalkingData >::const_reference val)

        :type p: pointer
        :type val: const_reference

        """
        return _IntWalk.NCollection_StdAllocator_IntWalk_WalkingData_construct(self, *args)


    def destroy(self, *args):
        """
        destroy(NCollection_StdAllocator_IntWalk_WalkingData self, NCollection_StdAllocator< IntWalk_WalkingData >::pointer p)

        :type p: pointer

        """
        return _IntWalk.NCollection_StdAllocator_IntWalk_WalkingData_destroy(self, *args)


    def Allocator(self, *args):
        """
        :rtype: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        res = _IntWalk.NCollection_StdAllocator_IntWalk_WalkingData_Allocator(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _IntWalk.delete_NCollection_StdAllocator_IntWalk_WalkingData
NCollection_StdAllocator_IntWalk_WalkingData_swigregister = _IntWalk.NCollection_StdAllocator_IntWalk_WalkingData_swigregister
NCollection_StdAllocator_IntWalk_WalkingData_swigregister(NCollection_StdAllocator_IntWalk_WalkingData)

class vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        return _IntWalk.vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _IntWalk.vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer___nonzero__(self)

    def __bool__(self):
        return _IntWalk.vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer___bool__(self)

    def __len__(self):
        return _IntWalk.vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer___len__(self)

    def __getslice__(self, i, j):
        return _IntWalk.vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _IntWalk.vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _IntWalk.vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _IntWalk.vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer___delitem__(self, *args)

    def __getitem__(self, *args):
        return _IntWalk.vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer___getitem__(self, *args)

    def __setitem__(self, *args):
        return _IntWalk.vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer___setitem__(self, *args)

    def pop(self):
        return _IntWalk.vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer_pop(self)

    def append(self, x):
        return _IntWalk.vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer_append(self, x)

    def empty(self):
        return _IntWalk.vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer_empty(self)

    def size(self):
        return _IntWalk.vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer_size(self)

    def swap(self, v):
        return _IntWalk.vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer_swap(self, v)

    def begin(self):
        return _IntWalk.vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer_begin(self)

    def end(self):
        return _IntWalk.vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer_end(self)

    def rbegin(self):
        return _IntWalk.vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer_rbegin(self)

    def rend(self):
        return _IntWalk.vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer_rend(self)

    def clear(self):
        return _IntWalk.vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer_clear(self)

    def get_allocator(self):
        return _IntWalk.vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer_get_allocator(self)

    def pop_back(self):
        return _IntWalk.vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer_pop_back(self)

    def erase(self, *args):
        return _IntWalk.vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer_erase(self, *args)

    def __init__(self, *args):
        this = _IntWalk.new_vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _IntWalk.vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer_push_back(self, x)

    def front(self):
        return _IntWalk.vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer_front(self)

    def back(self):
        return _IntWalk.vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer_back(self)

    def assign(self, n, x):
        return _IntWalk.vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer_assign(self, n, x)

    def resize(self, *args):
        return _IntWalk.vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer_resize(self, *args)

    def insert(self, *args):
        return _IntWalk.vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer_insert(self, *args)

    def reserve(self, n):
        return _IntWalk.vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer_reserve(self, n)

    def capacity(self):
        return _IntWalk.vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer_capacity(self)
    __swig_destroy__ = _IntWalk.delete_vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer
vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer_swigregister = _IntWalk.vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer_swigregister
vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer_swigregister(vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer)


try:
	IntWalk_VectorOfInteger = vector_Standard_Integer_NCollection_StdAllocator_Standard_Integer
except NameError:
	pass # does not exist, probably ignored

class vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        return _IntWalk.vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _IntWalk.vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData___nonzero__(self)

    def __bool__(self):
        return _IntWalk.vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData___bool__(self)

    def __len__(self):
        return _IntWalk.vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData___len__(self)

    def __getslice__(self, i, j):
        return _IntWalk.vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _IntWalk.vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _IntWalk.vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _IntWalk.vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData___delitem__(self, *args)

    def __getitem__(self, *args):
        return _IntWalk.vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData___getitem__(self, *args)

    def __setitem__(self, *args):
        return _IntWalk.vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData___setitem__(self, *args)

    def pop(self):
        return _IntWalk.vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData_pop(self)

    def append(self, x):
        return _IntWalk.vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData_append(self, x)

    def empty(self):
        return _IntWalk.vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData_empty(self)

    def size(self):
        return _IntWalk.vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData_size(self)

    def swap(self, v):
        return _IntWalk.vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData_swap(self, v)

    def begin(self):
        return _IntWalk.vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData_begin(self)

    def end(self):
        return _IntWalk.vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData_end(self)

    def rbegin(self):
        return _IntWalk.vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData_rbegin(self)

    def rend(self):
        return _IntWalk.vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData_rend(self)

    def clear(self):
        return _IntWalk.vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData_clear(self)

    def get_allocator(self):
        return _IntWalk.vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData_get_allocator(self)

    def pop_back(self):
        return _IntWalk.vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData_pop_back(self)

    def erase(self, *args):
        return _IntWalk.vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData_erase(self, *args)

    def __init__(self, *args):
        this = _IntWalk.new_vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        return _IntWalk.vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData_push_back(self, x)

    def front(self):
        return _IntWalk.vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData_front(self)

    def back(self):
        return _IntWalk.vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData_back(self)

    def assign(self, n, x):
        return _IntWalk.vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData_assign(self, n, x)

    def resize(self, *args):
        return _IntWalk.vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData_resize(self, *args)

    def insert(self, *args):
        return _IntWalk.vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData_insert(self, *args)

    def reserve(self, n):
        return _IntWalk.vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData_reserve(self, n)

    def capacity(self):
        return _IntWalk.vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData_capacity(self)
    __swig_destroy__ = _IntWalk.delete_vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData
vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData_swigregister = _IntWalk.vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData_swigregister
vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData_swigregister(vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData)


try:
	IntWalk_VectorOfWalkingData = vector_IntWalk_WalkingData_NCollection_StdAllocator_IntWalk_WalkingData
except NameError:
	pass # does not exist, probably ignored

class IntWalk_TheInt2S(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntWalk_TheInt2S self, NCollection_Array1_Standard_Real Param, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_HSurface S2, Standard_Real const TolTangency) -> IntWalk_TheInt2S
        __init__(IntWalk_TheInt2S self, Handle_Adaptor3d_HSurface S1, Handle_Adaptor3d_HSurface S2, Standard_Real const TolTangency) -> IntWalk_TheInt2S

        initialize the parameters to compute the solution point
        it 's possible to write to optimize:
        IntImp_Int2S inter(S1,S2,Func,TolTangency);
        math_FunctionSetRoot rsnld(inter.Function());
        while ...{
        Param(1)=...
        Param(2)=...
        param(3)=...
        inter.Perform(Param,rsnld);
        }

        :type S1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type S2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type TolTangency: float

        """
        this = _IntWalk.new_IntWalk_TheInt2S(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(IntWalk_TheInt2S self, NCollection_Array1_Standard_Real Param, math_FunctionSetRoot Rsnld) -> IntImp_ConstIsoparametric
        Perform(IntWalk_TheInt2S self, NCollection_Array1_Standard_Real Param, math_FunctionSetRoot Rsnld, IntImp_ConstIsoparametric const ChoixIso) -> IntImp_ConstIsoparametric

        returns the best constant isoparametric to find
        the next intersection's point +stores the solution
        point (the solution point is found with the close point
        to intersect the isoparametric with the other patch;
        the choice of the isoparametic is given by ChoixIso)

        :type Param: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type Rsnld: OCC.wrapper.math.math_FunctionSetRoot
        :type ChoixIso: OCC.wrapper.IntImp.IntImp_ConstIsoparametric
        :rtype: OCC.wrapper.IntImp.IntImp_ConstIsoparametric

        """
        return _IntWalk.IntWalk_TheInt2S_Perform(self, *args)


    def IsDone(self, *args):
        """
        IsDone(IntWalk_TheInt2S self) -> Standard_Boolean

        Returns TRUE if the creation completed without failure.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntWalk.IntWalk_TheInt2S_IsDone(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(IntWalk_TheInt2S self) -> Standard_Boolean

        Returns TRUE when there is no solution to the problem.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntWalk.IntWalk_TheInt2S_IsEmpty(self, *args)


    def Point(self, *args):
        """
        Returns the intersection point.

        :rtype: OCC.wrapper.IntSurf.IntSurf_PntOn2S

        """
        res = _IntWalk.IntWalk_TheInt2S_Point(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsTangent(self, *args):
        """
        IsTangent(IntWalk_TheInt2S self) -> Standard_Boolean

        Returns True if the surfaces are tangent at the
        intersection point.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntWalk.IntWalk_TheInt2S_IsTangent(self, *args)


    def Direction(self, *args):
        """
        Returns the tangent at the intersection line.

        :rtype: OCC.wrapper.gp.gp_Dir

        """
        res = _IntWalk.IntWalk_TheInt2S_Direction(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DirectionOnS1(self, *args):
        """
        Returns the tangent at the intersection line in the
        parametric space of the first surface.

        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        res = _IntWalk.IntWalk_TheInt2S_DirectionOnS1(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DirectionOnS2(self, *args):
        """
        Returns the tangent at the intersection line in the
        parametric space of the second surface.

        :rtype: OCC.wrapper.gp.gp_Dir2d

        """
        res = _IntWalk.IntWalk_TheInt2S_DirectionOnS2(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Function(self, *args):
        """
        Function(IntWalk_TheInt2S self) -> IntWalk_TheFunctionOfTheInt2S

        return the math function which
        is used to compute the intersection

        :rtype: OCC.wrapper.IntWalk.IntWalk_TheFunctionOfTheInt2S

        """
        return _IntWalk.IntWalk_TheInt2S_Function(self, *args)


    def ChangePoint(self, *args):
        """
        ChangePoint(IntWalk_TheInt2S self) -> IntSurf_PntOn2S

        return the intersection point which is
        enable for changing.

        :rtype: OCC.wrapper.IntSurf.IntSurf_PntOn2S

        """
        return _IntWalk.IntWalk_TheInt2S_ChangePoint(self, *args)

    __swig_destroy__ = _IntWalk.delete_IntWalk_TheInt2S
IntWalk_TheInt2S_swigregister = _IntWalk.IntWalk_TheInt2S_swigregister
IntWalk_TheInt2S_swigregister(IntWalk_TheInt2S)

class IntWalk_PWalking(object):
    """
    This class implements an algorithm to determine the
    intersection between 2 parametrized surfaces, marching from
    a starting point. The intersection line
    starts and ends on the natural surface's  boundaries .
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(IntWalk_PWalking self, Handle_Adaptor3d_HSurface Caro1, Handle_Adaptor3d_HSurface Caro2, Standard_Real const TolTangency, Standard_Real const Epsilon, Standard_Real const Deflection, Standard_Real const Increment) -> IntWalk_PWalking
        __init__(IntWalk_PWalking self, Handle_Adaptor3d_HSurface Caro1, Handle_Adaptor3d_HSurface Caro2, Standard_Real const TolTangency, Standard_Real const Epsilon, Standard_Real const Deflection, Standard_Real const Increment, Standard_Real const U1, Standard_Real const V1, Standard_Real const U2, Standard_Real const V2) -> IntWalk_PWalking

        Returns the intersection line containing the exact
        point Poin. This line is a polygonal line.
        Deflection is the maximum deflection admitted between two
        consecutive points on the resulting polyline.
        TolTangency is the tolerance to find a tangent point.
        Func is the criterion which has to be evaluated at each
        solution point (each point of the line).
        The line found starts at a point on or in 2 natural domains
        of surfaces. It can be closed in the
        standard case if it is open it stops and begins at the
        border of one of the domains. If an open line
        stops at the middle of a domain, one stops at the tangent point.
        Epsilon is SquareTolerance of points confusion.

        :type Caro1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type Caro2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type TolTangency: float
        :type Epsilon: float
        :type Deflection: float
        :type Increment: float
        :type U1: float
        :type V1: float
        :type U2: float
        :type V2: float

        """
        this = _IntWalk.new_IntWalk_PWalking(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Perform(self, *args):
        """
        Perform(IntWalk_PWalking self, NCollection_Array1_Standard_Real ParDep)
        Perform(IntWalk_PWalking self, NCollection_Array1_Standard_Real ParDep, Standard_Real const u1min, Standard_Real const v1min, Standard_Real const u2min, Standard_Real const v2min, Standard_Real const u1max, Standard_Real const v1max, Standard_Real const u2max, Standard_Real const v2max)

        calculate the line of intersection. The regulation
        of steps is done using min and max values on u and
        v.  (if this data is not presented as in the
        previous method, the initial steps are calculated
        starting from min and max uv of faces).

        :type ParDep: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type u1min: float
        :type v1min: float
        :type u2min: float
        :type v2min: float
        :type u1max: float
        :type v1max: float
        :type u2max: float
        :type v2max: float

        """
        return _IntWalk.IntWalk_PWalking_Perform(self, *args)


    def PerformFirstPoint(self, *args):
        """
        PerformFirstPoint(IntWalk_PWalking self, NCollection_Array1_Standard_Real ParDep, IntSurf_PntOn2S FirstPoint) -> Standard_Boolean

        calculate the first point of a line of intersection

        :type ParDep: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type FirstPoint: OCC.wrapper.IntSurf.IntSurf_PntOn2S
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntWalk.IntWalk_PWalking_PerformFirstPoint(self, *args)


    def IsDone(self, *args):
        """
        IsDone(IntWalk_PWalking self) -> Standard_Boolean

        Returns true if the calculus was successful.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntWalk.IntWalk_PWalking_IsDone(self, *args)


    def NbPoints(self, *args):
        """
        NbPoints(IntWalk_PWalking self) -> Standard_Integer

        Returns the number of points of the resulting polyline.
        An exception is raised if IsDone returns False.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _IntWalk.IntWalk_PWalking_NbPoints(self, *args)


    def Value(self, *args):
        """
        Returns the point of range Index on the polyline.
        An exception is raised if IsDone returns False.
        An exception is raised if Index<=0 or Index>NbPoints.

        :type Index: int
        :rtype: OCC.wrapper.IntSurf.IntSurf_PntOn2S

        """
        res = _IntWalk.IntWalk_PWalking_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Line(self, *args):
        """
        :rtype: OCC.wrapper.IntSurf.Handle_IntSurf_LineOn2S

        """
        res = _IntWalk.IntWalk_PWalking_Line(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TangentAtFirst(self, *args):
        """
        TangentAtFirst(IntWalk_PWalking self) -> Standard_Boolean

        Returns True if the surface are tangent at the first point
        of the line.
        An exception is raised if IsDone returns False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntWalk.IntWalk_PWalking_TangentAtFirst(self, *args)


    def TangentAtLast(self, *args):
        """
        TangentAtLast(IntWalk_PWalking self) -> Standard_Boolean

        Returns true if the surface are tangent at the last point
        of the line.
        An exception is raised if IsDone returns False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntWalk.IntWalk_PWalking_TangentAtLast(self, *args)


    def IsClosed(self, *args):
        """
        IsClosed(IntWalk_PWalking self) -> Standard_Boolean

        Returns True if the line is closed.
        An exception is raised if IsDone returns False.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntWalk.IntWalk_PWalking_IsClosed(self, *args)


    def TangentAtLine(self, *args):
        """
        :type Index: int
        :rtype: OCC.wrapper.gp.gp_Dir

        """
        res = _IntWalk.IntWalk_PWalking_TangentAtLine(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def TestDeflection(self, *args):
        """
        TestDeflection(IntWalk_PWalking self, IntImp_ConstIsoparametric const ChoixIso) -> IntWalk_StatusDeflection

        :type ChoixIso: OCC.wrapper.IntImp.IntImp_ConstIsoparametric
        :rtype: OCC.wrapper.IntWalk.IntWalk_StatusDeflection

        """
        return _IntWalk.IntWalk_PWalking_TestDeflection(self, *args)


    def TestArret(self, *args):
        """
        TestArret(IntWalk_PWalking self, Standard_Boolean const DejaReparti, NCollection_Array1_Standard_Real Param) -> Standard_Boolean

        :type DejaReparti: bool
        :type Param: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type ChoixIso: OCC.wrapper.IntImp.IntImp_ConstIsoparametric
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntWalk.IntWalk_PWalking_TestArret(self, *args)


    def RepartirOuDiviser(self, *args):
        """
        RepartirOuDiviser(IntWalk_PWalking self)

        :type DejaReparti: bool
        :type ChoixIso: OCC.wrapper.IntImp.IntImp_ConstIsoparametric
        :type Arrive: bool

        """
        return _IntWalk.IntWalk_PWalking_RepartirOuDiviser(self, *args)


    def AddAPoint(self, *args):
        """
        AddAPoint(IntWalk_PWalking self, IntSurf_PntOn2S thePOn2S)

        Inserts thePOn2S in the end of line

        :type thePOn2S: OCC.wrapper.IntSurf.IntSurf_PntOn2S

        """
        return _IntWalk.IntWalk_PWalking_AddAPoint(self, *args)


    def RemoveAPoint(self, *args):
        """
        RemoveAPoint(IntWalk_PWalking self, Standard_Integer const theIndex)

        Removes point with index theIndex from line.
        If theIndex is greater than the number of points in line
        then the last point will be removed.
        theIndex must be started with 1.

        :type theIndex: int

        """
        return _IntWalk.IntWalk_PWalking_RemoveAPoint(self, *args)


    def PutToBoundary(self, *args):
        """
        PutToBoundary(IntWalk_PWalking self, Handle_Adaptor3d_HSurface theASurf1, Handle_Adaptor3d_HSurface theASurf2) -> Standard_Boolean

        :type theASurf1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type theASurf2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntWalk.IntWalk_PWalking_PutToBoundary(self, *args)


    def SeekAdditionalPoints(self, *args):
        """
        SeekAdditionalPoints(IntWalk_PWalking self, Handle_Adaptor3d_HSurface theASurf1, Handle_Adaptor3d_HSurface theASurf2, Standard_Integer const theMinNbPoints) -> Standard_Boolean

        :type theASurf1: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type theASurf2: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type theMinNbPoints: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _IntWalk.IntWalk_PWalking_SeekAdditionalPoints(self, *args)


    def MaxStep(self, *args):
        """
        MaxStep(IntWalk_PWalking self, Standard_Integer theIndex) -> Standard_Real

        :type theIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _IntWalk.IntWalk_PWalking_MaxStep(self, *args)

    __swig_destroy__ = _IntWalk.delete_IntWalk_PWalking
IntWalk_PWalking_swigregister = _IntWalk.IntWalk_PWalking_swigregister
IntWalk_PWalking_swigregister(IntWalk_PWalking)




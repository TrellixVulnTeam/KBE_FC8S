# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_TopLoc')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_TopLoc')
    _TopLoc = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_TopLoc', [dirname(__file__)])
        except ImportError:
            import _TopLoc
            return _TopLoc
        try:
            _mod = imp.load_module('_TopLoc', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _TopLoc = swig_import_helper()
    del swig_import_helper
else:
    import _TopLoc
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _TopLoc.delete_SwigPyIterator

    def value(self):
        return _TopLoc.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _TopLoc.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _TopLoc.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _TopLoc.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _TopLoc.SwigPyIterator_equal(self, x)

    def copy(self):
        return _TopLoc.SwigPyIterator_copy(self)

    def next(self):
        return _TopLoc.SwigPyIterator_next(self)

    def __next__(self):
        return _TopLoc.SwigPyIterator___next__(self)

    def previous(self):
        return _TopLoc.SwigPyIterator_previous(self)

    def advance(self, n):
        return _TopLoc.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _TopLoc.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _TopLoc.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _TopLoc.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _TopLoc.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _TopLoc.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _TopLoc.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _TopLoc.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _TopLoc.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_TopLoc.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _TopLoc.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _TopLoc.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopLoc.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _TopLoc.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _TopLoc.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _TopLoc.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _TopLoc.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_TopLoc.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _TopLoc.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _TopLoc.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopLoc.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _TopLoc.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _TopLoc.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _TopLoc.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _TopLoc.ptr_to_number(item)
ptr_to_number = _TopLoc.ptr_to_number

def HashCode(*args):
    return _TopLoc.HashCode(*args)
HashCode = _TopLoc.HashCode

def ptr_equal(a, b):
    return _TopLoc.ptr_equal(a, b)
ptr_equal = _TopLoc.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
class TopLoc_SListNodeOfItemLocation(Standard.Standard_Transient):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopLoc_SListNodeOfItemLocation
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopLoc_SListNodeOfItemLocation(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TopLoc_SListNodeOfItemLocation self, TopLoc_ItemLocation I, TopLoc_SListOfItemLocation aTail) -> TopLoc_SListNodeOfItemLocation

        :type I: OCC.wrapper.TopLoc.TopLoc_ItemLocation
        :type aTail: OCC.wrapper.TopLoc.TopLoc_SListOfItemLocation

        """
        this = _TopLoc.new_TopLoc_SListNodeOfItemLocation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Tail(self, *args):
        """
        Tail(TopLoc_SListNodeOfItemLocation self) -> TopLoc_SListOfItemLocation

        :rtype: OCC.wrapper.TopLoc.TopLoc_SListOfItemLocation

        """
        return _TopLoc.TopLoc_SListNodeOfItemLocation_Tail(self, *args)


    def Value(self, *args):
        """
        Value(TopLoc_SListNodeOfItemLocation self) -> TopLoc_ItemLocation

        :rtype: OCC.wrapper.TopLoc.TopLoc_ItemLocation

        """
        return _TopLoc.TopLoc_SListNodeOfItemLocation_Value(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopLoc.TopLoc_SListNodeOfItemLocation_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopLoc.TopLoc_SListNodeOfItemLocation_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopLoc.TopLoc_SListNodeOfItemLocation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopLoc.delete_TopLoc_SListNodeOfItemLocation
TopLoc_SListNodeOfItemLocation_swigregister = _TopLoc.TopLoc_SListNodeOfItemLocation_swigregister
TopLoc_SListNodeOfItemLocation_swigregister(TopLoc_SListNodeOfItemLocation)

def TopLoc_SListNodeOfItemLocation_get_type_name(*args):
    """
    TopLoc_SListNodeOfItemLocation_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopLoc.TopLoc_SListNodeOfItemLocation_get_type_name(*args)

def TopLoc_SListNodeOfItemLocation_get_type_descriptor(*args):
    """
    TopLoc_SListNodeOfItemLocation_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopLoc.TopLoc_SListNodeOfItemLocation_get_type_descriptor(*args)

class TopLoc_Location(object):
    """
    A Location is a composite transition. It comprises a
    series of elementary reference coordinates, i.e.
    objects of type TopLoc_Datum3D, and the powers to
    which these objects are raised.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopLoc_Location self) -> TopLoc_Location
        __init__(TopLoc_Location self, gp_Trsf T) -> TopLoc_Location
        __init__(TopLoc_Location self, Handle_TopLoc_Datum3D D) -> TopLoc_Location

        Constructs the local coordinate system object defined by the 3D datum D.
        Exceptions
        Standard_ConstructionError if the transformation
        T does not represent a 3D coordinate system.

        :type D: OCC.wrapper.TopLoc.Handle_TopLoc_Datum3D

        """
        this = _TopLoc.new_TopLoc_Location(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsIdentity(self, *args):
        """
        IsIdentity(TopLoc_Location self) -> Standard_Boolean

        Returns true if this location is equal to the Identity transformation.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopLoc.TopLoc_Location_IsIdentity(self, *args)


    def Identity(self, *args):
        """
        Identity(TopLoc_Location self)

        Resets this location to the Identity transformation.


        """
        return _TopLoc.TopLoc_Location_Identity(self, *args)


    def FirstDatum(self, *args):
        """
        Returns    the  first   elementary  datum  of  the
        Location.  Use the NextLocation function recursively to access
        the other data comprising this location.
        Exceptions
        Standard_NoSuchObject if this location is empty.

        :rtype: OCC.wrapper.TopLoc.Handle_TopLoc_Datum3D

        """
        res = _TopLoc.TopLoc_Location_FirstDatum(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FirstPower(self, *args):
        """
        FirstPower(TopLoc_Location self) -> Standard_Integer

        Returns   the  power  elevation  of    the   first
        elementary datum.
        Exceptions
        Standard_NoSuchObject if this location is empty.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopLoc.TopLoc_Location_FirstPower(self, *args)


    def NextLocation(self, *args):
        """
        Returns  a Location representing  <me> without the
        first datum. We have the relation :

        <me> = NextLocation() * FirstDatum() ^ FirstPower()
        Exceptions
        Standard_NoSuchObject if this location is empty.

        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        res = _TopLoc.TopLoc_Location_NextLocation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Transformation(self, *args):
        """
        Returns  the transformation    associated  to  the
        coordinate system.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _TopLoc.TopLoc_Location_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Inverted(self, *args):
        """
        Inverted(TopLoc_Location self) -> TopLoc_Location

        Returns the inverse of <me>.

        <me> * Inverted() is an Identity.

        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _TopLoc.TopLoc_Location_Inverted(self, *args)


    def Multiplied(self, *args):
        """
        Multiplied(TopLoc_Location self, TopLoc_Location Other) -> TopLoc_Location

        Returns <me> * <Other>, the  elementary datums are
        concatenated.

        :type Other: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _TopLoc.TopLoc_Location_Multiplied(self, *args)


    def __mul__(self, *args):
        """
        __mul__(TopLoc_Location self, TopLoc_Location Other) -> TopLoc_Location

        :type Other: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _TopLoc.TopLoc_Location___mul__(self, *args)


    def Divided(self, *args):
        """
        Divided(TopLoc_Location self, TopLoc_Location Other) -> TopLoc_Location

        Returns  <me> / <Other>.

        :type Other: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _TopLoc.TopLoc_Location_Divided(self, *args)


    def __truediv__(self, *args):
        return _TopLoc.TopLoc_Location___truediv__(self, *args)
    __div__ = __truediv__



    def Predivided(self, *args):
        """
        Predivided(TopLoc_Location self, TopLoc_Location Other) -> TopLoc_Location

        Returns <Other>.Inverted() * <me>.

        :type Other: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _TopLoc.TopLoc_Location_Predivided(self, *args)


    def Powered(self, *args):
        """
        Powered(TopLoc_Location self, Standard_Integer const pwr) -> TopLoc_Location

        Returns me at the power <pwr>.   If <pwr>  is zero
        returns  Identity.  <pwr> can  be lower  than zero
        (usual meaning for powers).

        :type pwr: int
        :rtype: OCC.wrapper.TopLoc.TopLoc_Location

        """
        return _TopLoc.TopLoc_Location_Powered(self, *args)


    def HashCode(self, *args):
        """
        HashCode(TopLoc_Location self, Standard_Integer const Upper) -> Standard_Integer

        Returns a hashed value for this local coordinate system.
        This value is used, with map tables, to store and
        retrieve the object easily, and is in the range [ 1..Upper ].

        :type Upper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopLoc.TopLoc_Location_HashCode(self, *args)


    def __hash__(self, *args):
        """
        __hash__(TopLoc_Location self) -> Standard_Integer

        Returns the a hashcode based on the HashCode method, suitable for a python __hash__

        :rtype: int
        """
        return _TopLoc.TopLoc_Location___hash__(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(TopLoc_Location self, TopLoc_Location Other) -> Standard_Boolean

        Returns true if this location and the location Other
        have the same elementary data, i.e. contain the same
        series of TopLoc_Datum3D and respective powers.
        This method is an alias for operator ==.

        :type Other: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopLoc.TopLoc_Location_IsEqual(self, *args)


    def __eq__(self, *args):
        """
        __eq__(TopLoc_Location self, TopLoc_Location Other) -> Standard_Boolean

        :type Other: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopLoc.TopLoc_Location___eq__(self, *args)


    def IsDifferent(self, *args):
        """
        IsDifferent(TopLoc_Location self, TopLoc_Location Other) -> Standard_Boolean

        Returns true if this location and the location Other do
        not have the same elementary data, i.e. do not
        contain the same series of TopLoc_Datum3D and respective powers.
        This method is an alias for operator !=.

        :type Other: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopLoc.TopLoc_Location_IsDifferent(self, *args)


    def __ne__(self, *args):
        """
        __ne__(TopLoc_Location self, TopLoc_Location Other) -> Standard_Boolean

        :type Other: OCC.wrapper.TopLoc.TopLoc_Location
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopLoc.TopLoc_Location___ne__(self, *args)


    def ShallowDump(self, *args):
        """
        ShallowDump(TopLoc_Location self, Standard_OStream & S)

        Prints the contents of <me> on the stream <s>.

        :type S: OCC.wrapper.Standard.Standard_OStream

        """
        return _TopLoc.TopLoc_Location_ShallowDump(self, *args)

    __swig_destroy__ = _TopLoc.delete_TopLoc_Location
TopLoc_Location_swigregister = _TopLoc.TopLoc_Location_swigregister
TopLoc_Location_swigregister(TopLoc_Location)

class TopLoc_Datum3D(Standard.Standard_Transient):
    """
    Describes a coordinate transformation, i.e. a change
    to an elementary 3D coordinate system, or position in 3D space.
    A Datum3D is always described relative to the default datum.
    The default datum is described relative to itself: its
    origin is (0,0,0), and its axes are (1,0,0) (0,1,0) (0,0,1).
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    @property
    def handle(self):
        """
        Returns a handle of the object. The python ownership of the object is transferred to the handle.

        :rtype: Handle_TopLoc_Datum3D
        """
        try:
            return self.__handle__
        except AttributeError:
            self.__handle__ = h = Handle_TopLoc_Datum3D(self) 
            return h


    def __init__(self, *args):
        """
        __init__(TopLoc_Datum3D self) -> TopLoc_Datum3D
        __init__(TopLoc_Datum3D self, gp_Trsf T) -> TopLoc_Datum3D

        Constructs a Datum3D form a Trsf from gp. An error is
        raised if the Trsf is not a rigid transformation.

        :type T: OCC.wrapper.gp.gp_Trsf

        """
        this = _TopLoc.new_TopLoc_Datum3D(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

        self.handle




    def Transformation(self, *args):
        """
        Returns a gp_Trsf which, when applied to this datum,
        produces the default datum.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _TopLoc.TopLoc_Datum3D_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ShallowDump(self, *args):
        """
        ShallowDump(TopLoc_Datum3D self, Standard_OStream & S)

        Writes the contents of this Datum3D to the stream S.

        :type S: OCC.wrapper.Standard.Standard_OStream

        """
        return _TopLoc.TopLoc_Datum3D_ShallowDump(self, *args)


    def get_type_name(*args):
        """
        get_type_name() -> char const *

        :rtype: const char *

        """
        return _TopLoc.TopLoc_Datum3D_get_type_name(*args)

    get_type_name = staticmethod(get_type_name)

    def get_type_descriptor(*args):
        """
        get_type_descriptor() -> Handle_Standard_Type

        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        return _TopLoc.TopLoc_Datum3D_get_type_descriptor(*args)

    get_type_descriptor = staticmethod(get_type_descriptor)

    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopLoc.TopLoc_Datum3D_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res


    __swig_destroy__ = _TopLoc.delete_TopLoc_Datum3D
TopLoc_Datum3D_swigregister = _TopLoc.TopLoc_Datum3D_swigregister
TopLoc_Datum3D_swigregister(TopLoc_Datum3D)

def TopLoc_Datum3D_get_type_name(*args):
    """
    TopLoc_Datum3D_get_type_name() -> char const *

    :rtype: const char *

    """
    return _TopLoc.TopLoc_Datum3D_get_type_name(*args)

def TopLoc_Datum3D_get_type_descriptor(*args):
    """
    TopLoc_Datum3D_get_type_descriptor() -> Handle_Standard_Type

    :rtype: OCC.wrapper.Standard.Handle_Standard_Type

    """
    return _TopLoc.TopLoc_Datum3D_get_type_descriptor(*args)

class NCollection_DefaultHasher_TopLoc_Location(object):
    """
    Purpose:     The  DefaultHasher  is a  Hasher  that is used by
    default in NCollection maps. 
    To compute the  hash code of the key  is used the
    global function HashCode.
    To compare two keys is used  the  global function 
    IsEqual.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def HashCode(*args):
        """
        HashCode(TopLoc_Location theKey, Standard_Integer const Upper) -> Standard_Integer

        :type theKey: const TheKeyType &
        :type Upper: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopLoc.NCollection_DefaultHasher_TopLoc_Location_HashCode(*args)

    HashCode = staticmethod(HashCode)

    def IsEqual(*args):
        """
        IsEqual(TopLoc_Location theKey1, TopLoc_Location theKey2) -> Standard_Boolean

        :type theKey1: const TheKeyType &
        :type theKey2: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopLoc.NCollection_DefaultHasher_TopLoc_Location_IsEqual(*args)

    IsEqual = staticmethod(IsEqual)

    def __init__(self):
        """
        Purpose:     The  DefaultHasher  is a  Hasher  that is used by
        default in NCollection maps. 
        To compute the  hash code of the key  is used the
        global function HashCode.
        To compare two keys is used  the  global function 
        IsEqual.
        """
        this = _TopLoc.new_NCollection_DefaultHasher_TopLoc_Location()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopLoc.delete_NCollection_DefaultHasher_TopLoc_Location
NCollection_DefaultHasher_TopLoc_Location_swigregister = _TopLoc.NCollection_DefaultHasher_TopLoc_Location_swigregister
NCollection_DefaultHasher_TopLoc_Location_swigregister(NCollection_DefaultHasher_TopLoc_Location)

def NCollection_DefaultHasher_TopLoc_Location_HashCode(*args):
    """
    NCollection_DefaultHasher_TopLoc_Location_HashCode(TopLoc_Location theKey, Standard_Integer const Upper) -> Standard_Integer

    :type theKey: const TheKeyType &
    :type Upper: int
    :rtype: OCC.wrapper.Standard.Standard_Integer

    """
    return _TopLoc.NCollection_DefaultHasher_TopLoc_Location_HashCode(*args)

def NCollection_DefaultHasher_TopLoc_Location_IsEqual(*args):
    """
    NCollection_DefaultHasher_TopLoc_Location_IsEqual(TopLoc_Location theKey1, TopLoc_Location theKey2) -> Standard_Boolean

    :type theKey1: const TheKeyType &
    :type theKey2: const TheKeyType &
    :rtype: OCC.wrapper.Standard.Standard_Boolean

    """
    return _TopLoc.NCollection_DefaultHasher_TopLoc_Location_IsEqual(*args)


try:
	TopLoc_MapLocationHasher = NCollection_DefaultHasher_TopLoc_Location
except NameError:
	pass # does not exist, probably ignored

class NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     An indexed map is used to  store  keys and to bind
    an index to them.  Each new key stored in  the map
    gets an index.  Index are incremented  as keys are
    stored in the map. A key can be found by the index
    and an index by the  key. No key  but the last can
    be removed so the indices are in the range 1..Extent.
    See  the  class   Map   from NCollection   for   a
    discussion about the number of buckets.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def cbegin(self, *args):
        """
        cbegin(NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher self) -> NCollection_IndexedMap< TopLoc_Location,TopLoc_MapLocationHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopLoc.NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher self) -> NCollection_IndexedMap< TopLoc_Location,TopLoc_MapLocationHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopLoc.NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     An indexed map is used to  store  keys and to bind
        an index to them.  Each new key stored in  the map
        gets an index.  Index are incremented  as keys are
        stored in the map. A key can be found by the index
        and an index by the  key. No key  but the last can
        be removed so the indices are in the range 1..Extent.
        See  the  class   Map   from NCollection   for   a
        discussion about the number of buckets.
        """
        this = _TopLoc.new_NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher self, NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedMap

        """
        return _TopLoc.NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher self, NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher theOther) -> NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher

        Assign.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedMap

        """
        return _TopLoc.NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher self, NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher theOther) -> NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher

        Assignment operator

        :type theOther: OCC.wrapper.NCollection.NCollection_IndexedMap
        :rtype: OCC.wrapper.NCollection.NCollection_IndexedMap

        """
        return _TopLoc.NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher self, Standard_Integer const theExtent)

        ReSize

        :type theExtent: int

        """
        return _TopLoc.NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher self, TopLoc_Location theKey1) -> Standard_Integer

        Add

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopLoc.NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher_Add(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher self, TopLoc_Location theKey1) -> Standard_Boolean

        Contains

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopLoc.NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher_Contains(self, *args)


    def Substitute(self, *args):
        """
        Substitute(NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher self, Standard_Integer const theIndex, TopLoc_Location theKey1)

        Substitute

        :type theIndex: int
        :type theKey1: const TheKeyType &

        """
        return _TopLoc.NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher_Substitute(self, *args)


    def Swap(self, *args):
        """
        Swap(NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher self, Standard_Integer const theIndex1, Standard_Integer const theIndex2)

        Swaps two elements with the given indices.

        :type theIndex1: int
        :type theIndex2: int

        """
        return _TopLoc.NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher_Swap(self, *args)


    def RemoveLast(self, *args):
        """
        RemoveLast(NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher self)

        RemoveLast


        """
        return _TopLoc.NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher_RemoveLast(self, *args)


    def RemoveFromIndex(self, *args):
        """
        RemoveFromIndex(NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher self, Standard_Integer const theIndex)

        Remove the key of the given index.
        Caution! The index of the last key can be changed.

        :type theIndex: int

        """
        return _TopLoc.NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher_RemoveFromIndex(self, *args)


    def RemoveKey(self, *args):
        """
        RemoveKey(NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher self, TopLoc_Location theKey1) -> Standard_Boolean

        Remove the given key.
        Caution! The index of the last key can be changed.

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopLoc.NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher_RemoveKey(self, *args)


    def FindKey(self, *args):
        """
        FindKey

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _TopLoc.NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher_FindKey(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def __call__(self, *args):
        """
        operator ()

        :type theIndex: int
        :rtype: const TheKeyType &

        """
        res = _TopLoc.NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher___call__(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def FindIndex(self, *args):
        """
        FindIndex(NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher self, TopLoc_Location theKey1) -> Standard_Integer

        FindIndex

        :type theKey1: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopLoc.NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher_FindIndex(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopLoc.NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopLoc.NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher_Size(self, *args)


    def __iter__(self):
        return _TopLoc.NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher___iter__(self)
    __swig_destroy__ = _TopLoc.delete_NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher
NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher_swigregister = _TopLoc.NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher_swigregister
NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher_swigregister(NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher)

class NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopLoc.new_NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopLoc.delete_NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher_IteratorHelper

    def __next__(self):
        return _TopLoc.NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher_IteratorHelper___next__(self)
NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher_IteratorHelper_swigregister = _TopLoc.NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher_IteratorHelper_swigregister
NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher_IteratorHelper_swigregister(NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher_IteratorHelper)


try:
	TopLoc_IndexedMapOfLocation = NCollection_IndexedMap_TopLoc_Location_TopLoc_MapLocationHasher
except NameError:
	pass # does not exist, probably ignored

class Handle_TopLoc_SListNodeOfItemLocation(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopLoc_SListNodeOfItemLocation self)

        Nullify the handle


        """
        return _TopLoc.Handle_TopLoc_SListNodeOfItemLocation_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopLoc_SListNodeOfItemLocation self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopLoc.Handle_TopLoc_SListNodeOfItemLocation_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopLoc_SListNodeOfItemLocation self, TopLoc_SListNodeOfItemLocation thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopLoc.Handle_TopLoc_SListNodeOfItemLocation_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopLoc_SListNodeOfItemLocation self, Handle_TopLoc_SListNodeOfItemLocation theHandle) -> Handle_TopLoc_SListNodeOfItemLocation
        assign(Handle_TopLoc_SListNodeOfItemLocation self, TopLoc_SListNodeOfItemLocation thePtr) -> Handle_TopLoc_SListNodeOfItemLocation
        assign(Handle_TopLoc_SListNodeOfItemLocation self, Handle_TopLoc_SListNodeOfItemLocation theHandle) -> Handle_TopLoc_SListNodeOfItemLocation

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopLoc.Handle_TopLoc_SListNodeOfItemLocation_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopLoc_SListNodeOfItemLocation self) -> TopLoc_SListNodeOfItemLocation

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopLoc.Handle_TopLoc_SListNodeOfItemLocation_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopLoc_SListNodeOfItemLocation self) -> TopLoc_SListNodeOfItemLocation

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopLoc.Handle_TopLoc_SListNodeOfItemLocation___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopLoc_SListNodeOfItemLocation self) -> TopLoc_SListNodeOfItemLocation

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopLoc.Handle_TopLoc_SListNodeOfItemLocation___ref__(self, *args)


    def __hash__(self):
        return _TopLoc.Handle_TopLoc_SListNodeOfItemLocation___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopLoc.Handle_TopLoc_SListNodeOfItemLocation___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopLoc.new_Handle_TopLoc_SListNodeOfItemLocation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopLoc.Handle_TopLoc_SListNodeOfItemLocation_DownCast)
    __swig_destroy__ = _TopLoc.delete_Handle_TopLoc_SListNodeOfItemLocation

    def Tail(self, *args):
        """
        Tail(Handle_TopLoc_SListNodeOfItemLocation self) -> TopLoc_SListOfItemLocation

        :rtype: OCC.wrapper.TopLoc.TopLoc_SListOfItemLocation

        """
        return _TopLoc.Handle_TopLoc_SListNodeOfItemLocation_Tail(self, *args)


    def Value(self, *args):
        """
        Value(Handle_TopLoc_SListNodeOfItemLocation self) -> TopLoc_ItemLocation

        :rtype: OCC.wrapper.TopLoc.TopLoc_ItemLocation

        """
        return _TopLoc.Handle_TopLoc_SListNodeOfItemLocation_Value(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopLoc_SListNodeOfItemLocation self) -> char const *

        :rtype: const char *

        """
        return _TopLoc.Handle_TopLoc_SListNodeOfItemLocation_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopLoc.Handle_TopLoc_SListNodeOfItemLocation_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopLoc.Handle_TopLoc_SListNodeOfItemLocation_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TopLoc_SListNodeOfItemLocation self)

        Memory deallocator for transient classes


        """
        return _TopLoc.Handle_TopLoc_SListNodeOfItemLocation_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopLoc_SListNodeOfItemLocation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopLoc_SListNodeOfItemLocation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopLoc.Handle_TopLoc_SListNodeOfItemLocation_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopLoc_SListNodeOfItemLocation self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopLoc_SListNodeOfItemLocation self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopLoc.Handle_TopLoc_SListNodeOfItemLocation_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopLoc_SListNodeOfItemLocation self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopLoc.Handle_TopLoc_SListNodeOfItemLocation_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopLoc_SListNodeOfItemLocation self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopLoc.Handle_TopLoc_SListNodeOfItemLocation_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopLoc_SListNodeOfItemLocation self)

        Increments the reference counter of this object


        """
        return _TopLoc.Handle_TopLoc_SListNodeOfItemLocation_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopLoc_SListNodeOfItemLocation self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopLoc.Handle_TopLoc_SListNodeOfItemLocation_DecrementRefCounter(self, *args)

Handle_TopLoc_SListNodeOfItemLocation_swigregister = _TopLoc.Handle_TopLoc_SListNodeOfItemLocation_swigregister
Handle_TopLoc_SListNodeOfItemLocation_swigregister(Handle_TopLoc_SListNodeOfItemLocation)

def Handle_TopLoc_SListNodeOfItemLocation_DownCast(thing):
    return _TopLoc.Handle_TopLoc_SListNodeOfItemLocation_DownCast(thing)
Handle_TopLoc_SListNodeOfItemLocation_DownCast = _TopLoc.Handle_TopLoc_SListNodeOfItemLocation_DownCast

class NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher(NCollection.NCollection_BaseMap):
    """
    Purpose:     Single hashed Map. This  Map is used  to store and
    retrieve keys in linear time.

    The ::Iterator class can be  used to explore  the
    content of the map. It is not  wise to iterate and
    modify a map in parallel.

    To compute  the hashcode of  the key the  function
    ::HashCode must be defined in the global namespace

    To compare two keys the function ::IsEqual must be
    defined in the global namespace.

    The performance of  a Map is conditionned  by  its
    number of buckets that  should be kept greater  to
    the number   of keys.  This  map has  an automatic
    management of the number of buckets. It is resized
    when  the number of Keys  becomes greater than the
    number of buckets.

    If you have a fair  idea of the number of  objects
    you  can save on automatic   resizing by giving  a
    number of buckets  at creation or using the ReSize
    method. This should be  consider only for  crucial
    optimisation issues.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def cbegin(self, *args):
        """
        cbegin(NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher self) -> NCollection_Map< TopLoc_Location,TopLoc_MapLocationHasher >::const_iterator

        Returns a const iterator pointing to the first element in the map.

        :rtype: const_iterator

        """
        return _TopLoc.NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher_cbegin(self, *args)


    def cend(self, *args):
        """
        cend(NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher self) -> NCollection_Map< TopLoc_Location,TopLoc_MapLocationHasher >::const_iterator

        Returns a const iterator referring to the past-the-end element in the map.

        :rtype: const_iterator

        """
        return _TopLoc.NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher_cend(self, *args)


    def __init__(self, *args):
        """
        Purpose:     Single hashed Map. This  Map is used  to store and
        retrieve keys in linear time.

        The ::Iterator class can be  used to explore  the
        content of the map. It is not  wise to iterate and
        modify a map in parallel.

        To compute  the hashcode of  the key the  function
        ::HashCode must be defined in the global namespace

        To compare two keys the function ::IsEqual must be
        defined in the global namespace.

        The performance of  a Map is conditionned  by  its
        number of buckets that  should be kept greater  to
        the number   of keys.  This  map has  an automatic
        management of the number of buckets. It is resized
        when  the number of Keys  becomes greater than the
        number of buckets.

        If you have a fair  idea of the number of  objects
        you  can save on automatic   resizing by giving  a
        number of buckets  at creation or using the ReSize
        method. This should be  consider only for  crucial
        optimisation issues.
        """
        this = _TopLoc.new_NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Exchange(self, *args):
        """
        Exchange(NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher self, NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher theOther)

        Exchange the content of two maps without re-allocations.
        Notice that allocators will be swapped as well!

        :type theOther: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TopLoc.NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher_Exchange(self, *args)


    def Assign(self, *args):
        """
        Assign(NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher self, NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher theOther) -> NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher

        Assign.
        This method does not change the internal allocator.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TopLoc.NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher_Assign(self, *args)


    def assign(self, *args):
        """
        assign(NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher self, NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher theOther) -> NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher

        Assign operator

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TopLoc.NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher_assign(self, *args)


    def ReSize(self, *args):
        """
        ReSize(NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher self, Standard_Integer const N)

        ReSize

        :type N: int

        """
        return _TopLoc.NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher_ReSize(self, *args)


    def Add(self, *args):
        """
        Add(NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher self, TopLoc_Location K) -> Standard_Boolean

        Add

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopLoc.NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher_Add(self, *args)


    def Added(self, *args):
        """
        Added: add a new key if not yet in the map, and return 
        reference to either newly added or previously existing object

        :type K: const TheKeyType &
        :rtype: const TheKeyType &

        """
        res = _TopLoc.NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher_Added(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Remove(self, *args):
        """
        Remove(NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher self, TopLoc_Location K) -> Standard_Boolean

        Remove

        :type K: const TheKeyType &
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopLoc.NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher_Remove(self, *args)


    def Clear(self, *args):
        """
        Clear(NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher self, Standard_Boolean const doReleaseMemory)
        Clear(NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher self, Handle_NCollection_BaseAllocator theAllocator)

        Clear data and reset allocator

        :type theAllocator: OCC.wrapper.NCollection.Handle_NCollection_BaseAllocator

        """
        return _TopLoc.NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher_Clear(self, *args)


    def Size(self, *args):
        """
        Size(NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher self) -> Standard_Integer

        Size

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopLoc.NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher_Size(self, *args)


    def IsEqual(self, *args):
        """
        IsEqual(NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher self, NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher theOther) -> Standard_Boolean

        @return true if two maps contains exactly the same keys

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopLoc.NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher_IsEqual(self, *args)


    def Contains(self, *args):
        """
        Contains(NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher self, TopLoc_Location K) -> Standard_Boolean
        Contains(NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher self, NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher theOther) -> Standard_Boolean

        @return true if this map contains ALL keys of another map.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopLoc.NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher_Contains(self, *args)


    def Union(self, *args):
        """
        Union(NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher self, NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher theLeft, NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher theRight)

        Sets this Map to be the result of union (aka addition, fuse, merge, boolean OR) operation between two given Maps
        The new Map contains the values that are contained either in the first map or in the second map or in both.
        All previous content of this Map is cleared.
        This map (result of the boolean operation) can also be passed as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TopLoc.NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher_Union(self, *args)


    def Unite(self, *args):
        """
        Unite(NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher self, NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher theOther) -> Standard_Boolean

        Apply to this Map the boolean operation union (aka addition, fuse, merge, boolean OR) with another (given) Map.
        The result contains the values that were previously contained in this map or contained in the given (operand) map.
        This algorithm is similar to method Union().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopLoc.NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher_Unite(self, *args)


    def HasIntersection(self, *args):
        """
        HasIntersection(NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher self, NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher theMap) -> Standard_Boolean

        Returns true if this and theMap have common elements.

        :type theMap: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopLoc.NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher_HasIntersection(self, *args)


    def Intersection(self, *args):
        """
        Intersection(NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher self, NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher theLeft, NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher theRight)

        Sets this Map to be the result of intersection (aka multiplication, common, boolean AND) operation between two given Maps.
        The new Map contains only the values that are contained in both map operands.
        All previous content of this Map is cleared.
        This same map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TopLoc.NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher_Intersection(self, *args)


    def Intersect(self, *args):
        """
        Intersect(NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher self, NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher theOther) -> Standard_Boolean

        Apply to this Map the intersection operation (aka multiplication, common, boolean AND) with another (given) Map.
        The result contains only the values that are contained in both this and the given maps.
        This algorithm is similar to method Intersection().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopLoc.NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher_Intersect(self, *args)


    def Subtraction(self, *args):
        """
        Subtraction(NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher self, NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher theLeft, NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher theRight)

        Sets this Map to be the result of subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation between two given Maps.
        The new Map contains only the values that are contained in the first map operands and not contained in the second one.
        All previous content of this Map is cleared.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TopLoc.NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher_Subtraction(self, *args)


    def Subtract(self, *args):
        """
        Subtract(NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher self, NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher theOther) -> Standard_Boolean

        Apply to this Map the subtraction (aka set-theoretic difference, relative complement,
        exclude, cut, boolean NOT) operation with another (given) Map.
        The result contains only the values that were previously contained in this map and not contained in this map.
        This algorithm is similar to method Subtract() with two operands.
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopLoc.NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher_Subtract(self, *args)


    def Difference(self, *args):
        """
        Difference(NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher self, NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher theLeft, NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher theRight)

        Sets this Map to be the result of symmetric difference (aka exclusive disjunction, boolean XOR) operation between two given Maps.
        The new Map contains the values that are contained only in the first or the second operand maps but not in both.
        All previous content of this Map is cleared. This map (result of the boolean operation) can also be used as one of operands.

        :type theLeft: OCC.wrapper.NCollection.NCollection_Map
        :type theRight: OCC.wrapper.NCollection.NCollection_Map

        """
        return _TopLoc.NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher_Difference(self, *args)


    def Differ(self, *args):
        """
        Differ(NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher self, NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher theOther) -> Standard_Boolean

        Apply to this Map the symmetric difference (aka exclusive disjunction, boolean XOR) operation with another (given) Map.
        The result contains the values that are contained only in this or the operand map, but not in both.
        This algorithm is similar to method Difference().
        Returns True if contents of this map is changed.

        :type theOther: OCC.wrapper.NCollection.NCollection_Map
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopLoc.NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher_Differ(self, *args)


    def __iter__(self):
        return _TopLoc.NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher___iter__(self)
    __swig_destroy__ = _TopLoc.delete_NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher
NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher_swigregister = _TopLoc.NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher_swigregister
NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher_swigregister(NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher)

class NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher_IteratorHelper(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, item):
        this = _TopLoc.new_NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher_IteratorHelper(item)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopLoc.delete_NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher_IteratorHelper

    def __next__(self):
        return _TopLoc.NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher_IteratorHelper___next__(self)
NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher_IteratorHelper_swigregister = _TopLoc.NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher_IteratorHelper_swigregister
NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher_IteratorHelper_swigregister(NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher_IteratorHelper)


try:
	TopLoc_MapOfLocation = NCollection_Map_TopLoc_Location_TopLoc_MapLocationHasher
except NameError:
	pass # does not exist, probably ignored

class TopLoc_SListOfItemLocation(object):
    """
    An SListOfItemLocation is a LISP like list of Items.
    An SListOfItemLocation is :
    . Empty.
    . Or it has a Value and a  Tail  which is an other SListOfItemLocation.

    The Tail of an empty list is an empty list.
    SListOfItemLocation are  shared.  It  means   that they  can  be
    modified through other lists.
    SListOfItemLocation may  be used  as Iterators. They  have Next,
    More, and value methods. To iterate on the content
    of the list S just do.

    SListOfItemLocation Iterator;
    for (Iterator = S; Iterator.More(); Iterator.Next())
    X = Iterator.Value();
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopLoc_SListOfItemLocation self) -> TopLoc_SListOfItemLocation
        __init__(TopLoc_SListOfItemLocation self, TopLoc_ItemLocation anItem, TopLoc_SListOfItemLocation aTail) -> TopLoc_SListOfItemLocation
        __init__(TopLoc_SListOfItemLocation self, TopLoc_SListOfItemLocation Other) -> TopLoc_SListOfItemLocation

        Creates a list from an other one. The lists  are shared.

        :type Other: OCC.wrapper.TopLoc.TopLoc_SListOfItemLocation

        """
        this = _TopLoc.new_TopLoc_SListOfItemLocation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Assign(self, *args):
        """
        Assign(TopLoc_SListOfItemLocation self, TopLoc_SListOfItemLocation Other) -> TopLoc_SListOfItemLocation

        Sets  a list  from  an  other  one. The  lists are
        shared. The list itself is returned.

        :type Other: OCC.wrapper.TopLoc.TopLoc_SListOfItemLocation
        :rtype: OCC.wrapper.TopLoc.TopLoc_SListOfItemLocation

        """
        return _TopLoc.TopLoc_SListOfItemLocation_Assign(self, *args)


    def assign(self, *args):
        """
        assign(TopLoc_SListOfItemLocation self, TopLoc_SListOfItemLocation Other) -> TopLoc_SListOfItemLocation

        :type Other: OCC.wrapper.TopLoc.TopLoc_SListOfItemLocation
        :rtype: OCC.wrapper.TopLoc.TopLoc_SListOfItemLocation

        """
        return _TopLoc.TopLoc_SListOfItemLocation_assign(self, *args)


    def IsEmpty(self, *args):
        """
        IsEmpty(TopLoc_SListOfItemLocation self) -> Standard_Boolean

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopLoc.TopLoc_SListOfItemLocation_IsEmpty(self, *args)


    def Clear(self, *args):
        """
        Clear(TopLoc_SListOfItemLocation self)

        Sets the list to be empty.


        """
        return _TopLoc.TopLoc_SListOfItemLocation_Clear(self, *args)


    def Value(self, *args):
        """
        Returns the current value of the list. An error is
        raised  if the list is empty.

        :rtype: OCC.wrapper.TopLoc.TopLoc_ItemLocation

        """
        res = _TopLoc.TopLoc_SListOfItemLocation_Value(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Tail(self, *args):
        """
        Returns the current tail of  the list. On an empty
        list the tail is the list itself.

        :rtype: OCC.wrapper.TopLoc.TopLoc_SListOfItemLocation

        """
        res = _TopLoc.TopLoc_SListOfItemLocation_Tail(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Construct(self, *args):
        """
        Construct(TopLoc_SListOfItemLocation self, TopLoc_ItemLocation anItem)

        Replaces the list by a list with <anItem> as Value
        and the  list <me> as  tail.

        :type anItem: OCC.wrapper.TopLoc.TopLoc_ItemLocation

        """
        return _TopLoc.TopLoc_SListOfItemLocation_Construct(self, *args)


    def ToTail(self, *args):
        """
        ToTail(TopLoc_SListOfItemLocation self)

        Replaces the list <me> by its tail.


        """
        return _TopLoc.TopLoc_SListOfItemLocation_ToTail(self, *args)


    def More(self, *args):
        """
        More(TopLoc_SListOfItemLocation self) -> Standard_Boolean

        Returns True if the iterator  has a current value.
        This is !IsEmpty()

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopLoc.TopLoc_SListOfItemLocation_More(self, *args)


    def Next(self, *args):
        """
        Next(TopLoc_SListOfItemLocation self)

        Moves the iterator to the next object in the list.
        If the iterator is empty it will  stay empty. This is ToTail()


        """
        return _TopLoc.TopLoc_SListOfItemLocation_Next(self, *args)

    __swig_destroy__ = _TopLoc.delete_TopLoc_SListOfItemLocation
TopLoc_SListOfItemLocation_swigregister = _TopLoc.TopLoc_SListOfItemLocation_swigregister
TopLoc_SListOfItemLocation_swigregister(TopLoc_SListOfItemLocation)

class Handle_TopLoc_Datum3D(object):
    """
    Intrusive smart pointer for use with Standard_Transient class and its descendants.

    This class is similar to boost::intrusive_ptr<>. The reference counter
    is part of the base class (Standard_Transient), thus creation of a handle
    does not require allocation of additional memory for the counter.
    All handles to the same object share the common counter; object is deleted
    when the last handle pointing on it is destroyed. It is safe to create a new
    handle from plain C pointer to the object already pointed by another handle.
    The same object can be referenced by handles of different types (as soon as 
    they are compatible with the object type).

    Handle has type cast operator to const reference to handle to the base
    types, which allows it to be passed by reference in functions accepting 
    reference to handle to base class, without copying.

    By default, the type cast operator is provided also for non-const reference.
    These casts (potentially unsafe) can be disabled by defining macro
    OCCT_HANDLE_NOCAST; if it is defined, generalized copy constructor
    and assignment operators are defined allowing to initialize handle
    of base type from handle to derived type.

    Weak pointers are not supported.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def Nullify(self, *args):
        """
        Nullify(Handle_TopLoc_Datum3D self)

        Nullify the handle


        """
        return _TopLoc.Handle_TopLoc_Datum3D_Nullify(self, *args)


    def IsNull(self, *args):
        """
        IsNull(Handle_TopLoc_Datum3D self) -> bool

        Check for being null

        :rtype: bool

        """
        return _TopLoc.Handle_TopLoc_Datum3D_IsNull(self, *args)


    def reset(self, *args):
        """
        reset(Handle_TopLoc_Datum3D self, TopLoc_Datum3D thePtr)

        Reset by new pointer

        :type thePtr: T *

        """
        return _TopLoc.Handle_TopLoc_Datum3D_reset(self, *args)


    def assign(self, *args):
        """
        assign(Handle_TopLoc_Datum3D self, Handle_TopLoc_Datum3D theHandle) -> Handle_TopLoc_Datum3D
        assign(Handle_TopLoc_Datum3D self, TopLoc_Datum3D thePtr) -> Handle_TopLoc_Datum3D
        assign(Handle_TopLoc_Datum3D self, Handle_TopLoc_Datum3D theHandle) -> Handle_TopLoc_Datum3D

        Move operator

        :type theHandle: handle<T> &&
        :rtype: OCC.wrapper.Standard.handle

        """
        return _TopLoc.Handle_TopLoc_Datum3D_assign(self, *args)


    def get(self, *args):
        """
        get(Handle_TopLoc_Datum3D self) -> TopLoc_Datum3D

        STL-like cast to pointer to referred object (note non-const).
        @sa std::shared_ptr::get()

        :rtype: T *

        """
        return _TopLoc.Handle_TopLoc_Datum3D_get(self, *args)


    def __deref__(self, *args):
        """
        __deref__(Handle_TopLoc_Datum3D self) -> TopLoc_Datum3D

        Member access operator (note non-const)

        :rtype: T *

        """
        return _TopLoc.Handle_TopLoc_Datum3D___deref__(self, *args)


    def __ref__(self, *args):
        """
        __ref__(Handle_TopLoc_Datum3D self) -> TopLoc_Datum3D

        Dereferencing operator (note non-const)

        :rtype: T &

        """
        return _TopLoc.Handle_TopLoc_Datum3D___ref__(self, *args)


    def __hash__(self):
        return _TopLoc.Handle_TopLoc_Datum3D___hash__(self)

    def __eq__(self, *args):
        """
        :rtype: bool
        """
        try:
            return _TopLoc.Handle_TopLoc_Datum3D___eq__(self, *args)
        except TypeError:
            return False



    def __init__(self, *args):
        this = _TopLoc.new_Handle_TopLoc_Datum3D(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    DownCast = staticmethod(_TopLoc.Handle_TopLoc_Datum3D_DownCast)
    __swig_destroy__ = _TopLoc.delete_Handle_TopLoc_Datum3D

    def Transformation(self, *args):
        """
        Returns a gp_Trsf which, when applied to this datum,
        produces the default datum.

        :rtype: OCC.wrapper.gp.gp_Trsf

        """
        res = _TopLoc.Handle_TopLoc_Datum3D_Transformation(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def ShallowDump(self, *args):
        """
        ShallowDump(Handle_TopLoc_Datum3D self, Standard_OStream & S)

        Writes the contents of this Datum3D to the stream S.

        :type S: OCC.wrapper.Standard.Standard_OStream

        """
        return _TopLoc.Handle_TopLoc_Datum3D_ShallowDump(self, *args)


    def get_type_name(self, *args):
        """
        get_type_name(Handle_TopLoc_Datum3D self) -> char const *

        :rtype: const char *

        """
        return _TopLoc.Handle_TopLoc_Datum3D_get_type_name(self, *args)


    def get_type_descriptor(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopLoc.Handle_TopLoc_Datum3D_get_type_descriptor(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def DynamicType(self, *args):
        """
        :rtype: OCC.wrapper.Standard.Handle_Standard_Type

        """
        res = _TopLoc.Handle_TopLoc_Datum3D_DynamicType(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def Delete(self, *args):
        """
        Delete(Handle_TopLoc_Datum3D self)

        Memory deallocator for transient classes


        """
        return _TopLoc.Handle_TopLoc_Datum3D_Delete(self, *args)


    def IsInstance(self, *args):
        """
        IsInstance(Handle_TopLoc_Datum3D self, Handle_Standard_Type theType) -> Standard_Boolean
        IsInstance(Handle_TopLoc_Datum3D self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns a true value if this is an instance of TypeName.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopLoc.Handle_TopLoc_Datum3D_IsInstance(self, *args)


    def IsKind(self, *args):
        """
        IsKind(Handle_TopLoc_Datum3D self, Handle_Standard_Type theType) -> Standard_Boolean
        IsKind(Handle_TopLoc_Datum3D self, Standard_CString const theTypeName) -> Standard_Boolean

        Returns true if this is an instance of TypeName or an
        instance of any class that inherits from TypeName.
        Note that multiple inheritance is not supported by OCCT RTTI mechanism.

        :type theTypeName: OCC.wrapper.Standard.Standard_CString
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _TopLoc.Handle_TopLoc_Datum3D_IsKind(self, *args)


    def This(self, *args):
        """
        This(Handle_TopLoc_Datum3D self) -> Standard_Transient

        Returns non-const pointer to this object (like const_cast).
        For protection against creating handle to objects allocated in stack
        or call from constructor, it will raise exception Standard_ProgramError
        if reference counter is zero.

        :rtype: OCC.wrapper.Standard.Standard_Transient

        """
        return _TopLoc.Handle_TopLoc_Datum3D_This(self, *args)


    def GetRefCount(self, *args):
        """
        GetRefCount(Handle_TopLoc_Datum3D self) -> Standard_Integer

        Get the reference counter of this object

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopLoc.Handle_TopLoc_Datum3D_GetRefCount(self, *args)


    def IncrementRefCounter(self, *args):
        """
        IncrementRefCounter(Handle_TopLoc_Datum3D self)

        Increments the reference counter of this object


        """
        return _TopLoc.Handle_TopLoc_Datum3D_IncrementRefCounter(self, *args)


    def DecrementRefCounter(self, *args):
        """
        DecrementRefCounter(Handle_TopLoc_Datum3D self) -> Standard_Integer

        Decrements the reference counter of this object;
        returns the decremented value

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _TopLoc.Handle_TopLoc_Datum3D_DecrementRefCounter(self, *args)

Handle_TopLoc_Datum3D_swigregister = _TopLoc.Handle_TopLoc_Datum3D_swigregister
Handle_TopLoc_Datum3D_swigregister(Handle_TopLoc_Datum3D)

def Handle_TopLoc_Datum3D_DownCast(thing):
    return _TopLoc.Handle_TopLoc_Datum3D_DownCast(thing)
Handle_TopLoc_Datum3D_DownCast = _TopLoc.Handle_TopLoc_Datum3D_DownCast

class TopLoc_ItemLocation(object):
    """
    An ItemLocation is an elementary coordinate system
    in a Location.

    The  ItemLocation     contains :

    * The elementary Datum.

    * The exponent of the elementary Datum.

    * The transformation associated to the composition.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(TopLoc_ItemLocation self, Handle_TopLoc_Datum3D D, Standard_Integer const P) -> TopLoc_ItemLocation

        Sets the elementary Datum to <D>
        Sets the exponent to <P>

        :type D: OCC.wrapper.TopLoc.Handle_TopLoc_Datum3D
        :type P: int

        """
        this = _TopLoc.new_TopLoc_ItemLocation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _TopLoc.delete_TopLoc_ItemLocation
TopLoc_ItemLocation_swigregister = _TopLoc.TopLoc_ItemLocation_swigregister
TopLoc_ItemLocation_swigregister(TopLoc_ItemLocation)




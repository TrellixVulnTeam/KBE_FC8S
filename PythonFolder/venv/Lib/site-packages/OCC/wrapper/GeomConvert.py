# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_GeomConvert')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_GeomConvert')
    _GeomConvert = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_GeomConvert', [dirname(__file__)])
        except ImportError:
            import _GeomConvert
            return _GeomConvert
        try:
            _mod = imp.load_module('_GeomConvert', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _GeomConvert = swig_import_helper()
    del swig_import_helper
else:
    import _GeomConvert
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _GeomConvert.delete_SwigPyIterator

    def value(self):
        return _GeomConvert.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _GeomConvert.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _GeomConvert.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _GeomConvert.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _GeomConvert.SwigPyIterator_equal(self, x)

    def copy(self):
        return _GeomConvert.SwigPyIterator_copy(self)

    def next(self):
        return _GeomConvert.SwigPyIterator_next(self)

    def __next__(self):
        return _GeomConvert.SwigPyIterator___next__(self)

    def previous(self):
        return _GeomConvert.SwigPyIterator_previous(self)

    def advance(self, n):
        return _GeomConvert.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _GeomConvert.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _GeomConvert.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _GeomConvert.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _GeomConvert.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _GeomConvert.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _GeomConvert.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _GeomConvert.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class NCollection_CellFilter_InspectorXYZ(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _GeomConvert.NCollection_CellFilter_InspectorXYZ_Dimension
    Coord = staticmethod(_GeomConvert.NCollection_CellFilter_InspectorXYZ_Coord)

    def Shift(self, thePnt, theTol):
        return _GeomConvert.NCollection_CellFilter_InspectorXYZ_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _GeomConvert.new_NCollection_CellFilter_InspectorXYZ()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GeomConvert.delete_NCollection_CellFilter_InspectorXYZ
NCollection_CellFilter_InspectorXYZ_swigregister = _GeomConvert.NCollection_CellFilter_InspectorXYZ_swigregister
NCollection_CellFilter_InspectorXYZ_swigregister(NCollection_CellFilter_InspectorXYZ)

def NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt):
    return _GeomConvert.NCollection_CellFilter_InspectorXYZ_Coord(i, thePnt)
NCollection_CellFilter_InspectorXYZ_Coord = _GeomConvert.NCollection_CellFilter_InspectorXYZ_Coord

class NCollection_CellFilter_InspectorXY(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    Dimension = _GeomConvert.NCollection_CellFilter_InspectorXY_Dimension
    Coord = staticmethod(_GeomConvert.NCollection_CellFilter_InspectorXY_Coord)

    def Shift(self, thePnt, theTol):
        return _GeomConvert.NCollection_CellFilter_InspectorXY_Shift(self, thePnt, theTol)

    def __init__(self):
        this = _GeomConvert.new_NCollection_CellFilter_InspectorXY()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GeomConvert.delete_NCollection_CellFilter_InspectorXY
NCollection_CellFilter_InspectorXY_swigregister = _GeomConvert.NCollection_CellFilter_InspectorXY_swigregister
NCollection_CellFilter_InspectorXY_swigregister(NCollection_CellFilter_InspectorXY)

def NCollection_CellFilter_InspectorXY_Coord(i, thePnt):
    return _GeomConvert.NCollection_CellFilter_InspectorXY_Coord(i, thePnt)
NCollection_CellFilter_InspectorXY_Coord = _GeomConvert.NCollection_CellFilter_InspectorXY_Coord


def ptr_to_number(item):
    return _GeomConvert.ptr_to_number(item)
ptr_to_number = _GeomConvert.ptr_to_number

def HashCode(*args):
    return _GeomConvert.HashCode(*args)
HashCode = _GeomConvert.HashCode

def ptr_equal(a, b):
    return _GeomConvert.ptr_equal(a, b)
ptr_equal = _GeomConvert.ptr_equal
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Convert
else:
    import Convert
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import NCollection
else:
    import NCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Standard
else:
    import Standard
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import gp
else:
    import gp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColStd
else:
    import TColStd
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TCollection
else:
    import TCollection
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColgp
else:
    import TColgp
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import GeomAbs
else:
    import GeomAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom
else:
    import Geom
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor3d
else:
    import Adaptor3d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Adaptor2d
else:
    import Adaptor2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import Geom2d
else:
    import Geom2d
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TopAbs
else:
    import TopAbs
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import math
else:
    import math
del _swig_python_version_info
from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    from . import TColGeom
else:
    import TColGeom
del _swig_python_version_info
class GeomConvert_BSplineCurveKnotSplitting(object):
    """
    An algorithm to determine points at which a BSpline
    curve should be split in order to obtain arcs of the same continuity.
    If you require curves with a minimum continuity for
    your computation, it is useful to know the points
    between which an arc has a continuity of a given
    order. The continuity order is given at the construction time.
    For a BSpline curve, the discontinuities are
    localized at the knot values. Between two knot values
    the BSpline is infinitely and continuously
    differentiable. At a given knot, the continuity is equal
    to: Degree - Mult, where Degree is the
    degree of the BSpline curve and Mult is the multiplicity of the knot.
    It is possible to compute the arcs which correspond to
    this splitting using the global function
    SplitBSplineCurve provided by the package GeomConvert.
    A BSplineCurveKnotSplitting object provides a framework for:
    -   defining the curve to be analyzed and the
    required degree of continuity,
    -   implementing the computation algorithm, and
    -   consulting the results.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomConvert_BSplineCurveKnotSplitting self, Handle_Geom_BSplineCurve BasisCurve, Standard_Integer const ContinuityRange) -> GeomConvert_BSplineCurveKnotSplitting

        Determines points at which the BSpline curve
        BasisCurve should be split in order to obtain arcs
        with a degree of continuity equal to ContinuityRange.
        These points are knot values of BasisCurve. They
        are identified by indices in the knots table of BasisCurve.
        Use the available interrogation functions to access
        computed values, followed by the global function
        SplitBSplineCurve (provided by the package GeomConvert) to split the curve.
        Exceptions
        Standard_RangeError if ContinuityRange is less than zero.

        :type BasisCurve: OCC.wrapper.Geom.Handle_Geom_BSplineCurve
        :type ContinuityRange: int

        """
        this = _GeomConvert.new_GeomConvert_BSplineCurveKnotSplitting(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbSplits(self, *args):
        """
        NbSplits(GeomConvert_BSplineCurveKnotSplitting self) -> Standard_Integer

        Returns the number of points at which the analyzed
        BSpline curve should be split, in order to obtain arcs
        with the continuity required by this framework.
        All these points correspond to knot values. Note that
        the first and last points of the curve, which bound the
        first and last arcs, are counted among these splitting points.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomConvert.GeomConvert_BSplineCurveKnotSplitting_NbSplits(self, *args)


    def Splitting(self, *args):
        """
        Splitting(GeomConvert_BSplineCurveKnotSplitting self, NCollection_Array1_Standard_Integer SplitValues)

        Loads the SplitValues table with the split knots
        values computed in this framework. Each value in the
        table is an index in the knots table of the BSpline
        curve analyzed by this algorithm.
        The values in SplitValues are given in ascending
        order and comprise the indices of the knots which
        give the first and last points of the curve. Use two
        consecutive values from the table as arguments of the
        global function SplitBSplineCurve (provided by the
        package GeomConvert) to split the curve.
        Exceptions
        Standard_DimensionError if the array SplitValues
        was not created with the following bounds:
        -   1, and
        -   the number of split points computed in this
        framework (as given by the function NbSplits).

        :type SplitValues: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _GeomConvert.GeomConvert_BSplineCurveKnotSplitting_Splitting(self, *args)


    def SplitValue(self, *args):
        """
        SplitValue(GeomConvert_BSplineCurveKnotSplitting self, Standard_Integer const Index) -> Standard_Integer

        Returns the split knot of index Index to the split knots
        table computed in this framework. The returned value
        is an index in the knots table of the BSpline curve
        analyzed by this algorithm.
        Notes:
        -   If Index is equal to 1, the corresponding knot
        gives the first point of the curve.
        -   If Index is equal to the number of split knots
        computed in this framework, the corresponding
        point is the last point of the curve.
        Exceptions
        Standard_RangeError if Index is less than 1 or
        greater than the number of split knots computed in this framework.

        :type Index: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomConvert.GeomConvert_BSplineCurveKnotSplitting_SplitValue(self, *args)

    __swig_destroy__ = _GeomConvert.delete_GeomConvert_BSplineCurveKnotSplitting
GeomConvert_BSplineCurveKnotSplitting_swigregister = _GeomConvert.GeomConvert_BSplineCurveKnotSplitting_swigregister
GeomConvert_BSplineCurveKnotSplitting_swigregister(GeomConvert_BSplineCurveKnotSplitting)

class GeomConvert_(object):
    """
    The GeomConvert package provides some global functions as follows
    -   converting classical Geom curves into BSpline curves,
    -   segmenting BSpline curves, particularly at knots
    values: this function may be used in conjunction with the
    GeomConvert_BSplineCurveKnotSplitting
    class to segment a BSpline curve into arcs which
    comply with required continuity levels,
    -   converting classical Geom surfaces into BSpline surfaces, and
    -   segmenting BSpline surfaces, particularly at
    knots values: this function may be used in conjunction with the
    GeomConvert_BSplineSurfaceKnotSplitting
    class to segment a BSpline surface into patches
    which comply with required continuity levels.
    All geometric entities used in this package are bounded.

    References :
    . Generating the Bezier Points of B-spline curves and surfaces
    (Wolfgang Bohm) CAGD volume 13 number 6 november 1981
    . On NURBS: A Survey  (Leslie Piegl) IEEE Computer Graphics and
    Application January 1991
    . Curve and surface construction using rational B-splines
    (Leslie Piegl and Wayne Tiller) CAD Volume 19 number 9 november
    1987
    . A survey of curve and surface methods in CAGD (Wolfgang BOHM)
    CAGD 1 1984
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def SplitBSplineCurve(*args):
        """
        SplitBSplineCurve(Handle_Geom_BSplineCurve C, Standard_Integer const FromK1, Standard_Integer const ToK2, Standard_Boolean const SameOrientation) -> Handle_Geom_BSplineCurve
        SplitBSplineCurve(Handle_Geom_BSplineCurve C, Standard_Real const FromU1, Standard_Real const ToU2, Standard_Real const ParametricTolerance, Standard_Boolean const SameOrientation) -> Handle_Geom_BSplineCurve

        This function computes the segment of B-spline curve between the
        parametric values FromU1, ToU2.
        If C is periodic the arc has the same orientation as C if
        SameOrientation = True.
        If C is not periodic SameOrientation is not used for the
        computation and C is oriented fromU1 toU2.
        If U1 and U2 and two parametric values we consider that
        U1 = U2 if Abs (U1 - U2) <= ParametricTolerance and
        ParametricTolerance must  be greater or equal to Resolution
        from package gp.

        Raised if FromU1 or ToU2 are out of the parametric bounds of the
        curve (The tolerance criterion is ParametricTolerance).
        Raised if Abs (FromU1 - ToU2) <= ParametricTolerance
        Raised if ParametricTolerance < Resolution from gp.

        :type C: OCC.wrapper.Geom.Handle_Geom_BSplineCurve
        :type FromU1: float
        :type ToU2: float
        :type ParametricTolerance: float
        :type SameOrientation: bool
        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineCurve

        """
        return _GeomConvert.GeomConvert__SplitBSplineCurve(*args)

    SplitBSplineCurve = staticmethod(SplitBSplineCurve)

    def SplitBSplineSurface(*args):
        """
        SplitBSplineSurface(Handle_Geom_BSplineSurface S, Standard_Integer const FromUK1, Standard_Integer const ToUK2, Standard_Integer const FromVK1, Standard_Integer const ToVK2, Standard_Boolean const SameUOrientation, Standard_Boolean const SameVOrientation) -> Handle_Geom_BSplineSurface
        SplitBSplineSurface(Handle_Geom_BSplineSurface S, Standard_Integer const FromK1, Standard_Integer const ToK2, Standard_Boolean const USplit, Standard_Boolean const SameOrientation) -> Handle_Geom_BSplineSurface
        SplitBSplineSurface(Handle_Geom_BSplineSurface S, Standard_Real const FromU1, Standard_Real const ToU2, Standard_Real const FromV1, Standard_Real const ToV2, Standard_Real const ParametricTolerance, Standard_Boolean const SameUOrientation, Standard_Boolean const SameVOrientation) -> Handle_Geom_BSplineSurface
        SplitBSplineSurface(Handle_Geom_BSplineSurface S, Standard_Real const FromParam1, Standard_Real const ToParam2, Standard_Boolean const USplit, Standard_Real const ParametricTolerance, Standard_Boolean const SameOrientation) -> Handle_Geom_BSplineSurface

        This method splits the B-spline surface S in one direction
        between the parametric values FromParam1, ToParam2.
        If USplit = True then the Splitting direction is the U parametric
        direction else it is the V parametric direction.
        If S is periodic in the considered direction the patche has
        the same orientation as S in this direction if SameOrientation
        is true.
        If S is not periodic in the considered direction SameOrientation
        is not used for the computation and S is oriented FromParam1
        ToParam2.
        If U1 and U2 and two parametric values we consider that U1 = U2
        if Abs (U1 - U2) <= ParametricTolerance and ParametricTolerance
        must be greater or equal to Resolution from package gp.

        Raises if FromParam1 or ToParam2 are out of the parametric bounds
        of the surface in the considered direction.
        Raises if Abs (FromParam1 - ToParam2) <= ParametricTolerance.

        :type S: OCC.wrapper.Geom.Handle_Geom_BSplineSurface
        :type FromParam1: float
        :type ToParam2: float
        :type USplit: bool
        :type ParametricTolerance: float
        :type SameOrientation: bool
        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineSurface

        """
        return _GeomConvert.GeomConvert__SplitBSplineSurface(*args)

    SplitBSplineSurface = staticmethod(SplitBSplineSurface)

    def CurveToBSplineCurve(*args):
        """
        CurveToBSplineCurve(Handle_Geom_Curve C, Convert_ParameterisationType const Parameterisation=Convert_TgtThetaOver2) -> Handle_Geom_BSplineCurve

        This function converts a non infinite curve from
        Geom into a  B-spline curve.  C must be   an ellipse or  a
        circle  or a trimmed conic  or a trimmed  line or a Bezier
        curve or a trimmed  Bezier curve or a  BSpline curve or  a
        trimmed  BSpline curve or  an  OffsetCurve.  The returned  B-spline is
        not periodic except  if C is a Circle  or an  Ellipse.  If
        the  Parameterisation is  QuasiAngular than  the returned
        curve is NOT periodic  in case a  periodic Geom_Circle or
        Geom_Ellipse.  For TgtThetaOver2_1 and TgtThetaOver2_2 the
        method   raises  an exception  in    case  of a  periodic
        Geom_Circle or a Geom_Ellipse ParameterisationType applies
        only    if  the curve  is   a  Circle  or  an   ellipse :
        TgtThetaOver2,  -- TgtThetaOver2_1, -- TgtThetaOver2_2, --
        TgtThetaOver2_3, -- TgtThetaOver2_4,

        Purpose: this is the classical rational parameterisation
        2
        1 - t
        cos(theta) = ------
        2
        1 + t

        2t
        sin(theta) = ------
        2
        1 + t

        t = tan (theta/2)

        with TgtThetaOver2  the routine will compute the number of spans
        using the rule num_spans = [ (ULast - UFirst) / 1.2 ] + 1
        with TgtThetaOver2_N, N  spans will be forced: an error will
        be raized if (ULast - UFirst) >= PI and N = 1,
        ULast - UFirst >= 2 PI and N = 2

        QuasiAngular,
        here t is a rational function that approximates
        theta ----> tan(theta/2).
        Neverthless the composing with above function yields exact
        functions whose square sum up to 1
        RationalC1 ;
        t is replaced by a polynomial function of u so as to grant
        C1 contiuity across knots.
        Exceptions
        Standard_DomainError:
        -   if the curve C is infinite, or
        -   if C is a (complete) circle or ellipse, and Parameterisation is equal to
        Convert_TgtThetaOver2_1 or Convert_TgtThetaOver2_2.
        Standard_ConstructionError:
        -   if C is a (complete) circle or ellipse, and if Parameterisation is not equal to
        Convert_TgtThetaOver2, Convert_RationalC1,
        Convert_QuasiAngular (the curve is converted
        in these three cases) or to Convert_TgtThetaOver2_1 or
        Convert_TgtThetaOver2_2 (another exception is raised in these two cases).
        -   if C is a trimmed circle or ellipse, if Parameterisation is equal to
        Convert_TgtThetaOver2_1 and if U2 - U1 > 0.9999 * Pi, where U1 and U2 are
        respectively the first and the last parameters of the
        trimmed curve (this method of parameterization
        cannot be used to convert a half-circle or a half-ellipse, for example), or
        -   if C is a trimmed circle or ellipse, if
        Parameterisation is equal to Convert_TgtThetaOver2_2 and U2 - U1 >
        1.9999 * Pi where U1 and U2 are
        respectively the first and the last parameters of the
        trimmed curve (this method of parameterization
        cannot be used to convert a quasi-complete circle or ellipse).

        :type C: OCC.wrapper.Geom.Handle_Geom_Curve
        :type Parameterisation: OCC.wrapper.Convert.Convert_ParameterisationType
        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineCurve

        """
        return _GeomConvert.GeomConvert__CurveToBSplineCurve(*args)

    CurveToBSplineCurve = staticmethod(CurveToBSplineCurve)

    def SurfaceToBSplineSurface(*args):
        """
        SurfaceToBSplineSurface(Handle_Geom_Surface S) -> Handle_Geom_BSplineSurface

        This algorithm converts a non infinite surface from Geom
        into a B-spline surface.
        S must be a trimmed plane or a trimmed cylinder or a trimmed cone
        or a trimmed sphere or a trimmed torus or a sphere or a torus or
        a Bezier surface of a trimmed Bezier surface or a trimmed swept
        surface with a corresponding basis curve which can be turned into
        a B-spline curve   (see the method CurveToBSplineCurve).
        Raises DomainError if the type of the surface is not previously defined.

        :type S: OCC.wrapper.Geom.Handle_Geom_Surface
        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineSurface

        """
        return _GeomConvert.GeomConvert__SurfaceToBSplineSurface(*args)

    SurfaceToBSplineSurface = staticmethod(SurfaceToBSplineSurface)

    def ConcatG1(*args):
        """
        ConcatG1(NCollection_Array1_Handle_Geom_BSplineCurve ArrayOfCurves, NCollection_Array1_Standard_Real ArrayOfToler, Handle_TColGeom_HArray1OfBSplineCurve ArrayOfConcatenated, Standard_Boolean const ClosedG1Flag, Standard_Real const ClosedTolerance)

        This Method concatenates G1 the ArrayOfCurves as far
        as it  is possible.
        ArrayOfCurves[0..N-1]
        ArrayOfToler contains the  biggest tolerance of the two
        points shared by two consecutives curves.
        Its dimension: [0..N-2]
        ClosedG1     indicates if the ArrayOfCurves is closed.
        In this case ClosedG1 contains the biggest tolerance
        of the two points which are at the closure.
        Otherwise its value is 0.0

        :type ArrayOfCurves: OCC.wrapper.TColGeom.TColGeom_Array1OfBSplineCurve
        :type ArrayOfToler: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type ArrayOfConcatenated: OCC.wrapper.TColGeom.Handle_TColGeom_HArray1OfBSplineCurve
        :type ClosedG1Flag: bool
        :type ClosedTolerance: float

        """
        return _GeomConvert.GeomConvert__ConcatG1(*args)

    ConcatG1 = staticmethod(ConcatG1)

    def ConcatC1(*args):
        """
        ConcatC1(NCollection_Array1_Handle_Geom_BSplineCurve ArrayOfCurves, NCollection_Array1_Standard_Real ArrayOfToler, Handle_TColStd_HArray1OfInteger ArrayOfIndices, Handle_TColGeom_HArray1OfBSplineCurve ArrayOfConcatenated, Standard_Boolean const ClosedG1Flag, Standard_Real const ClosedTolerance)
        ConcatC1(NCollection_Array1_Handle_Geom_BSplineCurve ArrayOfCurves, NCollection_Array1_Standard_Real ArrayOfToler, Handle_TColStd_HArray1OfInteger ArrayOfIndices, Handle_TColGeom_HArray1OfBSplineCurve ArrayOfConcatenated, Standard_Boolean const ClosedG1Flag, Standard_Real const ClosedTolerance, Standard_Real const AngularTolerance)

        This Method concatenates C1 the ArrayOfCurves as far
        as it is possible.
        ArrayOfCurves[0..N-1]
        ArrayOfToler contains the  biggest tolerance of the two
        points shared by two consecutives curves.
        Its dimension: [0..N-2]
        ClosedG1     indicates if the ArrayOfCurves is closed.
        In this case ClosedG1 contains the biggest tolerance
        of the two points which are at the closure.
        Otherwise its value is 0.0

        :type ArrayOfCurves: OCC.wrapper.TColGeom.TColGeom_Array1OfBSplineCurve
        :type ArrayOfToler: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type ArrayOfIndices: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfInteger
        :type ArrayOfConcatenated: OCC.wrapper.TColGeom.Handle_TColGeom_HArray1OfBSplineCurve
        :type ClosedG1Flag: bool
        :type ClosedTolerance: float
        :type AngularTolerance: float

        """
        return _GeomConvert.GeomConvert__ConcatC1(*args)

    ConcatC1 = staticmethod(ConcatC1)

    def C0BSplineToC1BSplineCurve(*args):
        """
        C0BSplineToC1BSplineCurve(Handle_Geom_BSplineCurve BS, Standard_Real const tolerance, Standard_Real const AngularTolerance=1.0e-7)

        This  Method reduces as far as   it is possible the
        multiplicities of  the  knots of  the BSpline BS.(keeping  the
        geometry).  It returns a new BSpline which  could still be C0.
        tolerance is a  geometrical tolerance.
        The  Angular toleranceis in radians  and mesures  the angle of
        the tangents  on  the left and on  the right  to decide if  the
        curve is G1 or not at a given point

        :type BS: OCC.wrapper.Geom.Handle_Geom_BSplineCurve
        :type tolerance: float
        :type AngularTolerance: float

        """
        return _GeomConvert.GeomConvert__C0BSplineToC1BSplineCurve(*args)

    C0BSplineToC1BSplineCurve = staticmethod(C0BSplineToC1BSplineCurve)

    def C0BSplineToArrayOfC1BSplineCurve(*args):
        """
        C0BSplineToArrayOfC1BSplineCurve(Handle_Geom_BSplineCurve BS, Handle_TColGeom_HArray1OfBSplineCurve tabBS, Standard_Real const tolerance)
        C0BSplineToArrayOfC1BSplineCurve(Handle_Geom_BSplineCurve BS, Handle_TColGeom_HArray1OfBSplineCurve tabBS, Standard_Real const AngularTolerance, Standard_Real const tolerance)

        This   Method reduces as far   as it is  possible the
        multiplicities of  the  knots of  the  BSpline BS.(keeping the
        geometry).  It returns an array of BSpline C1.  tolerance is a
        geometrical tolerance : it  allows for the maximum deformation
        The  Angular tolerance is in  radians and mesures the angle of
        the tangents on the left and on the right to decide if the curve
        is C1 or not at a given point

        :type BS: OCC.wrapper.Geom.Handle_Geom_BSplineCurve
        :type tabBS: OCC.wrapper.TColGeom.Handle_TColGeom_HArray1OfBSplineCurve
        :type AngularTolerance: float
        :type tolerance: float

        """
        return _GeomConvert.GeomConvert__C0BSplineToArrayOfC1BSplineCurve(*args)

    C0BSplineToArrayOfC1BSplineCurve = staticmethod(C0BSplineToArrayOfC1BSplineCurve)

    def __init__(self):
        """
        The GeomConvert package provides some global functions as follows
        -   converting classical Geom curves into BSpline curves,
        -   segmenting BSpline curves, particularly at knots
        values: this function may be used in conjunction with the
        GeomConvert_BSplineCurveKnotSplitting
        class to segment a BSpline curve into arcs which
        comply with required continuity levels,
        -   converting classical Geom surfaces into BSpline surfaces, and
        -   segmenting BSpline surfaces, particularly at
        knots values: this function may be used in conjunction with the
        GeomConvert_BSplineSurfaceKnotSplitting
        class to segment a BSpline surface into patches
        which comply with required continuity levels.
        All geometric entities used in this package are bounded.

        References :
        . Generating the Bezier Points of B-spline curves and surfaces
        (Wolfgang Bohm) CAGD volume 13 number 6 november 1981
        . On NURBS: A Survey  (Leslie Piegl) IEEE Computer Graphics and
        Application January 1991
        . Curve and surface construction using rational B-splines
        (Leslie Piegl and Wayne Tiller) CAD Volume 19 number 9 november
        1987
        . A survey of curve and surface methods in CAGD (Wolfgang BOHM)
        CAGD 1 1984
        """
        this = _GeomConvert.new_GeomConvert_()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _GeomConvert.delete_GeomConvert_
GeomConvert__swigregister = _GeomConvert.GeomConvert__swigregister
GeomConvert__swigregister(GeomConvert_)

def GeomConvert__SplitBSplineCurve(*args):
    """
    SplitBSplineCurve(Handle_Geom_BSplineCurve C, Standard_Integer const FromK1, Standard_Integer const ToK2, Standard_Boolean const SameOrientation) -> Handle_Geom_BSplineCurve
    GeomConvert__SplitBSplineCurve(Handle_Geom_BSplineCurve C, Standard_Real const FromU1, Standard_Real const ToU2, Standard_Real const ParametricTolerance, Standard_Boolean const SameOrientation) -> Handle_Geom_BSplineCurve

    This function computes the segment of B-spline curve between the
    parametric values FromU1, ToU2.
    If C is periodic the arc has the same orientation as C if
    SameOrientation = True.
    If C is not periodic SameOrientation is not used for the
    computation and C is oriented fromU1 toU2.
    If U1 and U2 and two parametric values we consider that
    U1 = U2 if Abs (U1 - U2) <= ParametricTolerance and
    ParametricTolerance must  be greater or equal to Resolution
    from package gp.

    Raised if FromU1 or ToU2 are out of the parametric bounds of the
    curve (The tolerance criterion is ParametricTolerance).
    Raised if Abs (FromU1 - ToU2) <= ParametricTolerance
    Raised if ParametricTolerance < Resolution from gp.

    :type C: OCC.wrapper.Geom.Handle_Geom_BSplineCurve
    :type FromU1: float
    :type ToU2: float
    :type ParametricTolerance: float
    :type SameOrientation: bool
    :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineCurve

    """
    return _GeomConvert.GeomConvert__SplitBSplineCurve(*args)

def GeomConvert__SplitBSplineSurface(*args):
    """
    SplitBSplineSurface(Handle_Geom_BSplineSurface S, Standard_Integer const FromUK1, Standard_Integer const ToUK2, Standard_Integer const FromVK1, Standard_Integer const ToVK2, Standard_Boolean const SameUOrientation, Standard_Boolean const SameVOrientation) -> Handle_Geom_BSplineSurface
    SplitBSplineSurface(Handle_Geom_BSplineSurface S, Standard_Integer const FromK1, Standard_Integer const ToK2, Standard_Boolean const USplit, Standard_Boolean const SameOrientation) -> Handle_Geom_BSplineSurface
    SplitBSplineSurface(Handle_Geom_BSplineSurface S, Standard_Real const FromU1, Standard_Real const ToU2, Standard_Real const FromV1, Standard_Real const ToV2, Standard_Real const ParametricTolerance, Standard_Boolean const SameUOrientation, Standard_Boolean const SameVOrientation) -> Handle_Geom_BSplineSurface
    GeomConvert__SplitBSplineSurface(Handle_Geom_BSplineSurface S, Standard_Real const FromParam1, Standard_Real const ToParam2, Standard_Boolean const USplit, Standard_Real const ParametricTolerance, Standard_Boolean const SameOrientation) -> Handle_Geom_BSplineSurface

    This method splits the B-spline surface S in one direction
    between the parametric values FromParam1, ToParam2.
    If USplit = True then the Splitting direction is the U parametric
    direction else it is the V parametric direction.
    If S is periodic in the considered direction the patche has
    the same orientation as S in this direction if SameOrientation
    is true.
    If S is not periodic in the considered direction SameOrientation
    is not used for the computation and S is oriented FromParam1
    ToParam2.
    If U1 and U2 and two parametric values we consider that U1 = U2
    if Abs (U1 - U2) <= ParametricTolerance and ParametricTolerance
    must be greater or equal to Resolution from package gp.

    Raises if FromParam1 or ToParam2 are out of the parametric bounds
    of the surface in the considered direction.
    Raises if Abs (FromParam1 - ToParam2) <= ParametricTolerance.

    :type S: OCC.wrapper.Geom.Handle_Geom_BSplineSurface
    :type FromParam1: float
    :type ToParam2: float
    :type USplit: bool
    :type ParametricTolerance: float
    :type SameOrientation: bool
    :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineSurface

    """
    return _GeomConvert.GeomConvert__SplitBSplineSurface(*args)

def GeomConvert__CurveToBSplineCurve(*args):
    """
    GeomConvert__CurveToBSplineCurve(Handle_Geom_Curve C, Convert_ParameterisationType const Parameterisation=Convert_TgtThetaOver2) -> Handle_Geom_BSplineCurve

    This function converts a non infinite curve from
    Geom into a  B-spline curve.  C must be   an ellipse or  a
    circle  or a trimmed conic  or a trimmed  line or a Bezier
    curve or a trimmed  Bezier curve or a  BSpline curve or  a
    trimmed  BSpline curve or  an  OffsetCurve.  The returned  B-spline is
    not periodic except  if C is a Circle  or an  Ellipse.  If
    the  Parameterisation is  QuasiAngular than  the returned
    curve is NOT periodic  in case a  periodic Geom_Circle or
    Geom_Ellipse.  For TgtThetaOver2_1 and TgtThetaOver2_2 the
    method   raises  an exception  in    case  of a  periodic
    Geom_Circle or a Geom_Ellipse ParameterisationType applies
    only    if  the curve  is   a  Circle  or  an   ellipse :
    TgtThetaOver2,  -- TgtThetaOver2_1, -- TgtThetaOver2_2, --
    TgtThetaOver2_3, -- TgtThetaOver2_4,

    Purpose: this is the classical rational parameterisation
    2
    1 - t
    cos(theta) = ------
    2
    1 + t

    2t
    sin(theta) = ------
    2
    1 + t

    t = tan (theta/2)

    with TgtThetaOver2  the routine will compute the number of spans
    using the rule num_spans = [ (ULast - UFirst) / 1.2 ] + 1
    with TgtThetaOver2_N, N  spans will be forced: an error will
    be raized if (ULast - UFirst) >= PI and N = 1,
    ULast - UFirst >= 2 PI and N = 2

    QuasiAngular,
    here t is a rational function that approximates
    theta ----> tan(theta/2).
    Neverthless the composing with above function yields exact
    functions whose square sum up to 1
    RationalC1 ;
    t is replaced by a polynomial function of u so as to grant
    C1 contiuity across knots.
    Exceptions
    Standard_DomainError:
    -   if the curve C is infinite, or
    -   if C is a (complete) circle or ellipse, and Parameterisation is equal to
    Convert_TgtThetaOver2_1 or Convert_TgtThetaOver2_2.
    Standard_ConstructionError:
    -   if C is a (complete) circle or ellipse, and if Parameterisation is not equal to
    Convert_TgtThetaOver2, Convert_RationalC1,
    Convert_QuasiAngular (the curve is converted
    in these three cases) or to Convert_TgtThetaOver2_1 or
    Convert_TgtThetaOver2_2 (another exception is raised in these two cases).
    -   if C is a trimmed circle or ellipse, if Parameterisation is equal to
    Convert_TgtThetaOver2_1 and if U2 - U1 > 0.9999 * Pi, where U1 and U2 are
    respectively the first and the last parameters of the
    trimmed curve (this method of parameterization
    cannot be used to convert a half-circle or a half-ellipse, for example), or
    -   if C is a trimmed circle or ellipse, if
    Parameterisation is equal to Convert_TgtThetaOver2_2 and U2 - U1 >
    1.9999 * Pi where U1 and U2 are
    respectively the first and the last parameters of the
    trimmed curve (this method of parameterization
    cannot be used to convert a quasi-complete circle or ellipse).

    :type C: OCC.wrapper.Geom.Handle_Geom_Curve
    :type Parameterisation: OCC.wrapper.Convert.Convert_ParameterisationType
    :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineCurve

    """
    return _GeomConvert.GeomConvert__CurveToBSplineCurve(*args)

def GeomConvert__SurfaceToBSplineSurface(*args):
    """
    GeomConvert__SurfaceToBSplineSurface(Handle_Geom_Surface S) -> Handle_Geom_BSplineSurface

    This algorithm converts a non infinite surface from Geom
    into a B-spline surface.
    S must be a trimmed plane or a trimmed cylinder or a trimmed cone
    or a trimmed sphere or a trimmed torus or a sphere or a torus or
    a Bezier surface of a trimmed Bezier surface or a trimmed swept
    surface with a corresponding basis curve which can be turned into
    a B-spline curve   (see the method CurveToBSplineCurve).
    Raises DomainError if the type of the surface is not previously defined.

    :type S: OCC.wrapper.Geom.Handle_Geom_Surface
    :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineSurface

    """
    return _GeomConvert.GeomConvert__SurfaceToBSplineSurface(*args)

def GeomConvert__ConcatG1(*args):
    """
    GeomConvert__ConcatG1(NCollection_Array1_Handle_Geom_BSplineCurve ArrayOfCurves, NCollection_Array1_Standard_Real ArrayOfToler, Handle_TColGeom_HArray1OfBSplineCurve ArrayOfConcatenated, Standard_Boolean const ClosedG1Flag, Standard_Real const ClosedTolerance)

    This Method concatenates G1 the ArrayOfCurves as far
    as it  is possible.
    ArrayOfCurves[0..N-1]
    ArrayOfToler contains the  biggest tolerance of the two
    points shared by two consecutives curves.
    Its dimension: [0..N-2]
    ClosedG1     indicates if the ArrayOfCurves is closed.
    In this case ClosedG1 contains the biggest tolerance
    of the two points which are at the closure.
    Otherwise its value is 0.0

    :type ArrayOfCurves: OCC.wrapper.TColGeom.TColGeom_Array1OfBSplineCurve
    :type ArrayOfToler: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type ArrayOfConcatenated: OCC.wrapper.TColGeom.Handle_TColGeom_HArray1OfBSplineCurve
    :type ClosedG1Flag: bool
    :type ClosedTolerance: float

    """
    return _GeomConvert.GeomConvert__ConcatG1(*args)

def GeomConvert__ConcatC1(*args):
    """
    ConcatC1(NCollection_Array1_Handle_Geom_BSplineCurve ArrayOfCurves, NCollection_Array1_Standard_Real ArrayOfToler, Handle_TColStd_HArray1OfInteger ArrayOfIndices, Handle_TColGeom_HArray1OfBSplineCurve ArrayOfConcatenated, Standard_Boolean const ClosedG1Flag, Standard_Real const ClosedTolerance)
    GeomConvert__ConcatC1(NCollection_Array1_Handle_Geom_BSplineCurve ArrayOfCurves, NCollection_Array1_Standard_Real ArrayOfToler, Handle_TColStd_HArray1OfInteger ArrayOfIndices, Handle_TColGeom_HArray1OfBSplineCurve ArrayOfConcatenated, Standard_Boolean const ClosedG1Flag, Standard_Real const ClosedTolerance, Standard_Real const AngularTolerance)

    This Method concatenates C1 the ArrayOfCurves as far
    as it is possible.
    ArrayOfCurves[0..N-1]
    ArrayOfToler contains the  biggest tolerance of the two
    points shared by two consecutives curves.
    Its dimension: [0..N-2]
    ClosedG1     indicates if the ArrayOfCurves is closed.
    In this case ClosedG1 contains the biggest tolerance
    of the two points which are at the closure.
    Otherwise its value is 0.0

    :type ArrayOfCurves: OCC.wrapper.TColGeom.TColGeom_Array1OfBSplineCurve
    :type ArrayOfToler: OCC.wrapper.TColStd.TColStd_Array1OfReal
    :type ArrayOfIndices: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfInteger
    :type ArrayOfConcatenated: OCC.wrapper.TColGeom.Handle_TColGeom_HArray1OfBSplineCurve
    :type ClosedG1Flag: bool
    :type ClosedTolerance: float
    :type AngularTolerance: float

    """
    return _GeomConvert.GeomConvert__ConcatC1(*args)

def GeomConvert__C0BSplineToC1BSplineCurve(*args):
    """
    GeomConvert__C0BSplineToC1BSplineCurve(Handle_Geom_BSplineCurve BS, Standard_Real const tolerance, Standard_Real const AngularTolerance=1.0e-7)

    This  Method reduces as far as   it is possible the
    multiplicities of  the  knots of  the BSpline BS.(keeping  the
    geometry).  It returns a new BSpline which  could still be C0.
    tolerance is a  geometrical tolerance.
    The  Angular toleranceis in radians  and mesures  the angle of
    the tangents  on  the left and on  the right  to decide if  the
    curve is G1 or not at a given point

    :type BS: OCC.wrapper.Geom.Handle_Geom_BSplineCurve
    :type tolerance: float
    :type AngularTolerance: float

    """
    return _GeomConvert.GeomConvert__C0BSplineToC1BSplineCurve(*args)

def GeomConvert__C0BSplineToArrayOfC1BSplineCurve(*args):
    """
    C0BSplineToArrayOfC1BSplineCurve(Handle_Geom_BSplineCurve BS, Handle_TColGeom_HArray1OfBSplineCurve tabBS, Standard_Real const tolerance)
    GeomConvert__C0BSplineToArrayOfC1BSplineCurve(Handle_Geom_BSplineCurve BS, Handle_TColGeom_HArray1OfBSplineCurve tabBS, Standard_Real const AngularTolerance, Standard_Real const tolerance)

    This   Method reduces as far   as it is  possible the
    multiplicities of  the  knots of  the  BSpline BS.(keeping the
    geometry).  It returns an array of BSpline C1.  tolerance is a
    geometrical tolerance : it  allows for the maximum deformation
    The  Angular tolerance is in  radians and mesures the angle of
    the tangents on the left and on the right to decide if the curve
    is C1 or not at a given point

    :type BS: OCC.wrapper.Geom.Handle_Geom_BSplineCurve
    :type tabBS: OCC.wrapper.TColGeom.Handle_TColGeom_HArray1OfBSplineCurve
    :type AngularTolerance: float
    :type tolerance: float

    """
    return _GeomConvert.GeomConvert__C0BSplineToArrayOfC1BSplineCurve(*args)

class GeomConvert_BSplineSurfaceToBezierSurface(object):
    """
    This algorithm converts a B-spline surface into several
    Bezier surfaces. It uses an algorithm of knot insertion.
    A BSplineSurfaceToBezierSurface object provides a framework for:
    -   defining the BSpline surface to be converted,
    -   implementing the construction algorithm, and
    -   consulting the results.
    References :
    Generating the Bezier points of B-spline curves and surfaces
    (Wolfgang Bohm) CAD volume 13 number 6 november 1981
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomConvert_BSplineSurfaceToBezierSurface self, Handle_Geom_BSplineSurface BasisSurface) -> GeomConvert_BSplineSurfaceToBezierSurface
        __init__(GeomConvert_BSplineSurfaceToBezierSurface self, Handle_Geom_BSplineSurface BasisSurface, Standard_Real const U1, Standard_Real const U2, Standard_Real const V1, Standard_Real const V2, Standard_Real const ParametricTolerance) -> GeomConvert_BSplineSurfaceToBezierSurface

        Computes all the data needed to convert
        the patch of the BSpline surface BasisSurface
        limited by the two parameter values U1 and U2 in
        the u parametric direction, and by the two
        parameter values V1 and V2 in the v parametric
        direction, into a series of adjacent Bezier surfaces.
        The result consists of a grid of BasisSurface patches
        limited by isoparametric curves corresponding to knot
        values, both in the u and v parametric directions of
        the surface. A row in the grid corresponds to a series
        of adjacent patches, all limited by the same two
        u-isoparametric curves. A column in the grid
        corresponds to a series of adjacent patches, all
        limited by the same two v-isoparametric curves.
        Use the available interrogation functions to ascertain
        the number of computed Bezier patches, and then to
        construct each individual Bezier surface (or all Bezier surfaces).
        Note: ParametricTolerance is not used.  Raises DomainError
        if U1 or U2 or V1 or V2 are out of the parametric bounds
        of the basis surface [FirstUKnotIndex, LastUKnotIndex] ,
        [FirstVKnotIndex, LastVKnotIndex] The tolerance criterion is
        ParametricTolerance.
        Raised if U2 - U1 <= ParametricTolerance or
        V2 - V1 <= ParametricTolerance.

        :type BasisSurface: OCC.wrapper.Geom.Handle_Geom_BSplineSurface
        :type U1: float
        :type U2: float
        :type V1: float
        :type V2: float
        :type ParametricTolerance: float

        """
        this = _GeomConvert.new_GeomConvert_BSplineSurfaceToBezierSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Patch(self, *args):
        """
        Patch(GeomConvert_BSplineSurfaceToBezierSurface self, Standard_Integer const UIndex, Standard_Integer const VIndex) -> Handle_Geom_BezierSurface

        Constructs and returns the Bezier surface of indices
        (UIndex, VIndex) to the patch grid computed on the
        BSpline surface analyzed by this algorithm.
        This Bezier surface has the same orientation as the
        BSpline surface analyzed in this framework.
        UIndex is an index common to a row in the patch
        grid. A row in the grid corresponds to a series of
        adjacent patches, all limited by the same two
        u-isoparametric curves of the surface. VIndex is an
        index common to a column in the patch grid. A column
        in the grid corresponds to a series of adjacent
        patches, all limited by the same two v-isoparametric
        curves of the surface.
        Exceptions
        Standard_OutOfRange if:
        -   UIndex is less than 1 or greater than the number
        of rows in the patch grid computed on the BSpline
        surface analyzed by this algorithm (as returned by
        the function NbUPatches); or if
        -   VIndex is less than 1 or greater than the number
        of columns in the patch grid computed on the
        BSpline surface analyzed by this algorithm (as
        returned by the function NbVPatches).

        :type UIndex: int
        :type VIndex: int
        :rtype: OCC.wrapper.Geom.Handle_Geom_BezierSurface

        """
        return _GeomConvert.GeomConvert_BSplineSurfaceToBezierSurface_Patch(self, *args)


    def Patches(self, *args):
        """
        Patches(GeomConvert_BSplineSurfaceToBezierSurface self, NCollection_Array2_Handle_Geom_BezierSurface Surfaces)

        Constructs all the Bezier surfaces whose data is
        computed by this algorithm, and loads them into the Surfaces table.
        These Bezier surfaces have the same orientation as
        the BSpline surface analyzed in this framework.
        The Surfaces array is organised in the same way as
        the patch grid computed on the BSpline surface
        analyzed by this algorithm. A row in the array
        corresponds to a series of adjacent patches, all
        limited by the same two u-isoparametric curves of
        the surface. A column in the array corresponds to a
        series of adjacent patches, all limited by the same two
        v-isoparametric curves of the surface.
        Exceptions
        Standard_DimensionError if the Surfaces array
        was not created with the following bounds:
        -   1, and the number of adjacent patch series in the
        u parametric direction of the patch grid computed
        on the BSpline surface, analyzed by this algorithm
        (as given by the function NbUPatches) as row bounds,
        -   1, and the number of adjacent patch series in the
        v parametric direction of the patch grid computed
        on the BSpline surface, analyzed by this algorithm
        (as given by the function NbVPatches) as column bounds.

        :type Surfaces: OCC.wrapper.TColGeom.TColGeom_Array2OfBezierSurface

        """
        return _GeomConvert.GeomConvert_BSplineSurfaceToBezierSurface_Patches(self, *args)


    def UKnots(self, *args):
        """
        UKnots(GeomConvert_BSplineSurfaceToBezierSurface self, NCollection_Array1_Standard_Real TKnots)

        This methode returns the bspline's u-knots associated to
        the converted Patches
        Raised  if the length  of Curves is not equal to
        NbUPatches +  1.

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomConvert.GeomConvert_BSplineSurfaceToBezierSurface_UKnots(self, *args)


    def VKnots(self, *args):
        """
        VKnots(GeomConvert_BSplineSurfaceToBezierSurface self, NCollection_Array1_Standard_Real TKnots)

        This methode returns the bspline's v-knots associated to
        the converted Patches
        Raised  if the length  of Curves is not equal to
        NbVPatches +  1.

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomConvert.GeomConvert_BSplineSurfaceToBezierSurface_VKnots(self, *args)


    def NbUPatches(self, *args):
        """
        NbUPatches(GeomConvert_BSplineSurfaceToBezierSurface self) -> Standard_Integer

        Returns the number of Bezier surfaces in the U direction.
        If at the creation time you have decomposed the basis Surface
        between the parametric values UFirst, ULast the number of
        Bezier surfaces in the U direction depends on the number of
        knots included inside the interval [UFirst, ULast].
        If you have decomposed the whole basis B-spline surface the
        number of Bezier surfaces NbUPatches is equal to the number of
        UKnots less one.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomConvert.GeomConvert_BSplineSurfaceToBezierSurface_NbUPatches(self, *args)


    def NbVPatches(self, *args):
        """
        NbVPatches(GeomConvert_BSplineSurfaceToBezierSurface self) -> Standard_Integer

        Returns the number of Bezier surfaces in the V direction.
        If at the creation time you have decomposed the basis surface
        between the parametric values VFirst, VLast the number of
        Bezier surfaces in the V direction depends on the number of
        knots included inside the interval [VFirst, VLast].
        If you have decomposed the whole basis B-spline surface the
        number of Bezier surfaces NbVPatches is equal to the number of
        VKnots less one.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomConvert.GeomConvert_BSplineSurfaceToBezierSurface_NbVPatches(self, *args)

    __swig_destroy__ = _GeomConvert.delete_GeomConvert_BSplineSurfaceToBezierSurface
GeomConvert_BSplineSurfaceToBezierSurface_swigregister = _GeomConvert.GeomConvert_BSplineSurfaceToBezierSurface_swigregister
GeomConvert_BSplineSurfaceToBezierSurface_swigregister(GeomConvert_BSplineSurfaceToBezierSurface)

class GeomConvert_ApproxCurve(object):
    """
    A framework to convert a 3D curve to a 3D BSpline.
    This is done by approximation to a BSpline curve within a given tolerance.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomConvert_ApproxCurve self, Handle_Geom_Curve Curve, Standard_Real const Tol3d, GeomAbs_Shape const Order, Standard_Integer const MaxSegments, Standard_Integer const MaxDegree) -> GeomConvert_ApproxCurve
        __init__(GeomConvert_ApproxCurve self, Handle_Adaptor3d_HCurve Curve, Standard_Real const Tol3d, GeomAbs_Shape const Order, Standard_Integer const MaxSegments, Standard_Integer const MaxDegree) -> GeomConvert_ApproxCurve

        Constructs a curve approximation framework defined by -
        -      the Curve,
        -      the tolerance value Tol3d,
        -      the degree of continuity Order,
        -      the maximum number of segments
        MaxSegments allowed in the resulting BSpline curve, and
        -      the highest degree MaxDeg which the
        polynomial defining the BSpline curve may have.

        :type Curve: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HCurve
        :type Tol3d: float
        :type Order: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type MaxSegments: int
        :type MaxDegree: int

        """
        this = _GeomConvert.new_GeomConvert_ApproxCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Curve(self, *args):
        """
        Curve(GeomConvert_ApproxCurve self) -> Handle_Geom_BSplineCurve

        Returns the BSpline curve resulting from the approximation algorithm.

        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineCurve

        """
        return _GeomConvert.GeomConvert_ApproxCurve_Curve(self, *args)


    def IsDone(self, *args):
        """
        IsDone(GeomConvert_ApproxCurve self) -> Standard_Boolean

        returns  Standard_True  if  the  approximation  has
        been  done  within  requiered tolerance

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomConvert.GeomConvert_ApproxCurve_IsDone(self, *args)


    def HasResult(self, *args):
        """
        HasResult(GeomConvert_ApproxCurve self) -> Standard_Boolean

        Returns  Standard_True if the approximation did come out
        with a result that  is not NECESSARELY within the required tolerance

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomConvert.GeomConvert_ApproxCurve_HasResult(self, *args)


    def MaxError(self, *args):
        """
        MaxError(GeomConvert_ApproxCurve self) -> Standard_Real

        Returns the greatest distance between a point on the
        source conic and the BSpline curve resulting from the
        approximation. (>0 when an approximation
        has  been  done, 0  if  no  approximation)

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomConvert.GeomConvert_ApproxCurve_MaxError(self, *args)


    def Dump(self, *args):
        """
        Dump(GeomConvert_ApproxCurve self, Standard_OStream & o)

        Print on the stream  o  information about the object

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _GeomConvert.GeomConvert_ApproxCurve_Dump(self, *args)

    __swig_destroy__ = _GeomConvert.delete_GeomConvert_ApproxCurve
GeomConvert_ApproxCurve_swigregister = _GeomConvert.GeomConvert_ApproxCurve_swigregister
GeomConvert_ApproxCurve_swigregister(GeomConvert_ApproxCurve)

class GeomConvert_BSplineCurveToBezierCurve(object):
    """
    An algorithm to convert a BSpline curve into a series
    of adjacent Bezier curves.
    A BSplineCurveToBezierCurve object provides a framework for:
    -   defining the BSpline curve to be converted
    -   implementing the construction algorithm, and
    -   consulting the results.
    References :
    Generating the Bezier points of B-spline curves and surfaces
    (Wolfgang Bohm) CAD volume 13 number 6 november 1981
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomConvert_BSplineCurveToBezierCurve self, Handle_Geom_BSplineCurve BasisCurve) -> GeomConvert_BSplineCurveToBezierCurve
        __init__(GeomConvert_BSplineCurveToBezierCurve self, Handle_Geom_BSplineCurve BasisCurve, Standard_Real const U1, Standard_Real const U2, Standard_Real const ParametricTolerance) -> GeomConvert_BSplineCurveToBezierCurve

        Computes all the data needed to convert
        the portion of the BSpline curve BasisCurve
        limited by the two parameter values U1 and U2 into a series of adjacent Bezier arcs.
        The result consists of a series of BasisCurve arcs
        limited by points corresponding to knot values of the curve.
        Use the available interrogation functions to ascertain
        the number of computed Bezier arcs, and then to
        construct each individual Bezier curve (or all Bezier curves).
        Note: ParametricTolerance is not used.
        Raises DomainError if U1 or U2 are out of the parametric bounds of the basis
        curve [FirstParameter, LastParameter]. The Tolerance criterion
        is ParametricTolerance.
        Raised if Abs (U2 - U1) <= ParametricTolerance.

        :type BasisCurve: OCC.wrapper.Geom.Handle_Geom_BSplineCurve
        :type U1: float
        :type U2: float
        :type ParametricTolerance: float

        """
        this = _GeomConvert.new_GeomConvert_BSplineCurveToBezierCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Arc(self, *args):
        """
        Arc(GeomConvert_BSplineCurveToBezierCurve self, Standard_Integer const Index) -> Handle_Geom_BezierCurve

        Constructs and returns the Bezier curve of index
        Index to the table of adjacent Bezier arcs
        computed by this algorithm.
        This Bezier curve has the same orientation as the
        BSpline curve analyzed in this framework.
        Exceptions
        Standard_OutOfRange if Index is less than 1 or
        greater than the number of adjacent Bezier arcs
        computed by this algorithm.

        :type Index: int
        :rtype: OCC.wrapper.Geom.Handle_Geom_BezierCurve

        """
        return _GeomConvert.GeomConvert_BSplineCurveToBezierCurve_Arc(self, *args)


    def Arcs(self, *args):
        """
        Arcs(GeomConvert_BSplineCurveToBezierCurve self, NCollection_Array1_Handle_Geom_BezierCurve Curves)

        Constructs all the Bezier curves whose data is
        computed by this algorithm and loads these curves into the Curves table.
        The Bezier curves have the same orientation as the
        BSpline curve analyzed in this framework.
        Exceptions
        Standard_DimensionError if the Curves array was
        not created with the following bounds:
        -   1 , and
        -   the number of adjacent Bezier arcs computed by
        this algorithm (as given by the function NbArcs).

        :type Curves: OCC.wrapper.TColGeom.TColGeom_Array1OfBezierCurve

        """
        return _GeomConvert.GeomConvert_BSplineCurveToBezierCurve_Arcs(self, *args)


    def Knots(self, *args):
        """
        Knots(GeomConvert_BSplineCurveToBezierCurve self, NCollection_Array1_Standard_Real TKnots)

        This methode returns the bspline's knots associated to
        the converted arcs
        Raised  if the length  of Curves is not equal to
        NbArcs +  1.

        :type TKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal

        """
        return _GeomConvert.GeomConvert_BSplineCurveToBezierCurve_Knots(self, *args)


    def NbArcs(self, *args):
        """
        NbArcs(GeomConvert_BSplineCurveToBezierCurve self) -> Standard_Integer

        Returns the number of BezierCurve arcs.
        If at the creation time you have decomposed the basis curve
        between the parametric values UFirst, ULast the number of
        BezierCurve arcs depends on the number of knots included inside
        the interval [UFirst, ULast].
        If you have decomposed the whole basis B-spline curve the number
        of BezierCurve arcs NbArcs is equal to the number of knots less
        one.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomConvert.GeomConvert_BSplineCurveToBezierCurve_NbArcs(self, *args)

    __swig_destroy__ = _GeomConvert.delete_GeomConvert_BSplineCurveToBezierCurve
GeomConvert_BSplineCurveToBezierCurve_swigregister = _GeomConvert.GeomConvert_BSplineCurveToBezierCurve_swigregister
GeomConvert_BSplineCurveToBezierCurve_swigregister(GeomConvert_BSplineCurveToBezierCurve)

class GeomConvert_ApproxSurface(object):
    """
    A framework to convert a surface to a BSpline
    surface. This is done by approximation to a BSpline
    surface within a given tolerance.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomConvert_ApproxSurface self, Handle_Geom_Surface Surf, Standard_Real const Tol3d, GeomAbs_Shape const UContinuity, GeomAbs_Shape const VContinuity, Standard_Integer const MaxDegU, Standard_Integer const MaxDegV, Standard_Integer const MaxSegments, Standard_Integer const PrecisCode) -> GeomConvert_ApproxSurface
        __init__(GeomConvert_ApproxSurface self, Handle_Adaptor3d_HSurface Surf, Standard_Real const Tol3d, GeomAbs_Shape const UContinuity, GeomAbs_Shape const VContinuity, Standard_Integer const MaxDegU, Standard_Integer const MaxDegV, Standard_Integer const MaxSegments, Standard_Integer const PrecisCode) -> GeomConvert_ApproxSurface

        Constructs a surface approximation framework defined by
        -   the Surf
        -   the tolerance value Tol3d
        -   the degree of continuity UContinuity, VContinuity
        in the directions of the U and V parameters
        -   the highest degree MaxDegU, MaxDegV which
        the polynomial defining the BSpline curve may
        have in the directions of the U and V parameters
        -   the maximum number of segments MaxSegments
        allowed in the resulting BSpline curve
        -   the index of precision PrecisCode.

        :type Surf: OCC.wrapper.Adaptor3d.Handle_Adaptor3d_HSurface
        :type Tol3d: float
        :type UContinuity: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type VContinuity: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type MaxDegU: int
        :type MaxDegV: int
        :type MaxSegments: int
        :type PrecisCode: int

        """
        this = _GeomConvert.new_GeomConvert_ApproxSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Surface(self, *args):
        """
        Surface(GeomConvert_ApproxSurface self) -> Handle_Geom_BSplineSurface

        Returns the BSpline surface resulting from the approximation algorithm.

        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineSurface

        """
        return _GeomConvert.GeomConvert_ApproxSurface_Surface(self, *args)


    def IsDone(self, *args):
        """
        IsDone(GeomConvert_ApproxSurface self) -> Standard_Boolean

        Returns Standard_True if the approximation has be done

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomConvert.GeomConvert_ApproxSurface_IsDone(self, *args)


    def HasResult(self, *args):
        """
        HasResult(GeomConvert_ApproxSurface self) -> Standard_Boolean

        Returns true if the approximation did come out with a result that
        is not NECESSARILY within the required tolerance or a result
        that is not recognized with the wished continuities.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomConvert.GeomConvert_ApproxSurface_HasResult(self, *args)


    def MaxError(self, *args):
        """
        MaxError(GeomConvert_ApproxSurface self) -> Standard_Real

        Returns the greatest distance between a point on the
        source conic surface and the BSpline surface
        resulting from the approximation (>0 when an approximation
        has been done, 0 if no  approximation )

        :rtype: OCC.wrapper.Standard.Standard_Real

        """
        return _GeomConvert.GeomConvert_ApproxSurface_MaxError(self, *args)


    def Dump(self, *args):
        """
        Dump(GeomConvert_ApproxSurface self, Standard_OStream & o)

        Prints on the stream o informations on the current state of the object.

        :type o: OCC.wrapper.Standard.Standard_OStream

        """
        return _GeomConvert.GeomConvert_ApproxSurface_Dump(self, *args)

    __swig_destroy__ = _GeomConvert.delete_GeomConvert_ApproxSurface
GeomConvert_ApproxSurface_swigregister = _GeomConvert.GeomConvert_ApproxSurface_swigregister
GeomConvert_ApproxSurface_swigregister(GeomConvert_ApproxSurface)

class GeomConvert_CompCurveToBSplineCurve(object):
    """Algorithm converts and concat several curve in an BSplineCurve"""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomConvert_CompCurveToBSplineCurve self, Convert_ParameterisationType const Parameterisation=Convert_TgtThetaOver2) -> GeomConvert_CompCurveToBSplineCurve
        __init__(GeomConvert_CompCurveToBSplineCurve self, Handle_Geom_BoundedCurve BasisCurve, Convert_ParameterisationType const Parameterisation=Convert_TgtThetaOver2) -> GeomConvert_CompCurveToBSplineCurve

        Initialize the algorithme with one curve
        - Parameterisation is used to convert

        :type BasisCurve: OCC.wrapper.Geom.Handle_Geom_BoundedCurve
        :type Parameterisation: OCC.wrapper.Convert.Convert_ParameterisationType

        """
        this = _GeomConvert.new_GeomConvert_CompCurveToBSplineCurve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Add(self, *args):
        """
        Add(GeomConvert_CompCurveToBSplineCurve self, Handle_Geom_BoundedCurve NewCurve, Standard_Real const Tolerance, Standard_Boolean const After, Standard_Boolean const WithRatio, Standard_Integer const MinM=0) -> Standard_Boolean

        Append a curve in  the BSpline Return False if the
        curve is not G0  with the BSplineCurve.  Tolerance
        is   used to   check   continuity  and decrease
        Multiplicity at the common Knot until MinM
        if MinM = 0, the common Knot can be removed

        WithRatio defines whether the resulting curve should have a uniform
        parameterization. Setting WithRatio to Standard_False may greatly
        decrease the speed of algorithms like CPnts_AbscissaPoint::AdvPerform
        when applied to the resulting curve.

        :type NewCurve: OCC.wrapper.Geom.Handle_Geom_BoundedCurve
        :type Tolerance: float
        :type After: bool
        :type WithRatio: bool
        :type MinM: int
        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomConvert.GeomConvert_CompCurveToBSplineCurve_Add(self, *args)


    def BSplineCurve(self, *args):
        """
        BSplineCurve(GeomConvert_CompCurveToBSplineCurve self) -> Handle_Geom_BSplineCurve

        :rtype: OCC.wrapper.Geom.Handle_Geom_BSplineCurve

        """
        return _GeomConvert.GeomConvert_CompCurveToBSplineCurve_BSplineCurve(self, *args)


    def Clear(self, *args):
        """
        Clear(GeomConvert_CompCurveToBSplineCurve self)

        Clear a result curve


        """
        return _GeomConvert.GeomConvert_CompCurveToBSplineCurve_Clear(self, *args)

    __swig_destroy__ = _GeomConvert.delete_GeomConvert_CompCurveToBSplineCurve
GeomConvert_CompCurveToBSplineCurve_swigregister = _GeomConvert.GeomConvert_CompCurveToBSplineCurve_swigregister
GeomConvert_CompCurveToBSplineCurve_swigregister(GeomConvert_CompCurveToBSplineCurve)

class GeomConvert_BSplineSurfaceKnotSplitting(object):
    """
    An algorithm to determine isoparametric curves along
    which a BSpline surface should be split in order to
    obtain patches of the same continuity. The continuity order is given at the
    construction time. It is possible to compute the surface patches
    corresponding to the splitting with the method of package
    SplitBSplineSurface.
    For a B-spline surface the discontinuities are localised at
    the knot values. Between two knots values the B-spline is
    infinitely continuously differentiable.  For each parametric
    direction at a knot of range index the continuity in this
    direction is equal to :  Degree - Mult (Index)   where  Degree
    is the degree of the basis B-spline functions and Mult the
    multiplicity of the knot of range Index in the given direction.
    If for your computation you need to have B-spline surface with a
    minima of continuity it can be interesting to know between which
    knot values, a B-spline patch, has a continuity of given order.
    This algorithm computes the indexes of the knots where you should
    split the surface, to obtain patches with a constant continuity
    given at the construction time. If you just want to compute the
    local derivatives on the surface you don't need to create the
    BSpline patches, you can use the functions LocalD1, LocalD2,
    LocalD3, LocalDN of the class BSplineSurface from package Geom.
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomConvert_BSplineSurfaceKnotSplitting self, Handle_Geom_BSplineSurface BasisSurface, Standard_Integer const UContinuityRange, Standard_Integer const VContinuityRange) -> GeomConvert_BSplineSurfaceKnotSplitting

        Determines the u- and v-isoparametric curves
        along which the BSpline surface BasisSurface
        should be split in order to obtain patches with a
        degree of continuity equal to UContinuityRange in
        the u parametric direction, and to
        VContinuityRange in the v parametric direction.
        These isoparametric curves are defined by
        parameters, which are BasisSurface knot values in
        the u or v parametric direction. They are identified
        by indices in the BasisSurface knots table in the
        corresponding parametric direction.
        Use the available interrogation functions to access
        computed values, followed by the global function
        SplitBSplineSurface (provided by the package
        GeomConvert) to split the surface.
        Exceptions
        Standard_RangeError if UContinuityRange or
        VContinuityRange is less than zero.

        :type BasisSurface: OCC.wrapper.Geom.Handle_Geom_BSplineSurface
        :type UContinuityRange: int
        :type VContinuityRange: int

        """
        this = _GeomConvert.new_GeomConvert_BSplineSurfaceKnotSplitting(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbUSplits(self, *args):
        """
        NbUSplits(GeomConvert_BSplineSurfaceKnotSplitting self) -> Standard_Integer

        Returns the number of u-isoparametric curves
        along which the analysed BSpline surface should be
        split in order to obtain patches with the continuity
        required by this framework.
        The parameters which define these curves are knot
        values in the corresponding parametric direction.
        Note that the four curves which bound the surface are
        counted among these splitting curves.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomConvert.GeomConvert_BSplineSurfaceKnotSplitting_NbUSplits(self, *args)


    def NbVSplits(self, *args):
        """
        NbVSplits(GeomConvert_BSplineSurfaceKnotSplitting self) -> Standard_Integer

        Returns the number of v-isoparametric curves
        along which the analysed BSpline surface should be
        split in order to obtain patches with the continuity
        required by this framework.
        The parameters which define these curves are knot
        values in the corresponding parametric direction.
        Note that the four curves which bound the surface are
        counted among these splitting curves.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomConvert.GeomConvert_BSplineSurfaceKnotSplitting_NbVSplits(self, *args)


    def Splitting(self, *args):
        """
        Splitting(GeomConvert_BSplineSurfaceKnotSplitting self, NCollection_Array1_Standard_Integer USplit, NCollection_Array1_Standard_Integer VSplit)

        Loads the USplit and VSplit tables with the split
        knots values computed in this framework. Each value
        in these tables is an index in the knots table
        corresponding to the u or v parametric direction of
        the BSpline surface analysed by this algorithm.
        The USplit and VSplit values are given in ascending
        order and comprise the indices of the knots which
        give the first and last isoparametric curves of the
        surface in the corresponding parametric direction.
        Use two consecutive values from the USplit table and
        two consecutive values from the VSplit table as
        arguments of the global function
        SplitBSplineSurface (provided by the package
        GeomConvert) to split the surface.
        Exceptions
        Standard_DimensionError if:
        -   the array USplit was not created with the following bounds:
        -   1 , and
        -   the number of split knots in the u parametric
        direction computed in this framework (as given
        by the function NbUSplits); or
        -   the array VSplit was not created with the following bounds:
        -   1 , and
        -   the number of split knots in the v parametric
        direction computed in this framework (as given
        by the function NbVSplits).

        :type USplit: OCC.wrapper.TColStd.TColStd_Array1OfInteger
        :type VSplit: OCC.wrapper.TColStd.TColStd_Array1OfInteger

        """
        return _GeomConvert.GeomConvert_BSplineSurfaceKnotSplitting_Splitting(self, *args)


    def USplitValue(self, *args):
        """
        USplitValue(GeomConvert_BSplineSurfaceKnotSplitting self, Standard_Integer const UIndex) -> Standard_Integer

        Returns the split knot of index UIndex
        to the split knots table for the u  parametric direction
        computed in this framework. The returned value is
        an index in the knots table relative to the u
        parametric direction of the BSpline surface analysed by this algorithm.
        Note: If UIndex is equal to 1, or to the number of split knots for the u
        parametric direction computed in
        this framework, the corresponding knot gives the
        parameter of one of the bounding curves of the surface.
        Exceptions
        Standard_RangeError if UIndex  is less than 1 or greater than the number
        of split knots for the u parametric direction computed in this framework.

        :type UIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomConvert.GeomConvert_BSplineSurfaceKnotSplitting_USplitValue(self, *args)


    def VSplitValue(self, *args):
        """
        VSplitValue(GeomConvert_BSplineSurfaceKnotSplitting self, Standard_Integer const VIndex) -> Standard_Integer

        Returns the split knot of index VIndex
        to the split knots table for the v  parametric direction
        computed in this framework. The returned value is
        an index in the knots table relative to the v
        parametric direction of the BSpline surface analysed by this algorithm.
        Note: If UIndex is equal to 1, or to the number of split knots for the v
        parametric direction computed in
        this framework, the corresponding knot gives the
        parameter of one of the bounding curves of the surface.
        Exceptions
        Standard_RangeError if VIndex  is less than 1 or greater than the number
        of split knots for the v parametric direction computed in this framework.

        :type VIndex: int
        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomConvert.GeomConvert_BSplineSurfaceKnotSplitting_VSplitValue(self, *args)

    __swig_destroy__ = _GeomConvert.delete_GeomConvert_BSplineSurfaceKnotSplitting
GeomConvert_BSplineSurfaceKnotSplitting_swigregister = _GeomConvert.GeomConvert_BSplineSurfaceKnotSplitting_swigregister
GeomConvert_BSplineSurfaceKnotSplitting_swigregister(GeomConvert_BSplineSurfaceKnotSplitting)

class GeomConvert_CompBezierSurfacesToBSplineSurface(object):
    """
    An algorithm to convert a grid of adjacent
    non-rational Bezier surfaces (with continuity CM) into a
    BSpline surface (with continuity CM).
    A CompBezierSurfacesToBSplineSurface object
    provides a framework for:
    -   defining the grid of adjacent Bezier surfaces
    which is to be converted into a BSpline surface,
    -   implementing the computation algorithm, and
    -   consulting the results.
    Warning
    Do not attempt to convert rational Bezier surfaces using such an algorithm.
    Input is array of Bezier patch
    1    2    3     4  -> VIndex [1, NbVPatches] -> VDirection
    -----------------------
    1    |    |    |    |      |
    -----------------------
    2    |    |    |    |      |
    -----------------------
    3    |    |    |    |      |
    -----------------------
    UIndex [1, NbUPatches]  Udirection

    Warning! Patches must have compatible parametrization
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(GeomConvert_CompBezierSurfacesToBSplineSurface self, NCollection_Array2_Handle_Geom_BezierSurface Beziers) -> GeomConvert_CompBezierSurfacesToBSplineSurface
        __init__(GeomConvert_CompBezierSurfacesToBSplineSurface self, NCollection_Array2_Handle_Geom_BezierSurface Beziers, Standard_Real const Tolerance, Standard_Boolean const RemoveKnots) -> GeomConvert_CompBezierSurfacesToBSplineSurface
        __init__(GeomConvert_CompBezierSurfacesToBSplineSurface self, NCollection_Array2_Handle_Geom_BezierSurface Beziers, NCollection_Array1_Standard_Real UKnots, NCollection_Array1_Standard_Real VKnots, GeomAbs_Shape const UContinuity=GeomAbs_C0, GeomAbs_Shape const VContinuity=GeomAbs_C0, Standard_Real const Tolerance=1.0e-4) -> GeomConvert_CompBezierSurfacesToBSplineSurface

        Computes all the data needed to construct a BSpline
        surface equivalent to the adjacent non-rational
        Bezier surfaces Beziers grid.
        Each surface in the Beziers grid becomes a natural
        patch, limited by knots values, on the BSpline surface
        whose data is computed. Surfaces in the grid must
        satisfy the following conditions:
        -   Coincident bounding curves between two
        consecutive surfaces in a row of the Beziers grid
        must be u-isoparametric bounding curves of these two surfaces.
        -   Coincident bounding curves between two
        consecutive surfaces in a column of the Beziers
        grid must be v-isoparametric bounding curves of these two surfaces.
        The BSpline surface whose data is computed has the
        following characteristics:
        -   Its degree in the u (respectively v) parametric
        direction is equal to that of the Bezier surface
        which has the highest degree in the u
        (respectively v) parametric direction in the Beziers grid.
        -   Coincident bounding curves between two
        consecutive columns of Bezier surfaces in the
        Beziers grid become u-isoparametric curves
        corresponding to knots values of the BSpline surface.
        -   Coincident bounding curves between two
        consecutive rows of Bezier surfaces in the Beziers
        grid become v-isoparametric curves
        corresponding to knots values of the BSpline surface.
        Knots values of the BSpline surface are given in the two tables:
        -   UKnots for the u parametric direction (which
        corresponds to the order of Bezier surface columns in the Beziers grid), and
        -   VKnots for the v parametric direction (which
        corresponds to the order of Bezier surface rows in the Beziers grid).
        The dimensions of UKnots (respectively VKnots)
        must be equal to the number of columns (respectively,
        rows) of the Beziers grid, plus 1 .
        UContinuity and VContinuity, which are both
        defaulted to GeomAbs_C0, specify the required
        continuity on the BSpline surface. If the required
        degree of continuity is greater than 0 in a given
        parametric direction, a deformation is applied locally
        on the initial surface (as defined by the Beziers grid)
        to satisfy this condition. This local deformation is not
        applied however, if it is greater than Tolerance
        (defaulted to 1.0 e-7). In such cases, the
        continuity condition is not satisfied, and the function
        IsDone will return false. A small tolerance value
        prevents any modification of the surface and a large
        tolerance value "smoothes" the surface.
        Use the available consultation functions to access the
        computed data. This data may be used to construct the BSpline surface.
        Warning
        The surfaces in the Beziers grid must be adjacent, i.e.
        two consecutive Bezier surfaces in the grid (in a row
        or column) must have a coincident bounding curve. In
        addition, the location of the parameterization on each
        of these surfaces (i.e. the relative location of u and v
        isoparametric curves on the surface) is of importance
        with regard to the positioning of the surfaces in the
        Beziers grid. Care must be taken with respect to the
        above, as these properties are not checked and an
        error may occur if they are not satisfied.
        Exceptions
        Standard_DimensionMismatch:
        -   if the number of knots in the UKnots table (i.e. the
        length of the UKnots array) is not equal to the
        number of columns of Bezier surfaces in the
        Beziers grid plus 1, or
        -   if the number of knots in the VKnots table (i.e. the
        length of the VKnots array) is not equal to the
        number of rows of Bezier surfaces in the Beziers grid, plus 1.
        Standard_ConstructionError:
        -   if UContinuity and VContinuity are not equal to
        one of the following values: GeomAbs_C0,
        GeomAbs_C1, GeomAbs_C2 and GeomAbs_C3; or
        -   if the number of columns in the Beziers grid is
        greater than 1, and the required degree of
        continuity in the u parametric direction is greater
        than that of the Bezier surface with the highest
        degree in the u parametric direction (in the Beziers grid), minus 1; or
        -   if the number of rows in the Beziers grid is
        greater than 1, and the required degree of
        continuity in the v parametric direction is greater
        than that of the Bezier surface with the highest
        degree in the v parametric direction (in the Beziers grid), minus 1 .
        Standard_NotImplemented if one of the Bezier
        surfaces in the Beziers grid is rational.

        :type Beziers: OCC.wrapper.TColGeom.TColGeom_Array2OfBezierSurface
        :type UKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type VKnots: OCC.wrapper.TColStd.TColStd_Array1OfReal
        :type UContinuity: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type VContinuity: OCC.wrapper.GeomAbs.GeomAbs_Shape
        :type Tolerance: float

        """
        this = _GeomConvert.new_GeomConvert_CompBezierSurfacesToBSplineSurface(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def NbUKnots(self, *args):
        """
        NbUKnots(GeomConvert_CompBezierSurfacesToBSplineSurface self) -> Standard_Integer

        Returns the number of knots in the U direction
        of the BSpline surface whose data is computed in this framework.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomConvert.GeomConvert_CompBezierSurfacesToBSplineSurface_NbUKnots(self, *args)


    def NbUPoles(self, *args):
        """
        NbUPoles(GeomConvert_CompBezierSurfacesToBSplineSurface self) -> Standard_Integer

        Returns number of poles in the U direction
        of the BSpline surface whose data is computed in this framework.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomConvert.GeomConvert_CompBezierSurfacesToBSplineSurface_NbUPoles(self, *args)


    def NbVKnots(self, *args):
        """
        NbVKnots(GeomConvert_CompBezierSurfacesToBSplineSurface self) -> Standard_Integer

        Returns the number of knots in the V direction
        of the BSpline surface whose data is computed in this framework.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomConvert.GeomConvert_CompBezierSurfacesToBSplineSurface_NbVKnots(self, *args)


    def NbVPoles(self, *args):
        """
        NbVPoles(GeomConvert_CompBezierSurfacesToBSplineSurface self) -> Standard_Integer

        Returns the number of poles in the V direction
        of the BSpline surface whose data is computed in this framework.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomConvert.GeomConvert_CompBezierSurfacesToBSplineSurface_NbVPoles(self, *args)


    def Poles(self, *args):
        """
        Returns the table of poles of the BSpline surface
        whose data is computed in this framework.

        :rtype: OCC.wrapper.TColgp.Handle_TColgp_HArray2OfPnt

        """
        res = _GeomConvert.GeomConvert_CompBezierSurfacesToBSplineSurface_Poles(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UKnots(self, *args):
        """
        Returns the knots table for the u parametric
        direction of the BSpline surface whose data is computed in this framework.

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        res = _GeomConvert.GeomConvert_CompBezierSurfacesToBSplineSurface_UKnots(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def UDegree(self, *args):
        """
        UDegree(GeomConvert_CompBezierSurfacesToBSplineSurface self) -> Standard_Integer

        Returns the degree for the u  parametric
        direction of the BSpline surface whose data is computed in this framework.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomConvert.GeomConvert_CompBezierSurfacesToBSplineSurface_UDegree(self, *args)


    def VKnots(self, *args):
        """
        Returns the knots table for the v parametric
        direction of the BSpline surface whose data is computed in this framework.

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfReal

        """
        res = _GeomConvert.GeomConvert_CompBezierSurfacesToBSplineSurface_VKnots(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def VDegree(self, *args):
        """
        VDegree(GeomConvert_CompBezierSurfacesToBSplineSurface self) -> Standard_Integer

        Returns the degree for the v  parametric
        direction of the BSpline surface whose data is computed in this framework.

        :rtype: OCC.wrapper.Standard.Standard_Integer

        """
        return _GeomConvert.GeomConvert_CompBezierSurfacesToBSplineSurface_VDegree(self, *args)


    def UMultiplicities(self, *args):
        """
        Returns the multiplicities table for the u
        parametric direction of the knots of the BSpline
        surface whose data is computed in this framework.

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfInteger

        """
        res = _GeomConvert.GeomConvert_CompBezierSurfacesToBSplineSurface_UMultiplicities(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def VMultiplicities(self, *args):
        """
        -- Returns the multiplicities table for the v
        parametric direction of the knots of the BSpline
        surface whose data is computed in this framework.

        :rtype: OCC.wrapper.TColStd.Handle_TColStd_HArray1OfInteger

        """
        res = _GeomConvert.GeomConvert_CompBezierSurfacesToBSplineSurface_VMultiplicities(self, *args)
        try:
            res.__d = self
        except AttributeError:
            pass
        return res



    def IsDone(self, *args):
        """
        IsDone(GeomConvert_CompBezierSurfacesToBSplineSurface self) -> Standard_Boolean

        Returns true if the conversion was successful.
        Unless an exception was raised at the time of
        construction, the conversion of the Bezier surface
        grid assigned to this algorithm is always carried out.
        IsDone returns false if the constraints defined at the
        time of construction cannot be respected. This occurs
        when there is an incompatibility between a required
        degree of continuity on the BSpline surface, and the
        maximum tolerance accepted for local deformations
        of the surface. In such a case the computed data
        does not satisfy all the initial constraints.

        :rtype: OCC.wrapper.Standard.Standard_Boolean

        """
        return _GeomConvert.GeomConvert_CompBezierSurfacesToBSplineSurface_IsDone(self, *args)

    __swig_destroy__ = _GeomConvert.delete_GeomConvert_CompBezierSurfacesToBSplineSurface
GeomConvert_CompBezierSurfacesToBSplineSurface_swigregister = _GeomConvert.GeomConvert_CompBezierSurfacesToBSplineSurface_swigregister
GeomConvert_CompBezierSurfacesToBSplineSurface_swigregister(GeomConvert_CompBezierSurfacesToBSplineSurface)



